{"ast":null,"code":"import { geoProjection as projection } from \"d3-geo\";\nimport { hammerRaw } from \"./hammer.js\";\nimport { cos, pi, sin } from \"./math.js\";\nimport { solve2d } from \"./newton.js\";\n\n// Bertin 1953 as a modified Briesemeister\n// https://bl.ocks.org/Fil/5b9ee9636dfb6ffa53443c9006beb642\nexport function bertin1953Raw() {\n  var hammer = hammerRaw(1.68, 2),\n    fu = 1.4,\n    k = 12;\n  function forward(lambda, phi) {\n    if (lambda + phi < -fu) {\n      var u = (lambda - phi + 1.6) * (lambda + phi + fu) / 8;\n      lambda += u;\n      phi -= 0.8 * u * sin(phi + pi / 2);\n    }\n    var r = hammer(lambda, phi);\n    var d = (1 - cos(lambda * phi)) / k;\n    if (r[1] < 0) {\n      r[0] *= 1 + d;\n    }\n    if (r[1] > 0) {\n      r[1] *= 1 + d / 1.5 * r[0] * r[0];\n    }\n    return r;\n  }\n  forward.invert = solve2d(forward);\n  return forward;\n}\nexport default function () {\n  // this projection should not be rotated\n  return projection(bertin1953Raw()).rotate([-16.5, -42]).scale(176.57).center([7.93, 0.09]);\n}","map":{"version":3,"names":["geoProjection","projection","hammerRaw","cos","pi","sin","solve2d","bertin1953Raw","hammer","fu","k","forward","lambda","phi","u","r","d","invert","rotate","scale","center"],"sources":["/home/josh/Documents/projects/subs/vue_subs/node_modules/d3-geo-projection/src/bertin.js"],"sourcesContent":["import {geoProjection as projection} from \"d3-geo\";\nimport {hammerRaw} from \"./hammer.js\";\nimport {cos, pi, sin} from \"./math.js\";\nimport {solve2d} from \"./newton.js\";\n\n// Bertin 1953 as a modified Briesemeister\n// https://bl.ocks.org/Fil/5b9ee9636dfb6ffa53443c9006beb642\nexport function bertin1953Raw() {\n  var hammer = hammerRaw(1.68, 2),\n      fu = 1.4, k = 12;\n\n  function forward(lambda, phi) {\n\n    if (lambda + phi < -fu) {\n      var u = (lambda - phi + 1.6) * (lambda + phi + fu) / 8;\n      lambda += u;\n      phi -= 0.8 * u * sin(phi + pi / 2);\n    }\n\n    var r = hammer(lambda, phi);\n\n    var d = (1 - cos(lambda * phi)) / k;\n\n    if (r[1] < 0) {\n      r[0] *= 1 + d;\n    }\n    if (r[1] > 0) {\n      r[1] *= 1 + d / 1.5 * r[0] * r[0];\n    }\n\n    return r;\n  }\n  \n  forward.invert = solve2d(forward);\n  return forward;\n}\n\nexport default function() {\n  // this projection should not be rotated\n  return projection(bertin1953Raw())\n    .rotate([-16.5, -42])\n    .scale(176.57)\n    .center([7.93, 0.09]);\n}\n"],"mappings":"AAAA,SAAQA,aAAa,IAAIC,UAAU,QAAO,QAAQ;AAClD,SAAQC,SAAS,QAAO,aAAa;AACrC,SAAQC,GAAG,EAAEC,EAAE,EAAEC,GAAG,QAAO,WAAW;AACtC,SAAQC,OAAO,QAAO,aAAa;;AAEnC;AACA;AACA,OAAO,SAASC,aAAaA,CAAA,EAAG;EAC9B,IAAIC,MAAM,GAAGN,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC;IAC3BO,EAAE,GAAG,GAAG;IAAEC,CAAC,GAAG,EAAE;EAEpB,SAASC,OAAOA,CAACC,MAAM,EAAEC,GAAG,EAAE;IAE5B,IAAID,MAAM,GAAGC,GAAG,GAAG,CAACJ,EAAE,EAAE;MACtB,IAAIK,CAAC,GAAG,CAACF,MAAM,GAAGC,GAAG,GAAG,GAAG,KAAKD,MAAM,GAAGC,GAAG,GAAGJ,EAAE,CAAC,GAAG,CAAC;MACtDG,MAAM,IAAIE,CAAC;MACXD,GAAG,IAAI,GAAG,GAAGC,CAAC,GAAGT,GAAG,CAACQ,GAAG,GAAGT,EAAE,GAAG,CAAC,CAAC;IACpC;IAEA,IAAIW,CAAC,GAAGP,MAAM,CAACI,MAAM,EAAEC,GAAG,CAAC;IAE3B,IAAIG,CAAC,GAAG,CAAC,CAAC,GAAGb,GAAG,CAACS,MAAM,GAAGC,GAAG,CAAC,IAAIH,CAAC;IAEnC,IAAIK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACZA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGC,CAAC;IACf;IACA,IAAID,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACZA,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,GAAGC,CAAC,GAAG,GAAG,GAAGD,CAAC,CAAC,CAAC,CAAC,GAAGA,CAAC,CAAC,CAAC,CAAC;IACnC;IAEA,OAAOA,CAAC;EACV;EAEAJ,OAAO,CAACM,MAAM,GAAGX,OAAO,CAACK,OAAO,CAAC;EACjC,OAAOA,OAAO;AAChB;AAEA,eAAe,YAAW;EACxB;EACA,OAAOV,UAAU,CAACM,aAAa,CAAC,CAAC,CAAC,CAC/BW,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,CACpBC,KAAK,CAAC,MAAM,CAAC,CACbC,MAAM,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;AACzB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}