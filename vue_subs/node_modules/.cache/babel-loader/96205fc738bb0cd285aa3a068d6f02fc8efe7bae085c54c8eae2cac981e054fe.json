{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/web.dom-exception.stack.js\";\n/**\r\n * Text class deals with all text placed on chart.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Container } from \"../Container\";\nimport { registry } from \"../Registry\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport * as $math from \"../utils/Math\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $dom from \"../utils/DOM\";\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\nimport { options } from \"../Options\";\n;\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\nvar Label = /** @class */function (_super) {\n  __extends(Label, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Label() {\n    var _this =\n    // Execute super's constructor\n    _super.call(this) || this;\n    /**\r\n     * Indicates if the whole text does not fit into max dimenstions set for it.\r\n     */\n    _this.isOversized = false;\n    // Set this class name\n    _this.className = \"Label\";\n    _this.fill = new InterfaceColorSet().getFor(\"text\");\n    // not good to set this, as then these will appear on each label and values set on container won't be applied.\n    //this.textDecoration = \"none\";\n    //this.fontWeight = \"normal\";\n    // Set defaults\n    _this.wrap = false;\n    _this.truncate = false;\n    _this.fullWords = true;\n    _this.ellipsis = \"â€¦\";\n    _this.textAlign = \"start\";\n    _this.textValign = \"top\";\n    _this.layout = \"absolute\";\n    _this.baseLineRatio = -0.27;\n    //this.pixelPerfect = true;\n    _this._positionPrecision = 1;\n    // Add events to watch for maxWidth/maxHeight changes so that we can\n    // invalidate this\n    _this.events.on(\"maxsizechanged\", function () {\n      if (_this.inited) {\n        _this.handleMaxSize();\n      }\n    }, _this, false);\n    // this solves strange bug when text just added to svg is 0x0\n    _this.events.once(\"validated\", _this.handleValidate, _this, false);\n    // Aply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * A placeholder method that is called **after** element finishes drawing\r\n   * itself.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.afterDraw = function () {\n    // since we removed validatePosition from sprite, we still need it here to handle rotated text\n    _super.prototype.afterDraw.call(this);\n    this.validatePosition();\n  };\n  /**\r\n   * Sets [[Paper]] instance to use to draw elements.\r\n   * @ignore\r\n   * @param paper Paper\r\n   * @return true if paper was changed, false, if it's the same\r\n   */\n  Label.prototype.setPaper = function (paper) {\n    var changed = _super.prototype.setPaper.call(this, paper);\n    if (changed) {\n      this.hardInvalidate();\n    }\n    return changed;\n  };\n  /**\r\n   * @ignore\r\n   */\n  Label.prototype.handleValidate = function () {\n    if ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\n      registry.events.once(\"exitframe\", this.hardInvalidate, this);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  Label.prototype.handleMaxSize = function () {\n    if (this.bbox.width > this.availableWidth || this.bbox.width < this.availableWidth && (this.isOversized || this.truncate) || this.bbox.height > this.availableHeight || this.bbox.height < this.availableHeight && this.isOversized) {\n      this.invalidate();\n    } else {\n      //this.alignSVGText();\n    }\n  };\n  /**\r\n   * [arrange description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   */\n  Label.prototype.arrange = function () {};\n  /**\r\n   * Updates current text according to data item and supported features.\r\n   * Returns `true` if current text has changed.\r\n   *\r\n   * @return Text changed?\r\n   */\n  Label.prototype.updateCurrentText = function () {\n    // Determine output format\n    var output, text;\n    if ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\n      // We favor HTML text if it's set and browser supports `foreignObject`\n      output = \"html\";\n      text = this.html;\n    } else {\n      output = \"svg\";\n      text = this.text;\n    }\n    // Need to toString source?\n    if ($type.isObject(text)) {\n      text = text.toString();\n    }\n    // Need to format text all the time\n    if ($type.hasValue(text) && text !== \"\") {\n      text = this.populateString(text, this.dataItem);\n    }\n    if (output == \"html\") {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"htmlOutput\", text);\n      }\n    } else {\n      if (this._adapterO) {\n        text = this._adapterO.apply(\"textOutput\", text);\n      }\n    }\n    // Update the text\n    var changed = text != this.currentText || output != this._currentFormat;\n    this.currentText = text;\n    this._currentFormat = output;\n    return changed;\n  };\n  /**\r\n   * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n   * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n   * reasons.\r\n   */\n  Label.prototype.hardInvalidate = function () {\n    this._prevStatus = \"\";\n    this.invalidate();\n  };\n  /**\r\n   * Gets line bbox, uses caching to save cpu\r\n   * @ignore\r\n   */\n  Label.prototype.getLineBBox = function (lineInfo) {\n    //let cacheKey = lineInfo.text + lineInfo.style;\n    //let lineBBox = this.getCache(cacheKey);\n    //if (!lineBBox) {\n    //lineBBox = lineInfo.element.getBBox();\n    //if (lineBBox.width != 0 && lineBBox.height != 0) {\n    //\tthis.setCache(cacheKey, lineBBox, 5000);\n    //}\n    //}\n    var element = lineInfo && lineInfo.element;\n    var node = element && element.node;\n    // Check for the parent Node to avoid FF from throwing errors\n    if (node && node.parentNode) {\n      lineInfo.bbox = element.getBBox();\n    }\n  };\n  /**\r\n   * Draws the textual label.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.draw = function () {\n    // Draw super\n    _super.prototype.draw.call(this);\n    var oldW = this.bbox.width;\n    var oldH = this.bbox.height;\n    var topParent = this.topParent;\n    if (topParent) {\n      if (!topParent.maxWidth || !topParent.maxHeight) {\n        topParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\n        return;\n      }\n    }\n    // Calculate max width and height\n    var maxWidth = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\n    var maxHeight = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\n    // save\n    var status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\n    // Update text\n    if (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\n      return;\n    }\n    this._measuredWidth = 0;\n    this._measuredHeight = 0;\n    // Reset\n    this.isOversized = false;\n    // Determine output format\n    var output = this._currentFormat;\n    var text = this.currentText;\n    // Empty string\n    if (!$type.hasValue(text) || text == \"\") {\n      this.element.attr({\n        display: \"none\"\n      });\n      return;\n    }\n    // Chop up text into lines\n    // We're still processing SVG and HTML in the same way for now\n    var lines = text.split(\"\\n\");\n    // Do we need to go through the trouble of measuring lines\n    //let measure: boolean = true;// (lines.length > 1) || this.wrap;\n    this._prevStatus = status;\n    this.textAlign = this.textAlign;\n    // need this to measure\n    var display = this.group.getAttr(\"display\");\n    if (display == \"none\") {\n      this.group.removeAttr(\"display\");\n    }\n    if (this.textPathElement) {\n      this.textPathElement.removeChildren();\n    }\n    // SVG or HTML?\n    if (output === \"svg\") {\n      /**\r\n       * SVG\r\n       */\n      this.element.removeAttr(\"display\");\n      // Clear the element\n      var group = this.element;\n      //group.removeChildren();\n      this.resetBBox();\n      // Init state variables\n      var currentHeight = 0;\n      var currentFormat = \"\";\n      // Process each line\n      for (var i = 0; i < lines.length; i++) {\n        // Get line\n        var line = lines[i];\n        // Check if line is empty\n        if (line == \"\") {\n          // It is, let's just update currentHeight and go to the next one\n          // If it's the first line, we'll have to use arbirary line height,\n          // since there's nothing to measure. For subsequent lines we can take\n          // previous line's height\n          var tempElement = this.getSVGLineElement(\"\", 0);\n          tempElement.add(this.getSvgElement(\".\", getTextFormatter().translateStyleShortcuts(currentFormat)));\n          group.add(tempElement);\n          var offset = Math.ceil(tempElement.getBBox().height);\n          if (offset > 0) {\n            currentHeight += offset;\n          }\n          group.removeElement(tempElement);\n          // Clear cache if necessary\n          var lineInfo_1 = this.getLineInfo(i);\n          if (lineInfo_1) {\n            lineInfo_1.text = \"\";\n            lineInfo_1.element.textContent = \"\";\n          }\n          continue;\n        }\n        // Chunk up the line and process each chunk\n        var chunks = getTextFormatter().chunk(line, null, this.ignoreFormatting);\n        var currentLineHeight = 0;\n        var firstChunk = true;\n        var skipTextChunks = false;\n        // Create line element or grab it from cache\n        var lineInfo = this.getLineInfo(i);\n        if (lineInfo) {\n          // Empty line\n          lineInfo.text = \"\";\n          lineInfo.element.textContent = \"\";\n        } else {\n          // Init new line info\n          lineInfo = {\n            \"text\": \"\",\n            \"element\": this.getSVGLineElement(\"\", 0),\n            \"complex\": false\n          };\n          // Create the line element\n          //lineInfo.element = this.getSVGLineElement(\"\", 0);\n          //lineElement = this.getSVGLineElement(\"\", 0);\n          group.add(lineInfo.element);\n        }\n        lineInfo.element.removeAttr(\"display\");\n        lineInfo.element.removeChildren(); // memory leak without this\n        if (this.textPathElement) {\n          lineInfo.element.add(this.textPathElement);\n        }\n        /*// @todo not needed anymore\r\n        if (this.rtl) {\r\n            chunks.reverse();\r\n        }*/\n        // Process each chunk\n        for (var x = 0; x < chunks.length; x++) {\n          // If there's more than one chunk, means the line is \"complex\"\n          if (x) {\n            lineInfo.complex = true;\n          }\n          // Get chunk\n          var chunk = chunks[x];\n          // Is this chunk format or text?\n          if (chunk.type === \"format\") {\n            // Log current format, so that we can apply it to multiple lines if\n            // necessary\n            currentFormat = chunk.text;\n          } else {\n            // It's text block\n            // Need to skip?\n            // We do this when truncating. We can't just simply go ahead and\n            // abandon chunk processing as they might have formatting\n            // instructions in them that are relevant for subsequent lines\n            if (skipTextChunks) {\n              continue;\n            }\n            // Add chunk to the current element\n            //lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\n            lineInfo.text = chunk.text;\n            lineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\n            if (this.textPathElement) {\n              this.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\n            } else {\n              this.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\n            }\n            this.getLineBBox(lineInfo);\n            lineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\n            // Updated current line height\n            if (currentLineHeight < lineInfo.bbox.height) {\n              currentLineHeight = lineInfo.bbox.height;\n            }\n            // Wrapping?\n            if ((this.wrap || this.truncate) && lineInfo.bbox.width > maxWidth) {\n              // Set oversized\n              this.isOversized = true;\n              // Take temporary measurements\n              var lineText = lineInfo.element.textContent;\n              var avgCharWidth = lineInfo.bbox.width / lineText.length; // * .9;\n              // Calculate average number of symbols / width\n              var excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\n              // Are we truncating or auto-wrapping text?\n              if (this.truncate) {\n                /**\r\n                 * Processing line truncation\r\n                 * With the addition of each text chunk we measure if current\r\n                 * line does not exceed maxWidth. If it does, we will stop\r\n                 * addition of further chunks as well as try to truncate\r\n                 * current or any number of previous chunks with an added\r\n                 * ellipsis\r\n                 */\n                // Indicator whether we need to add ellipsis to the current\n                // element, even if it fits. This is needed to indicate\n                // whether we have already removed some subsequent chunks in\n                // which case we need to add ellipsis.\n                var addEllipsis = false;\n                // Process each child in the temporary line, until the whole\n                // line fits, preferably with an ellipsis\n                // TODO use iterator instead\n                var node_1 = lineInfo.element.node;\n                if (node_1 && node_1.childNodes) {\n                  for (var e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\n                    // Get current element\n                    var node_2 = lineInfo.element.node.childNodes[e];\n                    // Add ellipsis only if previous chunk was removed in full\n                    // and this chunk already fits\n                    //if (addEllipsis && (bbox.width <= maxWidth)) {\n                    if (addEllipsis && lineInfo.bbox.width <= maxWidth) {\n                      // Add ellipsis\n                      node_2.textContent += \" \" + this.ellipsis;\n                      // Measure again (we need to make sure ellipsis fits)\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\n                      // If it fits, we're done here\n                      // If it doesn't we continue rolling\n                      if (lineInfo.bbox.width <= maxWidth) {\n                        break;\n                      }\n                    }\n                    addEllipsis = false;\n                    // Get element text\n                    var elementText = node_2.textContent;\n                    // Calculate average number of symbols / width\n                    lineText = lineInfo.element.textContent;\n                    excessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\n                    // Do this until we fit\n                    while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                      // Calculate max available chars\n                      var maxChars = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\n                      // Is there anything left?\n                      if (maxChars <= 1) {\n                        // Nope, let's jump to the previous item\n                        // Set excess characters to zero so that this loop does\n                        // not repeat when it over\n                        excessChars = 0;\n                        // Add ellipsis to previous item\n                        // Subsequent iterations will check if the ellipsis fits\n                        if (e > 0) {\n                          // Indicating to add ellipsis to previous item\n                          addEllipsis = true;\n                          // Removing this node\n                          lineInfo.element.node.removeChild(node_2);\n                        }\n                      }\n                      // Truncate the text\n                      elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\n                      if (elementText.length > maxChars && this.fullWords) {\n                        // Still too long?\n                        // Let's try truncating breaking words anyway\n                        elementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\n                      }\n                      // Set truncated text\n                      node_2.textContent = elementText;\n                      // Measure again\n                      lineInfo.bbox = lineInfo.element.getBBox();\n                      lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\n                      // Increase excess characters count, just in case it still\n                      // doesn't fit and we have to go at it again\n                      excessChars = Math.ceil(excessChars * 1.1);\n                    }\n                    // Do not process further chunks\n                    skipTextChunks = true;\n                  }\n                }\n              } else {\n                /**\r\n                 * Processign auto-wrap\r\n                 * In this case we're going to be adding text chunks until\r\n                 * they don't fit into current line. Once that happens we will\r\n                 * inject the rest of the chunks to the next line\r\n                 */\n                // Get last node added and measure it\n                var node_3 = lineInfo.element.node;\n                if (node_3) {\n                  var lastNode = lineInfo.element.node.lastChild;\n                  // Init split lines\n                  var splitLines = void 0;\n                  while (lineInfo.bbox.width > maxWidth && excessChars <= lineText.length && excessChars > 0) {\n                    // Calculate max available chars\n                    var maxChars = $math.max(chunk.text.length - excessChars, 1);\n                    // Don't split the words mid-word if it's not the first chunk\n                    // in the line\n                    if (firstChunk) {\n                      // Split mid-word if necessary\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\n                    } else {\n                      // Don't split mid-word\n                      splitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);\n                      // Check if the first word is too long\n                      if (splitLines[0].length > maxChars || maxChars === 1) {\n                        // Yes - move the whole chunk to the next line\n                        // Remove the element we just added\n                        lineInfo.element.node.removeChild(lastNode);\n                        // Break out of the while on next cycle\n                        excessChars = 0;\n                      }\n                    }\n                    // Use the first line to update last item\n                    if (excessChars > 0) {\n                      var lineText_1 = splitLines.shift();\n                      if (firstChunk) {\n                        lineText_1 = $utils.trim(lineText_1);\n                      }\n                      lastNode.textContent = getTextFormatter().cleanUp(lineText_1);\n                    }\n                    // Measure again, just in case\n                    lineInfo.bbox = lineInfo.element.getBBox();\n                    lineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\n                    // Increase excess characters count, just in case it still\n                    // doesn't fit and we have to go at it again\n                    //excessChars = Math.ceil(excessChars * 1.05);\n                    excessChars++;\n                  }\n                  // Construct the rest of the line\n                  if (splitLines.length > 0) {\n                    var restOfLine = \"\";\n                    // Add leftovers from splitting the current chunk\n                    if ($type.hasValue(splitLines)) {\n                      if (this.rtl) {\n                        restOfLine += splitLines.join(\"\") + currentFormat;\n                      } else {\n                        restOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      }\n                    }\n                    // Add the rest of the chunks\n                    for (var c = x + 1; c < chunks.length; c++) {\n                      if (chunks[c].type == \"value\") {\n                        // We're escaping single square brackets that were\n                        // cleaned up by chunk() back to double square brackets\n                        // so that they are not being treated as format on\n                        // next pass.\n                        restOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\n                      } else {\n                        restOfLine += chunks[c].text;\n                      }\n                    }\n                    // Inject the rest of the lines as chunks for subsequent\n                    lines.splice(i + 1, 0, restOfLine);\n                  }\n                  // Skip processing the rest of the chunks\n                  skipTextChunks = true;\n                }\n              }\n            }\n            // Let's update the text's bbox with the line's one\n            if (this.bbox.width < lineInfo.bbox.width) {\n              this.bbox.width = lineInfo.bbox.width;\n            }\n            // commented to avoid bug (seen on sankey link) where text is incorrectly aligned\n            //if (this.bbox.x > lineInfo.bbox.x) {\n            //this.bbox.x = lineInfo.bbox.x;\n            //}\n            this.bbox.height = currentHeight + currentLineHeight;\n            // Position current line\n            if (!this.textPathElement) {\n              lineInfo.element.attr({\n                \"x\": \"0\",\n                \"y\": currentHeight + currentLineHeight,\n                \"dy\": $math.round(this.baseLineRatio * currentLineHeight, 3).toString()\n              });\n            } else {\n              lineInfo.element.attr({\n                \"dy\": -this.paddingBottom.toString()\n              });\n            }\n            firstChunk = false;\n          }\n        }\n        // Trim the last item\n        var node = lineInfo.element.node;\n        if (node) {\n          var lastNode = node.lastChild;\n          if (lastNode) {\n            lastNode.textContent = this.rtl ? $utils.ltrim(lastNode.textContent) : $utils.rtrim(lastNode.textContent);\n          }\n        }\n        // Increment collective height\n        currentHeight += currentLineHeight;\n        // Save line cache\n        this.addLineInfo(lineInfo, i);\n      }\n      // Check if maybe we need to hide the whole label if it doesn't fit\n      this.maybeHideOversized();\n      this.measureFailed = false;\n      if (this.bbox.width == 0 || this.bbox.height == 0) {\n        this.measureFailed = true;\n      }\n      // Updated measured dims\n      this._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\n      this._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\n      // Align the lines\n      this.alignSVGText();\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n      if (oldH != this._measuredHeight || oldW != this._measuredWidth) {\n        this.dispatch(\"transformed\");\n      }\n      this.hideUnused(lines.length);\n    } else {\n      /**\r\n       * HTML\r\n       */\n      this.element.removeAttr(\"display\");\n      this.resetBBox();\n      // Clear the element\n      var group = this.element;\n      group.removeChildren();\n      this.setCache(\"lineInfo\", [], 0);\n      // Create a ForeignObject to use as HTML container\n      var fo = this.paper.foreignObject();\n      group.add(fo);\n      // Set widths on foreignObject so that autosizing measurements work\n      // This will bet reset to actual content width/height\n      if (this.maxWidth) {\n        fo.attr({\n          width: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\n        });\n      }\n      if (this.maxHeight) {\n        fo.attr({\n          height: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\n        });\n      }\n      // Create line element\n      //let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\n      var lineElement = this.getHTMLLineElement(text);\n      fo.node.appendChild(lineElement);\n      // Temporarily set to inline-block so we can measure real width and height\n      lineElement.style.display = \"inline-block\";\n      var clientWidth = lineElement.clientWidth;\n      var clientHeight = lineElement.clientHeight;\n      lineElement.style.display = \"block\";\n      this._bbox = {\n        x: 0,\n        y: 0,\n        width: clientWidth,\n        height: clientHeight\n      };\n      // Set exact dimensions of foreignObject so it is sized exactly as\n      // the content within (add one pixel to width so it does not wrap)\n      fo.attr({\n        width: clientWidth + 1,\n        height: clientHeight\n      });\n      // Check if maybe we need to hide the whole label if it doesn't fit\n      this.maybeHideOversized();\n      // Set measurements and update bbox\n      this._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\n      this._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\n      this.bbox.width = this._measuredWidth;\n      this.bbox.height = this._measuredHeight;\n      // Don't let labels bleed out of the alotted area\n      if (this.truncate) {\n        lineElement.style.overflow = \"hidden\";\n      }\n      if (clientWidth > maxWidth || clientHeight > maxHeight) {\n        this.isOversized = true;\n      }\n    }\n    // Set applicable styles\n    this.setStyles();\n    this.updateCenter();\n    this.updateBackground();\n    if (display == \"none\") {\n      this.group.attr({\n        display: \"none\"\n      });\n    }\n    if (this.pathElement) {\n      this.paper.appendDef(this.pathElement);\n    }\n  };\n  /**\r\n   * Hides element if it does not fit into available space\r\n   */\n  Label.prototype.maybeHideOversized = function () {\n    if (this.hideOversized) {\n      if (this.availableWidth < this.bbox.width || this.availableHeight < this.bbox.height) {\n        this.element.attr({\n          display: \"none\"\n        });\n        this.isOversized = true;\n      } else {\n        this.element.removeAttr(\"display\");\n        this.isOversized = false;\n      }\n    }\n  };\n  /**\r\n   * Aligns the lines horizontally and vertically, based on properties.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.alignSVGText = function () {\n    // Get Group\n    var group = this.element;\n    var children = group.node.children || group.node.childNodes;\n    // Is there anything to align?\n    if (!children || children && children.length == 0) {\n      return;\n    }\n    var width = this._measuredWidth;\n    var height = this._measuredHeight;\n    // TODO maybe these aren't needed ?\n    $utils.used(this.pixelPaddingLeft);\n    $utils.used(this.pixelPaddingRight);\n    $utils.used(this.pixelPaddingTop);\n    $utils.used(this.pixelPaddingBottom);\n    if (this.rtl) {\n      group.attr({\n        \"direction\": \"rtl\"\n      });\n    } else {\n      group.removeAttr(\"direction\");\n    }\n    // Process each line\n    //$iter.each(group.children.backwards().iterator(), (element) => {\n    for (var i = children.length - 1; i >= 0; i--) {\n      // Align horizontally\n      // Since we are using `text-anchor` for horizontal alignment, all we need\n      // to do here is move the `x` position\n      var node = children[i];\n      node.setAttribute(\"text-anchor\", this.textAlign);\n      if (this.textPathElement) {\n        node.removeAttribute(\"x\");\n        node.removeAttribute(\"y\");\n      } else {\n        switch (this.textAlign) {\n          case \"middle\":\n            node.setAttribute(\"x\", (width / 2).toString() + \"px\");\n            break;\n          case \"end\":\n            if (this.rtl) {} else {\n              node.setAttribute(\"x\", width.toString());\n            }\n            break;\n          default:\n            if (this.rtl) {\n              node.setAttribute(\"x\", width.toString());\n            } else {\n              node.removeAttribute(\"text-anchor\");\n            }\n            break;\n        }\n        var y = $type.toNumber(node.getAttribute(\"y\"));\n        switch (this.textValign) {\n          case \"middle\":\n            node.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\n            break;\n          case \"bottom\":\n            node.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\n            break;\n          default:\n            node.setAttribute(\"y\", (y || 0).toString());\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Produces an SVG line element with formatted text.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text    Text to wrap into line\r\n   * @param y       Current line vertical position\r\n   * @return A DOM element\r\n   * @todo Implement HTML support\r\n   */\n  Label.prototype.getSVGLineElement = function (text, y) {\n    // Create a <text> node and set text\n    var element = this.paper.addGroup(\"text\");\n    element.textContent = text;\n    // Set parameters\n    element.attr({\n      \"x\": \"0\"\n      //\"alignment-baseline\": \"hanging\",\n      //\"baseline-shift\": \"-20%\",\n      //\"text-anchor\": \"center\"\n    });\n    // Set `y` position\n    if ($type.hasValue(y)) {\n      element.attr({\n        \"y\": y.toString()\n      });\n    }\n    // Don't let labels blled out of the alotted area\n    if (this.truncate || this.wrap) {\n      element.attr({\n        \"overflow\": \"hidden\"\n      });\n    }\n    // Add RTL?\n    // This has now been moved to this.alignSVGText()\n    // if (this.rtl) {\n    // \telement.attr({\n    // \t\t\"direction\": \"rtl\",\n    // \t\t//\"unicode-bidi\": \"bidi-override\"\n    // \t});\n    // }\n    return element;\n  };\n  Object.defineProperty(Label.prototype, \"rtl\", {\n    /**\r\n     * @return RTL?\r\n     */\n    get: function () {\n      if ($type.hasValue(this._rtl)) {\n        return this._rtl;\n      } else if (this._topParent) {\n        return this._topParent.rtl;\n      }\n      return false;\n    },\n    /**\r\n     * An RTL (right-to-left) setting.\r\n     *\r\n     * RTL may affect alignment, text, and other visual properties.\r\n     *\r\n     * If you set this on a top-level chart object, it will be used for all\r\n     * child elements, e.g. labels, unless they have their own `rtl` setting\r\n     * set directly on them.\r\n     *\r\n     * @param value  `true` for to use RTL\r\n     */\n    set: function (value) {\n      value = $type.toBoolean(value);\n      this._rtl = value;\n      if (this.element) {\n        this.alignSVGText();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Resets cached BBox.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Label.prototype.resetBBox = function () {\n    this._bbox = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n  };\n  /**\r\n   * Creates and returns an HTML line element (`<div>`).\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Text to add\r\n   * @return `<div>` element reference\r\n   */\n  Label.prototype.getHTMLLineElement = function (text) {\n    // Create the <div> element\n    var div = document.createElement(\"div\");\n    div.innerHTML = text;\n    // Set text alignment\n    switch (this.textAlign) {\n      case \"middle\":\n        div.style.textAlign = \"center\";\n        break;\n      case \"end\":\n        div.style.textAlign = \"right\";\n        break;\n    }\n    // Disable or enable wrapping\n    if (this.wrap) {\n      div.style.wordWrap = \"break-word\";\n    } else {\n      div.style.whiteSpace = \"nowrap\";\n    }\n    // Don't let labels bleed out of the alotted area\n    // Moved to `draw()` because setting \"hidden\" kills all measuring\n    /*if (this.truncate) {\r\n        div.style.overflow = \"hidden\";\r\n    }*/\n    // Set RTL-related styles\n    if (this.rtl) {\n      div.style.direction = \"rtl\";\n      //div.style.unicodeBidi = \"bidi-override\";\n    }\n    // Translate some of the SVG styles into CSS\n    if ($type.hasValue(this.fill)) {\n      div.style.color = this.fill.toString();\n    }\n    return div;\n  };\n  /**\r\n   * Applies specific styles to text to make it not selectable, unless it is\r\n   * explicitly set as `selectable`.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Set styles via AMElement\r\n   */\n  Label.prototype.setStyles = function () {\n    var group = this.element;\n    if (!this.selectable || this.draggable || this.resizable || this.swipeable) {\n      group.addStyle({\n        \"webkitUserSelect\": \"none\",\n        \"msUserSelect\": \"none\"\n      });\n    } else if (this.selectable) {\n      group.removeStyle(\"webkitUserSelect\");\n      group.removeStyle(\"msUserSelect\");\n    }\n  };\n  /**\r\n   * Hides unused lines\r\n   */\n  Label.prototype.hideUnused = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    if (lines.length >= index) {\n      for (var i = index; i < lines.length; i++) {\n        var line = lines[i];\n        if (line && line.element) {\n          line.element.attr({\n            \"display\": \"none\"\n          });\n        }\n      }\n    }\n  };\n  Object.defineProperty(Label.prototype, \"text\", {\n    /**\r\n     * @return SVG text\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"text\");\n    },\n    /**\r\n     * An SVG text.\r\n     *\r\n     * Please note that setting `html` will override this setting if browser\r\n     * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n     * IEs.\r\n     *\r\n     * @param value  SVG Text\r\n     */\n    set: function (value) {\n      //this.setPropertyValue(\"html\", undefined);\n      this.setPropertyValue(\"text\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"path\", {\n    /**\r\n     * @return Path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"path\");\n    },\n    /**\r\n     * An SVG path string to position text along. If set, the text will follow\r\n     * the curvature of the path.\r\n     *\r\n     * Location along the path can be set using `locationOnPath`.\r\n     *\r\n     * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n     * this setting will be ignored.\r\n     *\r\n     * @since 4.1.2\r\n     * @param  value  Path\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"path\", value, true)) {\n        if (this.pathElement) {\n          this.pathElement.dispose();\n        }\n        if (this.textPathElement) {\n          this.textPathElement.dispose();\n        }\n        this.pathElement = this.paper.add(\"path\");\n        this.pathElement.attr({\n          \"d\": value\n        });\n        this.pathElement.attr({\n          \"id\": \"text-path-\" + this.uid\n        });\n        this._disposers.push(this.pathElement);\n        this.textPathElement = this.paper.addGroup(\"textPath\");\n        this.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\n        // TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\n        this.textPathElement.attr({\n          \"path\": value\n        });\n        this._disposers.push(this.textPathElement);\n        this.hardInvalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"locationOnPath\", {\n    /**\r\n     * @return Relatvie location on path\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"locationOnPath\");\n    },\n    /**\r\n     * Relative label location on `path`. Value range is from 0 (beginning)\r\n     * to 1 (end).\r\n     *\r\n     * Works only if you set `path` setting to an SVG path.\r\n     *\r\n     * @since 4.1.2\r\n     * @default 0\r\n     * @param  value  Relatvie location on path\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"locationOnPath\", value);\n      if (this.textPathElement) {\n        this.textPathElement.attr({\n          \"startOffset\": value * 100 + \"%\"\n        });\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"baseLineRatio\", {\n    /**\r\n     * @return Base line ratio\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"baseLineRatio\");\n    },\n    /**\r\n     * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n     * the label.\r\n     *\r\n     * @since 4.4.2\r\n     * @default -0.27\r\n     * @param  value  Base line ratio\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"baseLineRatio\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"wrap\", {\n    /**\r\n     * @return Auto-wrap enabled or not\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"wrap\");\n    },\n    /**\r\n     * Enables or disables autowrapping of text.\r\n     *\r\n     * @param value  Auto-wrapping enabled\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"wrap\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"truncate\", {\n    /**\r\n     * @return Truncate text?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"truncate\");\n    },\n    /**\r\n     * Indicates if text lines need to be truncated if they do not fit, using\r\n     * configurable `ellipsis` string.\r\n     *\r\n     * `truncate` overrides `wrap` if both are set to `true`.\r\n     *\r\n     * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n     * line truncation with ellipsis. It will just hide everything that goes\r\n     * outside the label.\r\n     *\r\n     * @param value  trincate text?\r\n     */\n    set: function (value) {\n      this.resetBBox();\n      this.setPropertyValue(\"truncate\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"fullWords\", {\n    /**\r\n     * @return Truncate on full words?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"fullWords\");\n    },\n    /**\r\n     * If `truncate` is enabled, should Label try to break only on full words\r\n     * (`true`), or whenever needed, including middle of the word. (`false`)\r\n     *\r\n     * @default true\r\n     * @param value  Truncate on full words?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"fullWords\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ellipsis\", {\n    /**\r\n     * @return Ellipsis string\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ellipsis\");\n    },\n    /**\r\n     * Ellipsis character to use if `truncate` is enabled.\r\n     *\r\n     * @param value Ellipsis string\r\n     * @default \"...\"\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ellipsis\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"selectable\", {\n    /**\r\n     * @return Text selectable?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"selectable\");\n    },\n    /**\r\n     * Forces the text to be selectable. This setting will be ignored if the\r\n     * object has some kind of interaction attached to it, such as it is\r\n     * `draggable`, `swipeable`, `resizable`.\r\n     *\r\n     * @param value  Text selectable?\r\n     * @default false\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"selectable\", value, true);\n      this.setStyles();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textAlign\", {\n    /**\r\n     * @return Alignment\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textAlign\");\n    },\n    /**\r\n     * Horizontal text alignment.\r\n     *\r\n     * Available choices:\r\n     * * \"start\"\r\n     * * \"middle\"\r\n     * * \"end\"\r\n     *\r\n     * @param value  Alignment\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textAlign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"textValign\", {\n    /**\r\n     * @ignore Exclude from docs (not used)\r\n     * @return Alignment\r\n     * @deprecated\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"textValign\");\n    },\n    /**\r\n     * Vertical text alignment.\r\n     *\r\n     * @ignore Exclude from docs (not used)\r\n     * @param value  Alignment\r\n     * @deprecated\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"textValign\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"html\", {\n    /**\r\n     * @return HTML content\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"html\");\n    },\n    /**\r\n     * Raw HTML to be used as text.\r\n     *\r\n     * NOTE: HTML text is subject to browser support. It relies on browsers\r\n     * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n     * support it. On those browsers, the text will fall back to basic SVG text,\r\n     * striping out all HTML markup and styling that goes with it.\r\n     *\r\n     * For more information about `foreignObject` and its browser compatibility\r\n     * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n     *\r\n     * @param value HTML text\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"html\", value, true);\n      if (!$type.hasValue(value)) {\n        var group = this.element;\n        group.removeChildrenByTag(\"foreignObject\");\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Label.prototype.setFill = function (value) {\n    _super.prototype.setFill.call(this, value);\n    if (this.html) {\n      var group = this.element;\n      var divs = group.node.getElementsByTagName(\"div\");\n      for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n        if ($type.hasValue(this.fill)) {\n          div.style.color = this.fill.toString();\n        }\n      }\n    }\n  };\n  Object.defineProperty(Label.prototype, \"hideOversized\", {\n    /**\r\n     * @return Hide if text does not fit?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"hideOversized\");\n    },\n    /**\r\n     * Indicates whether the whole text should be hidden if it does not fit into\r\n     * its allotted space.\r\n     *\r\n     * @param value  Hide if text does not fit?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"hideOversized\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"ignoreFormatting\", {\n    /**\r\n     * @return Ignore formatting?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreFormatting\");\n    },\n    /**\r\n     * If set to `true` square-bracket formatting blocks will be treated as\r\n     * regular text.\r\n     *\r\n     * @default false\r\n     * @param value  Ignore formatting?\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"ignoreFormatting\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Override `mesaureElement` so it does not get measure again, because\r\n   * internal `_bbox` is being updated by measuring routines in Text itself.\r\n   */\n  Label.prototype.measureElement = function () {};\n  /**\r\n   * Returns information about a line element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param index  Line index\r\n   * @return Line info object\r\n   */\n  Label.prototype.getLineInfo = function (index) {\n    this.initLineCache();\n    var lines = this.getCache(\"lineInfo\");\n    return lines.length > index ? lines[index] : undefined;\n  };\n  /**\r\n   * Adds a line to line info cache.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param line     Line info object\r\n   * @param index    Insert at specified index\r\n   */\n  Label.prototype.addLineInfo = function (line, index) {\n    this.initLineCache();\n    this.getCache(\"lineInfo\")[index] = line;\n  };\n  /**\r\n   * Checks if line cache is initialized and initializes it.\r\n   */\n  Label.prototype.initLineCache = function () {\n    if (!$type.hasValue(this.getCache(\"lineInfo\"))) {\n      this.setCache(\"lineInfo\", [], 0);\n    }\n  };\n  /**\r\n   * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n   *\r\n   * Check the description for [[Text]] class, for data binding.\r\n   *\r\n   * @param dataItem Data item\r\n   */\n  Label.prototype.setDataItem = function (dataItem) {\n    if (this._sourceDataItemEvents) {\n      this._sourceDataItemEvents.dispose();\n    }\n    if (dataItem) {\n      this._sourceDataItemEvents = new MultiDisposer([dataItem.events.on(\"valuechanged\", this.invalidate, this, false), dataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false), dataItem.events.on(\"propertychanged\", this.invalidate, this, false)]);\n    }\n    _super.prototype.setDataItem.call(this, dataItem);\n  };\n  Object.defineProperty(Label.prototype, \"availableWidth\", {\n    /**\r\n     * Returns available horizontal space.\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @return Available width (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Label.prototype, \"availableHeight\", {\n    /**\r\n     * Returns available vertical space.\r\n     *\r\n     * @return Available height (px)\r\n     */\n    get: function () {\n      return $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  // temp, replacing textFormatter method\n  Label.prototype.getSvgElement = function (text, style, parent) {\n    var element = this.paper.add(\"tspan\");\n    element.textContent = text;\n    if (style) {\n      if (options.nonce && parent) {\n        //element.node.setAttribute(\"nonce\", \"test123\");\n        var classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\n        element.node.setAttribute(\"class\", classid);\n        var defs = document.createElementNS($dom.SVGNS, \"defs\");\n        parent.node.appendChild(defs);\n        var e = document.createElement(\"style\");\n        e.type = \"text/css\";\n        e.innerHTML = \".\" + classid + \" { \" + style + \"}\";\n        e.setAttribute(\"nonce\", options.nonce);\n        defs.appendChild(e);\n      } else {\n        element.node.setAttribute(\"style\", style);\n      }\n    }\n    if (parent) {\n      parent.add(element);\n    }\n    return element;\n  };\n  /**\r\n   * Invalidates the whole element, including layout AND all its child\r\n   * elements.\r\n   */\n  Label.prototype.deepInvalidate = function () {\n    _super.prototype.deepInvalidate.call(this);\n    this.hardInvalidate();\n  };\n  Object.defineProperty(Label.prototype, \"readerTitle\", {\n    /**\r\n     * @return Title\r\n     */\n    get: function () {\n      var title = this.getPropertyValue(\"readerTitle\");\n      if (!title) {\n        title = this.populateString($utils.plainText($utils.isNotEmpty(this.html) ? this.html : this.text));\n      } else if (this.dataItem) {\n        title = this.populateString(title);\n      }\n      return title;\n    },\n    /**\r\n     * Screen reader title of the element.\r\n     *\r\n     * @param value Title\r\n     */\n    set: function (value) {\n      value = $type.toText(value);\n      if (this.setPropertyValue(\"readerTitle\", value)) {\n        this.applyAccessibility();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Label;\n}(Container);\nexport { Label };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"Label\"] = Label;\n/**\r\n * Add default responsive rules\r\n */\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\ndefaultRules.push({\n  relevant: ResponsiveBreakpoints.heightXS,\n  state: function (target, stateId) {\n    if (target instanceof Label && target.parent && target.parent.isBaseSprite) {\n      var state = target.states.create(stateId);\n      state.properties.disabled = true;\n      return state;\n    }\n    return null;\n  }\n});","map":{"version":3,"names":["Container","registry","getTextFormatter","MultiDisposer","InterfaceColorSet","$math","$utils","$type","$dom","defaultRules","ResponsiveBreakpoints","options","Label","_super","__extends","_this","call","isOversized","className","fill","getFor","wrap","truncate","fullWords","ellipsis","textAlign","textValign","layout","baseLineRatio","_positionPrecision","events","on","inited","handleMaxSize","once","handleValidate","applyTheme","prototype","afterDraw","validatePosition","setPaper","paper","changed","hardInvalidate","currentText","text","bbox","width","height","availableWidth","availableHeight","invalidate","arrange","updateCurrentText","output","isNotEmpty","html","supportsForeignObject","isObject","toString","hasValue","populateString","dataItem","_adapterO","apply","_currentFormat","_prevStatus","getLineBBox","lineInfo","element","node","parentNode","getBBox","draw","oldW","oldH","topParent","maxWidth","maxHeight","max","pixelPaddingLeft","pixelPaddingRight","pixelPaddingTop","pixelPaddingBottom","status","rtl","_measuredWidth","_measuredHeight","attr","display","lines","split","group","getAttr","removeAttr","textPathElement","removeChildren","resetBBox","currentHeight","currentFormat","i","length","line","tempElement","getSVGLineElement","add","getSvgElement","translateStyleShortcuts","offset","Math","ceil","removeElement","lineInfo_1","getLineInfo","textContent","chunks","chunk","ignoreFormatting","currentLineHeight","firstChunk","skipTextChunks","x","complex","type","style","lineText","avgCharWidth","excessChars","min","addEllipsis","node_1","childNodes","e","node_2","floor","elementText","maxChars","removeChild","truncateWithEllipsis","node_3","lastNode","lastChild","splitLines","splitTextByCharCount","lineText_1","shift","trim","cleanUp","restOfLine","join","replace","c","splice","round","paddingBottom","ltrim","rtrim","addLineInfo","maybeHideOversized","measureFailed","pixelWidth","pixelHeight","alignSVGText","dispatch","hideUnused","setCache","fo","foreignObject","lineElement","getHTMLLineElement","appendChild","clientWidth","clientHeight","_bbox","y","overflow","setStyles","updateCenter","updateBackground","pathElement","appendDef","hideOversized","children","used","setAttribute","removeAttribute","toNumber","getAttribute","addGroup","Object","defineProperty","get","_rtl","_topParent","set","value","toBoolean","div","document","createElement","innerHTML","wordWrap","whiteSpace","direction","color","selectable","draggable","resizable","swipeable","addStyle","removeStyle","index","initLineCache","getCache","getPropertyValue","setPropertyValue","dispose","uid","_disposers","push","attrNS","XLINK","removeChildrenByTag","setFill","divs","getElementsByTagName","measureElement","undefined","setDataItem","_sourceDataItemEvents","parent","nonce","classid","btoa","defs","createElementNS","SVGNS","deepInvalidate","title","plainText","toText","applyAccessibility","registeredClasses","relevant","heightXS","state","target","stateId","isBaseSprite","states","create","properties","disabled"],"sources":["../../../../../src/.internal/core/elements/Label.ts"],"sourcesContent":["/**\r\n * Text class deals with all text placed on chart.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerAdapters, IContainerEvents } from \"../Container\";\r\nimport { DataItem } from \"../DataItem\";\r\nimport { TextValign } from \"../defs/TextValign\";\r\nimport { TextAlign } from \"../defs/TextAlign\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Group } from \"../rendering/Group\";\r\nimport { registry } from \"../Registry\";\r\nimport { ITextChunk, getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { MultiDisposer } from \"../utils/Disposer\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Pattern } from \"../rendering/fills/Pattern\";\r\nimport { LinearGradient } from \"../rendering/fills/LinearGradient\";\r\nimport { RadialGradient } from \"../rendering/fills/RadialGradient\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { Paper } from \"../rendering/Paper\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport { defaultRules, ResponsiveBreakpoints } from \"../utils/Responsive\";\r\nimport { options } from \"../Options\";\r\n\r\n\r\n/**\r\n * Defines properties for [[Text]].\r\n */\r\nexport interface ILabelProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Horizontal align of the text.\r\n\t *\r\n\t * @default \"start\"\r\n\t */\r\n\ttextAlign?: TextAlign;\r\n\r\n\t/**\r\n\t * Vertical align of the text.\r\n\t *\r\n\t * @default \"top\"\r\n\t */\r\n\ttextValign?: TextValign;\r\n\r\n\t/**\r\n\t * A plain text content.\r\n\t */\r\n\ttext?: string;\r\n\r\n\t/**\r\n\t * Should the lines wrap if they do not fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\twrap?: boolean;\r\n\r\n\t/**\r\n\t * Should the text be selectable>\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tselectable?: boolean;\r\n\r\n\t/**\r\n\t * HTML content.\r\n\t */\r\n\thtml?: string;\r\n\r\n\t/**\r\n\t * Should the lines be truncated (optionally with ellipsis) if they do not\r\n\t * fit into max width?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\ttruncate?: boolean;\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t */\r\n\tfullWords?: boolean;\r\n\r\n\t/**\r\n\t * If lines are truncated, this ellipsis will be added at the end.\r\n\t *\r\n\t * @default \"â€¦\"\r\n\t */\r\n\tellipsis?: string;\r\n\r\n\t/**\r\n\t * Hide text of it does not fit into element's dimensions?\r\n\t *\r\n\t * @default false\r\n\t */\r\n\thideOversized?: boolean;\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tignoreFormatting?: boolean;\r\n\r\n\t/**\r\n\t * Path string along which text should be arranged\r\n\t */\r\n\tpath?: string\r\n\r\n\t/**\r\n\t * Relative label location on path.\r\n\t */\r\n\tlocationOnPath?: number;\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @default -0.27\r\n\t */\r\n\tbaseLineRatio?: number;\r\n}\r\n\r\n/**\r\n * Text line information.\r\n *\r\n * Objects used to hold cached information about lines in a Text element.\r\n */\r\nexport interface ITextLineInfo {\r\n\r\n\t/**\r\n\t * Measurements for the bounding box of the line.\r\n\t */\r\n\t\"bbox\"?: IRectangle,\r\n\r\n\t/**\r\n\t * A reference to an SVG `<g>` element that holds line elements.\r\n\t */\r\n\t\"element\"?: Group,\r\n\r\n\t/**\r\n\t * Indicates if line contains more than one element, e.g. has multiple\r\n\t * formatted blocks.\r\n\t */\r\n\t\"complex\"?: boolean,\r\n\r\n\t\"text\"?: string,\r\n\r\n\t\"style\"?: string\r\n};\r\n\r\n/**\r\n * Defines events for [[Text]].\r\n */\r\nexport interface ILabelEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Adapters for [[Text]].\r\n *\r\n * Includes both the [[Adapter]] definitions and properties.\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface ILabelAdapters extends IContainerAdapters, ILabelProperties {\r\n\r\n\t/**\r\n\t * Applied to the final formatted label text.\r\n\t */\r\n\ttextOutput: string;\r\n\r\n\t/**\r\n\t * Applied to the final formatted label HTML.\r\n\t */\r\n\thtmlOutput: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Text is used to display highly configurable, data-enabled textual elements.\r\n *\r\n * ## Data Binding\r\n *\r\n * A Text element can dynamically parse and populate its contents with values\r\n * from a [[DataItem]].\r\n *\r\n * To activate such binding, set element's `dataItem` property.\r\n *\r\n * When activated, text contents will be parsed for special tags, e.g.:\r\n *\r\n * ```TypeScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n * ```JavaScript\r\n * label.dataItem = myDataItem;\r\n * label.text = \"The title is: {title}\";\r\n * ```\r\n *\r\n * The above will automatically replace \"{title}\" in the string with the\r\n * actual data value from `myDataItem`.\r\n *\r\n * Note, that most often dataItem is set by the Component.\r\n *\r\n *\r\n * @see {@link ILabelEvents} for a list of available events\r\n * @see {@link ILabelAdapters} for a list of available Adapters\r\n * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-strings/} for info on string formatting and data binding\r\n * @todo Vertical align\r\n * @important\r\n */\r\nexport class Label extends Container {\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: ILabelProperties;\r\n\r\n\t/**\r\n\t * Defines Adapter type.\r\n\t */\r\n\tpublic _adapter!: ILabelAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: ILabelEvents;\r\n\r\n\t/**\r\n\t * Indicates if the whole text does not fit into max dimenstions set for it.\r\n\t */\r\n\tpublic isOversized: boolean = false;\r\n\r\n\t/**\r\n\t * Currently formatted text, read only.\r\n\t */\r\n\tpublic currentText: string;\r\n\r\n\t/**\r\n\t * Current format to be used for outputing text.\r\n\t */\r\n\tprotected _currentFormat: string;\r\n\r\n\t/**\r\n\t * [_sourceDataItemEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _sourceDataItemEvents: MultiDisposer;\r\n\r\n\r\n\tprotected _prevStatus: string;\r\n\r\n\t/**\r\n\t * SVG path element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic pathElement: $type.Optional<AMElement>;\r\n\r\n\t/**\r\n\t * SVG textpath element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic textPathElement: $type.Optional<Group>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Execute super's constructor\r\n\t\tsuper();\r\n\r\n\t\t// Set this class name\r\n\t\tthis.className = \"Label\";\r\n\r\n\t\tthis.fill = new InterfaceColorSet().getFor(\"text\");\r\n\r\n\t\t// not good to set this, as then these will appear on each label and values set on container won't be applied.\r\n\t\t//this.textDecoration = \"none\";\r\n\t\t//this.fontWeight = \"normal\";\r\n\r\n\r\n\t\t// Set defaults\r\n\t\tthis.wrap = false;\r\n\t\tthis.truncate = false;\r\n\t\tthis.fullWords = true;\r\n\t\tthis.ellipsis = \"â€¦\";\r\n\t\tthis.textAlign = \"start\";\r\n\t\tthis.textValign = \"top\";\r\n\r\n\t\tthis.layout = \"absolute\";\r\n\t\tthis.baseLineRatio = -0.27;\r\n\t\t//this.pixelPerfect = true;\r\n\t\tthis._positionPrecision = 1;\r\n\r\n\t\t// Add events to watch for maxWidth/maxHeight changes so that we can\r\n\t\t// invalidate this\r\n\t\tthis.events.on(\"maxsizechanged\", () => {\r\n\t\t\tif (this.inited) {\r\n\t\t\t\tthis.handleMaxSize()\r\n\t\t\t}\r\n\t\t}, this, false);\r\n\r\n\t\t// this solves strange bug when text just added to svg is 0x0\r\n\t\tthis.events.once(\"validated\", this.handleValidate, this, false);\r\n\r\n\t\t// Aply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * A placeholder method that is called **after** element finishes drawing\r\n\t * itself.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tprotected afterDraw(): void {\r\n\t\t// since we removed validatePosition from sprite, we still need it here to handle rotated text\r\n\t\tsuper.afterDraw();\r\n\t\tthis.validatePosition();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Sets [[Paper]] instance to use to draw elements.\r\n\t * @ignore\r\n\t * @param paper Paper\r\n\t * @return true if paper was changed, false, if it's the same\r\n\t */\r\n\tpublic setPaper(paper: Paper): boolean {\r\n\r\n\t\tlet changed = super.setPaper(paper);\r\n\r\n\t\tif (changed) {\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleValidate() {\r\n\t\tif ((this.currentText || this.text) && (this.bbox.width == 0 || this.bbox.height == 0)) {\r\n\t\t\tregistry.events.once(\"exitframe\", this.hardInvalidate, this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected handleMaxSize() {\r\n\t\tif (\r\n\t\t\t(this.bbox.width > this.availableWidth)\r\n\t\t\t|| ((this.bbox.width < this.availableWidth) && (this.isOversized || this.truncate))\r\n\t\t\t|| (this.bbox.height > this.availableHeight)\r\n\t\t\t|| ((this.bbox.height < this.availableHeight) && this.isOversized)\r\n\t\t) {\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t\telse {\r\n\t\t\t//this.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [arrange description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t */\r\n\tpublic arrange(): void {\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Updates current text according to data item and supported features.\r\n\t * Returns `true` if current text has changed.\r\n\t *\r\n\t * @return Text changed?\r\n\t */\r\n\tprotected updateCurrentText(): boolean {\r\n\t\t// Determine output format\r\n\t\tlet output: string, text: string;\r\n\r\n\t\tif ($utils.isNotEmpty(this.html) && this.paper.supportsForeignObject()) {\r\n\r\n\t\t\t// We favor HTML text if it's set and browser supports `foreignObject`\r\n\t\t\toutput = \"html\";\r\n\t\t\ttext = this.html;\r\n\t\t}\r\n\t\telse {\r\n\t\t\toutput = \"svg\";\r\n\t\t\ttext = this.text;\r\n\t\t}\r\n\r\n\t\t// Need to toString source?\r\n\t\tif ($type.isObject(text as any)) {\r\n\t\t\ttext = text.toString();\r\n\t\t}\r\n\r\n\t\t// Need to format text all the time\r\n\t\tif ($type.hasValue(text) && text !== \"\") {\r\n\t\t\ttext = this.populateString(text, this.dataItem);\r\n\t\t}\r\n\r\n\t\tif (output == \"html\") {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"htmlOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this._adapterO) {\r\n\t\t\t\ttext = this._adapterO.apply(\"textOutput\", text);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update the text\r\n\t\tlet changed = text != this.currentText || output != this._currentFormat;\r\n\t\tthis.currentText = text;\r\n\t\tthis._currentFormat = output;\r\n\r\n\t\treturn changed;\r\n\t}\r\n\r\n\t/**\r\n\t * Hard invalidate means the text will be redrawn even if it hasn't changed.\r\n\t * This is used when we change `fontSize`, `fontFamily`, or for some other\r\n\t * reasons.\r\n\t */\r\n\tpublic hardInvalidate() {\r\n\t\tthis._prevStatus = \"\";\r\n\t\tthis.invalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets line bbox, uses caching to save cpu\r\n\t * @ignore\r\n\t */\r\n\tprotected getLineBBox(lineInfo: ITextLineInfo) {\r\n\t\t//let cacheKey = lineInfo.text + lineInfo.style;\r\n\r\n\t\t//let lineBBox = this.getCache(cacheKey);\r\n\t\t//if (!lineBBox) {\r\n\t\t//lineBBox = lineInfo.element.getBBox();\r\n\t\t//if (lineBBox.width != 0 && lineBBox.height != 0) {\r\n\t\t//\tthis.setCache(cacheKey, lineBBox, 5000);\r\n\t\t//}\r\n\t\t//}\r\n\r\n\t\tlet element = lineInfo && lineInfo.element;\r\n\t\tlet node = element && element.node;\r\n\r\n\t\t// Check for the parent Node to avoid FF from throwing errors\r\n\t\tif (node && node.parentNode) {\r\n\t\t\tlineInfo.bbox = element.getBBox();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the textual label.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\r\n\t\t// Draw super\r\n\t\tsuper.draw();\r\n\r\n\t\tlet oldW = this.bbox.width;\r\n\t\tlet oldH = this.bbox.height;\r\n\r\n\t\tlet topParent = this.topParent;\r\n\t\tif (topParent) {\r\n\t\t\tif (!topParent.maxWidth || !topParent.maxHeight) {\r\n\t\t\t\ttopParent.events.once(\"maxsizechanged\", this.hardInvalidate, this, false);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Calculate max width and height\r\n\t\tlet maxWidth: number = $math.max(this.availableWidth - this.pixelPaddingLeft - this.pixelPaddingRight, 0);\r\n\t\tlet maxHeight: number = $math.max(this.availableHeight - this.pixelPaddingTop - this.pixelPaddingBottom, 0);\r\n\r\n\t\t// save\r\n\t\tlet status = maxHeight + \",\" + maxWidth + this.wrap + this.truncate + this.fullWords + this.rtl + this.ellipsis;\r\n\r\n\t\t// Update text\r\n\t\tif (!this.updateCurrentText() && this.inited && this._prevStatus == status) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._measuredWidth = 0;\r\n\t\tthis._measuredHeight = 0;\r\n\r\n\t\t// Reset\r\n\t\tthis.isOversized = false;\r\n\r\n\t\t// Determine output format\r\n\t\tlet output = this._currentFormat;\r\n\t\tlet text = this.currentText;\r\n\r\n\t\t// Empty string\r\n\t\tif (!$type.hasValue(text) || text == \"\") {\r\n\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Chop up text into lines\r\n\t\t// We're still processing SVG and HTML in the same way for now\r\n\t\tlet lines: string[] = text.split(\"\\n\");\r\n\r\n\t\t// Do we need to go through the trouble of measuring lines\r\n\t\t//let measure: boolean = true;// (lines.length > 1) || this.wrap;\r\n\r\n\t\tthis._prevStatus = status;\r\n\r\n\t\tthis.textAlign = this.textAlign;\r\n\r\n\t\t// need this to measure\r\n\t\tlet display = this.group.getAttr(\"display\");\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.removeAttr(\"display\");\r\n\t\t}\r\n\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.removeChildren();\r\n\t\t}\r\n\r\n\t\t// SVG or HTML?\r\n\t\tif (output === \"svg\") {\r\n\t\t\t/**\r\n\t\t\t * SVG\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\t\t\t//group.removeChildren();\r\n\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Init state variables\r\n\t\t\tlet currentHeight: number = 0;\r\n\t\t\tlet currentFormat: string = \"\";\r\n\r\n\t\t\t// Process each line\r\n\t\t\tfor (let i = 0; i < lines.length; i++) {\r\n\r\n\t\t\t\t// Get line\r\n\t\t\t\tlet line: string = lines[i];\r\n\r\n\t\t\t\t// Check if line is empty\r\n\t\t\t\tif (line == \"\") {\r\n\t\t\t\t\t// It is, let's just update currentHeight and go to the next one\r\n\t\t\t\t\t// If it's the first line, we'll have to use arbirary line height,\r\n\t\t\t\t\t// since there's nothing to measure. For subsequent lines we can take\r\n\t\t\t\t\t// previous line's height\r\n\t\t\t\t\tlet tempElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\ttempElement.add(\r\n\t\t\t\t\t\tthis.getSvgElement(\r\n\t\t\t\t\t\t\t\".\",\r\n\t\t\t\t\t\t\tgetTextFormatter().translateStyleShortcuts(currentFormat)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tgroup.add(tempElement);\r\n\t\t\t\t\tlet offset = Math.ceil(tempElement.getBBox().height);\r\n\t\t\t\t\tif (offset > 0) {\r\n\t\t\t\t\t\tcurrentHeight += offset;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgroup.removeElement(tempElement);\r\n\r\n\t\t\t\t\t// Clear cache if necessary\r\n\t\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\t\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Chunk up the line and process each chunk\r\n\t\t\t\tlet chunks: ITextChunk[] = getTextFormatter().chunk(line, null, this.ignoreFormatting);\r\n\t\t\t\tlet currentLineHeight: number = 0;\r\n\t\t\t\tlet firstChunk: boolean = true;\r\n\t\t\t\tlet skipTextChunks: boolean = false;\r\n\r\n\t\t\t\t// Create line element or grab it from cache\r\n\t\t\t\tlet lineInfo = this.getLineInfo(i);\r\n\r\n\t\t\t\tif (lineInfo) {\r\n\t\t\t\t\t// Empty line\r\n\t\t\t\t\tlineInfo.text = \"\";\r\n\t\t\t\t\tlineInfo.element.textContent = \"\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Init new line info\r\n\t\t\t\t\tlineInfo = {\r\n\t\t\t\t\t\t\"text\": \"\",\r\n\t\t\t\t\t\t\"element\": this.getSVGLineElement(\"\", 0),\r\n\t\t\t\t\t\t\"complex\": false\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Create the line element\r\n\t\t\t\t\t//lineInfo.element = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\t//lineElement = this.getSVGLineElement(\"\", 0);\r\n\t\t\t\t\tgroup.add(lineInfo.element);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlineInfo.element.removeAttr(\"display\");\r\n\t\t\t\tlineInfo.element.removeChildren(); // memory leak without this\r\n\r\n\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\tlineInfo.element.add(this.textPathElement);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*// @todo not needed anymore\r\n\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\tchunks.reverse();\r\n\t\t\t\t}*/\r\n\r\n\t\t\t\t// Process each chunk\r\n\t\t\t\tfor (let x: number = 0; x < chunks.length; x++) {\r\n\r\n\t\t\t\t\t// If there's more than one chunk, means the line is \"complex\"\r\n\t\t\t\t\tif (x) {\r\n\t\t\t\t\t\tlineInfo.complex = true;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Get chunk\r\n\t\t\t\t\tlet chunk = chunks[x];\r\n\r\n\t\t\t\t\t// Is this chunk format or text?\r\n\t\t\t\t\tif (chunk.type === \"format\") {\r\n\r\n\t\t\t\t\t\t// Log current format, so that we can apply it to multiple lines if\r\n\t\t\t\t\t\t// necessary\r\n\t\t\t\t\t\tcurrentFormat = chunk.text;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t// It's text block\r\n\r\n\t\t\t\t\t\t// Need to skip?\r\n\t\t\t\t\t\t// We do this when truncating. We can't just simply go ahead and\r\n\t\t\t\t\t\t// abandon chunk processing as they might have formatting\r\n\t\t\t\t\t\t// instructions in them that are relevant for subsequent lines\r\n\t\t\t\t\t\tif (skipTextChunks) {\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Add chunk to the current element\r\n\t\t\t\t\t\t//lineInfo.element.content += $utils.trim(getTextFormatter().format(currentFormat + chunk.text, output));\r\n\r\n\t\t\t\t\t\tlineInfo.text = chunk.text;\r\n\t\t\t\t\t\tlineInfo.style = getTextFormatter().translateStyleShortcuts(currentFormat);\r\n\r\n\r\n\t\t\t\t\t\tif (this.textPathElement) {\r\n\t\t\t\t\t\t\tthis.getSvgElement(lineInfo.text, lineInfo.style, this.textPathElement);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.getSvgElement(lineInfo.text, lineInfo.style, lineInfo.element);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis.getLineBBox(lineInfo);\r\n\t\t\t\t\t\tlineInfo.bbox.width = Math.ceil(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t// Updated current line height\r\n\t\t\t\t\t\tif (currentLineHeight < lineInfo.bbox.height) {\r\n\t\t\t\t\t\t\tcurrentLineHeight = lineInfo.bbox.height;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Wrapping?\r\n\t\t\t\t\t\tif ((this.wrap || this.truncate) && (lineInfo.bbox.width > maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t// Set oversized\r\n\t\t\t\t\t\t\tthis.isOversized = true;\r\n\r\n\t\t\t\t\t\t\t// Take temporary measurements\r\n\t\t\t\t\t\t\tlet lineText: string = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\tlet avgCharWidth: number = (lineInfo.bbox.width / lineText.length); // * .9;\r\n\r\n\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\tlet excessChars: number = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t// Are we truncating or auto-wrapping text?\r\n\t\t\t\t\t\t\tif (this.truncate) {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processing line truncation\r\n\t\t\t\t\t\t\t\t * With the addition of each text chunk we measure if current\r\n\t\t\t\t\t\t\t\t * line does not exceed maxWidth. If it does, we will stop\r\n\t\t\t\t\t\t\t\t * addition of further chunks as well as try to truncate\r\n\t\t\t\t\t\t\t\t * current or any number of previous chunks with an added\r\n\t\t\t\t\t\t\t\t * ellipsis\r\n\t\t\t\t\t\t\t\t */\r\n\r\n\t\t\t\t\t\t\t\t// Indicator whether we need to add ellipsis to the current\r\n\t\t\t\t\t\t\t\t// element, even if it fits. This is needed to indicate\r\n\t\t\t\t\t\t\t\t// whether we have already removed some subsequent chunks in\r\n\t\t\t\t\t\t\t\t// which case we need to add ellipsis.\r\n\t\t\t\t\t\t\t\tlet addEllipsis: boolean = false;\r\n\r\n\t\t\t\t\t\t\t\t// Process each child in the temporary line, until the whole\r\n\t\t\t\t\t\t\t\t// line fits, preferably with an ellipsis\r\n\t\t\t\t\t\t\t\t// TODO use iterator instead\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node && node.childNodes) {\r\n\t\t\t\t\t\t\t\t\tfor (let e = lineInfo.element.node.childNodes.length - 1; e >= 0; e--) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get current element\r\n\t\t\t\t\t\t\t\t\t\tlet node = lineInfo.element.node.childNodes[e];\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add ellipsis only if previous chunk was removed in full\r\n\t\t\t\t\t\t\t\t\t\t// and this chunk already fits\r\n\t\t\t\t\t\t\t\t\t\t//if (addEllipsis && (bbox.width <= maxWidth)) {\r\n\t\t\t\t\t\t\t\t\t\tif (addEllipsis && (lineInfo.bbox.width <= maxWidth)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent += \" \" + this.ellipsis;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again (we need to make sure ellipsis fits)\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// If it fits, we're done here\r\n\t\t\t\t\t\t\t\t\t\t\t// If it doesn't we continue rolling\r\n\t\t\t\t\t\t\t\t\t\t\tif (lineInfo.bbox.width <= maxWidth) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\taddEllipsis = false;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Get element text\r\n\t\t\t\t\t\t\t\t\t\tlet elementText = node.textContent;\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate average number of symbols / width\r\n\t\t\t\t\t\t\t\t\t\tlineText = lineInfo.element.textContent;\r\n\t\t\t\t\t\t\t\t\t\texcessChars = $math.min(Math.ceil((lineInfo.bbox.width - maxWidth) / avgCharWidth), lineText.length);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do this until we fit\r\n\t\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(lineText.length - excessChars - this.ellipsis.length, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Is there anything left?\r\n\t\t\t\t\t\t\t\t\t\t\tif (maxChars <= 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Nope, let's jump to the previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Set excess characters to zero so that this loop does\r\n\t\t\t\t\t\t\t\t\t\t\t\t// not repeat when it over\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Subsequent iterations will check if the ellipsis fits\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (e > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Indicating to add ellipsis to previous item\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taddEllipsis = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t// Removing this node\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(node);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Truncate the text\r\n\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, this.fullWords, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ((elementText.length > maxChars) && this.fullWords) {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Still too long?\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Let's try truncating breaking words anyway\r\n\t\t\t\t\t\t\t\t\t\t\t\telementText = $utils.truncateWithEllipsis(elementText, maxChars, this.ellipsis, false, this.rtl);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Set truncated text\r\n\t\t\t\t\t\t\t\t\t\t\tnode.textContent = elementText;\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Measure again\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t\texcessChars = Math.ceil(excessChars * 1.1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Do not process further chunks\r\n\t\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t/**\r\n\t\t\t\t\t\t\t\t * Processign auto-wrap\r\n\t\t\t\t\t\t\t\t * In this case we're going to be adding text chunks until\r\n\t\t\t\t\t\t\t\t * they don't fit into current line. Once that happens we will\r\n\t\t\t\t\t\t\t\t * inject the rest of the chunks to the next line\r\n\t\t\t\t\t\t\t\t */\r\n\t\t\t\t\t\t\t\t// Get last node added and measure it\r\n\t\t\t\t\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\t\t\t\t\tif (node) {\r\n\t\t\t\t\t\t\t\t\tlet lastNode = lineInfo.element.node.lastChild;\r\n\r\n\t\t\t\t\t\t\t\t\t// Init split lines\r\n\t\t\t\t\t\t\t\t\tlet splitLines: string[];\r\n\t\t\t\t\t\t\t\t\twhile ((lineInfo.bbox.width > maxWidth) && (excessChars <= lineText.length) && (excessChars > 0)) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Calculate max available chars\r\n\t\t\t\t\t\t\t\t\t\tlet maxChars: number = $math.max(chunk.text.length - excessChars, 1);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Don't split the words mid-word if it's not the first chunk\r\n\t\t\t\t\t\t\t\t\t\t// in the line\r\n\t\t\t\t\t\t\t\t\t\tif (firstChunk) {\r\n\t\t\t\t\t\t\t\t\t\t\t// Split mid-word if necessary\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl);\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Don't split mid-word\r\n\t\t\t\t\t\t\t\t\t\t\tsplitLines = $utils.splitTextByCharCount(chunk.text, maxChars, true, this.rtl, false);\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t// Check if the first word is too long\r\n\t\t\t\t\t\t\t\t\t\t\tif ((splitLines[0].length > maxChars) || maxChars === 1) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Yes - move the whole chunk to the next line\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Remove the element we just added\r\n\t\t\t\t\t\t\t\t\t\t\t\tlineInfo.element.node.removeChild(lastNode)\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\t// Break out of the while on next cycle\r\n\t\t\t\t\t\t\t\t\t\t\t\texcessChars = 0;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Use the first line to update last item\r\n\t\t\t\t\t\t\t\t\t\tif (excessChars > 0) {\r\n\t\t\t\t\t\t\t\t\t\t\tlet lineText = splitLines.shift();\r\n\t\t\t\t\t\t\t\t\t\t\tif (firstChunk) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tlineText = $utils.trim(lineText);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\tlastNode.textContent = getTextFormatter().cleanUp(lineText);\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Measure again, just in case\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox = lineInfo.element.getBBox();\r\n\t\t\t\t\t\t\t\t\t\tlineInfo.bbox.width = Math.floor(lineInfo.bbox.width);\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Increase excess characters count, just in case it still\r\n\t\t\t\t\t\t\t\t\t\t// doesn't fit and we have to go at it again\r\n\t\t\t\t\t\t\t\t\t\t//excessChars = Math.ceil(excessChars * 1.05);\r\n\t\t\t\t\t\t\t\t\t\texcessChars++;\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\t\t\t\t\t// Construct the rest of the line\r\n\t\t\t\t\t\t\t\t\tif (splitLines.length > 0) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tlet restOfLine: string = \"\";\r\n\t\t\t\t\t\t\t\t\t\t// Add leftovers from splitting the current chunk\r\n\t\t\t\t\t\t\t\t\t\tif ($type.hasValue(splitLines)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += splitLines.join(\"\") + currentFormat;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += currentFormat + splitLines.join(\"\").replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Add the rest of the chunks\r\n\t\t\t\t\t\t\t\t\t\tfor (let c: number = x + 1; c < chunks.length; c++) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (chunks[c].type == \"value\") {\r\n\t\t\t\t\t\t\t\t\t\t\t\t// We're escaping single square brackets that were\r\n\t\t\t\t\t\t\t\t\t\t\t\t// cleaned up by chunk() back to double square brackets\r\n\t\t\t\t\t\t\t\t\t\t\t\t// so that they are not being treated as format on\r\n\t\t\t\t\t\t\t\t\t\t\t\t// next pass.\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text.replace(/([\\[\\]]{1})/g, \"$1$1\");\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t\t\trestOfLine += chunks[c].text;\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// Inject the rest of the lines as chunks for subsequent\r\n\r\n\t\t\t\t\t\t\t\t\t\tlines.splice(i + 1, 0, restOfLine);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t// Skip processing the rest of the chunks\r\n\t\t\t\t\t\t\t\t\tskipTextChunks = true;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Let's update the text's bbox with the line's one\r\n\t\t\t\t\t\tif (this.bbox.width < lineInfo.bbox.width) {\r\n\t\t\t\t\t\t\tthis.bbox.width = lineInfo.bbox.width;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// commented to avoid bug (seen on sankey link) where text is incorrectly aligned\r\n\t\t\t\t\t\t//if (this.bbox.x > lineInfo.bbox.x) {\r\n\t\t\t\t\t\t//this.bbox.x = lineInfo.bbox.x;\r\n\t\t\t\t\t\t//}\r\n\r\n\t\t\t\t\t\tthis.bbox.height = currentHeight + currentLineHeight;\r\n\r\n\t\t\t\t\t\t// Position current line\r\n\t\t\t\t\t\tif (!this.textPathElement) {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"x\": \"0\",\r\n\t\t\t\t\t\t\t\t\"y\": currentHeight + currentLineHeight,\r\n\t\t\t\t\t\t\t\t\"dy\": $math.round((this.baseLineRatio * currentLineHeight), 3).toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tlineInfo.element.attr({\r\n\t\t\t\t\t\t\t\t\"dy\": -this.paddingBottom.toString()\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfirstChunk = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Trim the last item\r\n\t\t\t\tlet node = lineInfo.element.node;\r\n\t\t\t\tif (node) {\r\n\t\t\t\t\tlet lastNode = node.lastChild;\r\n\t\t\t\t\tif (lastNode) {\r\n\t\t\t\t\t\tlastNode.textContent = this.rtl ?\r\n\t\t\t\t\t\t\t$utils.ltrim(lastNode.textContent) :\r\n\t\t\t\t\t\t\t$utils.rtrim(lastNode.textContent);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Increment collective height\r\n\t\t\t\tcurrentHeight += currentLineHeight;\r\n\r\n\t\t\t\t// Save line cache\r\n\t\t\t\tthis.addLineInfo(lineInfo, i);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\tthis.measureFailed = false;\r\n\t\t\tif (this.bbox.width == 0 || this.bbox.height == 0) {\r\n\t\t\t\tthis.measureFailed = true;\r\n\t\t\t}\r\n\r\n\t\t\t// Updated measured dims\r\n\t\t\tthis._measuredWidth = $math.round($math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight));\r\n\t\t\tthis._measuredHeight = $math.round($math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom));\r\n\r\n\t\t\t// Align the lines\r\n\t\t\tthis.alignSVGText();\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\tif (oldH != this._measuredHeight || oldW != this._measuredWidth) {\r\n\t\t\t\tthis.dispatch(\"transformed\");\r\n\t\t\t}\r\n\r\n\t\t\tthis.hideUnused(lines.length);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t/**\r\n\t\t\t * HTML\r\n\t\t\t */\r\n\r\n\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\tthis.resetBBox();\r\n\r\n\t\t\t// Clear the element\r\n\t\t\tlet group: Group = <Group>this.element;\r\n\t\t\tgroup.removeChildren();\r\n\t\t\tthis.setCache(\"lineInfo\", [], 0);\r\n\r\n\t\t\t// Create a ForeignObject to use as HTML container\r\n\t\t\tlet fo = this.paper.foreignObject();\r\n\t\t\tgroup.add(fo);\r\n\r\n\t\t\t// Set widths on foreignObject so that autosizing measurements work\r\n\t\t\t// This will bet reset to actual content width/height\r\n\t\t\tif (this.maxWidth) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\twidth: this.maxWidth - this.pixelPaddingLeft - this.pixelPaddingRight\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tif (this.maxHeight) {\r\n\t\t\t\tfo.attr({\r\n\t\t\t\t\theight: this.maxHeight - this.pixelPaddingTop - this.pixelPaddingBottom\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Create line element\r\n\t\t\t//let lineElement: HTMLElement = this.getHTMLLineElement(getTextFormatter().format(this.html, output));\r\n\t\t\tlet lineElement: HTMLElement = this.getHTMLLineElement(text);\r\n\t\t\tfo.node.appendChild(lineElement);\r\n\r\n\t\t\t// Temporarily set to inline-block so we can measure real width and height\r\n\t\t\tlineElement.style.display = \"inline-block\";\r\n\t\t\tconst clientWidth = lineElement.clientWidth;\r\n\t\t\tconst clientHeight = lineElement.clientHeight;\r\n\r\n\t\t\tlineElement.style.display = \"block\";\r\n\t\t\tthis._bbox = {\r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 0,\r\n\t\t\t\twidth: clientWidth,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t};\r\n\r\n\t\t\t// Set exact dimensions of foreignObject so it is sized exactly as\r\n\t\t\t// the content within (add one pixel to width so it does not wrap)\r\n\t\t\tfo.attr({\r\n\t\t\t\twidth: clientWidth + 1,\r\n\t\t\t\theight: clientHeight\r\n\t\t\t});\r\n\r\n\t\t\t// Check if maybe we need to hide the whole label if it doesn't fit\r\n\t\t\tthis.maybeHideOversized();\r\n\r\n\t\t\t// Set measurements and update bbox\r\n\t\t\tthis._measuredWidth = $math.max(this.bbox.width, this.pixelWidth - this.pixelPaddingLeft - this.pixelPaddingRight);\r\n\t\t\tthis._measuredHeight = $math.max(this.bbox.height, this.pixelHeight - this.pixelPaddingTop - this.pixelPaddingBottom);\r\n\r\n\t\t\tthis.bbox.width = this._measuredWidth;\r\n\t\t\tthis.bbox.height = this._measuredHeight;\r\n\r\n\t\t\t// Don't let labels bleed out of the alotted area\r\n\t\t\tif (this.truncate) {\r\n\t\t\t\tlineElement.style.overflow = \"hidden\";\r\n\t\t\t}\r\n\r\n\t\t\tif ((clientWidth > maxWidth) || (clientHeight > maxHeight)) {\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\t// Set applicable styles\r\n\t\tthis.setStyles();\r\n\t\tthis.updateCenter();\r\n\t\tthis.updateBackground();\r\n\r\n\t\tif (display == \"none\") {\r\n\t\t\tthis.group.attr({ display: \"none\" });\r\n\t\t}\r\n\r\n\t\tif (this.pathElement) {\r\n\t\t\tthis.paper.appendDef(this.pathElement);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides element if it does not fit into available space\r\n\t */\r\n\tprivate maybeHideOversized(): void {\r\n\t\tif (this.hideOversized) {\r\n\t\t\tif ((this.availableWidth < this.bbox.width) || (this.availableHeight < this.bbox.height)) {\r\n\t\t\t\tthis.element.attr({ display: \"none\" });\r\n\t\t\t\tthis.isOversized = true;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.element.removeAttr(\"display\");\r\n\t\t\t\tthis.isOversized = false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Aligns the lines horizontally and vertically, based on properties.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic alignSVGText(): void {\r\n\t\t// Get Group\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tlet children = group.node.children || group.node.childNodes;\r\n\r\n\t\t// Is there anything to align?\r\n\t\tif (!children || (children && children.length == 0)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet width = this._measuredWidth;\r\n\t\tlet height = this._measuredHeight;\r\n\r\n\t\t// TODO maybe these aren't needed ?\r\n\t\t$utils.used(this.pixelPaddingLeft);\r\n\t\t$utils.used(this.pixelPaddingRight);\r\n\t\t$utils.used(this.pixelPaddingTop);\r\n\t\t$utils.used(this.pixelPaddingBottom);\r\n\r\n\t\tif (this.rtl) {\r\n\t\t\tgroup.attr({\r\n\t\t\t\t\"direction\": \"rtl\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgroup.removeAttr(\"direction\");\r\n\t\t}\r\n\r\n\t\t// Process each line\r\n\t\t//$iter.each(group.children.backwards().iterator(), (element) => {\r\n\t\tfor (let i = children.length - 1; i >= 0; i--) {\r\n\t\t\t// Align horizontally\r\n\t\t\t// Since we are using `text-anchor` for horizontal alignment, all we need\r\n\t\t\t// to do here is move the `x` position\r\n\t\t\tlet node = <SVGElement>children[i];\r\n\r\n\t\t\tnode.setAttribute(\"text-anchor\", this.textAlign);\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tnode.removeAttribute(\"x\");\r\n\t\t\t\tnode.removeAttribute(\"y\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tswitch (this.textAlign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"x\", (width / 2).toString() + \"px\");\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"end\":\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tif (this.rtl) {\r\n\t\t\t\t\t\t\tnode.setAttribute(\"x\", width.toString());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tnode.removeAttribute(\"text-anchor\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet y = $type.toNumber(node.getAttribute(\"y\"));\r\n\r\n\t\t\t\tswitch (this.textValign) {\r\n\t\t\t\t\tcase \"middle\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + (height - this.bbox.height) / 2).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"bottom\":\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", ((y || 0) + height - this.bbox.height).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tnode.setAttribute(\"y\", (y || 0).toString());\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Produces an SVG line element with formatted text.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text    Text to wrap into line\r\n\t * @param y       Current line vertical position\r\n\t * @return A DOM element\r\n\t * @todo Implement HTML support\r\n\t */\r\n\tpublic getSVGLineElement(text: string, y?: number): Group {\r\n\r\n\t\t// Create a <text> node and set text\r\n\t\tlet element: Group = this.paper.addGroup(\"text\");\r\n\t\telement.textContent = text;\r\n\r\n\t\t// Set parameters\r\n\t\telement.attr({\r\n\t\t\t\"x\": \"0\"\r\n\t\t\t//\"alignment-baseline\": \"hanging\",\r\n\t\t\t//\"baseline-shift\": \"-20%\",\r\n\t\t\t//\"text-anchor\": \"center\"\r\n\t\t});\r\n\r\n\t\t// Set `y` position\r\n\t\tif ($type.hasValue(y)) {\r\n\t\t\telement.attr({\r\n\t\t\t\t\"y\": y.toString()\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Don't let labels blled out of the alotted area\r\n\t\tif (this.truncate || this.wrap) {\r\n\t\t\telement.attr({ \"overflow\": \"hidden\" });\r\n\t\t}\r\n\r\n\t\t// Add RTL?\r\n\t\t// This has now been moved to this.alignSVGText()\r\n\t\t// if (this.rtl) {\r\n\t\t// \telement.attr({\r\n\t\t// \t\t\"direction\": \"rtl\",\r\n\t\t// \t\t//\"unicode-bidi\": \"bidi-override\"\r\n\t\t// \t});\r\n\t\t// }\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * An RTL (right-to-left) setting.\r\n\t *\r\n\t * RTL may affect alignment, text, and other visual properties.\r\n\t *\r\n\t * If you set this on a top-level chart object, it will be used for all\r\n\t * child elements, e.g. labels, unless they have their own `rtl` setting\r\n\t * set directly on them.\r\n\t *\r\n\t * @param value  `true` for to use RTL\r\n\t */\r\n\tpublic set rtl(value: boolean) {\r\n\t\tvalue = $type.toBoolean(value);\r\n\t\tthis._rtl = value;\r\n\t\tif (this.element) {\r\n\t\t\tthis.alignSVGText();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return RTL?\r\n\t */\r\n\tpublic get rtl(): boolean {\r\n\t\tif ($type.hasValue(this._rtl)) {\r\n\t\t\treturn this._rtl;\r\n\t\t}\r\n\t\telse if (this._topParent) {\r\n\t\t\treturn this._topParent.rtl;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets cached BBox.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic resetBBox(): void {\r\n\t\tthis._bbox = { x: 0, y: 0, width: 0, height: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Creates and returns an HTML line element (`<div>`).\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Text to add\r\n\t * @return `<div>` element reference\r\n\t */\r\n\tpublic getHTMLLineElement(text: string): HTMLElement {\r\n\r\n\t\t// Create the <div> element\r\n\t\tlet div: HTMLElement = document.createElement(\"div\");\r\n\t\tdiv.innerHTML = text;\r\n\r\n\t\t// Set text alignment\r\n\t\tswitch (this.textAlign) {\r\n\t\t\tcase \"middle\":\r\n\t\t\t\tdiv.style.textAlign = \"center\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"end\":\r\n\t\t\t\tdiv.style.textAlign = \"right\";\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t// Disable or enable wrapping\r\n\t\tif (this.wrap) {\r\n\t\t\tdiv.style.wordWrap = \"break-word\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdiv.style.whiteSpace = \"nowrap\";\r\n\t\t}\r\n\r\n\t\t// Don't let labels bleed out of the alotted area\r\n\t\t// Moved to `draw()` because setting \"hidden\" kills all measuring\r\n\t\t/*if (this.truncate) {\r\n\t\t\tdiv.style.overflow = \"hidden\";\r\n\t\t}*/\r\n\r\n\t\t// Set RTL-related styles\r\n\t\tif (this.rtl) {\r\n\t\t\tdiv.style.direction = \"rtl\";\r\n\t\t\t//div.style.unicodeBidi = \"bidi-override\";\r\n\t\t}\r\n\r\n\t\t// Translate some of the SVG styles into CSS\r\n\t\tif ($type.hasValue(this.fill)) {\r\n\t\t\tdiv.style.color = this.fill.toString();\r\n\t\t}\r\n\r\n\t\treturn div;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies specific styles to text to make it not selectable, unless it is\r\n\t * explicitly set as `selectable`.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Set styles via AMElement\r\n\t */\r\n\tpublic setStyles(): void {\r\n\t\tlet group: Group = <Group>this.element;\r\n\t\tif (!this.selectable || this.draggable || this.resizable || this.swipeable) {\r\n\t\t\tgroup.addStyle({\r\n\t\t\t\t\"webkitUserSelect\": \"none\",\r\n\t\t\t\t\"msUserSelect\": \"none\"\r\n\t\t\t});\r\n\t\t}\r\n\t\telse if (this.selectable) {\r\n\t\t\tgroup.removeStyle(\"webkitUserSelect\");\r\n\t\t\tgroup.removeStyle(\"msUserSelect\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Hides unused lines\r\n\t */\r\n\tprotected hideUnused(index: number) {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines: ITextLineInfo[] = this.getCache(\"lineInfo\");\r\n\t\tif (lines.length >= index) {\r\n\t\t\tfor (let i = index; i < lines.length; i++) {\r\n\t\t\t\tlet line = lines[i];\r\n\t\t\t\tif (line && line.element) {\r\n\t\t\t\t\tline.element.attr({ \"display\": \"none\" });\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG text.\r\n\t *\r\n\t * Please note that setting `html` will override this setting if browser\r\n\t * supports `foreignObject` in SGV, such as most modern browsers excluding\r\n\t * IEs.\r\n\t *\r\n\t * @param value  SVG Text\r\n\t */\r\n\tpublic set text(value: string) {\r\n\t\t//this.setPropertyValue(\"html\", undefined);\r\n\t\tthis.setPropertyValue(\"text\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return SVG text\r\n\t */\r\n\tpublic get text(): string {\r\n\t\treturn this.getPropertyValue(\"text\");\r\n\t}\r\n\r\n\t/**\r\n\t * An SVG path string to position text along. If set, the text will follow\r\n\t * the curvature of the path.\r\n\t *\r\n\t * Location along the path can be set using `locationOnPath`.\r\n\t *\r\n\t * IMPORTANT: Only SVG text can be put on path. If you are using HTML text\r\n\t * this setting will be ignored.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @param  value  Path\r\n\t */\r\n\tpublic set path(value: string) {\r\n\t\tif (this.setPropertyValue(\"path\", value, true)) {\r\n\t\t\tif (this.pathElement) {\r\n\t\t\t\tthis.pathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tif (this.textPathElement) {\r\n\t\t\t\tthis.textPathElement.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tthis.pathElement = this.paper.add(\"path\");\r\n\t\t\tthis.pathElement.attr({ \"d\": value });\r\n\t\t\tthis.pathElement.attr({ \"id\": \"text-path-\" + this.uid });\r\n\t\t\tthis._disposers.push(this.pathElement);\r\n\r\n\t\t\tthis.textPathElement = this.paper.addGroup(\"textPath\");\r\n\t\t\tthis.textPathElement.attrNS($dom.XLINK, \"xlink:href\", \"#text-path-\" + this.uid);\r\n\t\t\t// TODO remove after https://bugzilla.mozilla.org/show_bug.cgi?id=455986 is fixed\r\n\t\t\tthis.textPathElement.attr({ \"path\": value });\r\n\t\t\tthis._disposers.push(this.textPathElement);\r\n\t\t\tthis.hardInvalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Path\r\n\t */\r\n\tpublic get path(): string {\r\n\t\treturn this.getPropertyValue(\"path\");\r\n\t}\r\n\r\n\t/**\r\n\t * Relative label location on `path`. Value range is from 0 (beginning)\r\n\t * to 1 (end).\r\n\t *\r\n\t * Works only if you set `path` setting to an SVG path.\r\n\t *\r\n\t * @since 4.1.2\r\n\t * @default 0\r\n\t * @param  value  Relatvie location on path\r\n\t */\r\n\tpublic set locationOnPath(value: number) {\r\n\t\tthis.setPropertyValue(\"locationOnPath\", value);\r\n\t\tif (this.textPathElement) {\r\n\t\t\tthis.textPathElement.attr({ \"startOffset\": (value * 100) + \"%\" })\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Relatvie location on path\r\n\t */\r\n\tpublic get locationOnPath(): number {\r\n\t\treturn this.getPropertyValue(\"locationOnPath\");\r\n\t}\r\n\r\n\t/**\r\n\t * A ratio to calculate text baseline. Ralative distance from the bottom of\r\n\t * the label.\r\n\t *\r\n\t * @since 4.4.2\r\n\t * @default -0.27\r\n\t * @param  value  Base line ratio\r\n\t */\r\n\tpublic set baseLineRatio(value: number) {\r\n\t\tthis.setPropertyValue(\"baseLineRatio\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Base line ratio\r\n\t */\r\n\tpublic get baseLineRatio(): number {\r\n\t\treturn this.getPropertyValue(\"baseLineRatio\");\r\n\t}\r\n\r\n\t/**\r\n\t * Enables or disables autowrapping of text.\r\n\t *\r\n\t * @param value  Auto-wrapping enabled\r\n\t */\r\n\tpublic set wrap(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"wrap\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Auto-wrap enabled or not\r\n\t */\r\n\tpublic get wrap(): boolean {\r\n\t\treturn this.getPropertyValue(\"wrap\");\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if text lines need to be truncated if they do not fit, using\r\n\t * configurable `ellipsis` string.\r\n\t *\r\n\t * `truncate` overrides `wrap` if both are set to `true`.\r\n\t *\r\n\t * NOTE: For HTML text, this setting **won't** trigger a parser and actual\r\n\t * line truncation with ellipsis. It will just hide everything that goes\r\n\t * outside the label.\r\n\t *\r\n\t * @param value  trincate text?\r\n\t */\r\n\tpublic set truncate(value: boolean) {\r\n\t\tthis.resetBBox();\r\n\t\tthis.setPropertyValue(\"truncate\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate text?\r\n\t */\r\n\tpublic get truncate(): boolean {\r\n\t\treturn this.getPropertyValue(\"truncate\");\r\n\t}\r\n\r\n\t/**\r\n\t * If `truncate` is enabled, should Label try to break only on full words\r\n\t * (`true`), or whenever needed, including middle of the word. (`false`)\r\n\t *\r\n\t * @default true\r\n\t * @param value  Truncate on full words?\r\n\t */\r\n\tpublic set fullWords(value: boolean) {\r\n\t\tthis.setPropertyValue(\"fullWords\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Truncate on full words?\r\n\t */\r\n\tpublic get fullWords(): boolean {\r\n\t\treturn this.getPropertyValue(\"fullWords\");\r\n\t}\r\n\r\n\t/**\r\n\t * Ellipsis character to use if `truncate` is enabled.\r\n\t *\r\n\t * @param value Ellipsis string\r\n\t * @default \"...\"\r\n\t */\r\n\tpublic set ellipsis(value: string) {\r\n\t\tthis.setPropertyValue(\"ellipsis\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ellipsis string\r\n\t */\r\n\tpublic get ellipsis(): string {\r\n\t\treturn this.getPropertyValue(\"ellipsis\");\r\n\t}\r\n\r\n\t/**\r\n\t * Forces the text to be selectable. This setting will be ignored if the\r\n\t * object has some kind of interaction attached to it, such as it is\r\n\t * `draggable`, `swipeable`, `resizable`.\r\n\t *\r\n\t * @param value  Text selectable?\r\n\t * @default false\r\n\t */\r\n\tpublic set selectable(value: boolean) {\r\n\t\tthis.setPropertyValue(\"selectable\", value, true);\r\n\t\tthis.setStyles();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Text selectable?\r\n\t */\r\n\tpublic get selectable(): boolean {\r\n\t\treturn this.getPropertyValue(\"selectable\");\r\n\t}\r\n\r\n\t/**\r\n\t * Horizontal text alignment.\r\n\t *\r\n\t * Available choices:\r\n\t * * \"start\"\r\n\t * * \"middle\"\r\n\t * * \"end\"\r\n\t *\r\n\t * @param value  Alignment\r\n\t */\r\n\tpublic set textAlign(value: TextAlign) {\r\n\t\tthis.setPropertyValue(\"textAlign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Alignment\r\n\t */\r\n\tpublic get textAlign(): TextAlign {\r\n\t\treturn this.getPropertyValue(\"textAlign\");\r\n\t}\r\n\r\n\t/**\r\n\t * Vertical text alignment.\r\n\t *\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @param value  Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic set textValign(value: TextValign) {\r\n\t\tthis.setPropertyValue(\"textValign\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs (not used)\r\n\t * @return Alignment\r\n\t * @deprecated\r\n\t */\r\n\tpublic get textValign(): TextValign {\r\n\t\treturn this.getPropertyValue(\"textValign\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Raw HTML to be used as text.\r\n\t *\r\n\t * NOTE: HTML text is subject to browser support. It relies on browsers\r\n\t * supporting SVG `foreignObject` nodes. Some browsers (read IEs) do not\r\n\t * support it. On those browsers, the text will fall back to basic SVG text,\r\n\t * striping out all HTML markup and styling that goes with it.\r\n\t *\r\n\t * For more information about `foreignObject` and its browser compatibility\r\n\t * refer to [this page](https://developer.mozilla.org/en/docs/Web/SVG/Element/foreignObject#Browser_compatibility).\r\n\t *\r\n\t * @param value HTML text\r\n\t */\r\n\tpublic set html(value: string) {\r\n\t\tthis.setPropertyValue(\"html\", value, true);\r\n\t\tif (!$type.hasValue(value)) {\r\n\t\t\tconst group: Group = <Group>this.element;\r\n\t\t\tgroup.removeChildrenByTag(\"foreignObject\");\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return HTML content\r\n\t */\r\n\tpublic get html(): string {\r\n\t\treturn this.getPropertyValue(\"html\");\r\n\t}\r\n\r\n\tprotected setFill(value: $type.Optional<Color | Pattern | LinearGradient | RadialGradient>): void {\r\n\t\tsuper.setFill(value);\r\n\t\tif (this.html) {\r\n\t\t\tconst group: Group = <Group>this.element;\r\n\t\t\tconst divs = group.node.getElementsByTagName(\"div\");\r\n\t\t\tfor(let i = 0; i < divs.length; i++) {\r\n\t\t\t\tconst div = divs[i];\r\n\t\t\t\tif ($type.hasValue(this.fill)) {\r\n\t\t\t\t\tdiv.style.color = this.fill.toString();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether the whole text should be hidden if it does not fit into\r\n\t * its allotted space.\r\n\t *\r\n\t * @param value  Hide if text does not fit?\r\n\t */\r\n\tpublic set hideOversized(value: boolean) {\r\n\t\tthis.setPropertyValue(\"hideOversized\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Hide if text does not fit?\r\n\t */\r\n\tpublic get hideOversized(): boolean {\r\n\t\treturn this.getPropertyValue(\"hideOversized\");\r\n\t}\r\n\r\n\t/**\r\n\t * If set to `true` square-bracket formatting blocks will be treated as\r\n\t * regular text.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Ignore formatting?\r\n\t */\r\n\tpublic set ignoreFormatting(value: boolean) {\r\n\t\tthis.setPropertyValue(\"ignoreFormatting\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ignore formatting?\r\n\t */\r\n\tpublic get ignoreFormatting(): boolean {\r\n\t\treturn this.getPropertyValue(\"ignoreFormatting\");\r\n\t}\r\n\r\n\t/**\r\n\t * Override `mesaureElement` so it does not get measure again, because\r\n\t * internal `_bbox` is being updated by measuring routines in Text itself.\r\n\t */\r\n\tpublic measureElement(): void { }\r\n\r\n\t/**\r\n\t * Returns information about a line element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param index  Line index\r\n\t * @return Line info object\r\n\t */\r\n\tpublic getLineInfo(index: number): ITextLineInfo {\r\n\t\tthis.initLineCache();\r\n\t\tlet lines = this.getCache(\"lineInfo\");\r\n\t\treturn lines.length > index ? lines[index] : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a line to line info cache.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param line     Line info object\r\n\t * @param index    Insert at specified index\r\n\t */\r\n\tpublic addLineInfo(line: ITextLineInfo, index: number): void {\r\n\t\tthis.initLineCache();\r\n\t\tthis.getCache(\"lineInfo\")[index] = line;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if line cache is initialized and initializes it.\r\n\t */\r\n\tprivate initLineCache(): void {\r\n\t\tif (!$type.hasValue(this.getCache(\"lineInfo\"))) {\r\n\t\t\tthis.setCache(\"lineInfo\", [], 0);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataItem]] to use for populating dynamic sections of the text.\r\n\t *\r\n\t * Check the description for [[Text]] class, for data binding.\r\n\t *\r\n\t * @param dataItem Data item\r\n\t */\r\n\tpublic setDataItem(dataItem: DataItem): void {\r\n\t\tif (this._sourceDataItemEvents) {\r\n\t\t\tthis._sourceDataItemEvents.dispose();\r\n\t\t}\r\n\t\tif (dataItem) {\r\n\t\t\tthis._sourceDataItemEvents = new MultiDisposer([\r\n\t\t\t\tdataItem.events.on(\"valuechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"workingvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"calculatedvaluechanged\", this.invalidate, this, false),\r\n\t\t\t\tdataItem.events.on(\"propertychanged\", this.invalidate, this, false)\r\n\t\t\t]);\r\n\t\t}\r\n\t\tsuper.setDataItem(dataItem);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available horizontal space.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Available width (px)\r\n\t */\r\n\tpublic get availableWidth(): number {\r\n\t\treturn $type.hasValue(this.maxWidth) ? this.maxWidth : this.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns available vertical space.\r\n\t *\r\n\t * @return Available height (px)\r\n\t */\r\n\tpublic get availableHeight(): number {\r\n\t\treturn $type.hasValue(this.maxHeight) ? this.maxHeight : this.pixelHeight;\r\n\t}\r\n\r\n\t// temp, replacing textFormatter method\r\n\tpublic getSvgElement(text: string, style?: string, parent?: Group): AMElement {\r\n\t\tlet element = this.paper.add(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\r\n\t\t\tif (options.nonce && parent) {\r\n\t\t\t\t//element.node.setAttribute(\"nonce\", \"test123\");\r\n\t\t\t\tconst classid = \"amcharts_element_style_\" + btoa(style).replace(/[^\\w]*/g, \"\");\r\n\t\t\t\telement.node.setAttribute(\"class\", classid);\r\n\r\n\t\t\t\tconst defs = <SVGDefsElement>document.createElementNS($dom.SVGNS, \"defs\");\r\n\t\t\t\tparent.node.appendChild(defs);\r\n\r\n\t\t\t\tconst e = document.createElement(\"style\");\r\n\t\t\t\te.type = \"text/css\";\r\n\t\t\t\te.innerHTML = \".\" + classid + \" { \" + style + \"}\";\r\n\t\t\t\te.setAttribute(\"nonce\", options.nonce)\r\n\t\t\t\tdefs.appendChild(e);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (parent) {\r\n\t\t\tparent.add(element);\r\n\t\t}\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the whole element, including layout AND all its child\r\n\t * elements.\r\n\t */\r\n\tpublic deepInvalidate() {\r\n\t\tsuper.deepInvalidate();\r\n\t\tthis.hardInvalidate();\r\n\t}\r\n\r\n\t/**\r\n\t * Screen reader title of the element.\r\n\t *\r\n\t * @param value Title\r\n\t */\r\n\tpublic set readerTitle(value: string) {\r\n\t\tvalue = $type.toText(value);\r\n\t\tif (this.setPropertyValue(\"readerTitle\", value)) {\r\n\t\t\tthis.applyAccessibility();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Title\r\n\t */\r\n\tpublic get readerTitle(): string {\r\n\t\tlet title = this.getPropertyValue(\"readerTitle\");\r\n\t\tif (!title) {\r\n\t\t\ttitle = this.populateString(\r\n\t\t\t\t$utils.plainText(\r\n\t\t\t\t\t$utils.isNotEmpty(this.html)\r\n\t\t\t\t\t\t? this.html\r\n\t\t\t\t\t\t: this.text\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse if (this.dataItem) {\r\n\t\t\ttitle = this.populateString(title);\r\n\t\t}\r\n\t\treturn title;\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Label\"] = Label;\r\n\r\n/**\r\n * Add default responsive rules\r\n */\r\n\r\n/**\r\n * Hide labels added directly to chart, like titles if chart is short.\r\n */\r\ndefaultRules.push({\r\n\trelevant: ResponsiveBreakpoints.heightXS,\r\n\tstate: function(target, stateId) {\r\n\t\tif (target instanceof Label && target.parent && target.parent.isBaseSprite) {\r\n\t\t\tlet state = target.states.create(stateId);\r\n\t\t\tstate.properties.disabled = true;\r\n\t\t\treturn state;\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n});\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}