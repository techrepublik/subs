{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObject } from \"../Base\";\nimport { AMElement } from \"../rendering/AMElement\";\nimport { Adapter } from \"../utils/Adapter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\nvar TextFormatter = /** @class */function (_super) {\n  __extends(TextFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n  function TextFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * Adapter.\r\n     */\n    _this.adapter = new Adapter(_this);\n    _this.className = \"TextFormatter\";\n    _this.applyTheme();\n    return _this;\n  }\n  TextFormatter.prototype.debug = function () {};\n  /**\r\n   * Formats the text according to specifications passed in.\r\n   *\r\n   * @param text    Text to format\r\n   * @param output  Output format (svg, html)\r\n   * @return Formatted text\r\n   */\n  TextFormatter.prototype.format = function (text, output) {\n    // Apply default\n    if (!$type.hasValue(output)) {\n      output = \"svg\";\n    }\n    // Init return value\n    var formatted = \"\";\n    // Replace double (escaped) square spaces with remporary codes\n    text = this.escape(text);\n    // Divvy up the string by style tags\n    var styles = text.match(/\\[([^\\]]*?)\\]/gm);\n    if (!styles) {\n      // Nothing to do here - no formatting elements\n      return this.wrap(text, \"\", output);\n    }\n    // Get pure text - no style tags\n    var texts = text.split(/\\[[^\\[\\]]*\\]/);\n    // Go through each of the texts and wrap it in style tags\n    for (var i = 0, len = texts.length; i < len; i++) {\n      // Get text bit\n      var t = texts[i];\n      // Check if string is empty\n      if (t === \"\") {\n        continue;\n      }\n      // Run through an adapter\n      t = this.adapter.apply(\"chunk\", t);\n      // Get related style\n      var s = \"\";\n      if (i > 0) {\n        s = styles[i - 1].replace('[', '').replace(']', '');\n      }\n      // Wrap text in tag\n      formatted += this.wrap(t, s, output);\n    }\n    // Replace placeholders back\n    formatted = this.unescape(formatted);\n    // Return result\n    return this.cleanUp(formatted);\n  };\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  TextFormatter.prototype.escape = function (text) {\n    return text.replace(/\\[\\[/g, registry.getPlaceholder(\"1\")).replace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).replace(/\\]\\]/g, registry.getPlaceholder(\"2\")).replace(/\\{\\{/g, registry.getPlaceholder(\"3\")).replace(/\\}\\}/g, registry.getPlaceholder(\"4\")).replace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  TextFormatter.prototype.unescape = function (text) {\n    return text.replace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").replace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").replace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").replace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").replace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"''\");\n  };\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n  TextFormatter.prototype.cleanUp = function (text) {\n    return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n  };\n  /**\r\n   * Wraps text into corresponding tags.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Styles\r\n   * @param output  Format to output in (svg, html)\r\n   * @return Formatted string\r\n   */\n  TextFormatter.prototype.wrap = function (text, style, output) {\n    if (style === \"\" || style === \"/\") {\n      //return text;\n      style = \"\";\n    }\n    switch (output) {\n      case \"html\":\n        return this.wrapHtml(text, this.translateStyleShortcuts(style));\n      default:\n        return this.wrapSvg(text, this.translateStyleShortcuts(style));\n    }\n  };\n  /**\r\n   * Wraps text in styled SVG tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   */\n  TextFormatter.prototype.wrapSvg = function (text, style) {\n    if (style === \"\") {\n      return \"<tspan>\" + text + \"</tspan>\";\n    } else {\n      return \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\n    }\n  };\n  /**\r\n   * Returns an SVG `<tspan>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text\r\n   * @param style  Style\r\n   * @return Element\r\n   */\n  TextFormatter.prototype.getSvgElement = function (text, style) {\n    var element = new AMElement(\"tspan\");\n    element.textContent = text;\n    if (style) {\n      element.node.setAttribute(\"style\", style);\n    }\n    return element;\n  };\n  /**\r\n   * Wraps text in HTML <span> tag.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text to wrap\r\n   * @param style  Style property\r\n   * @return Formatted tag\r\n   * @todo Translate SVG styles into HTML ones\r\n   */\n  TextFormatter.prototype.wrapHtml = function (text, style) {\n    if (style === \"\") {\n      return \"<span>\" + text + \"</span>\";\n    } else {\n      return \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\n    }\n  };\n  /**\r\n   * Returns an HTML `<span>` element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text   Text/HTML\r\n   * @param style  Style definition\r\n   * @return HTML element\r\n   */\n  TextFormatter.prototype.getHtmlElement = function (text, style) {\n    var element = document.createElement(\"span\");\n    element.innerHTML = text;\n    if (style) {\n      element.setAttribute(\"style\", style);\n    }\n    return element;\n  };\n  /**\r\n   * Trabslates SVG CSS into HTML CSS.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  SVG CSS\r\n   * @return HTML CSS\r\n   * @todo Implement actual translation\r\n   */\n  TextFormatter.prototype.styleSvgToHtml = function (style) {\n    style = style.replace(/fill:/, \"color:\");\n    return style;\n  };\n  /**\r\n   * Translates style shortcuts into full styles, i.e.:\r\n   * \"bold\" => \"font-weight: bold\"\r\n   * \"#f00\" => \"fill: #f00\"\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Untranslated style\r\n   * @return Translated style\r\n   * @todo Implement actual translation\r\n   */\n  TextFormatter.prototype.translateStyleShortcuts = function (style) {\n    if (style == \"\" || style == \"[ ]\") {\n      return \"\";\n    }\n    var cached = registry.getCache(\"translateStyleShortcuts_\" + style);\n    if (cached) {\n      return cached;\n    }\n    // Pre-process quoted text\n    var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n    if (q) {\n      for (var i = 0; i < q.length; i++) {\n        style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n      }\n    }\n    // Get style parts\n    var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\n    // Empty?\n    if (!b) {\n      return style;\n    }\n    // Check each part\n    for (var i = 0; i < b.length; i++) {\n      if (b[i].match(/^bold$/i)) {\n        // Bold\n        b[i] = \"font-weight:\" + b[i];\n      } else if (b[i] == \"/\") {\n        // Just closing tag\n        // Do nothing\n        b[i] = \"\";\n      } else if (!b[i].match(/:/)) {\n        // Color\n        b[i] = \"fill:\" + b[i];\n      } else {\n        b[i] = b[i].replace(/\\+/g, \" \");\n      }\n    }\n    var res = b.join(';');\n    registry.setCache(\"translateStyleShortcuts_\" + style, res);\n    return res;\n  };\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n  TextFormatter.prototype.chunk = function (text, quotedBlocks, noFormatting) {\n    if (quotedBlocks === void 0) {\n      quotedBlocks = false;\n    }\n    if (noFormatting === void 0) {\n      noFormatting = false;\n    }\n    // Init result\n    var res = [];\n    // Replace double (escaped) square spaces and quotes with temporary codes\n    text = this.escape(text);\n    // Deal with style blocks\n    var chunks = quotedBlocks ? text.split(\"'\") : [text];\n    for (var i = 0; i < chunks.length; i++) {\n      var chunk = chunks[i];\n      // Empty?\n      if (chunk === \"\") {\n        continue;\n      }\n      if (i % 2 === 0) {\n        // Text outside quotes\n        // Parse for style blocks which are \"text\" chunks, the rest chunks are\n        // \"value\"\n        chunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\n        chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Placeholder?\n          if (chunk2 === $strings.PLACEHOLDER) {\n            continue;\n          }\n          // Empty?\n          if (chunk2 === \"\") {\n            continue;\n          }\n          // Block or value\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"value\",\n              \"text\": this.adapter.apply(\"chunk\", chunk2)\n            });\n          } else {\n            res.push({\n              \"type\": noFormatting ? \"value\" : \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      } else {\n        // A text within doublequotes\n        // All chunks are \"text\"\n        var chunks2 = chunk.split(/[\\[\\]]+/);\n        for (var i2 = 0; i2 < chunks2.length; i2++) {\n          var chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\n          // Empty?\n          if (chunk2 === \"\") {\n            continue;\n          }\n          // Block or text\n          if (i2 % 2 === 0) {\n            res.push({\n              \"type\": \"text\",\n              \"text\": chunk2\n            });\n          } else if (this.isImage(chunk2)) {\n            res.push({\n              \"type\": \"image\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          } else {\n            res.push({\n              \"type\": \"format\",\n              \"text\": \"[\" + chunk2 + \"]\"\n            });\n          }\n        }\n      }\n    }\n    return res;\n  };\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Format\r\n   * @return `true` if it is an image\r\n   */\n  TextFormatter.prototype.isImage = function (text) {\n    return text.match(/img[ ]?:/) ? true : false;\n  };\n  return TextFormatter;\n}(BaseObject);\nexport { TextFormatter };\nvar formatter;\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\nexport function getTextFormatter() {\n  if (formatter == null) {\n    formatter = new TextFormatter();\n  }\n  return formatter;\n}\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;","map":{"version":3,"names":["BaseObject","AMElement","Adapter","registry","$strings","$type","TextFormatter","_super","__extends","_this","call","adapter","className","applyTheme","prototype","debug","format","text","output","hasValue","formatted","escape","styles","match","wrap","texts","split","i","len","length","t","apply","s","replace","unescape","cleanUp","getPlaceholder","RegExp","style","wrapHtml","translateStyleShortcuts","wrapSvg","getSvgElement","element","textContent","node","setAttribute","styleSvgToHtml","getHtmlElement","document","createElement","innerHTML","cached","getCache","q","b","res","join","setCache","chunk","quotedBlocks","noFormatting","chunks","PLACEHOLDER","chunks2","i2","chunk2","push","isImage","formatter","getTextFormatter","registeredClasses"],"sources":["../../../../../src/.internal/core/formatters/TextFormatter.ts"],"sourcesContent":["/**\r\n * Handles formatting of pseudo-markup in text.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { AMElement } from \"../rendering/AMElement\";\r\nimport { Adapter } from \"../utils/Adapter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n/**\r\n * Defines an interface for an object that holds a chunk of text.\r\n */\r\nexport interface ITextChunk {\r\n\r\n\t/**\r\n\t * Type of the chunk.\r\n\t */\r\n\t\"type\": \"value\" | \"text\" | \"format\" | \"image\",\r\n\r\n\t/**\r\n\t * Text.\r\n\t */\r\n\t\"text\": string\r\n\r\n}\r\n\r\n/**\r\n * A list of Adapters for [[TextFormatter]].\r\n */\r\nexport interface ITextFormatterAdapters {\r\n\r\n\t/**\r\n\t * Applied to each chunk of text when it is parsed and added to chunk list.\r\n\t */\r\n\tchunk: string\r\n\r\n}\r\n\r\n/**\r\n * Handles formatting of pseudo-markdown in text.\r\n *\r\n * @todo Encode < > in output\r\n * @todo Add more adapters\r\n * @important\r\n */\r\nexport class TextFormatter extends BaseObject {\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: ITextFormatterAdapters;\r\n\r\n\t/**\r\n\t * Adapter.\r\n\t */\r\n\tpublic adapter = new Adapter<TextFormatter, ITextFormatterAdapters>(this);\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"TextFormatter\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tprotected debug(): void { }\r\n\r\n\t/**\r\n\t * Formats the text according to specifications passed in.\r\n\t *\r\n\t * @param text    Text to format\r\n\t * @param output  Output format (svg, html)\r\n\t * @return Formatted text\r\n\t */\r\n\tpublic format(text: string, output?: string): string {\r\n\r\n\t\t// Apply default\r\n\t\tif (!$type.hasValue(output)) {\r\n\t\t\toutput = \"svg\";\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet formatted: string = \"\";\r\n\r\n\t\t// Replace double (escaped) square spaces with remporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Divvy up the string by style tags\r\n\t\tlet styles: string[] | null = text.match(/\\[([^\\]]*?)\\]/gm);\r\n\r\n\t\tif (!styles) {\r\n\t\t\t// Nothing to do here - no formatting elements\r\n\t\t\treturn this.wrap(text, \"\", output);\r\n\t\t}\r\n\r\n\t\t// Get pure text - no style tags\r\n\t\tlet texts: string[] = text.split(/\\[[^\\[\\]]*\\]/);\r\n\r\n\t\t// Go through each of the texts and wrap it in style tags\r\n\t\tfor (let i = 0, len = texts.length; i < len; i++) {\r\n\r\n\t\t\t// Get text bit\r\n\t\t\tlet t: string = texts[i];\r\n\r\n\t\t\t// Check if string is empty\r\n\t\t\tif (t === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Run through an adapter\r\n\t\t\tt = this.adapter.apply(\"chunk\", t);\r\n\r\n\t\t\t// Get related style\r\n\t\t\tlet s: string = \"\";\r\n\t\t\tif (i > 0) {\r\n\t\t\t\ts = styles[i - 1].replace('[', '').replace(']', '');\r\n\t\t\t}\r\n\r\n\t\t\t// Wrap text in tag\r\n\t\t\tformatted += this.wrap(t, s, output);\r\n\t\t}\r\n\r\n\t\t// Replace placeholders back\r\n\t\tformatted = this.unescape(formatted);\r\n\r\n\t\t// Return result\r\n\t\treturn this.cleanUp(formatted);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces brackets with temporary placeholders.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Escaped text\r\n\t */\r\n\tpublic escape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, registry.getPlaceholder(\"1\")).\r\n\t\t\treplace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\]\\]/g, registry.getPlaceholder(\"2\")).\r\n\t\t\treplace(/\\{\\{/g, registry.getPlaceholder(\"3\")).\r\n\t\t\treplace(/\\}\\}/g, registry.getPlaceholder(\"4\")).\r\n\t\t\treplace(/\\'\\'/g, registry.getPlaceholder(\"5\"));\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders back to brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Escaped text\r\n\t * @return Unescaped text\r\n\t */\r\n\tpublic unescape(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"1\"), \"g\"), \"[[\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"2\"), \"g\"), \"]]\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"3\"), \"g\"), \"{{\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"4\"), \"g\"), \"}}\").\r\n\t\t\treplace(new RegExp(registry.getPlaceholder(\"5\"), \"g\"), \"''\");\r\n\t}\r\n\r\n\t/**\r\n\t * Cleans up the text text for leftover double square brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Cleaned up text\r\n\t */\r\n\tpublic cleanUp(text: string): string {\r\n\t\treturn text.\r\n\t\t\treplace(/\\[\\[/g, \"[\").\r\n\t\t\treplace(/\\]\\]/g, \"]\").\r\n\t\t\treplace(/\\{\\{/g, \"{\").\r\n\t\t\treplace(/\\}\\}/g, \"}\").\r\n\t\t\treplace(/\\'\\'/g, \"'\");\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text into corresponding tags.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Styles\r\n\t * @param output  Format to output in (svg, html)\r\n\t * @return Formatted string\r\n\t */\r\n\tpublic wrap(text: string, style: string, output: string): string {\r\n\r\n\t\tif (style === \"\" || style === \"/\") {\r\n\t\t\t//return text;\r\n\t\t\tstyle = \"\";\r\n\t\t}\r\n\r\n\t\tswitch (output) {\r\n\t\t\tcase \"html\":\r\n\t\t\t\treturn this.wrapHtml(text, this.translateStyleShortcuts(style));\r\n\t\t\tdefault:\r\n\t\t\t\treturn this.wrapSvg(text, this.translateStyleShortcuts(style));\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in styled SVG tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t */\r\n\tpublic wrapSvg(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<tspan>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<tspan style='\" + style + \"'>\" + text + \"</tspan>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an SVG `<tspan>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text\r\n\t * @param style  Style\r\n\t * @return Element\r\n\t */\r\n\tpublic getSvgElement(text: string, style?: string): AMElement {\r\n\t\tlet element = new AMElement(\"tspan\");\r\n\t\telement.textContent = text;\r\n\t\tif (style) {\r\n\t\t\telement.node.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps text in HTML <span> tag.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text to wrap\r\n\t * @param style  Style property\r\n\t * @return Formatted tag\r\n\t * @todo Translate SVG styles into HTML ones\r\n\t */\r\n\tpublic wrapHtml(text: string, style: string): string {\r\n\t\tif (style === \"\") {\r\n\t\t\treturn \"<span>\" + text + \"</span>\";\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"<span style='\" + this.styleSvgToHtml(style) + \"'>\" + text + \"</span>\";\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an HTML `<span>` element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text   Text/HTML\r\n\t * @param style  Style definition\r\n\t * @return HTML element\r\n\t */\r\n\tpublic getHtmlElement(text: string, style?: string): HTMLElement {\r\n\t\tlet element = document.createElement(\"span\");\r\n\t\telement.innerHTML = text;\r\n\t\tif (style) {\r\n\t\t\telement.setAttribute(\"style\", style);\r\n\t\t}\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Trabslates SVG CSS into HTML CSS.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  SVG CSS\r\n\t * @return HTML CSS\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic styleSvgToHtml(style: string): string {\r\n\t\tstyle = style.replace(/fill:/, \"color:\");\r\n\t\treturn style;\r\n\t}\r\n\r\n\t/**\r\n\t * Translates style shortcuts into full styles, i.e.:\r\n\t * \"bold\" => \"font-weight: bold\"\r\n\t * \"#f00\" => \"fill: #f00\"\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Untranslated style\r\n\t * @return Translated style\r\n\t * @todo Implement actual translation\r\n\t */\r\n\tpublic translateStyleShortcuts(style: string): string {\r\n\r\n\r\n\t\tif (style == \"\" || style == \"[ ]\") {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\r\n\t\tlet cached = registry.getCache(\"translateStyleShortcuts_\" + style);\r\n\t\tif (cached) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// Pre-process quoted text\r\n\t\tconst q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\r\n\t\tif (q) {\r\n\t\t\tfor (let i: number = 0; i < q.length; i++) {\r\n\t\t\t\tstyle = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Get style parts\r\n\t\tlet b: string[] | null = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w]+)|(\\/)/gi);\r\n\r\n\t\t// Empty?\r\n\t\tif (!b) {\r\n\t\t\treturn style;\r\n\t\t}\r\n\r\n\t\t// Check each part\r\n\t\tfor (let i: number = 0; i < b.length; i++) {\r\n\r\n\t\t\tif (b[i].match(/^bold$/i)) {\r\n\t\t\t\t// Bold\r\n\t\t\t\tb[i] = \"font-weight:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse if (b[i] == \"/\") {\r\n\t\t\t\t// Just closing tag\r\n\t\t\t\t// Do nothing\r\n\t\t\t\tb[i] = \"\";\r\n\t\t\t}\r\n\t\t\telse if (!b[i].match(/:/)) {\r\n\t\t\t\t// Color\r\n\t\t\t\tb[i] = \"fill:\" + b[i];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tb[i] = b[i].replace(/\\+/g, \" \");\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet res = b.join(';');\r\n\t\tregistry.setCache(\"translateStyleShortcuts_\" + style, res);\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n\t *\r\n\t * If the second parameter `quotedBlocks` is set to `true` this method will\r\n\t * also single out text blocks enclosed within single quotes that no\r\n\t * formatting should be applied to, and they should be displayed as is.\r\n\t *\r\n\t * Default for the above is `false`, so that you can use single quote in text\r\n\t * without escaping it.\r\n\t *\r\n\t * If enabled, single quotes can be escaped by doubling it - adding two\r\n\t * single quotes, which will be replaced by a one single quote in the final\r\n\t * output.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text          Text to chunk\r\n\t * @param quotedBlocks  Use quoted blocks\r\n\t * @param noFormatting  Formatting blocks will be treated as regular text\r\n\t * @return Array of string chunks\r\n\t */\r\n\tpublic chunk(text: string, quotedBlocks: boolean = false, noFormatting: boolean = false): ITextChunk[] {\r\n\r\n\t\t// Init result\r\n\t\tlet res: ITextChunk[] = [];\r\n\r\n\t\t// Replace double (escaped) square spaces and quotes with temporary codes\r\n\t\ttext = this.escape(text);\r\n\r\n\t\t// Deal with style blocks\r\n\t\tlet chunks = quotedBlocks ? text.split(\"'\") : [text];\r\n\t\tfor (let i: number = 0; i < chunks.length; i++) {\r\n\t\t\tlet chunk = chunks[i];\r\n\r\n\t\t\t// Empty?\r\n\t\t\tif (chunk === \"\") {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif ((i % 2) === 0) {\r\n\r\n\t\t\t\t// Text outside quotes\r\n\t\t\t\t// Parse for style blocks which are \"text\" chunks, the rest chunks are\r\n\t\t\t\t// \"value\"\r\n\r\n\t\t\t\tchunk = chunk.replace(/\\]\\[/g, \"]\" + $strings.PLACEHOLDER + \"[\");\r\n\t\t\t\tchunk = chunk.replace(/\\[\\]/g, \"[ ]\");\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Placeholder?\r\n\t\t\t\t\tif (chunk2 === $strings.PLACEHOLDER) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or value\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"value\",\r\n\t\t\t\t\t\t\t\"text\": this.adapter.apply(\"chunk\", chunk2)\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": noFormatting ? \"value\" : \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\t// A text within doublequotes\r\n\t\t\t\t// All chunks are \"text\"\r\n\r\n\t\t\t\tlet chunks2 = chunk.split(/[\\[\\]]+/);\r\n\t\t\t\tfor (let i2: number = 0; i2 < chunks2.length; i2++) {\r\n\t\t\t\t\tlet chunk2 = this.cleanUp(this.unescape(chunks2[i2]));\r\n\r\n\t\t\t\t\t// Empty?\r\n\t\t\t\t\tif (chunk2 === \"\") {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Block or text\r\n\t\t\t\t\tif ((i2 % 2) === 0) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"text\",\r\n\t\t\t\t\t\t\t\"text\": chunk2\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (this.isImage(chunk2)) {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"image\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tres.push({\r\n\t\t\t\t\t\t\t\"type\": \"format\",\r\n\t\t\t\t\t\t\t\"text\": \"[\" + chunk2 + \"]\"\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if supplied format contains image information and should be\r\n\t * formatted as such.\r\n\t * I.e.: `[img: myImage.png]`\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Format\r\n\t * @return `true` if it is an image\r\n\t */\r\n\tpublic isImage(text: string): boolean {\r\n\t\treturn text.match(/img[ ]?:/) ? true : false;\r\n\t}\r\n\r\n}\r\n\r\n\r\nlet formatter: TextFormatter;\r\n\r\n/**\r\n * Returns the global instance of [[TextFormatter]].\r\n *\r\n * All classes and instances should reuse this universal text formatter,\r\n * rather than create their own instance of it.\r\n */\r\nexport function getTextFormatter(): TextFormatter {\r\n\tif (formatter == null) {\r\n\t\tformatter = new TextFormatter();\r\n\t}\r\n\r\n\treturn formatter;\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"TextFormatter\"] = TextFormatter;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}