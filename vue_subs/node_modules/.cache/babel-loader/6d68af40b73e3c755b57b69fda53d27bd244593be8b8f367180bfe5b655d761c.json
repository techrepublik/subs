{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\n/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\nexport function toNumberRange(value, min, max) {\n  if ($type.hasValue(value)) {\n    value = $type.toNumber(value);\n    return fitToRange(value, min, max);\n  }\n  return value;\n}\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\nexport function round(value, precision, floor) {\n  if (!$type.isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\nexport function ceil(value, precision) {\n  if (!$type.isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\nexport function stretch(t, from, to) {\n  return t * (to - from) + from;\n}\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\nexport function fitToRange(value, minValue, maxValue) {\n  if ($type.isNumber(minValue)) {\n    if ($type.isNumber(maxValue) && maxValue < minValue) {\n      var temp = maxValue;\n      maxValue = minValue;\n      minValue = temp;\n    }\n    if (value < minValue) {\n      value = minValue;\n    }\n  }\n  if ($type.isNumber(maxValue)) {\n    if (value > maxValue) {\n      value = maxValue;\n    }\n  }\n  return value;\n}\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\nexport function sin(value) {\n  return round(Math.sin(RADIANS * value), 10);\n}\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\nexport function tan(value) {\n  return round(Math.tan(RADIANS * value), 10);\n}\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\nexport function cos(value) {\n  return round(Math.cos(RADIANS * value), 10);\n}\nexport function max(left, right) {\n  if ($type.isNumber(left)) {\n    if ($type.isNumber(right)) {\n      if (right > left) {\n        return right;\n      } else {\n        return left;\n      }\n    } else {\n      return left;\n    }\n  } else if ($type.isNumber(right)) {\n    return right;\n  } else {\n    return null;\n  }\n}\nexport function min(left, right) {\n  if ($type.isNumber(left)) {\n    if ($type.isNumber(right)) {\n      if (right < left) {\n        return right;\n      } else {\n        return left;\n      }\n    } else {\n      return left;\n    }\n  } else if ($type.isNumber(right)) {\n    return right;\n  } else {\n    return null;\n  }\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\nexport function intersect(range1, range2) {\n  var start1 = $type.getValue(range1.start);\n  var start2 = $type.getValue(range2.start);\n  var end1 = $type.getValue(range1.end);\n  var end2 = $type.getValue(range2.end);\n  return Math.max(start1, start2) <= Math.min(end1, end2);\n}\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\nexport function invertRange(range) {\n  var start = $type.getValue(range.start);\n  var end = $type.getValue(range.end);\n  return {\n    start: 1 - end,\n    end: 1 - start\n  };\n}\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\nexport function intersection(range1, range2) {\n  var start1 = $type.getValue(range1.start);\n  var start2 = $type.getValue(range2.start);\n  var end1 = $type.getValue(range1.end);\n  var end2 = $type.getValue(range2.end);\n  var startMax = Math.max(start1, start2);\n  var endMin = Math.min(end1, end2);\n  if (endMin < startMax) {\n    return undefined;\n  } else {\n    return {\n      start: startMax,\n      end: endMin\n    };\n  }\n}\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\nexport function getDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n  return Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\n}\n/**\r\n * Returns pixel \"horizontal distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\nexport function getHorizontalDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n  return Math.abs(point1.x - point2.x);\n}\n/**\r\n * Returns pixel \"vertical distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\nexport function getVerticalDistance(point1, point2) {\n  if (!point1) {\n    return 0;\n  }\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n  return Math.abs(point1.y - point2.y);\n}\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\nexport function getCubicCurveDistance(point1, point2, controlPointA, controlPointB, stepCount) {\n  if (!point1) {\n    return 0;\n  }\n  if (!point2) {\n    point2 = {\n      x: 0,\n      y: 0\n    };\n  }\n  var distance = 0;\n  var prevPoint = point1;\n  if (stepCount > 0) {\n    for (var s = 0; s <= stepCount; s++) {\n      var point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\n      distance += getDistance(prevPoint, point);\n      prevPoint = point;\n    }\n  }\n  return distance;\n}\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\nexport function getScale(point1, startPoint1, point2, startPoint2) {\n  var initialDistance = getDistance(startPoint1, startPoint2);\n  var currentDistance = getDistance(point1, point2);\n  return Math.abs(currentDistance / initialDistance);\n}\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\nexport function getMidPoint(point1, point2, position) {\n  if (!$type.isNumber(position)) {\n    position = 0.5;\n  }\n  return {\n    \"x\": point1.x + (point2.x - point1.x) * position,\n    \"y\": point1.y + (point2.y - point1.y) * position\n  };\n}\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\nexport function getRotation(point1, startPoint1, point2, startPoint2) {\n  // Get start and end angles\n  var startAngle = getAngle(startPoint1, startPoint2);\n  var angle = getAngle(point1, point2);\n  // Calculate angle\n  var diff = startAngle - angle;\n  if (diff < 0) {\n    diff += 360;\n  }\n  return diff;\n}\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n  if (angle < 0) {\n    angle += 360;\n  }\n  return normalizeAngle(angle);\n}\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\nexport function getCenterShift(center, point1, startPoint1, point2, startPoint2) {\n  // Get angle\n  var angle = getRotation(point1, startPoint1, point2, startPoint2) - 90;\n  if (angle < 0) {\n    angle += 360;\n  }\n  // Get distance between new position\n  var distance = getDistance(point1, point2);\n  // Calculate new X\n  var x = Math.cos(angle) / distance + point1.x;\n  var y = Math.cos(angle) / distance + point1.y;\n  var shift = {\n    \"x\": x - center.x,\n    \"y\": y - center.y\n  };\n  return shift;\n}\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\nexport function getBBox(points) {\n  if (points) {\n    var length_1 = points.length;\n    if (length_1 !== 0) {\n      var left = void 0;\n      var right = void 0;\n      var top_1;\n      var bottom = void 0;\n      for (var i = 0; i < length_1; i++) {\n        var point = points[i];\n        if (!$type.isNumber(right) || point.x > right) {\n          right = point.x;\n        }\n        if (!$type.isNumber(left) || point.x < left) {\n          left = point.x;\n        }\n        if (!$type.isNumber(top_1) || point.y < top_1) {\n          top_1 = point.y;\n        }\n        if (!$type.isNumber(bottom) || point.y > bottom) {\n          bottom = point.y;\n        }\n      }\n      return {\n        x: left,\n        y: top_1,\n        width: right - left,\n        height: bottom - top_1\n      };\n    }\n  }\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n}\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\nexport function getCommonRectangle(rectangles) {\n  var length = rectangles.length;\n  if (length !== 0) {\n    var minX = void 0;\n    var minY = void 0;\n    var maxX = void 0;\n    var maxY = void 0;\n    for (var i = 0; i < length; i++) {\n      var rectangle = rectangles[i];\n      minX = min(rectangle.x, minX);\n      minY = min(rectangle.y, minY);\n      maxX = max(rectangle.x + rectangle.width, maxX);\n      maxY = max(rectangle.y + rectangle.height, maxY);\n    }\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\nexport function getPointOnCubicCurve(pointA, pointB, controlPointA, controlPointB, position) {\n  var point = {\n    x: 0,\n    y: 0\n  };\n  var mt1 = 1 - position;\n  var mt2 = mt1 * mt1;\n  var mt3 = mt2 * mt1;\n  point.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\n  point.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\n  return point;\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\nexport function getCubicControlPointA(p0, p1, p2, p3, tensionX, tensionY) {\n  tensionX = adjustTension(tensionX);\n  tensionY = adjustTension(tensionY);\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\nexport function getCubicControlPointB(p0, p1, p2, p3, tensionX, tensionY) {\n  tensionX = adjustTension(tensionX);\n  tensionY = adjustTension(tensionY);\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\nexport function adjustTension(tension) {\n  return 1 - tension + 0.00001;\n}\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\nexport function normalizeAngle(value) {\n  if (value == 360) {\n    return 360;\n  }\n  return value % 360;\n}\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n  return value;\n}\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\nexport function getArcRect(startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n  if (!$type.isNumber(radius)) {\n    radius = 1;\n  }\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\nexport function isInRectangle(point, rectangle) {\n  if (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y >= rectangle.y && point.y <= rectangle.y + rectangle.height) {\n    return true;\n  }\n  return false;\n}\nexport function getLineIntersection(pointA1, pointA2, pointB1, pointB2) {\n  var x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\n  var y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\n  return {\n    x: x,\n    y: y\n  };\n}","map":{"version":3,"names":["$type","PI","Math","HALFPI","RADIANS","DEGREES","toNumberRange","value","min","max","hasValue","toNumber","fitToRange","round","precision","floor","isNumber","rounded","d","pow","ceil","stretch","t","from","to","minValue","maxValue","temp","sin","tan","cos","left","right","closest","values","referenceValue","reduce","prev","curr","abs","intersect","range1","range2","start1","getValue","start","start2","end1","end","end2","invertRange","range","intersection","startMax","endMin","undefined","getDistance","point1","point2","x","y","sqrt","getHorizontalDistance","getVerticalDistance","getCubicCurveDistance","controlPointA","controlPointB","stepCount","distance","prevPoint","s","point","getPointOnCubicCurve","getScale","startPoint1","startPoint2","initialDistance","currentDistance","getMidPoint","position","getRotation","startAngle","getAngle","angle","diff","diffX","diffY","atan2","normalizeAngle","getCenterShift","center","shift","getBBox","points","length_1","length","top_1","bottom","i","width","height","getCommonRectangle","rectangles","minX","minY","maxX","maxY","rectangle","getPointOnQuadraticCurve","pointA","pointB","controlPoint","mt1","mt2","mt3","getCubicControlPointA","p0","p1","p2","p3","tensionX","tensionY","adjustTension","getCubicControlPointB","tension","fitAngleToRange","endAngle","count","maxEnd","maxStart","getArcRect","radius","Number","MAX_VALUE","bpoints","push","getArcPoint","fromAngle","toAngle","pt","arc","isInRectangle","getLineIntersection","pointA1","pointA2","pointB1","pointB2"],"sources":["../../../../../src/.internal/core/utils/Math.ts"],"sourcesContent":["/**\r\n * A collection of Math-related functions\r\n *\r\n * @todo Comment trigonometric functions?\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { IRange } from \"../defs/IRange\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport const PI = Math.PI;\r\nexport const HALFPI = PI / 2;\r\nexport const RADIANS = PI / 180;\r\nexport const DEGREES = 180 / PI;\r\n\r\n/**\r\n * Converts any value and fits it into a specific value range.\r\n *\r\n * @param value  Source value\r\n * @param min    Minimum allowable value\r\n * @param max    Maximum allowable value\r\n * @return Number\r\n */\r\nexport function toNumberRange(value: any, min: number, max: number): number {\r\n\tif ($type.hasValue(value)) {\r\n\t\tvalue = $type.toNumber(value);\r\n\t\treturn fitToRange(value, min, max);\r\n\t}\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\r\nexport function round(value: number, precision?: number, floor?: boolean): number {\r\n\tif (!$type.isNumber(precision) || precision <= 0) {\r\n\r\n\t\tlet rounded = Math.round(value);\r\n\t\tif (floor) {\r\n\t\t\tif (rounded - value == 0.5) {\r\n\t\t\t\trounded--;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn rounded;\r\n\t}\r\n\telse {\r\n\t\tlet d: number = Math.pow(10, precision);\r\n\t\treturn Math.round(value * d) / d;\r\n\t}\r\n}\r\n\r\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\r\nexport function ceil(value: number, precision?: number): number {\r\n\tif (!$type.isNumber(precision) || precision <= 0) {\r\n\t\treturn Math.ceil(value);\r\n\t}\r\n\telse {\r\n\t\tlet d: number = Math.pow(10, precision);\r\n\t\treturn Math.ceil(value * d) / d;\r\n\t}\r\n}\r\n\r\n/**\r\n * Stretches `t` so that it will always be between `from` and `to`.\r\n *\r\n * @param t     Number from 0 to 1\r\n * @param from  Lowest possible value\r\n * @param to    Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function stretch(t: number, from: number, to: number): number {\r\n\treturn (t * (to - from)) + from;\r\n}\r\n\r\n\r\n/**\r\n * Adjust numeric value so it fits to specific value range.\r\n *\r\n * @param value     Value\r\n * @param minValue  Lowest possible value\r\n * @param maxValue  Highest possible value\r\n * @return Adjusted value\r\n */\r\nexport function fitToRange(value: number, minValue: $type.Optional<number>, maxValue: $type.Optional<number>): number {\r\n\tif ($type.isNumber(minValue)) {\r\n\t\tif ($type.isNumber(maxValue) && maxValue < minValue) {\r\n\t\t\tlet temp = maxValue;\r\n\t\t\tmaxValue = minValue;\r\n\t\t\tminValue = temp;\r\n\t\t}\r\n\r\n\t\tif (value < minValue) {\r\n\t\t\tvalue = minValue;\r\n\t\t}\r\n\t}\r\n\r\n\tif ($type.isNumber(maxValue)) {\r\n\t\tif (value > maxValue) {\r\n\t\t\tvalue = maxValue;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n/**\r\n * Returns sine of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function sin(value: number): number {\r\n\treturn round(Math.sin(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns tan of a number.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\r\nexport function tan(value: number): number {\r\n\treturn round(Math.tan(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns cosine of a number.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\r\nexport function cos(value: number): number {\r\n\treturn round(Math.cos(RADIANS * value), 10);\r\n}\r\n\r\n/**\r\n * Returns biggest value out of passed in numeric values.\r\n *\r\n * @param left   Numeric value\r\n * @param right  Numeric value\r\n * @return Biggest value\r\n */\r\nexport function max(left: number, right: number): number;\r\nexport function max(left: number, right: $type.Optional<number>): number;\r\nexport function max(left: $type.Optional<number>, right: number): number;\r\nexport function max(left: $type.Optional<number>, right: $type.Optional<number>): $type.Optional<number>;\r\nexport function max(left: any, right: any): any {\r\n\tif ($type.isNumber(left)) {\r\n\t\tif ($type.isNumber(right)) {\r\n\t\t\tif (right > left) {\r\n\t\t\t\treturn right;\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\treturn left;\r\n\t\t}\r\n\r\n\t} else if ($type.isNumber(right)) {\r\n\t\treturn right;\r\n\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns smallest value out of passed in numeric values.\r\n *\r\n * @param left   Numeric value\r\n * @param right  Numeric value\r\n * @return Smallest value\r\n */\r\nexport function min(left: number, right: number): number;\r\nexport function min(left: number, right: $type.Optional<number>): number;\r\nexport function min(left: $type.Optional<number>, right: number): number;\r\nexport function min(left: $type.Optional<number>, right: $type.Optional<number>): $type.Optional<number>;\r\nexport function min(left: any, right: any): any {\r\n\tif ($type.isNumber(left)) {\r\n\t\tif ($type.isNumber(right)) {\r\n\t\t\tif (right < left) {\r\n\t\t\t\treturn right;\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn left;\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\treturn left;\r\n\t\t}\r\n\r\n\t} else if ($type.isNumber(right)) {\r\n\t\treturn right;\r\n\r\n\t} else {\r\n\t\treturn null;\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\r\nexport function closest(values: number[], referenceValue: number): number {\r\n\treturn values.reduce(function(prev, curr) {\r\n\t\treturn (Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev);\r\n\t});\r\n}\r\n\r\n/**\r\n * Checks whether two ranges of values intersect.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Any intersecting numbers?\r\n */\r\nexport function intersect(range1: IRange, range2: IRange): boolean {\r\n\tlet start1: number = $type.getValue(range1.start);\r\n\tlet start2: number = $type.getValue(range2.start);\r\n\tlet end1: number = $type.getValue(range1.end);\r\n\tlet end2: number = $type.getValue(range2.end);\r\n\r\n\treturn Math.max(start1, start2) <= Math.min(end1, end2);\r\n}\r\n\r\n/**\r\n * Inverts the range of values.\r\n *\r\n * @param range  Range\r\n */\r\nexport function invertRange(range: IRange) {\r\n\tlet start: number = $type.getValue(range.start);\r\n\tlet end: number = $type.getValue(range.end);\r\n\treturn { start: 1 - end, end: 1 - start };\r\n}\r\n\r\n/**\r\n * Returns an intersection range between two ranges of values.\r\n *\r\n * @param range1  Range 1\r\n * @param range2  Range 2\r\n * @return Intersecting value range\r\n */\r\nexport function intersection(range1: IRange, range2: IRange): $type.Optional<IRange> {\r\n\tlet start1: number = $type.getValue(range1.start);\r\n\tlet start2: number = $type.getValue(range2.start);\r\n\tlet end1: number = $type.getValue(range1.end);\r\n\tlet end2: number = $type.getValue(range2.end);\r\n\tlet startMax: number = Math.max(start1, start2);\r\n\tlet endMin: number = Math.min(end1, end2);\r\n\r\n\tif (endMin < startMax) {\r\n\t\treturn undefined;\r\n\t}\r\n\telse {\r\n\t\treturn { start: startMax, end: endMin };\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns pixel \"distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.sqrt(Math.pow(Math.abs(point1.x - point2.x), 2) + Math.pow(Math.abs(point1.y - point2.y), 2));\r\n}\r\n\r\n/**\r\n * Returns pixel \"horizontal distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getHorizontalDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.abs(point1.x - point2.x);\r\n}\r\n\r\n/**\r\n * Returns pixel \"vertical distance\" between two points.\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Distance in relative pixels\r\n */\r\nexport function getVerticalDistance(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\treturn Math.abs(point1.y - point2.y);\r\n}\r\n\r\n/**\r\n * Returns approximate pixel \"distance\" between two points of cubic curve\r\n *\r\n * If second point is not specified, distance from {x:0, y:0} point is\r\n * calculated.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @param controlPointA  Control Point 1\r\n * @param controlPointB  Control Point 2\r\n * @param stepCount  number of steps (the more, the more accurate result)\r\n * @return Distance in relative pixels\r\n */\r\nexport function getCubicCurveDistance(point1: IPoint, point2: IPoint, controlPointA: IPoint, controlPointB: IPoint, stepCount:number): number {\r\n\tif (!point1) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: 0, y: 0 };\r\n\t}\r\n\r\n\tlet distance = 0;\r\n\tlet prevPoint: IPoint = point1;\r\n\tif (stepCount > 0) {\r\n\t\tfor (let s = 0; s <= stepCount; s++) {\r\n\t\t\tlet point = getPointOnCubicCurve(point1, point2, controlPointA, controlPointB, s / stepCount);\r\n\t\t\tdistance += getDistance(prevPoint, point);\r\n\t\t\tprevPoint = point;\r\n\t\t}\r\n\t}\r\n\treturn distance;\r\n}\r\n\r\n/**\r\n * Returns scale based on original and end position of the two points.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Scale        Calculated scale\r\n */\r\nexport function getScale(point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): number {\r\n\tlet initialDistance: number = getDistance(startPoint1, startPoint2);\r\n\tlet currentDistance: number = getDistance(point1, point2);\r\n\r\n\treturn Math.abs(currentDistance / initialDistance);\r\n}\r\n\r\n/**\r\n * Returns an exact mid point between two points.\r\n *\r\n * @param point1     Position of point 1\r\n * @param point2     Position of point 2\r\n * @return Mid point  Position of mid-point\r\n */\r\nexport function getMidPoint(point1: IPoint, point2: IPoint, position?: number): IPoint {\r\n\tif (!$type.isNumber(position)) {\r\n\t\tposition = 0.5;\r\n\t}\r\n\r\n\treturn {\r\n\t\t\"x\": (point1.x + (point2.x - point1.x) * position),\r\n\t\t\"y\": (point1.y + (point2.y - point1.y) * position)\r\n\t}\r\n}\r\n\r\n/**\r\n * Returns difference in angles between starting and ending position of two\r\n * vectors.\r\n *\r\n * @param point1       Current position of point 1\r\n * @param startPoint1  Start position of point 1\r\n * @param point2       Current position of point 1\r\n * @param startPoint2  Start position of point 2\r\n * @return Angle difference in degrees\r\n */\r\nexport function getRotation(point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): number {\r\n\r\n\t// Get start and end angles\r\n\tlet startAngle: number = getAngle(startPoint1, startPoint2);\r\n\tlet angle: number = getAngle(point1, point2);\r\n\r\n\t// Calculate angle\r\n\tlet diff: number = startAngle - angle;\r\n\tif (diff < 0) {\r\n\t\tdiff += 360;\r\n\t}\r\n\r\n\treturn diff;\r\n}\r\n\r\n/**\r\n * Calculates angle of the vector based on two or one point.\r\n *\r\n * @param point1  Point 1\r\n * @param point2  Point 2\r\n * @return Angle in degrees\r\n */\r\nexport function getAngle(point1: IPoint, point2?: IPoint): number {\r\n\tif (!point2) {\r\n\t\tpoint2 = { x: point1.x * 2, y: point1.y * 2 };\r\n\t}\r\n\tlet diffX: number = point2.x - point1.x;\r\n\tlet diffY: number = point2.y - point1.y;\r\n\tlet angle: number = Math.atan2(diffY, diffX) * DEGREES;\r\n\tif (angle < 0) {\r\n\t\tangle += 360;\r\n\t}\r\n\treturn normalizeAngle(angle);\r\n}\r\n\r\n/**\r\n * Returns the shift in coordinates of the center when item is rotated, moved\r\n * and scaled at the same time.\r\n *\r\n * @param center       Current center\r\n * @param point1       Frst reference point\r\n * @param startPoint1  Original position of the first reference point\r\n * @param point2       Second reference point\r\n * @param startPoint2  Original position of the first reference point\r\n * @return Shift in center point coordinates\r\n */\r\nexport function getCenterShift(center: IPoint, point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint): IPoint {\r\n\r\n\t// Get angle\r\n\tlet angle: number = getRotation(point1, startPoint1, point2, startPoint2) - 90;\r\n\tif (angle < 0) {\r\n\t\tangle += 360;\r\n\t}\r\n\r\n\t// Get distance between new position\r\n\tlet distance: number = getDistance(point1, point2);\r\n\r\n\t// Calculate new X\r\n\tlet x: number = Math.cos(angle) / distance + point1.x;\r\n\tlet y: number = Math.cos(angle) / distance + point1.y;\r\n\r\n\tlet shift: IPoint = {\r\n\t\t\"x\": x - center.x,\r\n\t\t\"y\": y - center.y\r\n\t}\r\n\treturn shift;\r\n}\r\n\r\n/**\r\n * Converts an array of points into a bounding box rectangle.\r\n *\r\n * Array can contain any number of points.\r\n *\r\n * @param points  Points\r\n * @return Bounding box rectangle\r\n */\r\nexport function getBBox(points: IPoint[]): $type.Optional<IRectangle> {\r\n\tif (points) {\r\n\t\tlet length = points.length;\r\n\r\n\t\tif (length !== 0) {\r\n\t\t\tlet left!: number;\r\n\t\t\tlet right!: number;\r\n\t\t\tlet top!: number;\r\n\t\t\tlet bottom!: number;\r\n\r\n\t\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\t\tlet point: IPoint = points[i];\r\n\r\n\t\t\t\tif (!$type.isNumber(right) || (point.x > right)) {\r\n\t\t\t\t\tright = point.x;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(left) || (point.x < left)) {\r\n\t\t\t\t\tleft = point.x;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (!$type.isNumber(top) || (point.y < top)) {\r\n\t\t\t\t\ttop = point.y;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(bottom) || (point.y > bottom)) {\r\n\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn { x: left, y: top, width: right - left, height: bottom - top };\r\n\t\t}\r\n\t}\r\n\r\n\treturn { x: 0, y: 0, width: 0, height: 0 };\r\n}\r\n\r\n/**\r\n * Returns a [[IRectangle]] object representing a common rectangle that fits\r\n * all passed in rectangles in it.\r\n *\r\n * @param rectangles  An array of rectangles\r\n * @return Common rectangle\r\n */\r\nexport function getCommonRectangle(rectangles: IRectangle[]): $type.Optional<IRectangle> {\r\n\tlet length = rectangles.length;\r\n\r\n\tif (length !== 0) {\r\n\t\tlet minX!: number;\r\n\t\tlet minY!: number;\r\n\t\tlet maxX!: number;\r\n\t\tlet maxY!: number;\r\n\r\n\t\tfor (let i = 0; i < length; i++) {\r\n\t\t\tlet rectangle = rectangles[i];\r\n\t\t\tminX = min(rectangle.x, minX);\r\n\t\t\tminY = min(rectangle.y, minY);\r\n\t\t\tmaxX = max(rectangle.x + rectangle.width, maxX);\r\n\t\t\tmaxY = max(rectangle.y + rectangle.height, maxY);\r\n\t\t}\r\n\r\n\t\treturn { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\r\n\t}\r\n}\r\n\r\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnQuadraticCurve(pointA: IPoint, pointB: IPoint, controlPoint: IPoint, position: number): IPoint {\r\n\tlet x: number = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\r\n\tlet y: number = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\r\n\treturn { x: x, y: y };\r\n}\r\n\r\n/**\r\n * [getPointOnCubicCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA         [description]\r\n * @param pointB         [description]\r\n * @param controlPointA  [description]\r\n * @param controlPointB  [description]\r\n * @param position       [description]\r\n * @return [description]\r\n */\r\nexport function getPointOnCubicCurve(pointA: IPoint, pointB: IPoint, controlPointA: IPoint, controlPointB: IPoint, position: number): IPoint {\r\n\tlet point: IPoint = { x: 0, y: 0 };\r\n\tlet mt1: number = 1 - position;\r\n\tlet mt2: number = mt1 * mt1;\r\n\tlet mt3: number = mt2 * mt1;\r\n\r\n\tpoint.x = pointA.x * mt3 + controlPointA.x * 3 * mt2 * position + controlPointB.x * 3 * mt1 * position * position + pointB.x * position * position * position;\r\n\tpoint.y = pointA.y * mt3 + controlPointA.y * 3 * mt2 * position + controlPointB.y * 3 * mt1 * position * position + pointB.y * position * position * position;\r\n\r\n\treturn point;\r\n}\r\n\r\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointA(p0: IPoint, p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\r\n\ttensionX = adjustTension(tensionX);\r\n\ttensionY = adjustTension(tensionY);\r\n\treturn { x: ((-p0.x + p1.x / tensionX + p2.x) * tensionX), y: ((-p0.y + p1.y / tensionY + p2.y) * tensionY) };\r\n}\r\n\r\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\r\nexport function getCubicControlPointB(p0: IPoint, p1: IPoint, p2: IPoint, p3: IPoint, tensionX: number, tensionY: number): IPoint {\r\n\ttensionX = adjustTension(tensionX);\r\n\ttensionY = adjustTension(tensionY);\r\n\treturn { x: ((p1.x + p2.x / tensionX - p3.x) * tensionX), y: ((p1.y + p2.y / tensionY - p3.y) * tensionY) };\r\n}\r\n\r\n/**\r\n * [adjustTension description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param tension  [description]\r\n * @return [description]\r\n */\r\nexport function adjustTension(tension: number): number {\r\n\treturn 1 - tension + 0.00001;\r\n}\r\n\r\n/**\r\n * [normalizeAngle description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param value  [description]\r\n * @return [description]\r\n */\r\nexport function normalizeAngle(value: number): number {\r\n\tif (value == 360) {\r\n\t\treturn 360;\r\n\t}\r\n\treturn value % 360;\r\n}\r\n\r\n\r\n\r\n/**\r\n * [normalizeAngleToRange description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @todo review this with various angles, can be tested on radar chart with custom start/end angles\r\n * @param value       [description]\r\n * @param startAngle  [description]\r\n * @param endAngle    [description]\r\n * @return [description]\r\n */\r\nexport function fitAngleToRange(value: number, startAngle: number, endAngle: number): number {\r\n\r\n\tif (startAngle > endAngle) {\r\n\t\tlet temp: number = startAngle;\r\n\t\tstartAngle = endAngle;\r\n\t\tendAngle = temp;\r\n\t}\r\n\r\n\tvalue = normalizeAngle(value);\r\n\r\n\tlet count = (startAngle - normalizeAngle(startAngle)) / 360;\r\n\r\n\tif (value < startAngle) {\r\n\t\tvalue += 360 * (count + 1);\r\n\t}\r\n\r\n\tlet maxEnd: number = startAngle + (endAngle - startAngle) / 2 + 180;\r\n\tlet maxStart: number = startAngle + (endAngle - startAngle) / 2 - 180;\r\n\r\n\tif (value > endAngle) {\r\n\r\n\t\tif (value - 360 > startAngle) {\r\n\t\t\tvalue -= 360;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (value < maxEnd) {\r\n\t\t\t\tvalue = endAngle;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tvalue = startAngle;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tif (value < startAngle) {\r\n\t\tif (value > maxStart) {\r\n\t\t\tvalue = startAngle;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tvalue = endAngle;\r\n\t\t}\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n\r\n\r\n/**\r\n * Returns [[IRectangle]] of an arc in relative values, assuming that the\r\n * center is at the circle center.\r\n *\r\n * Used to find out max radius of an arc.\r\n *\r\n * @ignore Exclude from docs\r\n * @param startAngle  Start angle\r\n * @param endAngle    End angle\r\n * @param radius    \t Relative radius\r\n * @return Rectangle\r\n */\r\nexport function getArcRect(startAngle: number, endAngle: number, radius?: number): IRectangle {\r\n\r\n\tlet minX = Number.MAX_VALUE;\r\n\tlet minY = Number.MAX_VALUE;\r\n\tlet maxX = -Number.MAX_VALUE;\r\n\tlet maxY = -Number.MAX_VALUE;\r\n\r\n\tlet bpoints = [];\r\n\r\n\tif (!$type.isNumber(radius)) {\r\n\t\tradius = 1;\r\n\t}\r\n\r\n\tbpoints.push(getArcPoint(radius, startAngle));\r\n\tbpoints.push(getArcPoint(radius, endAngle));\r\n\r\n\tlet fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\r\n\tlet toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\r\n\r\n\tfor (let angle = fromAngle; angle <= toAngle; angle += 90) {\r\n\t\tif (angle >= startAngle && angle <= endAngle) {\r\n\t\t\tbpoints.push(getArcPoint(radius, angle));\r\n\t\t}\r\n\t}\r\n\r\n\tfor (let i = 0; i < bpoints.length; i++) {\r\n\t\tlet pt = bpoints[i];\r\n\t\tif (pt.x < minX) { minX = pt.x; }\r\n\t\tif (pt.y < minY) { minY = pt.y; }\r\n\t\tif (pt.x > maxX) { maxX = pt.x; }\r\n\t\tif (pt.y > maxY) { maxY = pt.y; }\r\n\t}\r\n\r\n\treturn ({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });\r\n}\r\n\r\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\r\nexport function getArcPoint(radius: number, arc: number) {\r\n\treturn ({ x: radius * cos(arc), y: radius * sin(arc) });\r\n}\r\n\r\n/**\r\n * Returns true if a point is within rectangle\r\n *\r\n * @param point\r\n * @param rectangle\r\n * @return {boolean}\r\n */\r\nexport function isInRectangle(point: IPoint, rectangle: IRectangle): boolean {\r\n\tif (point.x >= rectangle.x && point.x <= rectangle.x + rectangle.width && point.y >= rectangle.y && point.y <= rectangle.y + rectangle.height) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\n\r\nexport function getLineIntersection(pointA1: IPoint, pointA2: IPoint, pointB1: IPoint, pointB2: IPoint) {\r\n\tlet x = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.x - pointB2.x) - (pointA1.x - pointA2.x) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n\tlet y = ((pointA1.x * pointA2.y - pointA2.x * pointA1.y) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x * pointB2.y - pointB1.y * pointB2.x)) / ((pointA1.x - pointA2.x) * (pointB1.y - pointB2.y) - (pointA1.y - pointA2.y) * (pointB1.x - pointB2.x));\r\n\treturn { x: x, y: y };\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}