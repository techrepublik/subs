{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * Polygon module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Sprite } from \"../Sprite\";\nimport { Morpher } from \"../utils/Morpher\";\nimport { registry } from \"../Registry\";\nimport * as $path from \"../rendering/Path\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\nvar Polygon = /** @class */function (_super) {\n  __extends(Polygon, _super);\n  /**\r\n   * Constructor\r\n   */\n  function Polygon() {\n    var _this = _super.call(this) || this;\n    _this.className = \"Polygon\";\n    _this.element = _this.paper.add(\"path\");\n    _this.shapeRendering = \"auto\";\n    _this._currentPoints = [];\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(Polygon.prototype, \"points\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      var points = this.getPropertyValue(\"points\");\n      var path = this.path;\n      if (path && (!points || points.length == 0)) {\n        var valueStr = path.slice(1, path.length - 1);\n        var segments = valueStr.split(\"ZM\");\n        for (var s = 0; s < segments.length; s++) {\n          var segment = segments[s];\n          if (segment.length > 0) {\n            var areaHole = segment.split(\"M\");\n            var areaArr = areaHole[0];\n            var holeArr = areaHole[1];\n            if (areaArr && areaArr.length > 0) {\n              var pointsArr = areaArr.split(\"L\");\n              if (pointsArr.length > 0) {\n                var area = [];\n                var areaAndHole = [area];\n                points.push(areaAndHole);\n                for (var p = 0; p < pointsArr.length; p++) {\n                  var coords = pointsArr[p].split(\",\");\n                  area.push({\n                    x: +coords[0],\n                    y: +coords[1]\n                  });\n                }\n                if (holeArr && holeArr.length > 0) {\n                  var pointsArr_1 = holeArr.split(\"L\");\n                  if (pointsArr_1.length > 0) {\n                    var hole = [];\n                    areaAndHole.push(hole);\n                    for (var p = pointsArr_1.length - 1; p >= 0; p--) {\n                      var coords = pointsArr_1[p].split(\",\");\n                      hole.push({\n                        x: +coords[0],\n                        y: +coords[1]\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        this.setPropertyValue(\"points\", points);\n        this._currentPoints = points;\n      }\n      return points;\n    },\n    /**\r\n     * An array of X/Y coordinates for each elbow of the polygon.\r\n     *\r\n     * @todo Example\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      this.setPropertyValue(\"points\", points, true);\n      this._currentPoints = points;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"currentPoints\", {\n    /**\r\n     * @return Polygon points\r\n     */\n    get: function () {\n      if ((!this._currentPoints || this._currentPoints.length == 0) && this.path) {\n        this._currentPoints = this.points;\n      }\n      return this._currentPoints;\n    },\n    /**\r\n     * Current points. Used when morphing the element, so that original `points`\r\n     * are not overwritten.\r\n     *\r\n     * @param points  Polygon points\r\n     */\n    set: function (points) {\n      if (this._currentPoints != points) {\n        this._currentPoints = points;\n        this.draw();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Polygon.prototype.draw = function () {\n    var path = \"\";\n    var points = this._currentPoints;\n    var left;\n    var right;\n    var top;\n    var bottom;\n    if (points.length > 0) {\n      // separate areas\n      for (var i = 0, len = points.length; i < len; i++) {\n        // surface\n        var surface = points[i][0];\n        var hole = points[i][1];\n        if (surface && surface.length > 0) {\n          var point = surface[0];\n          path += $path.moveTo(point);\n          for (var s = 0; s < surface.length; s++) {\n            point = surface[s];\n            path += $path.lineTo(point);\n            if (!$type.isNumber(right) || right < point.x) {\n              right = point.x;\n            }\n            if (!$type.isNumber(left) || left > point.x) {\n              left = point.x;\n            }\n            if (!$type.isNumber(top) || top > point.y) {\n              top = point.y;\n            }\n            if (!$type.isNumber(bottom) || bottom < point.y) {\n              bottom = point.y;\n            }\n          }\n        }\n        // hole\n        if (hole && hole.length > 0) {\n          var point = hole[0];\n          path += $path.moveTo(point);\n          for (var h = 0, hlen = hole.length; h < hlen; h++) {\n            point = hole[h];\n            path += $path.lineTo(point);\n          }\n        }\n      }\n      if (path) {\n        path += $path.closePath();\n      }\n      this.bbox.x = left;\n      this.bbox.y = top;\n      this.bbox.width = right - left;\n      this.bbox.height = bottom - top;\n      _super.prototype.setPath.call(this, path);\n    }\n  };\n  /**\r\n   * @ignore\r\n   */\n  Polygon.prototype.setPath = function (value) {\n    if (_super.prototype.setPath.call(this, value)) {\n      this.points = [];\n      this._bbox = this.group.getBBox();\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * Measures element\r\n   */\n  Polygon.prototype.measureElement = function () {\n    // Overriding to avoid extra measurement.\n  };\n  Object.defineProperty(Polygon.prototype, \"centerPoint\", {\n    /**\r\n     * A calculated center point for the shape.\r\n     *\r\n     * @readonly\r\n     * @return Center\r\n     */\n    get: function () {\n      return {\n        x: this.bbox.x + this.bbox.width / 2,\n        y: this.bbox.y + this.bbox.height / 2\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Polygon.prototype, \"morpher\", {\n    /**\r\n     * A [[Morpher]] instance that is used to morph polygon into some other\r\n     * shape.\r\n     *\r\n     * @readonly\r\n     * @return Morpher instance\r\n     */\n    get: function () {\n      if (!this._morpher) {\n        this._morpher = new Morpher(this);\n        this._disposers.push(this._morpher);\n      }\n      return this._morpher;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Polygon;\n}(Sprite);\nexport { Polygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"Polygon\"] = Polygon;","map":{"version":3,"names":["Sprite","Morpher","registry","$path","$type","Polygon","_super","__extends","_this","call","className","element","paper","add","shapeRendering","_currentPoints","applyTheme","Object","defineProperty","prototype","get","points","getPropertyValue","path","length","valueStr","slice","segments","split","s","segment","areaHole","areaArr","holeArr","pointsArr","area","areaAndHole","push","p","coords","x","y","pointsArr_1","hole","setPropertyValue","set","draw","left","right","top","bottom","i","len","surface","point","moveTo","lineTo","isNumber","h","hlen","closePath","bbox","width","height","setPath","value","_bbox","group","getBBox","measureElement","_morpher","_disposers","registeredClasses"],"sources":["../../../../../src/.internal/core/elements/Polygon.ts"],"sourcesContent":["/**\r\n * Polygon module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite, ISpriteProperties, ISpriteAdapters, ISpriteEvents } from \"../Sprite\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { Morpher } from \"../utils/Morpher\";\r\nimport { IMorphable } from \"../defs/IMorphable\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $path from \"../rendering/Path\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[Polygon]].\r\n */\r\nexport interface IPolygonProperties extends ISpriteProperties {\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t */\r\n\tpoints?: Array<Array<Array<IPoint>>>;\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[Polygon]].\r\n */\r\nexport interface IPolygonEvents extends ISpriteEvents { }\r\n\r\n/**\r\n * Defines adapters for [[Polygon]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IPolygonAdapters extends ISpriteAdapters, IPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Draws a polygon.\r\n *\r\n * @see {@link IPolygonEvents} for a list of available events\r\n * @see {@link IPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class Polygon extends Sprite implements IMorphable {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IPolygonAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IPolygonEvents;\r\n\r\n\t/**\r\n\t * A morpher instance that is used to morph polygon into some other shape.\r\n\t */\r\n\tprotected _morpher: $type.Optional<Morpher>;\r\n\r\n\t/**\r\n\t * Current points that morpher uses. This is needed so that we don't\r\n\t * overwrite polygons original points.\r\n\t */\r\n\tprotected _currentPoints: Array<Array<Array<IPoint>>>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"Polygon\";\r\n\t\tthis.element = this.paper.add(\"path\");\r\n\t\tthis.shapeRendering = \"auto\";\r\n\t\tthis._currentPoints = [];\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * An array of X/Y coordinates for each elbow of the polygon.\r\n\t *\r\n\t * @todo Example\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set points(points: Array<Array<Array<IPoint>>>) {\r\n\t\tthis.setPropertyValue(\"points\", points, true);\r\n\t\tthis._currentPoints = points;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get points(): Array<Array<Array<IPoint>>> {\r\n\t\tlet points = this.getPropertyValue(\"points\");\r\n\t\tlet path = this.path;\r\n\r\n\t\tif (path && (!points || points.length == 0)) {\r\n\r\n\t\t\tlet valueStr = path.slice(1, path.length - 1);\r\n\r\n\t\t\tlet segments: string[] = valueStr.split(\"ZM\");\r\n\r\n\t\t\tfor (let s = 0; s < segments.length; s++) {\r\n\t\t\t\tlet segment = segments[s];\r\n\t\t\t\tif (segment.length > 0) {\r\n\t\t\t\t\tlet areaHole = segment.split(\"M\");\r\n\r\n\t\t\t\t\tlet areaArr = areaHole[0];\r\n\t\t\t\t\tlet holeArr = areaHole[1];\r\n\r\n\t\t\t\t\tif (areaArr && areaArr.length > 0) {\r\n\r\n\t\t\t\t\t\tlet pointsArr = areaArr.split(\"L\");\r\n\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\r\n\t\t\t\t\t\t\tlet area: IPoint[] = [];\r\n\r\n\t\t\t\t\t\t\tlet areaAndHole: Array<Array<IPoint>> = [area];\r\n\t\t\t\t\t\t\tpoints.push(areaAndHole);\r\n\r\n\t\t\t\t\t\t\tfor (let p = 0; p < pointsArr.length; p++) {\r\n\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\tarea.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif (holeArr && holeArr.length > 0) {\r\n\t\t\t\t\t\t\t\tlet pointsArr = holeArr.split(\"L\");\r\n\t\t\t\t\t\t\t\tif (pointsArr.length > 0) {\r\n\t\t\t\t\t\t\t\t\tlet hole: IPoint[] = [];\r\n\t\t\t\t\t\t\t\t\tareaAndHole.push(hole);\r\n\t\t\t\t\t\t\t\t\tfor (let p = pointsArr.length - 1; p >= 0; p--) {\r\n\t\t\t\t\t\t\t\t\t\tlet coords = pointsArr[p].split(\",\");\r\n\t\t\t\t\t\t\t\t\t\thole.push({ x: +coords[0], y: +coords[1] });\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.setPropertyValue(\"points\", points);\r\n\t\t\tthis._currentPoints = points;\r\n\t\t}\r\n\t\treturn points;\r\n\t}\r\n\r\n\t/**\r\n\t * Current points. Used when morphing the element, so that original `points`\r\n\t * are not overwritten.\r\n\t *\r\n\t * @param points  Polygon points\r\n\t */\r\n\tpublic set currentPoints(points: Array<Array<Array<IPoint>>>) {\r\n\t\tif (this._currentPoints != points) {\r\n\t\t\tthis._currentPoints = points;\r\n\t\t\tthis.draw();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon points\r\n\t */\r\n\tpublic get currentPoints(): Array<Array<Array<IPoint>>> {\r\n\t\tif((!this._currentPoints || this._currentPoints.length == 0) && this.path){\r\n\t\t\tthis._currentPoints = this.points;\r\n\t\t}\r\n\t\treturn this._currentPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Draws the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic draw(): void {\r\n\t\tlet path: string = \"\";\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this._currentPoints;\r\n\r\n\t\tlet left: $type.Optional<number>;\r\n\t\tlet right: $type.Optional<number>;\r\n\t\tlet top: $type.Optional<number>;\r\n\t\tlet bottom: $type.Optional<number>;\r\n\r\n\t\tif (points.length > 0) {\r\n\t\t\t// separate areas\r\n\t\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\t\t// surface\r\n\t\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\t\tif (surface && surface.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = surface[0];\r\n\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let s: number = 0; s < surface.length; s++) {\r\n\t\t\t\t\t\tpoint = surface[s];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(right) || (right < point.x)) {\r\n\t\t\t\t\t\t\tright = point.x;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(left) || (left > point.x)) {\r\n\t\t\t\t\t\t\tleft = point.x;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!$type.isNumber(top) || (top > point.y)) {\r\n\t\t\t\t\t\t\ttop = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (!$type.isNumber(bottom) || (bottom < point.y)) {\r\n\t\t\t\t\t\t\tbottom = point.y;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// hole\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tlet point: IPoint = hole[0];\r\n\t\t\t\t\tpath += $path.moveTo(point);\r\n\r\n\t\t\t\t\tfor (let h = 0, hlen = hole.length; h < hlen; h++) {\r\n\t\t\t\t\t\tpoint = hole[h];\r\n\t\t\t\t\t\tpath += $path.lineTo(point);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (path) {\r\n\t\t\t\tpath += $path.closePath();\r\n\t\t\t}\r\n\r\n\t\t\tthis.bbox.x = left;\r\n\t\t\tthis.bbox.y = top;\r\n\t\t\tthis.bbox.width = right - left;\r\n\t\t\tthis.bbox.height = bottom - top;\r\n\r\n\t\t\tsuper.setPath(path);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected setPath(value: string): boolean {\r\n\t\tif (super.setPath(value)) {\r\n\t\t\tthis.points = [];\r\n\t\t\tthis._bbox = this.group.getBBox();\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Measures element\r\n\t */\r\n\tprotected measureElement(): void {\r\n\r\n\t\t// Overriding to avoid extra measurement.\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * A calculated center point for the shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center\r\n\t */\r\n\tpublic get centerPoint(): IPoint {\r\n\t\treturn { x: this.bbox.x + this.bbox.width / 2, y: this.bbox.y + this.bbox.height / 2 };\r\n\t}\r\n\r\n\t/**\r\n\t * A [[Morpher]] instance that is used to morph polygon into some other\r\n\t * shape.\r\n\t *\r\n\t * @readonly\r\n\t * @return Morpher instance\r\n\t */\r\n\tpublic get morpher(): Morpher {\r\n\t\tif (!this._morpher) {\r\n\t\t\tthis._morpher = new Morpher(this);\r\n\t\t\tthis._disposers.push(this._morpher);\r\n\t\t}\r\n\t\treturn this._morpher;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Polygon\"] = Polygon;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}