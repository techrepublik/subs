{"ast":null,"code":"import \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n// Register each file as a corresponding Vuex module. Module nesting\n// will mirror [sub-]directory hierarchy and modules are namespaced\n// as the camelCase equivalent of their file name.\n\nimport camelCase from 'lodash/camelCase';\nconst modulesCache = {};\nconst storeData = {\n  modules: {}\n};\n(function updateModules() {\n  // Allow us to dynamically require all Vuex module files.\n  // https://webpack.js.org/guides/dependency-management/#require-context\n  const requireModule = require.context(\n  // Search for files in the current directory.\n  '.',\n  // Search for files in subdirectories.\n  true,\n  // Include any .js files that are not this file or a unit test.\n  /^((?!index|\\.unit\\.).)*\\.js$/);\n\n  // For every Vuex module...\n  requireModule.keys().forEach(fileName => {\n    const moduleDefinition = requireModule(fileName);\n\n    // Skip the module during hot reload if it refers to the\n    // same module definition as the one we have cached.\n    if (modulesCache[fileName] === moduleDefinition) return;\n\n    // Update the module cache, for efficient hot reloading.\n    modulesCache[fileName] = moduleDefinition;\n\n    // Get the module path as an array.\n    const modulePath = fileName\n    // Remove the \"./\" from the beginning.\n    .replace(/^\\.\\//, '')\n    // Remove the file extension from the end.\n    .replace(/\\.\\w+$/, '')\n    // Split nested modules into an array path.\n    .split(/\\//)\n    // camelCase all module namespaces and names.\n    .map(camelCase);\n\n    // Get the modules object for the current path.\n    const {\n      modules\n    } = getNamespace(storeData, modulePath);\n\n    // Add the module to our modules object.\n    modules[modulePath.pop()] = {\n      // Modules are namespaced by default.\n      namespaced: true,\n      ...moduleDefinition\n    };\n  });\n\n  // If the environment supports hot reloading...\n  if (module.hot) {\n    // Whenever any Vuex module is updated...\n    module.hot.accept(requireModule.id, () => {\n      // Update `storeData.modules` with the latest definitions.\n      updateModules();\n      // Trigger a hot update in the store.\n      require('../store').default.hotUpdate({\n        modules: storeData.modules\n      });\n    });\n  }\n})();\n\n// Recursively get the namespace of a Vuex module, even if nested.\nfunction getNamespace(subtree, path) {\n  if (path.length === 1) return subtree;\n  const namespace = path.shift();\n  subtree.modules[namespace] = {\n    modules: {},\n    namespaced: true,\n    ...subtree.modules[namespace]\n  };\n  return getNamespace(subtree.modules[namespace], path);\n}\nexport default storeData.modules;","map":{"version":3,"names":["camelCase","modulesCache","storeData","modules","updateModules","requireModule","require","context","keys","forEach","fileName","moduleDefinition","modulePath","replace","split","map","getNamespace","pop","namespaced","module","hot","accept","id","default","hotUpdate","subtree","path","length","namespace","shift"],"sources":["/Users/admin/Desktop/techrepublik/pro/subs/vue_subs/src/state/modules/index.js"],"sourcesContent":["// Register each file as a corresponding Vuex module. Module nesting\r\n// will mirror [sub-]directory hierarchy and modules are namespaced\r\n// as the camelCase equivalent of their file name.\r\n\r\nimport camelCase from 'lodash/camelCase'\r\n\r\nconst modulesCache = {}\r\nconst storeData = { modules: {} }\r\n\r\n    ; (function updateModules() {\r\n        // Allow us to dynamically require all Vuex module files.\r\n        // https://webpack.js.org/guides/dependency-management/#require-context\r\n        const requireModule = require.context(\r\n            // Search for files in the current directory.\r\n            '.',\r\n            // Search for files in subdirectories.\r\n            true,\r\n            // Include any .js files that are not this file or a unit test.\r\n            /^((?!index|\\.unit\\.).)*\\.js$/\r\n        )\r\n\r\n        // For every Vuex module...\r\n        requireModule.keys().forEach((fileName) => {\r\n            const moduleDefinition = requireModule(fileName)\r\n\r\n            // Skip the module during hot reload if it refers to the\r\n            // same module definition as the one we have cached.\r\n            if (modulesCache[fileName] === moduleDefinition) return\r\n\r\n            // Update the module cache, for efficient hot reloading.\r\n            modulesCache[fileName] = moduleDefinition\r\n\r\n            // Get the module path as an array.\r\n            const modulePath = fileName\r\n                // Remove the \"./\" from the beginning.\r\n                .replace(/^\\.\\//, '')\r\n                // Remove the file extension from the end.\r\n                .replace(/\\.\\w+$/, '')\r\n                // Split nested modules into an array path.\r\n                .split(/\\//)\r\n                // camelCase all module namespaces and names.\r\n                .map(camelCase)\r\n\r\n            // Get the modules object for the current path.\r\n            const { modules } = getNamespace(storeData, modulePath)\r\n\r\n            // Add the module to our modules object.\r\n            modules[modulePath.pop()] = {\r\n                // Modules are namespaced by default.\r\n                namespaced: true,\r\n                ...moduleDefinition,\r\n            }\r\n        })\r\n\r\n        // If the environment supports hot reloading...\r\n        if (module.hot) {\r\n            // Whenever any Vuex module is updated...\r\n            module.hot.accept(requireModule.id, () => {\r\n                // Update `storeData.modules` with the latest definitions.\r\n                updateModules()\r\n                // Trigger a hot update in the store.\r\n                require('../store').default.hotUpdate({ modules: storeData.modules })\r\n            })\r\n        }\r\n    })()\r\n\r\n// Recursively get the namespace of a Vuex module, even if nested.\r\nfunction getNamespace(subtree, path) {\r\n    if (path.length === 1) return subtree\r\n\r\n    const namespace = path.shift()\r\n    subtree.modules[namespace] = {\r\n        modules: {},\r\n        namespaced: true,\r\n        ...subtree.modules[namespace],\r\n    }\r\n    return getNamespace(subtree.modules[namespace], path)\r\n}\r\n\r\nexport default storeData.modules"],"mappings":";;;AAAA;AACA;AACA;;AAEA,OAAOA,SAAS,MAAM,kBAAkB;AAExC,MAAMC,YAAY,GAAG,CAAC,CAAC;AACvB,MAAMC,SAAS,GAAG;EAAEC,OAAO,EAAE,CAAC;AAAE,CAAC;AAE3B,CAAC,SAASC,aAAaA,CAAA,EAAG;EACxB;EACA;EACA,MAAMC,aAAa,GAAGC,OAAO,CAACC,OAAO;EACjC;EACA,GAAG;EACH;EACA,IAAI;EACJ;EACA,8BACJ,CAAC;;EAED;EACAF,aAAa,CAACG,IAAI,CAAC,CAAC,CAACC,OAAO,CAAEC,QAAQ,IAAK;IACvC,MAAMC,gBAAgB,GAAGN,aAAa,CAACK,QAAQ,CAAC;;IAEhD;IACA;IACA,IAAIT,YAAY,CAACS,QAAQ,CAAC,KAAKC,gBAAgB,EAAE;;IAEjD;IACAV,YAAY,CAACS,QAAQ,CAAC,GAAGC,gBAAgB;;IAEzC;IACA,MAAMC,UAAU,GAAGF;IACf;IAAA,CACCG,OAAO,CAAC,OAAO,EAAE,EAAE;IACpB;IAAA,CACCA,OAAO,CAAC,QAAQ,EAAE,EAAE;IACrB;IAAA,CACCC,KAAK,CAAC,IAAI;IACX;IAAA,CACCC,GAAG,CAACf,SAAS,CAAC;;IAEnB;IACA,MAAM;MAAEG;IAAQ,CAAC,GAAGa,YAAY,CAACd,SAAS,EAAEU,UAAU,CAAC;;IAEvD;IACAT,OAAO,CAACS,UAAU,CAACK,GAAG,CAAC,CAAC,CAAC,GAAG;MACxB;MACAC,UAAU,EAAE,IAAI;MAChB,GAAGP;IACP,CAAC;EACL,CAAC,CAAC;;EAEF;EACA,IAAIQ,MAAM,CAACC,GAAG,EAAE;IACZ;IACAD,MAAM,CAACC,GAAG,CAACC,MAAM,CAAChB,aAAa,CAACiB,EAAE,EAAE,MAAM;MACtC;MACAlB,aAAa,CAAC,CAAC;MACf;MACAE,OAAO,CAAC,UAAU,CAAC,CAACiB,OAAO,CAACC,SAAS,CAAC;QAAErB,OAAO,EAAED,SAAS,CAACC;MAAQ,CAAC,CAAC;IACzE,CAAC,CAAC;EACN;AACJ,CAAC,EAAE,CAAC;;AAER;AACA,SAASa,YAAYA,CAACS,OAAO,EAAEC,IAAI,EAAE;EACjC,IAAIA,IAAI,CAACC,MAAM,KAAK,CAAC,EAAE,OAAOF,OAAO;EAErC,MAAMG,SAAS,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC;EAC9BJ,OAAO,CAACtB,OAAO,CAACyB,SAAS,CAAC,GAAG;IACzBzB,OAAO,EAAE,CAAC,CAAC;IACXe,UAAU,EAAE,IAAI;IAChB,GAAGO,OAAO,CAACtB,OAAO,CAACyB,SAAS;EAChC,CAAC;EACD,OAAOZ,YAAY,CAACS,OAAO,CAACtB,OAAO,CAACyB,SAAS,CAAC,EAAEF,IAAI,CAAC;AACzD;AAEA,eAAexB,SAAS,CAACC,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}