{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.every.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.find.js\";\nimport \"core-js/modules/esnext.iterator.flat-map.js\";\nimport \"core-js/modules/esnext.iterator.for-each.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nimport \"core-js/modules/esnext.iterator.reduce.js\";\nimport \"core-js/modules/esnext.iterator.some.js\";\nvar Hn = Object.defineProperty;\nvar zn = (e, t, o) => t in e ? Hn(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: o\n}) : e[t] = o;\nvar De = (e, t, o) => (zn(e, typeof t != \"symbol\" ? t + \"\" : t, o), o);\nimport { unref as v, computed as w, ref as W, shallowRef as ua, watch as ue, getCurrentScope as el, onScopeDispose as tl, shallowReadonly as Tt, effectScope as al, isRef as ol, toRef as E, readonly as Xe, customRef as Rn, getCurrentInstance as Ht, onMounted as st, nextTick as Ne, reactive as da, watchEffect as Xt, toValue as it, onActivated as xn, defineComponent as q, onBeforeUnmount as Wa, openBlock as m, createElementBlock as N, Fragment as ge, createElementVNode as ee, renderSlot as A, createBlock as x, Teleport as zt, mergeProps as Q, normalizeClass as j, normalizeStyle as ze, createTextVNode as ne, toDisplayString as Z, createCommentVNode as J, createApp as Mn, h as Le, provide as at, resolveDynamicComponent as se, withCtx as R, useAttrs as Kt, inject as Ge, createVNode as ye, Transition as Dn, normalizeProps as Se, guardReactiveProps as Ee, useSlots as Me, renderList as Te, TransitionGroup as jn, withDirectives as ht, vShow as ha, withModifiers as Bt, vModelCheckbox as qn, vModelRadio as Gn, vModelSelect as Wn, createSlots as Ua, onUnmounted as Un, withKeys as Qt } from \"vue\";\nclass dt {\n  constructor(t, o = {}) {\n    De(this, \"cancelable\", !0);\n    De(this, \"componentId\", null);\n    De(this, \"_defaultPrevented\", !1);\n    De(this, \"eventType\", \"\");\n    De(this, \"nativeEvent\", null);\n    De(this, \"_preventDefault\");\n    De(this, \"relatedTarget\", null);\n    De(this, \"target\", null);\n    if (!t) throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`);\n    Object.assign(this, dt.Defaults, o, {\n      eventType: t\n    }), this._preventDefault = function () {\n      this.cancelable && (this.defaultPrevented = !0);\n    };\n  }\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n  set defaultPrevented(t) {\n    this._defaultPrevented = t;\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  get preventDefault() {\n    return this._preventDefault;\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  set preventDefault(t) {\n    this._preventDefault = t;\n  }\n  static get Defaults() {\n    return {\n      cancelable: !0,\n      componentId: null,\n      eventType: \"\",\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null\n    };\n  }\n}\nclass Rt extends dt {\n  constructor(o, a = {}) {\n    super(o, a);\n    De(this, \"trigger\", null);\n    Object.assign(this, dt.Defaults, a, {\n      eventType: o\n    });\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null\n    };\n  }\n}\nclass ll extends dt {\n  constructor(o, a) {\n    super(o, a);\n    De(this, \"from\");\n    De(this, \"to\");\n    De(this, \"direction\");\n    Object.assign(this, dt.Defaults, a, {\n      eventType: o\n    });\n    const {\n      from: l,\n      direction: n,\n      to: i\n    } = a;\n    this.from = l, this.to = i, this.direction = n;\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults\n    };\n  }\n}\nconst nl = /_/g,\n  sl = /([a-z])([A-Z])/g,\n  Xn = /(\\s|^)(\\w)/g,\n  Kn = /(\\s|^)(\\w)/,\n  sa = /\\s+/,\n  Yn = /^#/,\n  Zn = /^#[A-Za-z]+[\\w\\-:.]*$/,\n  Jn = /-u-.+/,\n  Qn = /[-/\\\\^$*+?.()|[\\]{}]/g,\n  es = /[\\s\\uFEFF\\xA0]+/g,\n  ca = (e, t = 2) => typeof e == \"string\" ? e : e == null ? \"\" : Array.isArray(e) || Object.prototype.toString.call(e) === \"[object Object]\" && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e),\n  _a = e => e.replace(nl, \" \").replace(sl, (t, o, a) => `${o} ${a}`).replace(Kn, (t, o, a) => o + a.toUpperCase()),\n  bo = e => e.replace(nl, \" \").replace(sl, (t, o, a) => `${o} ${a}`).replace(Xn, (t, o, a) => o + a.toUpperCase()),\n  ts = e => {\n    const t = e.trim();\n    return t.charAt(0).toUpperCase() + t.slice(1);\n  },\n  as = e => e.replace(Qn, \"\\\\$&\"),\n  os = e => as(e).replace(es, \"\\\\s\"),\n  Va = e => `\\\\${e}`,\n  ls = e => {\n    const t = ca(e),\n      {\n        length: o\n      } = t,\n      a = t.charCodeAt(0);\n    return t.split(\"\").reduce((l, n, i) => {\n      const s = t.charCodeAt(i);\n      return s === 0 ? `${l}ï¿½` :\n      // ... is U+007F OR\n      s === 127 ||\n      // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      s >= 1 && s <= 31 ||\n      // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      i === 0 && s >= 48 && s <= 57 ||\n      // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      i === 1 && s >= 48 && s <= 57 && a === 45 ? l + Va(`${s.toString(16)} `) :\n      // ... is the first character AND ...\n      i === 0 &&\n      // ... is a `-` (U+002D) AND ...\n      s === 45 &&\n      // ... there is no second character ...\n      o === 1 ? l + Va(n) :\n      // ... is greater than or equal to U+0080 OR ...\n      s >= 128 ||\n      // ... is `-` (U+002D) OR ...\n      s === 45 ||\n      // ... is `_` (U+005F) OR ...\n      s === 95 ||\n      // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n      s >= 48 && s <= 57 ||\n      // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n      s >= 65 && s <= 90 ||\n      // ... is in the range [a-z] (U+0061 to U+007A) ...\n      s >= 97 && s <= 122 ? l + n : l + Va(n);\n    }, \"\");\n  },\n  il = typeof window < \"u\",\n  rl = typeof document < \"u\",\n  ns = typeof Element < \"u\",\n  ss = typeof navigator < \"u\",\n  is = il && rl && ss,\n  _t = il ? window : {},\n  Xa = rl ? document : {};\n(() => {\n  let e = !1;\n  if (!is) return e;\n  try {\n    const t = {\n      // This function will be called when the browser\n      // attempts to access the passive property\n      get passive() {\n        return e = !0, e;\n      }\n    };\n    \"addEventListener\" in _t && typeof _t.addEventListener == \"function\" && _t.addEventListener(\"test\", t, t), \"removeEventListener\" in _t && typeof _t.removeEventListener == \"function\" && _t.removeEventListener(\"test\", t, t);\n  } catch {\n    e = !1;\n  }\n})();\nconst ul = typeof window < \"u\",\n  rs = typeof document < \"u\",\n  us = typeof navigator < \"u\",\n  Ka = ul && rs && us,\n  yo = ul ? window : {},\n  ds = (() => {\n    let e = !1;\n    if (Ka) try {\n      const t = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          e = !0;\n        }\n      };\n      yo.addEventListener(\"test\", t, t), yo.removeEventListener(\"test\", t, t);\n    } catch {\n      e = !1;\n    }\n    return e;\n  })(),\n  Aa = ns ? Element.prototype : void 0,\n  ot = e => !!(e && typeof e == \"object\" && \"nodeType\" in e && e.nodeType === Node.ELEMENT_NODE),\n  cs = e => ot(e) ? e.getBoundingClientRect() : null,\n  fs = (e = []) => {\n    const {\n      activeElement: t\n    } = document;\n    return t && !e.some(o => o === t) ? t : null;\n  },\n  vs = e => ot(e) && e === fs(),\n  ps = (e, t = {}) => {\n    try {\n      e.focus(t);\n    } catch (o) {\n      console.error(o);\n    }\n    return vs(e);\n  },\n  ms = (e, t) => t && ot(e) && e.getAttribute(t) || null,\n  gs = e => {\n    if (ms(e, \"display\") === \"none\") return !1;\n    const t = cs(e);\n    return !!(t && t.height > 0 && t.width > 0);\n  },\n  Ie = e => ((e == null ? void 0 : e()) ?? []).length === 0,\n  dl = (e, t) => (ot(t) ? t : Xa).querySelector(e) || null,\n  bs = (e, t) => Array.from([(ot(t) ? t : Xa).querySelectorAll(e)]),\n  Ya = (e, t) => t && ot(e) ? e.getAttribute(t) : null,\n  ys = e => Xa.getElementById(/^#/.test(e) ? e.slice(1) : e) || null,\n  hs = (e, t, o) => {\n    t && ot(e) && e.setAttribute(t, o);\n  },\n  Bs = (e, t) => {\n    t && ot(e) && e.removeAttribute(t);\n  },\n  Ss = (e, t) => ca(e).toLowerCase() === ca(t).toLowerCase(),\n  Cs = (e, t) => ot(e) ? e.matches(t) : !1,\n  ws = (Aa == null ? void 0 : Aa.closest) || function (e) {\n    let t = this;\n    if (!t) return null;\n    do {\n      if (ot(t) && t.matches(e)) return t;\n      t = t.parentElement || t.parentNode;\n    } while (t !== null && t.nodeType === Node.ELEMENT_NODE);\n    return null;\n  },\n  ho = (e, t, o = !1) => {\n    if (!ot(t)) return null;\n    const a = ws.call(t, e);\n    return o ? a : a === t ? null : a;\n  },\n  La = e => {\n    const t = window.getComputedStyle(e),\n      o = t.transitionDelay.split(\",\")[0] || \"\",\n      a = t.transitionDuration.split(\",\")[0] || \"\",\n      l = Number(o.slice(0, -1)) * 1e3,\n      n = Number(a.slice(0, -1)) * 1e3;\n    return l + n;\n  },\n  ks = [\"TD\", \"TH\", \"TR\"],\n  $s = [\"a\", \"a *\",\n  // Include content inside links\n  \"button\", \"button *\",\n  // Include content inside buttons\n  \"input:not(.disabled):not([disabled])\", \"select:not(.disabled):not([disabled])\", \"textarea:not(.disabled):not([disabled])\", '[role=\"link\"]', '[role=\"link\"] *', '[role=\"button\"]', '[role=\"button\"] *', \"[tabindex]:not(.disabled):not([disabled])\"].join(\",\"),\n  ea = e => {\n    if (!e || !e.target) return !1;\n    const t = e.target;\n    if (\"disabled\" in t && t.disabled || ks.indexOf(t.tagName) !== -1) return !1;\n    if (ho(\".dropdown-menu\", t)) return !0;\n    const o = t.tagName === \"LABEL\" ? t : ho(\"label\", t);\n    if (o) {\n      const a = Ya(o, \"for\"),\n        l = a ? ys(a) : dl(\"input, select, textarea\", o);\n      if (l && !l.disabled) return !0;\n    }\n    return Cs(t, $s);\n  },\n  cl = [\"top\", \"right\", \"bottom\", \"left\"],\n  Bo = [\"start\", \"end\"],\n  So = /* @__PURE__ */cl.reduce((e, t) => e.concat(t, t + \"-\" + Bo[0], t + \"-\" + Bo[1]), []),\n  et = Math.min,\n  Fe = Math.max,\n  fa = Math.round,\n  ta = Math.floor,\n  mt = e => ({\n    x: e,\n    y: e\n  }),\n  Ts = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n  },\n  _s = {\n    start: \"end\",\n    end: \"start\"\n  };\nfunction Fa(e, t, o) {\n  return Fe(e, et(t, o));\n}\nfunction ft(e, t) {\n  return typeof e == \"function\" ? e(t) : e;\n}\nfunction Ye(e) {\n  return e.split(\"-\")[0];\n}\nfunction Je(e) {\n  return e.split(\"-\")[1];\n}\nfunction fl(e) {\n  return e === \"x\" ? \"y\" : \"x\";\n}\nfunction Za(e) {\n  return e === \"y\" ? \"height\" : \"width\";\n}\nfunction xt(e) {\n  return [\"top\", \"bottom\"].includes(Ye(e)) ? \"y\" : \"x\";\n}\nfunction Ja(e) {\n  return fl(xt(e));\n}\nfunction vl(e, t, o) {\n  o === void 0 && (o = !1);\n  const a = Je(e),\n    l = Ja(e),\n    n = Za(l);\n  let i = l === \"x\" ? a === (o ? \"end\" : \"start\") ? \"right\" : \"left\" : a === \"start\" ? \"bottom\" : \"top\";\n  return t.reference[n] > t.floating[n] && (i = pa(i)), [i, pa(i)];\n}\nfunction Vs(e) {\n  const t = pa(e);\n  return [va(e), t, va(t)];\n}\nfunction va(e) {\n  return e.replace(/start|end/g, t => _s[t]);\n}\nfunction As(e, t, o) {\n  const a = [\"left\", \"right\"],\n    l = [\"right\", \"left\"],\n    n = [\"top\", \"bottom\"],\n    i = [\"bottom\", \"top\"];\n  switch (e) {\n    case \"top\":\n    case \"bottom\":\n      return o ? t ? l : a : t ? a : l;\n    case \"left\":\n    case \"right\":\n      return t ? n : i;\n    default:\n      return [];\n  }\n}\nfunction Os(e, t, o, a) {\n  const l = Je(e);\n  let n = As(Ye(e), o === \"start\", a);\n  return l && (n = n.map(i => i + \"-\" + l), t && (n = n.concat(n.map(va)))), n;\n}\nfunction pa(e) {\n  return e.replace(/left|right|bottom|top/g, t => Ts[t]);\n}\nfunction Es(e) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...e\n  };\n}\nfunction Qa(e) {\n  return typeof e != \"number\" ? Es(e) : {\n    top: e,\n    right: e,\n    bottom: e,\n    left: e\n  };\n}\nfunction It(e) {\n  return {\n    ...e,\n    top: e.y,\n    left: e.x,\n    right: e.x + e.width,\n    bottom: e.y + e.height\n  };\n}\nfunction Co(e, t, o) {\n  let {\n    reference: a,\n    floating: l\n  } = e;\n  const n = xt(t),\n    i = Ja(t),\n    s = Za(i),\n    u = Ye(t),\n    d = n === \"y\",\n    f = a.x + a.width / 2 - l.width / 2,\n    g = a.y + a.height / 2 - l.height / 2,\n    p = a[s] / 2 - l[s] / 2;\n  let y;\n  switch (u) {\n    case \"top\":\n      y = {\n        x: f,\n        y: a.y - l.height\n      };\n      break;\n    case \"bottom\":\n      y = {\n        x: f,\n        y: a.y + a.height\n      };\n      break;\n    case \"right\":\n      y = {\n        x: a.x + a.width,\n        y: g\n      };\n      break;\n    case \"left\":\n      y = {\n        x: a.x - l.width,\n        y: g\n      };\n      break;\n    default:\n      y = {\n        x: a.x,\n        y: a.y\n      };\n  }\n  switch (Je(t)) {\n    case \"start\":\n      y[i] -= p * (o && d ? -1 : 1);\n      break;\n    case \"end\":\n      y[i] += p * (o && d ? -1 : 1);\n      break;\n  }\n  return y;\n}\nconst Ps = async (e, t, o) => {\n  const {\n      placement: a = \"bottom\",\n      strategy: l = \"absolute\",\n      middleware: n = [],\n      platform: i\n    } = o,\n    s = n.filter(Boolean),\n    u = await (i.isRTL == null ? void 0 : i.isRTL(t));\n  let d = await i.getElementRects({\n      reference: e,\n      floating: t,\n      strategy: l\n    }),\n    {\n      x: f,\n      y: g\n    } = Co(d, a, u),\n    p = a,\n    y = {},\n    b = 0;\n  for (let V = 0; V < s.length; V++) {\n    const {\n        name: C,\n        fn: c\n      } = s[V],\n      {\n        x: h,\n        y: B,\n        data: _,\n        reset: k\n      } = await c({\n        x: f,\n        y: g,\n        initialPlacement: a,\n        placement: p,\n        strategy: l,\n        middlewareData: y,\n        rects: d,\n        platform: i,\n        elements: {\n          reference: e,\n          floating: t\n        }\n      });\n    if (f = h ?? f, g = B ?? g, y = {\n      ...y,\n      [C]: {\n        ...y[C],\n        ..._\n      }\n    }, k && b <= 50) {\n      b++, typeof k == \"object\" && (k.placement && (p = k.placement), k.rects && (d = k.rects === !0 ? await i.getElementRects({\n        reference: e,\n        floating: t,\n        strategy: l\n      }) : k.rects), {\n        x: f,\n        y: g\n      } = Co(d, p, u)), V = -1;\n      continue;\n    }\n  }\n  return {\n    x: f,\n    y: g,\n    placement: p,\n    strategy: l,\n    middlewareData: y\n  };\n};\nasync function Lt(e, t) {\n  var o;\n  t === void 0 && (t = {});\n  const {\n      x: a,\n      y: l,\n      platform: n,\n      rects: i,\n      elements: s,\n      strategy: u\n    } = e,\n    {\n      boundary: d = \"clippingAncestors\",\n      rootBoundary: f = \"viewport\",\n      elementContext: g = \"floating\",\n      altBoundary: p = !1,\n      padding: y = 0\n    } = ft(t, e),\n    b = Qa(y),\n    C = s[p ? g === \"floating\" ? \"reference\" : \"floating\" : g],\n    c = It(await n.getClippingRect({\n      element: (o = await (n.isElement == null ? void 0 : n.isElement(C))) == null || o ? C : C.contextElement || (await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(s.floating))),\n      boundary: d,\n      rootBoundary: f,\n      strategy: u\n    })),\n    h = g === \"floating\" ? {\n      ...i.floating,\n      x: a,\n      y: l\n    } : i.reference,\n    B = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(s.floating)),\n    _ = (await (n.isElement == null ? void 0 : n.isElement(B))) ? (await (n.getScale == null ? void 0 : n.getScale(B))) || {\n      x: 1,\n      y: 1\n    } : {\n      x: 1,\n      y: 1\n    },\n    k = It(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({\n      rect: h,\n      offsetParent: B,\n      strategy: u\n    }) : h);\n  return {\n    top: (c.top - k.top + b.top) / _.y,\n    bottom: (k.bottom - c.bottom + b.bottom) / _.y,\n    left: (c.left - k.left + b.left) / _.x,\n    right: (k.right - c.right + b.right) / _.x\n  };\n}\nconst Ns = e => ({\n  name: \"arrow\",\n  options: e,\n  async fn(t) {\n    const {\n        x: o,\n        y: a,\n        placement: l,\n        rects: n,\n        platform: i,\n        elements: s,\n        middlewareData: u\n      } = t,\n      {\n        element: d,\n        padding: f = 0\n      } = ft(e, t) || {};\n    if (d == null) return {};\n    const g = Qa(f),\n      p = {\n        x: o,\n        y: a\n      },\n      y = Ja(l),\n      b = Za(y),\n      V = await i.getDimensions(d),\n      C = y === \"y\",\n      c = C ? \"top\" : \"left\",\n      h = C ? \"bottom\" : \"right\",\n      B = C ? \"clientHeight\" : \"clientWidth\",\n      _ = n.reference[b] + n.reference[y] - p[y] - n.floating[b],\n      k = p[y] - n.reference[y],\n      S = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(d));\n    let $ = S ? S[B] : 0;\n    (!$ || !(await (i.isElement == null ? void 0 : i.isElement(S)))) && ($ = s.floating[B] || n.floating[b]);\n    const I = _ / 2 - k / 2,\n      T = $ / 2 - V[b] / 2 - 1,\n      O = et(g[c], T),\n      F = et(g[h], T),\n      K = O,\n      z = $ - V[b] - F,\n      P = $ / 2 - V[b] / 2 + I,\n      D = Fa(K, P, z),\n      ae = !u.arrow && Je(l) != null && P != D && n.reference[b] / 2 - (P < K ? O : F) - V[b] / 2 < 0,\n      le = ae ? P < K ? P - K : P - z : 0;\n    return {\n      [y]: p[y] + le,\n      data: {\n        [y]: D,\n        centerOffset: P - D - le,\n        ...(ae && {\n          alignmentOffset: le\n        })\n      },\n      reset: ae\n    };\n  }\n});\nfunction Is(e, t, o) {\n  return (e ? [...o.filter(l => Je(l) === e), ...o.filter(l => Je(l) !== e)] : o.filter(l => Ye(l) === l)).filter(l => e ? Je(l) === e || (t ? va(l) !== l : !1) : !0);\n}\nconst Ls = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"autoPlacement\",\n      options: e,\n      async fn(t) {\n        var o, a, l;\n        const {\n            rects: n,\n            middlewareData: i,\n            placement: s,\n            platform: u,\n            elements: d\n          } = t,\n          {\n            crossAxis: f = !1,\n            alignment: g,\n            allowedPlacements: p = So,\n            autoAlignment: y = !0,\n            ...b\n          } = ft(e, t),\n          V = g !== void 0 || p === So ? Is(g || null, y, p) : p,\n          C = await Lt(t, b),\n          c = ((o = i.autoPlacement) == null ? void 0 : o.index) || 0,\n          h = V[c];\n        if (h == null) return {};\n        const B = vl(h, n, await (u.isRTL == null ? void 0 : u.isRTL(d.floating)));\n        if (s !== h) return {\n          reset: {\n            placement: V[0]\n          }\n        };\n        const _ = [C[Ye(h)], C[B[0]], C[B[1]]],\n          k = [...(((a = i.autoPlacement) == null ? void 0 : a.overflows) || []), {\n            placement: h,\n            overflows: _\n          }],\n          S = V[c + 1];\n        if (S) return {\n          data: {\n            index: c + 1,\n            overflows: k\n          },\n          reset: {\n            placement: S\n          }\n        };\n        const $ = k.map(O => {\n            const F = Je(O.placement);\n            return [O.placement, F && f ?\n            // Check along the mainAxis and main crossAxis side.\n            O.overflows.slice(0, 2).reduce((K, z) => K + z, 0) :\n            // Check only the mainAxis.\n            O.overflows[0], O.overflows];\n          }).sort((O, F) => O[1] - F[1]),\n          T = ((l = $.filter(O => O[2].slice(0,\n          // Aligned placements should not check their opposite crossAxis\n          // side.\n          Je(O[0]) ? 2 : 3).every(F => F <= 0))[0]) == null ? void 0 : l[0]) || $[0][0];\n        return T !== s ? {\n          data: {\n            index: c + 1,\n            overflows: k\n          },\n          reset: {\n            placement: T\n          }\n        } : {};\n      }\n    };\n  },\n  pl = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"flip\",\n      options: e,\n      async fn(t) {\n        var o, a;\n        const {\n            placement: l,\n            middlewareData: n,\n            rects: i,\n            initialPlacement: s,\n            platform: u,\n            elements: d\n          } = t,\n          {\n            mainAxis: f = !0,\n            crossAxis: g = !0,\n            fallbackPlacements: p,\n            fallbackStrategy: y = \"bestFit\",\n            fallbackAxisSideDirection: b = \"none\",\n            flipAlignment: V = !0,\n            ...C\n          } = ft(e, t);\n        if ((o = n.arrow) != null && o.alignmentOffset) return {};\n        const c = Ye(l),\n          h = Ye(s) === s,\n          B = await (u.isRTL == null ? void 0 : u.isRTL(d.floating)),\n          _ = p || (h || !V ? [pa(s)] : Vs(s));\n        !p && b !== \"none\" && _.push(...Os(s, V, b, B));\n        const k = [s, ..._],\n          S = await Lt(t, C),\n          $ = [];\n        let I = ((a = n.flip) == null ? void 0 : a.overflows) || [];\n        if (f && $.push(S[c]), g) {\n          const K = vl(l, i, B);\n          $.push(S[K[0]], S[K[1]]);\n        }\n        if (I = [...I, {\n          placement: l,\n          overflows: $\n        }], !$.every(K => K <= 0)) {\n          var T, O;\n          const K = (((T = n.flip) == null ? void 0 : T.index) || 0) + 1,\n            z = k[K];\n          if (z) return {\n            data: {\n              index: K,\n              overflows: I\n            },\n            reset: {\n              placement: z\n            }\n          };\n          let P = (O = I.filter(D => D.overflows[0] <= 0).sort((D, ae) => D.overflows[1] - ae.overflows[1])[0]) == null ? void 0 : O.placement;\n          if (!P) switch (y) {\n            case \"bestFit\":\n              {\n                var F;\n                const D = (F = I.map(ae => [ae.placement, ae.overflows.filter(le => le > 0).reduce((le, ve) => le + ve, 0)]).sort((ae, le) => ae[1] - le[1])[0]) == null ? void 0 : F[0];\n                D && (P = D);\n                break;\n              }\n            case \"initialPlacement\":\n              P = s;\n              break;\n          }\n          if (l !== P) return {\n            reset: {\n              placement: P\n            }\n          };\n        }\n        return {};\n      }\n    };\n  };\nfunction wo(e, t) {\n  return {\n    top: e.top - t.height,\n    right: e.right - t.width,\n    bottom: e.bottom - t.height,\n    left: e.left - t.width\n  };\n}\nfunction ko(e) {\n  return cl.some(t => e[t] >= 0);\n}\nconst Fs = function (e) {\n  return e === void 0 && (e = {}), {\n    name: \"hide\",\n    options: e,\n    async fn(t) {\n      const {\n          rects: o\n        } = t,\n        {\n          strategy: a = \"referenceHidden\",\n          ...l\n        } = ft(e, t);\n      switch (a) {\n        case \"referenceHidden\":\n          {\n            const n = await Lt(t, {\n                ...l,\n                elementContext: \"reference\"\n              }),\n              i = wo(n, o.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: i,\n                referenceHidden: ko(i)\n              }\n            };\n          }\n        case \"escaped\":\n          {\n            const n = await Lt(t, {\n                ...l,\n                altBoundary: !0\n              }),\n              i = wo(n, o.floating);\n            return {\n              data: {\n                escapedOffsets: i,\n                escaped: ko(i)\n              }\n            };\n          }\n        default:\n          return {};\n      }\n    }\n  };\n};\nfunction ml(e) {\n  const t = et(...e.map(n => n.left)),\n    o = et(...e.map(n => n.top)),\n    a = Fe(...e.map(n => n.right)),\n    l = Fe(...e.map(n => n.bottom));\n  return {\n    x: t,\n    y: o,\n    width: a - t,\n    height: l - o\n  };\n}\nfunction Hs(e) {\n  const t = e.slice().sort((l, n) => l.y - n.y),\n    o = [];\n  let a = null;\n  for (let l = 0; l < t.length; l++) {\n    const n = t[l];\n    !a || n.y - a.y > a.height / 2 ? o.push([n]) : o[o.length - 1].push(n), a = n;\n  }\n  return o.map(l => It(ml(l)));\n}\nconst zs = function (e) {\n  return e === void 0 && (e = {}), {\n    name: \"inline\",\n    options: e,\n    async fn(t) {\n      const {\n          placement: o,\n          elements: a,\n          rects: l,\n          platform: n,\n          strategy: i\n        } = t,\n        {\n          padding: s = 2,\n          x: u,\n          y: d\n        } = ft(e, t),\n        f = Array.from((await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference))) || []),\n        g = Hs(f),\n        p = It(ml(f)),\n        y = Qa(s);\n      function b() {\n        if (g.length === 2 && g[0].left > g[1].right && u != null && d != null) return g.find(C => u > C.left - y.left && u < C.right + y.right && d > C.top - y.top && d < C.bottom + y.bottom) || p;\n        if (g.length >= 2) {\n          if (xt(o) === \"y\") {\n            const O = g[0],\n              F = g[g.length - 1],\n              K = Ye(o) === \"top\",\n              z = O.top,\n              P = F.bottom,\n              D = K ? O.left : F.left,\n              ae = K ? O.right : F.right,\n              le = ae - D,\n              ve = P - z;\n            return {\n              top: z,\n              bottom: P,\n              left: D,\n              right: ae,\n              width: le,\n              height: ve,\n              x: D,\n              y: z\n            };\n          }\n          const C = Ye(o) === \"left\",\n            c = Fe(...g.map(O => O.right)),\n            h = et(...g.map(O => O.left)),\n            B = g.filter(O => C ? O.left === h : O.right === c),\n            _ = B[0].top,\n            k = B[B.length - 1].bottom,\n            S = h,\n            $ = c,\n            I = $ - S,\n            T = k - _;\n          return {\n            top: _,\n            bottom: k,\n            left: S,\n            right: $,\n            width: I,\n            height: T,\n            x: S,\n            y: _\n          };\n        }\n        return p;\n      }\n      const V = await n.getElementRects({\n        reference: {\n          getBoundingClientRect: b\n        },\n        floating: a.floating,\n        strategy: i\n      });\n      return l.reference.x !== V.reference.x || l.reference.y !== V.reference.y || l.reference.width !== V.reference.width || l.reference.height !== V.reference.height ? {\n        reset: {\n          rects: V\n        }\n      } : {};\n    }\n  };\n};\nasync function Rs(e, t) {\n  const {\n      placement: o,\n      platform: a,\n      elements: l\n    } = e,\n    n = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)),\n    i = Ye(o),\n    s = Je(o),\n    u = xt(o) === \"y\",\n    d = [\"left\", \"top\"].includes(i) ? -1 : 1,\n    f = n && u ? -1 : 1,\n    g = ft(t, e);\n  let {\n    mainAxis: p,\n    crossAxis: y,\n    alignmentAxis: b\n  } = typeof g == \"number\" ? {\n    mainAxis: g,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...g\n  };\n  return s && typeof b == \"number\" && (y = s === \"end\" ? b * -1 : b), u ? {\n    x: y * f,\n    y: p * d\n  } : {\n    x: p * d,\n    y: y * f\n  };\n}\nconst gl = function (e) {\n    return e === void 0 && (e = 0), {\n      name: \"offset\",\n      options: e,\n      async fn(t) {\n        const {\n            x: o,\n            y: a\n          } = t,\n          l = await Rs(t, e);\n        return {\n          x: o + l.x,\n          y: a + l.y,\n          data: l\n        };\n      }\n    };\n  },\n  bl = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"shift\",\n      options: e,\n      async fn(t) {\n        const {\n            x: o,\n            y: a,\n            placement: l\n          } = t,\n          {\n            mainAxis: n = !0,\n            crossAxis: i = !1,\n            limiter: s = {\n              fn: C => {\n                let {\n                  x: c,\n                  y: h\n                } = C;\n                return {\n                  x: c,\n                  y: h\n                };\n              }\n            },\n            ...u\n          } = ft(e, t),\n          d = {\n            x: o,\n            y: a\n          },\n          f = await Lt(t, u),\n          g = xt(Ye(l)),\n          p = fl(g);\n        let y = d[p],\n          b = d[g];\n        if (n) {\n          const C = p === \"y\" ? \"top\" : \"left\",\n            c = p === \"y\" ? \"bottom\" : \"right\",\n            h = y + f[C],\n            B = y - f[c];\n          y = Fa(h, y, B);\n        }\n        if (i) {\n          const C = g === \"y\" ? \"top\" : \"left\",\n            c = g === \"y\" ? \"bottom\" : \"right\",\n            h = b + f[C],\n            B = b - f[c];\n          b = Fa(h, b, B);\n        }\n        const V = s.fn({\n          ...t,\n          [p]: y,\n          [g]: b\n        });\n        return {\n          ...V,\n          data: {\n            x: V.x - o,\n            y: V.y - a\n          }\n        };\n      }\n    };\n  },\n  yl = function (e) {\n    return e === void 0 && (e = {}), {\n      name: \"size\",\n      options: e,\n      async fn(t) {\n        const {\n            placement: o,\n            rects: a,\n            platform: l,\n            elements: n\n          } = t,\n          {\n            apply: i = () => {},\n            ...s\n          } = ft(e, t),\n          u = await Lt(t, s),\n          d = Ye(o),\n          f = Je(o),\n          g = xt(o) === \"y\",\n          {\n            width: p,\n            height: y\n          } = a.floating;\n        let b, V;\n        d === \"top\" || d === \"bottom\" ? (b = d, V = f === ((await (l.isRTL == null ? void 0 : l.isRTL(n.floating))) ? \"start\" : \"end\") ? \"left\" : \"right\") : (V = d, b = f === \"end\" ? \"top\" : \"bottom\");\n        const C = y - u[b],\n          c = p - u[V],\n          h = !t.middlewareData.shift;\n        let B = C,\n          _ = c;\n        if (g) {\n          const S = p - u.left - u.right;\n          _ = f || h ? et(c, S) : S;\n        } else {\n          const S = y - u.top - u.bottom;\n          B = f || h ? et(C, S) : S;\n        }\n        if (h && !f) {\n          const S = Fe(u.left, 0),\n            $ = Fe(u.right, 0),\n            I = Fe(u.top, 0),\n            T = Fe(u.bottom, 0);\n          g ? _ = p - 2 * (S !== 0 || $ !== 0 ? S + $ : Fe(u.left, u.right)) : B = y - 2 * (I !== 0 || T !== 0 ? I + T : Fe(u.top, u.bottom));\n        }\n        await i({\n          ...t,\n          availableWidth: _,\n          availableHeight: B\n        });\n        const k = await l.getDimensions(n.floating);\n        return p !== k.width || y !== k.height ? {\n          reset: {\n            rects: !0\n          }\n        } : {};\n      }\n    };\n  };\nfunction gt(e) {\n  return hl(e) ? (e.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction We(e) {\n  var t;\n  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;\n}\nfunction vt(e) {\n  var t;\n  return (t = (hl(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;\n}\nfunction hl(e) {\n  return e instanceof Node || e instanceof We(e).Node;\n}\nfunction ct(e) {\n  return e instanceof Element || e instanceof We(e).Element;\n}\nfunction nt(e) {\n  return e instanceof HTMLElement || e instanceof We(e).HTMLElement;\n}\nfunction $o(e) {\n  return typeof ShadowRoot > \"u\" ? !1 : e instanceof ShadowRoot || e instanceof We(e).ShadowRoot;\n}\nfunction Yt(e) {\n  const {\n    overflow: t,\n    overflowX: o,\n    overflowY: a,\n    display: l\n  } = Ze(e);\n  return /auto|scroll|overlay|hidden|clip/.test(t + a + o) && ![\"inline\", \"contents\"].includes(l);\n}\nfunction xs(e) {\n  return [\"table\", \"td\", \"th\"].includes(gt(e));\n}\nfunction eo(e) {\n  const t = to(),\n    o = Ze(e);\n  return o.transform !== \"none\" || o.perspective !== \"none\" || (o.containerType ? o.containerType !== \"normal\" : !1) || !t && (o.backdropFilter ? o.backdropFilter !== \"none\" : !1) || !t && (o.filter ? o.filter !== \"none\" : !1) || [\"transform\", \"perspective\", \"filter\"].some(a => (o.willChange || \"\").includes(a)) || [\"paint\", \"layout\", \"strict\", \"content\"].some(a => (o.contain || \"\").includes(a));\n}\nfunction Ms(e) {\n  let t = Ft(e);\n  for (; nt(t) && !Ba(t);) {\n    if (eo(t)) return t;\n    t = Ft(t);\n  }\n  return null;\n}\nfunction to() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction Ba(e) {\n  return [\"html\", \"body\", \"#document\"].includes(gt(e));\n}\nfunction Ze(e) {\n  return We(e).getComputedStyle(e);\n}\nfunction Sa(e) {\n  return ct(e) ? {\n    scrollLeft: e.scrollLeft,\n    scrollTop: e.scrollTop\n  } : {\n    scrollLeft: e.pageXOffset,\n    scrollTop: e.pageYOffset\n  };\n}\nfunction Ft(e) {\n  if (gt(e) === \"html\") return e;\n  const t =\n  // Step into the shadow DOM of the parent of a slotted node.\n  e.assignedSlot ||\n  // DOM Element detected.\n  e.parentNode ||\n  // ShadowRoot detected.\n  $o(e) && e.host ||\n  // Fallback.\n  vt(e);\n  return $o(t) ? t.host : t;\n}\nfunction Bl(e) {\n  const t = Ft(e);\n  return Ba(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : nt(t) && Yt(t) ? t : Bl(t);\n}\nfunction Wt(e, t, o) {\n  var a;\n  t === void 0 && (t = []), o === void 0 && (o = !0);\n  const l = Bl(e),\n    n = l === ((a = e.ownerDocument) == null ? void 0 : a.body),\n    i = We(l);\n  return n ? t.concat(i, i.visualViewport || [], Yt(l) ? l : [], i.frameElement && o ? Wt(i.frameElement) : []) : t.concat(l, Wt(l, [], o));\n}\nfunction Sl(e) {\n  const t = Ze(e);\n  let o = parseFloat(t.width) || 0,\n    a = parseFloat(t.height) || 0;\n  const l = nt(e),\n    n = l ? e.offsetWidth : o,\n    i = l ? e.offsetHeight : a,\n    s = fa(o) !== n || fa(a) !== i;\n  return s && (o = n, a = i), {\n    width: o,\n    height: a,\n    $: s\n  };\n}\nfunction ao(e) {\n  return ct(e) ? e : e.contextElement;\n}\nfunction Pt(e) {\n  const t = ao(e);\n  if (!nt(t)) return mt(1);\n  const o = t.getBoundingClientRect(),\n    {\n      width: a,\n      height: l,\n      $: n\n    } = Sl(t);\n  let i = (n ? fa(o.width) : o.width) / a,\n    s = (n ? fa(o.height) : o.height) / l;\n  return (!i || !Number.isFinite(i)) && (i = 1), (!s || !Number.isFinite(s)) && (s = 1), {\n    x: i,\n    y: s\n  };\n}\nconst Ds = /* @__PURE__ */mt(0);\nfunction Cl(e) {\n  const t = We(e);\n  return !to() || !t.visualViewport ? Ds : {\n    x: t.visualViewport.offsetLeft,\n    y: t.visualViewport.offsetTop\n  };\n}\nfunction js(e, t, o) {\n  return t === void 0 && (t = !1), !o || t && o !== We(e) ? !1 : t;\n}\nfunction St(e, t, o, a) {\n  t === void 0 && (t = !1), o === void 0 && (o = !1);\n  const l = e.getBoundingClientRect(),\n    n = ao(e);\n  let i = mt(1);\n  t && (a ? ct(a) && (i = Pt(a)) : i = Pt(e));\n  const s = js(n, o, a) ? Cl(n) : mt(0);\n  let u = (l.left + s.x) / i.x,\n    d = (l.top + s.y) / i.y,\n    f = l.width / i.x,\n    g = l.height / i.y;\n  if (n) {\n    const p = We(n),\n      y = a && ct(a) ? We(a) : a;\n    let b = p.frameElement;\n    for (; b && a && y !== p;) {\n      const V = Pt(b),\n        C = b.getBoundingClientRect(),\n        c = Ze(b),\n        h = C.left + (b.clientLeft + parseFloat(c.paddingLeft)) * V.x,\n        B = C.top + (b.clientTop + parseFloat(c.paddingTop)) * V.y;\n      u *= V.x, d *= V.y, f *= V.x, g *= V.y, u += h, d += B, b = We(b).frameElement;\n    }\n  }\n  return It({\n    width: f,\n    height: g,\n    x: u,\n    y: d\n  });\n}\nfunction qs(e) {\n  let {\n    rect: t,\n    offsetParent: o,\n    strategy: a\n  } = e;\n  const l = nt(o),\n    n = vt(o);\n  if (o === n) return t;\n  let i = {\n      scrollLeft: 0,\n      scrollTop: 0\n    },\n    s = mt(1);\n  const u = mt(0);\n  if ((l || !l && a !== \"fixed\") && ((gt(o) !== \"body\" || Yt(n)) && (i = Sa(o)), nt(o))) {\n    const d = St(o);\n    s = Pt(o), u.x = d.x + o.clientLeft, u.y = d.y + o.clientTop;\n  }\n  return {\n    width: t.width * s.x,\n    height: t.height * s.y,\n    x: t.x * s.x - i.scrollLeft * s.x + u.x,\n    y: t.y * s.y - i.scrollTop * s.y + u.y\n  };\n}\nfunction Gs(e) {\n  return Array.from(e.getClientRects());\n}\nfunction wl(e) {\n  return St(vt(e)).left + Sa(e).scrollLeft;\n}\nfunction Ws(e) {\n  const t = vt(e),\n    o = Sa(e),\n    a = e.ownerDocument.body,\n    l = Fe(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth),\n    n = Fe(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);\n  let i = -o.scrollLeft + wl(e);\n  const s = -o.scrollTop;\n  return Ze(a).direction === \"rtl\" && (i += Fe(t.clientWidth, a.clientWidth) - l), {\n    width: l,\n    height: n,\n    x: i,\n    y: s\n  };\n}\nfunction Us(e, t) {\n  const o = We(e),\n    a = vt(e),\n    l = o.visualViewport;\n  let n = a.clientWidth,\n    i = a.clientHeight,\n    s = 0,\n    u = 0;\n  if (l) {\n    n = l.width, i = l.height;\n    const d = to();\n    (!d || d && t === \"fixed\") && (s = l.offsetLeft, u = l.offsetTop);\n  }\n  return {\n    width: n,\n    height: i,\n    x: s,\n    y: u\n  };\n}\nfunction Xs(e, t) {\n  const o = St(e, !0, t === \"fixed\"),\n    a = o.top + e.clientTop,\n    l = o.left + e.clientLeft,\n    n = nt(e) ? Pt(e) : mt(1),\n    i = e.clientWidth * n.x,\n    s = e.clientHeight * n.y,\n    u = l * n.x,\n    d = a * n.y;\n  return {\n    width: i,\n    height: s,\n    x: u,\n    y: d\n  };\n}\nfunction To(e, t, o) {\n  let a;\n  if (t === \"viewport\") a = Us(e, o);else if (t === \"document\") a = Ws(vt(e));else if (ct(t)) a = Xs(t, o);else {\n    const l = Cl(e);\n    a = {\n      ...t,\n      x: t.x - l.x,\n      y: t.y - l.y\n    };\n  }\n  return It(a);\n}\nfunction kl(e, t) {\n  const o = Ft(e);\n  return o === t || !ct(o) || Ba(o) ? !1 : Ze(o).position === \"fixed\" || kl(o, t);\n}\nfunction Ks(e, t) {\n  const o = t.get(e);\n  if (o) return o;\n  let a = Wt(e, [], !1).filter(s => ct(s) && gt(s) !== \"body\"),\n    l = null;\n  const n = Ze(e).position === \"fixed\";\n  let i = n ? Ft(e) : e;\n  for (; ct(i) && !Ba(i);) {\n    const s = Ze(i),\n      u = eo(i);\n    !u && s.position === \"fixed\" && (l = null), (n ? !u && !l : !u && s.position === \"static\" && !!l && [\"absolute\", \"fixed\"].includes(l.position) || Yt(i) && !u && kl(e, i)) ? a = a.filter(f => f !== i) : l = s, i = Ft(i);\n  }\n  return t.set(e, a), a;\n}\nfunction Ys(e) {\n  let {\n    element: t,\n    boundary: o,\n    rootBoundary: a,\n    strategy: l\n  } = e;\n  const i = [...(o === \"clippingAncestors\" ? Ks(t, this._c) : [].concat(o)), a],\n    s = i[0],\n    u = i.reduce((d, f) => {\n      const g = To(t, f, l);\n      return d.top = Fe(g.top, d.top), d.right = et(g.right, d.right), d.bottom = et(g.bottom, d.bottom), d.left = Fe(g.left, d.left), d;\n    }, To(t, s, l));\n  return {\n    width: u.right - u.left,\n    height: u.bottom - u.top,\n    x: u.left,\n    y: u.top\n  };\n}\nfunction Zs(e) {\n  return Sl(e);\n}\nfunction Js(e, t, o) {\n  const a = nt(t),\n    l = vt(t),\n    n = o === \"fixed\",\n    i = St(e, !0, n, t);\n  let s = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const u = mt(0);\n  if (a || !a && !n) if ((gt(t) !== \"body\" || Yt(l)) && (s = Sa(t)), a) {\n    const d = St(t, !0, n, t);\n    u.x = d.x + t.clientLeft, u.y = d.y + t.clientTop;\n  } else l && (u.x = wl(l));\n  return {\n    x: i.left + s.scrollLeft - u.x,\n    y: i.top + s.scrollTop - u.y,\n    width: i.width,\n    height: i.height\n  };\n}\nfunction _o(e, t) {\n  return !nt(e) || Ze(e).position === \"fixed\" ? null : t ? t(e) : e.offsetParent;\n}\nfunction $l(e, t) {\n  const o = We(e);\n  if (!nt(e)) return o;\n  let a = _o(e, t);\n  for (; a && xs(a) && Ze(a).position === \"static\";) a = _o(a, t);\n  return a && (gt(a) === \"html\" || gt(a) === \"body\" && Ze(a).position === \"static\" && !eo(a)) ? o : a || Ms(e) || o;\n}\nconst Qs = async function (e) {\n  let {\n    reference: t,\n    floating: o,\n    strategy: a\n  } = e;\n  const l = this.getOffsetParent || $l,\n    n = this.getDimensions;\n  return {\n    reference: Js(t, await l(o), a),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await n(o))\n    }\n  };\n};\nfunction ei(e) {\n  return Ze(e).direction === \"rtl\";\n}\nconst ti = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: qs,\n  getDocumentElement: vt,\n  getClippingRect: Ys,\n  getOffsetParent: $l,\n  getElementRects: Qs,\n  getClientRects: Gs,\n  getDimensions: Zs,\n  getScale: Pt,\n  isElement: ct,\n  isRTL: ei\n};\nfunction ai(e, t) {\n  let o = null,\n    a;\n  const l = vt(e);\n  function n() {\n    clearTimeout(a), o && o.disconnect(), o = null;\n  }\n  function i(s, u) {\n    s === void 0 && (s = !1), u === void 0 && (u = 1), n();\n    const {\n      left: d,\n      top: f,\n      width: g,\n      height: p\n    } = e.getBoundingClientRect();\n    if (s || t(), !g || !p) return;\n    const y = ta(f),\n      b = ta(l.clientWidth - (d + g)),\n      V = ta(l.clientHeight - (f + p)),\n      C = ta(d),\n      h = {\n        rootMargin: -y + \"px \" + -b + \"px \" + -V + \"px \" + -C + \"px\",\n        threshold: Fe(0, et(1, u)) || 1\n      };\n    let B = !0;\n    function _(k) {\n      const S = k[0].intersectionRatio;\n      if (S !== u) {\n        if (!B) return i();\n        S ? i(!1, S) : a = setTimeout(() => {\n          i(!1, 1e-7);\n        }, 100);\n      }\n      B = !1;\n    }\n    try {\n      o = new IntersectionObserver(_, {\n        ...h,\n        // Handle <iframe>s\n        root: l.ownerDocument\n      });\n    } catch {\n      o = new IntersectionObserver(_, h);\n    }\n    o.observe(e);\n  }\n  return i(!0), n;\n}\nfunction Tl(e, t, o, a) {\n  a === void 0 && (a = {});\n  const {\n      ancestorScroll: l = !0,\n      ancestorResize: n = !0,\n      elementResize: i = typeof ResizeObserver == \"function\",\n      layoutShift: s = typeof IntersectionObserver == \"function\",\n      animationFrame: u = !1\n    } = a,\n    d = ao(e),\n    f = l || n ? [...(d ? Wt(d) : []), ...Wt(t)] : [];\n  f.forEach(c => {\n    l && c.addEventListener(\"scroll\", o, {\n      passive: !0\n    }), n && c.addEventListener(\"resize\", o);\n  });\n  const g = d && s ? ai(d, o) : null;\n  let p = -1,\n    y = null;\n  i && (y = new ResizeObserver(c => {\n    let [h] = c;\n    h && h.target === d && y && (y.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {\n      y && y.observe(t);\n    })), o();\n  }), d && !u && y.observe(d), y.observe(t));\n  let b,\n    V = u ? St(e) : null;\n  u && C();\n  function C() {\n    const c = St(e);\n    V && (c.x !== V.x || c.y !== V.y || c.width !== V.width || c.height !== V.height) && o(), V = c, b = requestAnimationFrame(C);\n  }\n  return o(), () => {\n    f.forEach(c => {\n      l && c.removeEventListener(\"scroll\", o), n && c.removeEventListener(\"resize\", o);\n    }), g && g(), y && y.disconnect(), y = null, u && cancelAnimationFrame(b);\n  };\n}\nconst oi = (e, t, o) => {\n  const a = /* @__PURE__ */new Map(),\n    l = {\n      platform: ti,\n      ...o\n    },\n    n = {\n      ...l.platform,\n      _c: a\n    };\n  return Ps(e, t, {\n    ...l,\n    platform: n\n  });\n};\nfunction Ha(e) {\n  var t;\n  return (t = e == null ? void 0 : e.$el) != null ? t : e;\n}\nfunction li(e) {\n  return {\n    name: \"arrow\",\n    options: e,\n    fn(t) {\n      const o = Ha(v(e.element));\n      return o == null ? {} : Ns({\n        element: o,\n        padding: e.padding\n      }).fn(t);\n    }\n  };\n}\nfunction _l(e) {\n  return typeof window > \"u\" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction Vo(e, t) {\n  const o = _l(e);\n  return Math.round(t * o) / o;\n}\nfunction Vl(e, t, o) {\n  o === void 0 && (o = {});\n  const a = o.whileElementsMounted,\n    l = w(() => {\n      var $;\n      return ($ = v(o.open)) != null ? $ : !0;\n    }),\n    n = w(() => v(o.middleware)),\n    i = w(() => {\n      var $;\n      return ($ = v(o.placement)) != null ? $ : \"bottom\";\n    }),\n    s = w(() => {\n      var $;\n      return ($ = v(o.strategy)) != null ? $ : \"absolute\";\n    }),\n    u = w(() => {\n      var $;\n      return ($ = v(o.transform)) != null ? $ : !0;\n    }),\n    d = w(() => Ha(e.value)),\n    f = w(() => Ha(t.value)),\n    g = W(0),\n    p = W(0),\n    y = W(s.value),\n    b = W(i.value),\n    V = ua({}),\n    C = W(!1),\n    c = w(() => {\n      const $ = {\n        position: y.value,\n        left: \"0\",\n        top: \"0\"\n      };\n      if (!f.value) return $;\n      const I = Vo(f.value, g.value),\n        T = Vo(f.value, p.value);\n      return u.value ? {\n        ...$,\n        transform: \"translate(\" + I + \"px, \" + T + \"px)\",\n        ...(_l(f.value) >= 1.5 && {\n          willChange: \"transform\"\n        })\n      } : {\n        position: y.value,\n        left: I + \"px\",\n        top: T + \"px\"\n      };\n    });\n  let h;\n  function B() {\n    d.value == null || f.value == null || oi(d.value, f.value, {\n      middleware: n.value,\n      placement: i.value,\n      strategy: s.value\n    }).then($ => {\n      g.value = $.x, p.value = $.y, y.value = $.strategy, b.value = $.placement, V.value = $.middlewareData, C.value = !0;\n    });\n  }\n  function _() {\n    typeof h == \"function\" && (h(), h = void 0);\n  }\n  function k() {\n    if (_(), a === void 0) {\n      B();\n      return;\n    }\n    if (d.value != null && f.value != null) {\n      h = a(d.value, f.value, B);\n      return;\n    }\n  }\n  function S() {\n    l.value || (C.value = !1);\n  }\n  return ue([n, i, s], B, {\n    flush: \"sync\"\n  }), ue([d, f], k, {\n    flush: \"sync\"\n  }), ue(l, S, {\n    flush: \"sync\"\n  }), el() && tl(_), {\n    x: Tt(g),\n    y: Tt(p),\n    strategy: Tt(y),\n    placement: Tt(b),\n    middlewareData: Tt(V),\n    isPositioned: Tt(C),\n    floatingStyles: c,\n    update: B\n  };\n}\nconst ni = /* @__PURE__ */new Set([\"background\", \"cite\", \"href\", \"itemtype\", \"longdesc\", \"poster\", \"src\", \"xlink:href\"]),\n  si = /^aria-[\\w-]*$/i,\n  ii = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,\n  ri = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i,\n  ui = (e, t) => {\n    const o = e.nodeName.toLowerCase();\n    return t.includes(o) ? ni.has(o) ? !!(ii.test(e.nodeValue || \"\") || ri.test(e.nodeValue || \"\")) : !0 : t.filter(a => a instanceof RegExp).some(a => a.test(o));\n  },\n  At = {\n    // Global attributes allowed on any supplied element below.\n    \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", si],\n    a: [\"target\", \"href\", \"title\", \"rel\"],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  },\n  Ot = (e, t, o) => {\n    if (!e.length) return e;\n    if (o && typeof o == \"function\") return o(e);\n    const l = new window.DOMParser().parseFromString(e, \"text/html\"),\n      n = l.body.querySelectorAll(\"*\");\n    for (const i of n) {\n      const s = i.nodeName.toLowerCase();\n      if (!Object.keys(t).includes(s)) {\n        i.remove();\n        continue;\n      }\n      const u = i.attributes,\n        d = [...(t[\"*\"] || []), ...(t[s] || [])];\n      for (const f of u) ui(f, d) || i.removeAttribute(f.nodeName);\n    }\n    return l.body.innerHTML;\n  };\nfunction bt(e) {\n  return el() ? (tl(e), !0) : !1;\n}\nfunction Al(e) {\n  let t = !1,\n    o;\n  const a = al(!0);\n  return (...l) => (t || (o = a.run(() => e(...l)), t = !0), o);\n}\nfunction di(e) {\n  let t = 0,\n    o,\n    a;\n  const l = () => {\n    t -= 1, a && t <= 0 && (a.stop(), o = void 0, a = void 0);\n  };\n  return (...n) => (t += 1, o || (a = al(!0), o = a.run(() => e(...n))), bt(l), o);\n}\nfunction Ke(e) {\n  return typeof e == \"function\" ? e() : v(e);\n}\nconst ma = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst ci = e => typeof e < \"u\",\n  fi = Object.prototype.toString,\n  vi = e => fi.call(e) === \"[object Object]\",\n  yt = () => {},\n  za = /* @__PURE__ */pi();\nfunction pi() {\n  var e;\n  return ma && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ *//iP(ad|hone|od)/.test(window.navigator.userAgent);\n}\nfunction Ol(e, t) {\n  function o(...a) {\n    return new Promise((l, n) => {\n      Promise.resolve(e(() => t.apply(this, a), {\n        fn: t,\n        thisArg: this,\n        args: a\n      })).then(l).catch(n);\n    });\n  }\n  return o;\n}\nconst El = e => e();\nfunction mi(e, t = {}) {\n  let o,\n    a,\n    l = yt;\n  const n = s => {\n    clearTimeout(s), l(), l = yt;\n  };\n  return s => {\n    const u = Ke(e),\n      d = Ke(t.maxWait);\n    return o && n(o), u <= 0 || d !== void 0 && d <= 0 ? (a && (n(a), a = null), Promise.resolve(s())) : new Promise((f, g) => {\n      l = t.rejectOnCancel ? g : f, d && !a && (a = setTimeout(() => {\n        o && n(o), a = null, f(s());\n      }, d)), o = setTimeout(() => {\n        a && n(a), a = null, f(s());\n      }, u);\n    });\n  };\n}\nfunction gi(e = El) {\n  const t = W(!0);\n  function o() {\n    t.value = !1;\n  }\n  function a() {\n    t.value = !0;\n  }\n  const l = (...n) => {\n    t.value && e(...n);\n  };\n  return {\n    isActive: Xe(t),\n    pause: o,\n    resume: a,\n    eventFilter: l\n  };\n}\nfunction Pl(...e) {\n  if (e.length !== 1) return E(...e);\n  const t = e[0];\n  return typeof t == \"function\" ? Xe(Rn(() => ({\n    get: t,\n    set: yt\n  }))) : W(t);\n}\nfunction bi(e, t = 200, o = {}) {\n  return Ol(mi(t, o), e);\n}\nfunction yi(e, t, o = {}) {\n  const {\n    eventFilter: a = El,\n    ...l\n  } = o;\n  return ue(e, Ol(a, t), l);\n}\nfunction hi(e, t, o = {}) {\n  const {\n      eventFilter: a,\n      ...l\n    } = o,\n    {\n      eventFilter: n,\n      pause: i,\n      resume: s,\n      isActive: u\n    } = gi(a);\n  return {\n    stop: yi(e, t, {\n      ...l,\n      eventFilter: n\n    }),\n    pause: i,\n    resume: s,\n    isActive: u\n  };\n}\nfunction Nl(e, t = !0) {\n  Ht() ? st(e) : t ? e() : Ne(e);\n}\nfunction Il(e, t = 1e3, o = {}) {\n  const {\n    immediate: a = !0,\n    immediateCallback: l = !1\n  } = o;\n  let n = null;\n  const i = W(!1);\n  function s() {\n    n && (clearInterval(n), n = null);\n  }\n  function u() {\n    i.value = !1, s();\n  }\n  function d() {\n    const f = Ke(t);\n    f <= 0 || (i.value = !0, l && e(), s(), n = setInterval(e, f));\n  }\n  if (a && ma && d(), ol(t) || typeof t == \"function\") {\n    const f = ue(t, () => {\n      i.value && ma && d();\n    });\n    bt(f);\n  }\n  return bt(u), {\n    isActive: i,\n    pause: u,\n    resume: d\n  };\n}\nfunction he(e, t = {}) {\n  const {\n    method: o = \"parseFloat\",\n    radix: a,\n    nanToZero: l\n  } = t;\n  return w(() => {\n    let n = Ke(e);\n    return typeof n == \"string\" && (n = Number[o](n, a)), l && Number.isNaN(n) && (n = 0), n;\n  });\n}\nfunction ut(e) {\n  var t;\n  const o = Ke(e);\n  return (t = o == null ? void 0 : o.$el) != null ? t : o;\n}\nconst tt = ma ? window : void 0;\nfunction Oe(...e) {\n  let t, o, a, l;\n  if (typeof e[0] == \"string\" || Array.isArray(e[0]) ? ([o, a, l] = e, t = tt) : [t, o, a, l] = e, !t) return yt;\n  Array.isArray(o) || (o = [o]), Array.isArray(a) || (a = [a]);\n  const n = [],\n    i = () => {\n      n.forEach(f => f()), n.length = 0;\n    },\n    s = (f, g, p, y) => (f.addEventListener(g, p, y), () => f.removeEventListener(g, p, y)),\n    u = ue(() => [ut(t), Ke(l)], ([f, g]) => {\n      if (i(), !f) return;\n      const p = vi(g) ? {\n        ...g\n      } : g;\n      n.push(...o.flatMap(y => a.map(b => s(f, y, b, p))));\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    }),\n    d = () => {\n      u(), i();\n    };\n  return bt(d), d;\n}\nlet Ao = !1;\nfunction Ll(e, t, o = {}) {\n  const {\n    window: a = tt,\n    ignore: l = [],\n    capture: n = !0,\n    detectIframe: i = !1\n  } = o;\n  if (!a) return;\n  za && !Ao && (Ao = !0, Array.from(a.document.body.children).forEach(p => p.addEventListener(\"click\", yt)), a.document.documentElement.addEventListener(\"click\", yt));\n  let s = !0;\n  const u = p => l.some(y => {\n      if (typeof y == \"string\") return Array.from(a.document.querySelectorAll(y)).some(b => b === p.target || p.composedPath().includes(b));\n      {\n        const b = ut(y);\n        return b && (p.target === b || p.composedPath().includes(b));\n      }\n    }),\n    f = [Oe(a, \"click\", p => {\n      const y = ut(e);\n      if (!(!y || y === p.target || p.composedPath().includes(y))) {\n        if (p.detail === 0 && (s = !u(p)), !s) {\n          s = !0;\n          return;\n        }\n        t(p);\n      }\n    }, {\n      passive: !0,\n      capture: n\n    }), Oe(a, \"pointerdown\", p => {\n      const y = ut(e);\n      s = !u(p) && !!(y && !p.composedPath().includes(y));\n    }, {\n      passive: !0\n    }), i && Oe(a, \"blur\", p => {\n      setTimeout(() => {\n        var y;\n        const b = ut(e);\n        ((y = a.document.activeElement) == null ? void 0 : y.tagName) === \"IFRAME\" && !(b != null && b.contains(a.document.activeElement)) && t(p);\n      }, 0);\n    })].filter(Boolean);\n  return () => f.forEach(p => p());\n}\nfunction Bi(e) {\n  return typeof e == \"function\" ? e : typeof e == \"string\" ? t => t.key === e : Array.isArray(e) ? t => e.includes(t.key) : () => !0;\n}\nfunction qe(...e) {\n  let t,\n    o,\n    a = {};\n  e.length === 3 ? (t = e[0], o = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == \"object\" ? (t = !0, o = e[0], a = e[1]) : (t = e[0], o = e[1]) : (t = !0, o = e[0]);\n  const {\n      target: l = tt,\n      eventName: n = \"keydown\",\n      passive: i = !1,\n      dedupe: s = !1\n    } = a,\n    u = Bi(t);\n  return Oe(l, n, f => {\n    f.repeat && Ke(s) || u(f) && o(f);\n  }, i);\n}\nfunction Si() {\n  const e = W(!1);\n  return Ht() && st(() => {\n    e.value = !0;\n  }), e;\n}\nfunction Ci(e) {\n  const t = Si();\n  return w(() => (t.value, !!e()));\n}\nfunction wi(e, t = {}) {\n  const {\n      window: o = tt\n    } = t,\n    a = Ci(() => o && \"matchMedia\" in o && typeof o.matchMedia == \"function\");\n  let l;\n  const n = W(!1),\n    i = d => {\n      n.value = d.matches;\n    },\n    s = () => {\n      l && (\"removeEventListener\" in l ? l.removeEventListener(\"change\", i) : l.removeListener(i));\n    },\n    u = Xt(() => {\n      a.value && (s(), l = o.matchMedia(Ke(e)), \"addEventListener\" in l ? l.addEventListener(\"change\", i) : l.addListener(i), n.value = l.matches);\n    });\n  return bt(() => {\n    u(), s(), l = void 0;\n  }), n;\n}\nfunction ki(e) {\n  return JSON.parse(JSON.stringify(e));\n}\nconst aa = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {},\n  oa = \"__vueuse_ssr_handlers__\",\n  $i = /* @__PURE__ */Ti();\nfunction Ti() {\n  return oa in aa || (aa[oa] = aa[oa] || {}), aa[oa];\n}\nfunction oo(e, t) {\n  return $i[e] || t;\n}\nfunction _i(e) {\n  return e == null ? \"any\" : e instanceof Set ? \"set\" : e instanceof Map ? \"map\" : e instanceof Date ? \"date\" : typeof e == \"boolean\" ? \"boolean\" : typeof e == \"string\" ? \"string\" : typeof e == \"object\" ? \"object\" : Number.isNaN(e) ? \"any\" : \"number\";\n}\nconst Vi = {\n    boolean: {\n      read: e => e === \"true\",\n      write: e => String(e)\n    },\n    object: {\n      read: e => JSON.parse(e),\n      write: e => JSON.stringify(e)\n    },\n    number: {\n      read: e => Number.parseFloat(e),\n      write: e => String(e)\n    },\n    any: {\n      read: e => e,\n      write: e => String(e)\n    },\n    string: {\n      read: e => e,\n      write: e => String(e)\n    },\n    map: {\n      read: e => new Map(JSON.parse(e)),\n      write: e => JSON.stringify(Array.from(e.entries()))\n    },\n    set: {\n      read: e => new Set(JSON.parse(e)),\n      write: e => JSON.stringify(Array.from(e))\n    },\n    date: {\n      read: e => new Date(e),\n      write: e => e.toISOString()\n    }\n  },\n  Oo = \"vueuse-storage\";\nfunction Ai(e, t, o, a = {}) {\n  var l;\n  const {\n      flush: n = \"pre\",\n      deep: i = !0,\n      listenToStorageChanges: s = !0,\n      writeDefaults: u = !0,\n      mergeDefaults: d = !1,\n      shallow: f,\n      window: g = tt,\n      eventFilter: p,\n      onError: y = T => {\n        console.error(T);\n      },\n      initOnMounted: b\n    } = a,\n    V = (f ? ua : W)(typeof t == \"function\" ? t() : t);\n  if (!o) try {\n    o = oo(\"getDefaultStorage\", () => {\n      var T;\n      return (T = tt) == null ? void 0 : T.localStorage;\n    })();\n  } catch (T) {\n    y(T);\n  }\n  if (!o) return V;\n  const C = Ke(t),\n    c = _i(C),\n    h = (l = a.serializer) != null ? l : Vi[c],\n    {\n      pause: B,\n      resume: _\n    } = hi(V, () => k(V.value), {\n      flush: n,\n      deep: i,\n      eventFilter: p\n    });\n  return g && s && Nl(() => {\n    Oe(g, \"storage\", I), Oe(g, Oo, $), b && I();\n  }), b || I(), V;\n  function k(T) {\n    try {\n      if (T == null) o.removeItem(e);else {\n        const O = h.write(T),\n          F = o.getItem(e);\n        F !== O && (o.setItem(e, O), g && g.dispatchEvent(new CustomEvent(Oo, {\n          detail: {\n            key: e,\n            oldValue: F,\n            newValue: O,\n            storageArea: o\n          }\n        })));\n      }\n    } catch (O) {\n      y(O);\n    }\n  }\n  function S(T) {\n    const O = T ? T.newValue : o.getItem(e);\n    if (O == null) return u && C !== null && o.setItem(e, h.write(C)), C;\n    if (!T && d) {\n      const F = h.read(O);\n      return typeof d == \"function\" ? d(F, C) : c === \"object\" && !Array.isArray(F) ? {\n        ...C,\n        ...F\n      } : F;\n    } else return typeof O != \"string\" ? O : h.read(O);\n  }\n  function $(T) {\n    I(T.detail);\n  }\n  function I(T) {\n    if (!(T && T.storageArea !== o)) {\n      if (T && T.key == null) {\n        V.value = C;\n        return;\n      }\n      if (!(T && T.key !== e)) {\n        B();\n        try {\n          (T == null ? void 0 : T.newValue) !== h.write(V.value) && (V.value = S(T));\n        } catch (O) {\n          y(O);\n        } finally {\n          T ? Ne(_) : _();\n        }\n      }\n    }\n  }\n}\nfunction Oi(e) {\n  return wi(\"(prefers-color-scheme: dark)\", e);\n}\nfunction Ei(e = {}) {\n  const {\n      selector: t = \"html\",\n      attribute: o = \"class\",\n      initialValue: a = \"auto\",\n      window: l = tt,\n      storage: n,\n      storageKey: i = \"vueuse-color-scheme\",\n      listenToStorageChanges: s = !0,\n      storageRef: u,\n      emitAuto: d,\n      disableTransition: f = !0\n    } = e,\n    g = {\n      auto: \"\",\n      light: \"light\",\n      dark: \"dark\",\n      ...(e.modes || {})\n    },\n    p = Oi({\n      window: l\n    }),\n    y = w(() => p.value ? \"dark\" : \"light\"),\n    b = u || (i == null ? Pl(a) : Ai(i, a, n, {\n      window: l,\n      listenToStorageChanges: s\n    })),\n    V = w(() => b.value === \"auto\" ? y.value : b.value),\n    C = oo(\"updateHTMLAttrs\", (_, k, S) => {\n      const $ = typeof _ == \"string\" ? l == null ? void 0 : l.document.querySelector(_) : ut(_);\n      if (!$) return;\n      let I;\n      if (f) {\n        I = l.document.createElement(\"style\");\n        const T = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        I.appendChild(document.createTextNode(T)), l.document.head.appendChild(I);\n      }\n      if (k === \"class\") {\n        const T = S.split(/\\s/g);\n        Object.values(g).flatMap(O => (O || \"\").split(/\\s/g)).filter(Boolean).forEach(O => {\n          T.includes(O) ? $.classList.add(O) : $.classList.remove(O);\n        });\n      } else $.setAttribute(k, S);\n      f && (l.getComputedStyle(I).opacity, document.head.removeChild(I));\n    });\n  function c(_) {\n    var k;\n    C(t, o, (k = g[_]) != null ? k : _);\n  }\n  function h(_) {\n    e.onChanged ? e.onChanged(_, c) : c(_);\n  }\n  ue(V, h, {\n    flush: \"post\",\n    immediate: !0\n  }), Nl(() => h(V.value));\n  const B = w({\n    get() {\n      return d ? b.value : V.value;\n    },\n    set(_) {\n      b.value = _;\n    }\n  });\n  try {\n    return Object.assign(B, {\n      store: b,\n      system: y,\n      state: V\n    });\n  } catch {\n    return B;\n  }\n}\nfunction lo(e, t = {}) {\n  const {\n      delayEnter: o = 0,\n      delayLeave: a = 0,\n      window: l = tt\n    } = t,\n    n = W(!1);\n  let i;\n  const s = u => {\n    const d = u ? o : a;\n    i && (clearTimeout(i), i = void 0), d ? i = setTimeout(() => n.value = u, d) : n.value = u;\n  };\n  return l && (Oe(e, \"mouseenter\", () => s(!0), {\n    passive: !0\n  }), Oe(e, \"mouseleave\", () => s(!1), {\n    passive: !0\n  })), n;\n}\nfunction xe(e, t = {}) {\n  const {\n      initialValue: o = !1,\n      focusVisible: a = !1\n    } = t,\n    l = W(!1),\n    n = w(() => ut(e));\n  Oe(n, \"focus\", s => {\n    var u, d;\n    (!a || (d = (u = s.target).matches) != null && d.call(u, \":focus-visible\")) && (l.value = !0);\n  }), Oe(n, \"blur\", () => l.value = !1);\n  const i = w({\n    get: () => l.value,\n    set(s) {\n      var u, d;\n      !s && l.value ? (u = n.value) == null || u.blur() : s && !l.value && ((d = n.value) == null || d.focus());\n    }\n  });\n  return ue(n, () => {\n    i.value = o;\n  }, {\n    immediate: !0,\n    flush: \"post\"\n  }), {\n    focused: i\n  };\n}\nfunction Oa(e) {\n  return typeof Window < \"u\" && e instanceof Window ? e.document.documentElement : typeof Document < \"u\" && e instanceof Document ? e.documentElement : e;\n}\nconst Pi = {\n  page: e => [e.pageX, e.pageY],\n  client: e => [e.clientX, e.clientY],\n  screen: e => [e.screenX, e.screenY],\n  movement: e => e instanceof Touch ? null : [e.movementX, e.movementY]\n};\nfunction Ni(e = {}) {\n  const {\n    type: t = \"page\",\n    touch: o = !0,\n    resetOnTouchEnds: a = !1,\n    initialValue: l = {\n      x: 0,\n      y: 0\n    },\n    window: n = tt,\n    target: i = n,\n    scroll: s = !0,\n    eventFilter: u\n  } = e;\n  let d = null;\n  const f = W(l.x),\n    g = W(l.y),\n    p = W(null),\n    y = typeof t == \"function\" ? t : Pi[t],\n    b = k => {\n      const S = y(k);\n      d = k, S && ([f.value, g.value] = S, p.value = \"mouse\");\n    },\n    V = k => {\n      if (k.touches.length > 0) {\n        const S = y(k.touches[0]);\n        S && ([f.value, g.value] = S, p.value = \"touch\");\n      }\n    },\n    C = () => {\n      if (!d || !n) return;\n      const k = y(d);\n      d instanceof MouseEvent && k && (f.value = k[0] + n.scrollX, g.value = k[1] + n.scrollY);\n    },\n    c = () => {\n      f.value = l.x, g.value = l.y;\n    },\n    h = u ? k => u(() => b(k), {}) : k => b(k),\n    B = u ? k => u(() => V(k), {}) : k => V(k),\n    _ = u ? () => u(() => C(), {}) : () => C();\n  if (i) {\n    const k = {\n      passive: !0\n    };\n    Oe(i, [\"mousemove\", \"dragover\"], h, k), o && t !== \"movement\" && (Oe(i, [\"touchstart\", \"touchmove\"], B, k), a && Oe(i, \"touchend\", c, k)), s && t === \"page\" && Oe(n, \"scroll\", _, {\n      passive: !0\n    });\n  }\n  return {\n    x: f,\n    y: g,\n    sourceType: p\n  };\n}\nfunction Eo(e, t = {}) {\n  const {\n      handleOutside: o = !0,\n      window: a = tt\n    } = t,\n    l = t.type || \"page\",\n    {\n      x: n,\n      y: i,\n      sourceType: s\n    } = Ni(t),\n    u = W(e ?? (a == null ? void 0 : a.document.body)),\n    d = W(0),\n    f = W(0),\n    g = W(0),\n    p = W(0),\n    y = W(0),\n    b = W(0),\n    V = W(!0);\n  let C = () => {};\n  return a && (C = ue([u, n, i], () => {\n    const c = ut(u);\n    if (!c) return;\n    const {\n      left: h,\n      top: B,\n      width: _,\n      height: k\n    } = c.getBoundingClientRect();\n    g.value = h + (l === \"page\" ? a.pageXOffset : 0), p.value = B + (l === \"page\" ? a.pageYOffset : 0), y.value = k, b.value = _;\n    const S = n.value - g.value,\n      $ = i.value - p.value;\n    V.value = _ === 0 || k === 0 || S < 0 || $ < 0 || S > _ || $ > k, (o || !V.value) && (d.value = S, f.value = $);\n  }, {\n    immediate: !0\n  }), Oe(document, \"mouseleave\", () => {\n    V.value = !0;\n  })), {\n    x: n,\n    y: i,\n    sourceType: s,\n    elementX: d,\n    elementY: f,\n    elementPositionX: g,\n    elementPositionY: p,\n    elementHeight: y,\n    elementWidth: b,\n    isOutside: V,\n    stop: C\n  };\n}\nfunction Fl(e) {\n  const t = window.getComputedStyle(e);\n  if (t.overflowX === \"scroll\" || t.overflowY === \"scroll\" || t.overflowX === \"auto\" && e.clientWidth < e.scrollWidth || t.overflowY === \"auto\" && e.clientHeight < e.scrollHeight) return !0;\n  {\n    const o = e.parentNode;\n    return !o || o.tagName === \"BODY\" ? !1 : Fl(o);\n  }\n}\nfunction Ii(e) {\n  const t = e || window.event,\n    o = t.target;\n  return Fl(o) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);\n}\nconst la = /* @__PURE__ */new WeakMap();\nfunction Li(e, t = !1) {\n  const o = W(t);\n  let a = null,\n    l;\n  ue(Pl(e), s => {\n    const u = Oa(Ke(s));\n    if (u) {\n      const d = u;\n      la.get(d) || la.set(d, l), o.value && (d.style.overflow = \"hidden\");\n    }\n  }, {\n    immediate: !0\n  });\n  const n = () => {\n      const s = Oa(Ke(e));\n      !s || o.value || (za && (a = Oe(s, \"touchmove\", u => {\n        Ii(u);\n      }, {\n        passive: !1\n      })), s.style.overflow = \"hidden\", o.value = !0);\n    },\n    i = () => {\n      var s;\n      const u = Oa(Ke(e));\n      !u || !o.value || (za && (a == null || a()), u.style.overflow = (s = la.get(u)) != null ? s : \"\", la.delete(u), o.value = !1);\n    };\n  return bt(i), w({\n    get() {\n      return o.value;\n    },\n    set(s) {\n      s ? n() : i();\n    }\n  });\n}\nfunction Fi(e, t = {}) {\n  const {\n      threshold: o = 50,\n      onSwipe: a,\n      onSwipeEnd: l,\n      onSwipeStart: n,\n      passive: i = !0,\n      window: s = tt\n    } = t,\n    u = da({\n      x: 0,\n      y: 0\n    }),\n    d = da({\n      x: 0,\n      y: 0\n    }),\n    f = w(() => u.x - d.x),\n    g = w(() => u.y - d.y),\n    {\n      max: p,\n      abs: y\n    } = Math,\n    b = w(() => p(y(f.value), y(g.value)) >= o),\n    V = W(!1),\n    C = w(() => b.value ? y(f.value) > y(g.value) ? f.value > 0 ? \"left\" : \"right\" : g.value > 0 ? \"up\" : \"down\" : \"none\"),\n    c = T => [T.touches[0].clientX, T.touches[0].clientY],\n    h = (T, O) => {\n      u.x = T, u.y = O;\n    },\n    B = (T, O) => {\n      d.x = T, d.y = O;\n    };\n  let _;\n  const k = Hi(s == null ? void 0 : s.document);\n  i ? _ = k ? {\n    passive: !0\n  } : {\n    capture: !1\n  } : _ = k ? {\n    passive: !1,\n    capture: !0\n  } : {\n    capture: !0\n  };\n  const S = T => {\n      V.value && (l == null || l(T, C.value)), V.value = !1;\n    },\n    $ = [Oe(e, \"touchstart\", T => {\n      if (T.touches.length !== 1) return;\n      _.capture && !_.passive && T.preventDefault();\n      const [O, F] = c(T);\n      h(O, F), B(O, F), n == null || n(T);\n    }, _), Oe(e, \"touchmove\", T => {\n      if (T.touches.length !== 1) return;\n      const [O, F] = c(T);\n      B(O, F), !V.value && b.value && (V.value = !0), V.value && (a == null || a(T));\n    }, _), Oe(e, [\"touchend\", \"touchcancel\"], S, _)];\n  return {\n    isPassiveEventSupported: k,\n    isSwiping: V,\n    direction: C,\n    coordsStart: u,\n    coordsEnd: d,\n    lengthX: f,\n    lengthY: g,\n    stop: () => $.forEach(T => T())\n  };\n}\nfunction Hi(e) {\n  if (!e) return !1;\n  let t = !1;\n  const o = {\n    get passive() {\n      return t = !0, !1;\n    }\n  };\n  return e.addEventListener(\"x\", yt, o), e.removeEventListener(\"x\", yt), t;\n}\nfunction ke(e, t, o, a = {}) {\n  var l, n, i;\n  const {\n      clone: s = !1,\n      passive: u = !1,\n      eventName: d,\n      deep: f = !1,\n      defaultValue: g,\n      shouldEmit: p\n    } = a,\n    y = Ht(),\n    b = o || (y == null ? void 0 : y.emit) || ((l = y == null ? void 0 : y.$emit) == null ? void 0 : l.bind(y)) || ((i = (n = y == null ? void 0 : y.proxy) == null ? void 0 : n.$emit) == null ? void 0 : i.bind(y == null ? void 0 : y.proxy));\n  let V = d;\n  t || (t = \"modelValue\"), V = V || `update:${t.toString()}`;\n  const C = B => s ? typeof s == \"function\" ? s(B) : ki(B) : B,\n    c = () => ci(e[t]) ? C(e[t]) : g,\n    h = B => {\n      p ? p(B) && b(V, B) : b(V, B);\n    };\n  if (u) {\n    const B = c(),\n      _ = W(B);\n    let k = !1;\n    return ue(() => e[t], S => {\n      k || (k = !0, _.value = C(S), Ne(() => k = !1));\n    }), ue(_, S => {\n      !k && (S !== e[t] || f) && h(S);\n    }, {\n      deep: f\n    }), _;\n  } else return w({\n    get() {\n      return c();\n    },\n    set(B) {\n      h(B);\n    }\n  });\n}\nconst Zt = e => w(() => {\n    const t = it(e);\n    return t ? `justify-content-${t}` : \"\";\n  }),\n  zi = e => typeof e == \"boolean\" || e === \"\" || e === \"true\" || e === \"false\",\n  r = e => w(() => {\n    const t = it(e);\n    return zi(t) ? typeof t == \"boolean\" ? t : t === \"\" || t === \"true\" : t;\n  }),\n  Ca = (e, t) => {\n    const o = r(e),\n      a = E(t);\n    return w(() => o.value === !0 ? \"true\" : typeof o.value == \"string\" ? o.value : a.value === !1 ? \"true\" : o.value === !1 ? \"false\" : void 0);\n  },\n  Ct = (e, t) => {\n    const o = E(t),\n      a = E(e),\n      l = E(() => Ji(a.value)),\n      n = w(() => l.value ? fo(a.value, o.value ?? [\"active\", \"activeClass\", \"append\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"variant\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\"]) : {});\n    return {\n      computedLink: l,\n      computedLinkProps: n\n    };\n  },\n  Hl = Al(() => {\n    const e = da([]);\n    return {\n      items: e,\n      reset: () => {\n        e.splice(0, e.length);\n      }\n    };\n  }),\n  Ri = (e = {}) => {\n    const t = e.persist ?? !1,\n      o = \"data-bs-theme\",\n      a = \"body\";\n    return Ei({\n      attribute: o,\n      selector: a,\n      storageKey: t === !0 ? `bv-color-${e.attribute ?? o}-${e.selector ?? a}` : null,\n      ...e\n    });\n  },\n  Qe = e => w(() => {\n    const t = it(e);\n    return {\n      [`text-bg-${t.variant}`]: t.variant !== null,\n      [`text-${t.textVariant}`]: t.textVariant !== null && t.variant === null,\n      [`bg-${t.bgVariant}`]: t.bgVariant !== null && t.variant === null\n    };\n  }),\n  xi = e => w(() => {\n    const t = it(e);\n    return {\n      container: t === !0,\n      [`container-${t}`]: typeof t == \"string\"\n    };\n  }),\n  zl = (e, t = W(1e3), o = {}) => {\n    const a = Xe(E(e)),\n      l = Xe(E(t)),\n      n = W(!1),\n      i = W(0),\n      s = E(() => Math.ceil(a.value / l.value)),\n      u = E(() => g.value || n.value ? Math.round(a.value - i.value * l.value) : 0),\n      {\n        pause: d,\n        resume: f,\n        isActive: g\n      } = Il(() => {\n        i.value = i.value + 1;\n      }, t, o),\n      p = () => {\n        n.value = !1, i.value = 0, f();\n      },\n      y = () => {\n        n.value = !1, i.value = s.value;\n      };\n    Xt(() => {\n      i.value > s.value && (i.value = s.value), i.value === s.value && d();\n    }), ue([l, a], () => {\n      y(), p();\n    });\n    const b = () => {\n        g.value !== !1 && (n.value = !0, d());\n      },\n      V = () => {\n        i.value !== s.value && (n.value = !1, f());\n      };\n    return {\n      isActive: Xe(g),\n      isPaused: Xe(n),\n      restart: p,\n      stop: y,\n      pause: b,\n      resume: V,\n      value: u\n    };\n  },\n  wt = e => w(() => {\n    const t = it(e);\n    return t === !0 ? \"is-valid\" : t === !1 ? \"is-invalid\" : null;\n  }),\n  Rl = e => w(() => {\n    const t = it(e);\n    return {\n      \"form-check\": t.plain === !1 && t.button === !1,\n      \"form-check-inline\": t.inline === !0,\n      \"form-switch\": t.switch === !0,\n      [`form-control-${t.size}`]: t.size !== void 0 && t.size !== \"md\" && t.button === !1\n    };\n  }),\n  xl = e => {\n    const t = E(e),\n      o = wt(() => t.value.state ?? null);\n    return w(() => [o.value, {\n      \"form-check-input\": t.value.plain === !1 && t.value.button === !1,\n      \"btn-check\": t.value.button === !0\n    }]);\n  },\n  Ml = e => w(() => {\n    const t = it(e);\n    return {\n      \"form-check-label\": t.plain === !1 && t.button === !1,\n      btn: t.button === !0,\n      [`btn-${t.buttonVariant}`]: t.button === !0 && t.buttonVariant !== void 0 && t.buttonVariant !== null,\n      [`btn-${t.size}`]: t.button && t.size && t.size !== \"md\"\n    };\n  }),\n  Dl = e => {\n    const t = E(e),\n      o = Ca(() => t.value.ariaInvalid, () => t.value.state);\n    return w(() => ({\n      \"aria-invalid\": o.value,\n      \"aria-required\": t.value.required === !0 ? !0 : void 0\n    }));\n  },\n  jl = e => w(() => {\n    const t = it(e);\n    return {\n      \"was-validated\": t.validated === !0,\n      \"btn-group\": t.buttons === !0 && t.stacked === !1,\n      \"btn-group-vertical\": t.stacked === !0 && t.buttons === !0,\n      [`btn-group-${t.size}`]: t.size !== void 0\n    };\n  }),\n  _e = (e, t) => w(() => it(e) || qt(t)),\n  ql = (e, t) => {\n    const o = W(null),\n      a = ke(e, \"modelValue\", t),\n      l = _e(() => e.id, \"input\"),\n      n = r(() => e.autofocus),\n      i = r(() => e.disabled),\n      s = r(() => e.lazy),\n      u = r(() => e.lazyFormatter),\n      d = r(() => e.number),\n      f = r(() => e.state),\n      g = r(() => e.trim),\n      p = he(() => e.debounce ?? 0),\n      y = he(() => e.debounceMaxWait ?? NaN),\n      b = bi(T => {\n        a.value = T;\n      }, () => s.value === !0 ? 0 : p.value, {\n        maxWait: () => s.value === !0 ? NaN : y.value\n      }),\n      V = (T, O = !1) => {\n        s.value === !0 && O === !1 || b(T);\n      },\n      {\n        focused: C\n      } = xe(o, {\n        initialValue: n.value\n      }),\n      c = (T, O, F = !1) => e.formatter !== void 0 && (!u.value || F) ? e.formatter(T, O) : T,\n      h = T => g.value ? T.trim() : d.value ? Number.parseFloat(T) : T;\n    st(() => {\n      var T;\n      o.value && (o.value.value = ((T = a.value) == null ? void 0 : T.toString()) ?? \"\");\n    }), xn(() => {\n      Ne(() => {\n        n.value && (C.value = !0);\n      });\n    });\n    const B = Ca(() => e.ariaInvalid, f);\n    return {\n      input: o,\n      computedId: l,\n      computedAriaInvalid: B,\n      onInput: T => {\n        const {\n            value: O\n          } = T.target,\n          F = c(O, T);\n        if (T.defaultPrevented) {\n          T.preventDefault();\n          return;\n        }\n        const K = h(F);\n        V(K), t(\"input\", F);\n      },\n      onChange: T => {\n        const {\n            value: O\n          } = T.target,\n          F = c(O, T);\n        if (T.defaultPrevented) {\n          T.preventDefault();\n          return;\n        }\n        const K = h(F);\n        a.value !== K && V(F, !0), t(\"change\", F);\n      },\n      onBlur: T => {\n        if (t(\"blur\", T), !s.value && !u.value) return;\n        const {\n            value: O\n          } = T.target,\n          F = c(O, T, !0),\n          K = h(F);\n        a.value !== K && V(F, !0);\n      },\n      focus: () => {\n        i.value || (C.value = !0);\n      },\n      blur: () => {\n        i.value || (C.value = !1);\n      }\n    };\n  },\n  Vt = (e, t) => {\n    if (!e) return e;\n    if (t in e) return e[t];\n    const o = t.split(\".\");\n    return Vt(e[o[0]], o.splice(1).join(\".\"));\n  },\n  Ea = (e, t = null, o, a) => {\n    if (Object.prototype.toString.call(e) === \"[object Object]\") {\n      const l = Vt(e, a.valueField),\n        n = Vt(e, a.textField),\n        i = Vt(e, a.htmlField),\n        s = Vt(e, a.disabledField),\n        u = e[a.optionsField] || null;\n      return u !== null ? {\n        label: String(Vt(e, a.labelField) || n),\n        options: no(u, o, a)\n      } : {\n        value: typeof l > \"u\" ? t || n : l,\n        text: String(typeof n > \"u\" ? t : n),\n        html: i,\n        disabled: !!s\n      };\n    }\n    return {\n      value: t || e,\n      text: String(e),\n      disabled: !1\n    };\n  },\n  no = (e, t, o) => Array.isArray(e) ? e.map(a => Ea(a, null, t, o)) : Object.prototype.toString.call(e) === \"[object Object]\" ? (console.warn(`[BootstrapVue warn]: ${t} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`), Object.keys(e).map(a => {\n    const l = e[a];\n    switch (typeof l) {\n      case \"object\":\n        return Ea(l.text, String(l.value), t, o);\n      default:\n        return Ea(l, String(a), t, o);\n    }\n  })) : [],\n  Pa = \"modal-open\",\n  so = di(() => {\n    const e = ua([]),\n      t = E(() => e.value.length),\n      o = E(() => e.value[e.value.length - 1]),\n      a = f => {\n        e.value = [...e.value, f];\n      },\n      l = f => {\n        e.value = e.value.filter(g => g.uid !== f.uid);\n      },\n      n = ua([]),\n      i = f => {\n        n.value = [...n.value, f];\n      },\n      s = f => {\n        n.value = n.value.filter(g => g.uid !== f.uid);\n      },\n      u = f => {\n        l(f), s(f);\n      },\n      d = oo(\"updateHTMLAttrs\", (f, g, p) => {\n        const y = typeof f == \"string\" ? window == null ? void 0 : window.document.querySelector(f) : ut(f);\n        y && (g === \"class\" ? y.classList.toggle(Pa, p === Pa) : y.setAttribute(g, p));\n      });\n    return bt(() => {\n      d(\"body\", \"class\", \"\");\n    }), ue(t, f => {\n      d(\"body\", \"class\", f > 0 ? Pa : \"\");\n    }), {\n      registry: n,\n      stack: e,\n      lastStack: o,\n      countStack: t,\n      pushStack: a,\n      removeStack: l,\n      pushRegistry: i,\n      removeRegistry: s,\n      dispose: u\n    };\n  }),\n  Mi = e => {\n    const {\n        pushRegistry: t,\n        pushStack: o,\n        removeStack: a,\n        stack: l,\n        dispose: n,\n        countStack: i\n      } = so(),\n      s = Ht();\n    if (!s || s.type.__name !== \"BModal\") throw new Error(\"useModalManager must only use in BModal component\");\n    return t(s), bt(() => {\n      n(s);\n    }), ue(e, (u, d) => {\n      u ? o(s) : d && !u && a(s);\n    }, {\n      immediate: !0\n    }), {\n      activePosition: w(() => l.value.findIndex(u => {\n        var d, f;\n        return ((d = u.exposed) == null ? void 0 : d.id) === ((f = s.exposed) == null ? void 0 : f.id);\n      })),\n      activeModalCount: i\n    };\n  },\n  Di = (e = void 0) => {\n    const {\n        registry: t\n      } = so(),\n      o = Ht(),\n      a = w(() => {\n        const n = it(e);\n        return n ? t.value.find(i => {\n          var s;\n          return ((s = i.exposed) == null ? void 0 : s.id.value) === n;\n        }) || null : o ? Gl(o) : null;\n      }),\n      l = E(() => {\n        var n;\n        return (n = a.value) == null ? void 0 : n.proxy;\n      });\n    return {\n      show() {\n        var n, i;\n        (i = (n = a.value) == null ? void 0 : n.exposed) == null || i.show();\n      },\n      hide(n = \"\") {\n        var i, s;\n        (s = (i = a.value) == null ? void 0 : i.exposed) == null || s.hide(n);\n      },\n      modal: l\n    };\n  },\n  Gl = e => e.parent ? e.parent.type.__name === \"BModal\" ? e.parent : Gl(e.parent) : null,\n  ji = () => {\n    const {\n      lastStack: e,\n      stack: t\n    } = so();\n    return {\n      hide: (l = \"\") => {\n        var n;\n        e.value && ((n = e.value.exposed) == null || n.hide(l));\n      },\n      hideAll: (l = \"\") => {\n        var n;\n        for (const i of t.value) (n = i.exposed) == null || n.hide(l);\n      }\n      // Todo: Supports listening events globally in the future\n    };\n  },\n  io = e => {\n    const t = (u, d) => {\n        const f = d === null ? \"\" : `${d}-`;\n        return u === \"circle\" ? `${f}rounded-circle` : u === \"pill\" ? `${f}rounded-pill` : typeof u == \"number\" || u === \"0\" || u === \"1\" || u === \"2\" || u === \"3\" || u === \"4\" || u === \"5\" ? `${f}rounded-${u}` : u === \"none\" ? `${f}rounded-0` : u === \"sm\" ? `${f}rounded-1` : u === \"lg\" ? `${f}rounded-5` : `${f}rounded`;\n      },\n      o = Xe(E(e)),\n      a = r(() => o.value.rounded),\n      l = r(() => o.value.roundedTop),\n      n = r(() => o.value.roundedBottom),\n      i = r(() => o.value.roundedStart),\n      s = r(() => o.value.roundedEnd);\n    return w(() => ({\n      [`${t(a.value, null)}`]: !!a.value,\n      [`${t(l.value, \"top\")}`]: !!l.value,\n      [`${t(n.value, \"bottom\")}`]: !!n.value,\n      [`${t(i.value, \"start\")}`]: !!i.value,\n      [`${t(s.value, \"end\")}`]: !!s.value\n    }));\n  },\n  Wl = (e, t) => {\n    const o = Xe(E(e)),\n      a = Xe(E(t)),\n      l = E(() => !a.value);\n    st(() => {\n      const n = Li(document.body, o.value && l.value);\n      ue([o, l], ([i, s]) => {\n        n.value = i && s;\n      });\n    });\n  },\n  qi = \"top-right\",\n  Ul = Al(() => {\n    const e = W([]);\n    return {\n      toasts: e,\n      show: (...[a, l]) => {\n        const n = {\n          pos: qi\n        };\n        typeof a == \"string\" ? Object.assign(n, l, {\n          body: a,\n          value: (l == null ? void 0 : l.value) || 5e3\n        }) : Object.assign(n, a, {\n          value: a.value || 5e3\n        });\n        const i = Symbol();\n        return e.value.push({\n          ...n,\n          self: i\n        }), i;\n      },\n      hide: a => {\n        const l = e.value.findIndex(n => n.self === a);\n        l !== -1 && e.value.splice(l, 1);\n      }\n    };\n  }),\n  Gi = [\"id\"],\n  Wi = [\"innerHTML\"],\n  Ui = [\"innerHTML\"],\n  ro = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BPopover\",\n    props: {\n      boundary: {\n        default: \"clippingAncestors\"\n      },\n      boundaryPadding: {\n        default: void 0\n      },\n      click: {\n        type: [String, Boolean],\n        default: !1\n      },\n      container: {\n        default: void 0\n      },\n      content: {\n        default: void 0\n      },\n      customClass: {\n        default: \"\"\n      },\n      delay: {\n        default: () => ({\n          show: 100,\n          hide: 300\n        })\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      hide: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      html: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      manual: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noAutoClose: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noHide: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noSize: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noninteractive: {\n        type: [String, Boolean],\n        default: !1\n      },\n      offset: {\n        default: null\n      },\n      placement: {\n        default: \"top\"\n      },\n      persistent: {\n        type: [String, Boolean],\n        default: !1\n      },\n      realtime: {\n        type: [String, Boolean],\n        default: !1\n      },\n      reference: {\n        default: null\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      target: {\n        default: null\n      },\n      title: {\n        default: void 0\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = r(() => a.modelValue),\n        i = W(n.value),\n        s = W(n.value);\n      Xt(() => {\n        l(\"update:modelValue\", i.value);\n      }), ue(n, () => {\n        n.value !== i.value && (n.value ? me() : de(new Event(\"update:modelValue\")));\n      });\n      const u = _e(() => a.id, \"popover\"),\n        d = r(() => a.click),\n        f = r(() => a.manual),\n        g = r(() => a.noShift),\n        p = r(() => a.noSize),\n        y = r(() => a.noFlip),\n        b = r(() => a.noFade),\n        V = r(() => a.noAutoClose),\n        C = r(() => a.noHide),\n        c = r(() => a.realtime),\n        h = r(() => a.inline),\n        B = r(() => a.persistent),\n        _ = r(() => a.tooltip),\n        k = r(() => a.noninteractive),\n        S = r(() => a.html),\n        $ = W(!1),\n        I = W(null),\n        T = W(null),\n        O = W(null),\n        F = W(null),\n        K = W(null),\n        z = w(() => a.title ? Ot(a.title, At) : \"\"),\n        P = w(() => a.content ? Ot(a.content, At) : \"\"),\n        D = E(() => a.placement.startsWith(\"auto\")),\n        ae = he(() => a.offset ?? NaN),\n        le = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? void 0 : a.boundary),\n        ve = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? a.boundary : void 0),\n        Be = W({}),\n        Ve = w(() => {\n          if (a.floatingMiddleware !== void 0) return a.floatingMiddleware;\n          const Y = a.offset !== null ? ae.value : _.value ? 6 : 8,\n            re = [gl(Y)];\n          return y.value === !1 && !D.value && re.push(pl({\n            boundary: le.value,\n            rootBoundary: ve.value,\n            padding: a.boundaryPadding\n          })), D.value && re.push(Ls({\n            alignment: a.placement.split(\"-\")[1] || void 0,\n            boundary: le.value,\n            rootBoundary: ve.value,\n            padding: a.boundaryPadding\n          })), g.value === !1 && re.push(bl({\n            boundary: le.value,\n            rootBoundary: ve.value,\n            padding: a.boundaryPadding\n          })), C.value === !1 && re.push(Fs({\n            boundary: le.value,\n            rootBoundary: ve.value,\n            padding: a.boundaryPadding\n          })), h.value === !0 && re.push(zs()), re.push(li({\n            element: O,\n            padding: 10\n          })), p.value === !1 && re.push(yl({\n            boundary: le.value,\n            rootBoundary: ve.value,\n            padding: a.boundaryPadding,\n            apply({\n              availableWidth: Ae,\n              availableHeight: He\n            }) {\n              Be.value = {\n                maxHeight: He ? `${He}px` : void 0,\n                maxWidth: Ae ? `${Ae}px` : void 0\n              };\n            }\n          })), re;\n        }),\n        oe = E(() => D.value ? void 0 : a.placement),\n        {\n          floatingStyles: fe,\n          middlewareData: $e,\n          placement: we,\n          update: M\n        } = Vl(T, I, {\n          placement: oe,\n          middleware: Ve,\n          strategy: E(() => a.strategy),\n          whileElementsMounted: (...Y) => Tl(...Y, {\n            animationFrame: c.value\n          })\n        }),\n        L = W({\n          position: \"absolute\"\n        });\n      ue($e, () => {\n        var Y;\n        if (C.value === !1 && ((Y = $e.value.hide) != null && Y.referenceHidden ? $.value = !0 : $.value = !1), $e.value.arrow) {\n          const {\n            x: re,\n            y: Ae\n          } = $e.value.arrow;\n          L.value = {\n            position: \"absolute\",\n            top: Ae ? `${Ae}px` : \"\",\n            left: re ? `${re}px` : \"\"\n          };\n        }\n      });\n      const U = w(() => {\n          const Y = _.value ? \"tooltip\" : \"popover\";\n          return [Y, `b-${Y}`, {\n            [`b-${Y}-${a.variant}`]: a.variant !== null,\n            show: i.value && !$.value,\n            \"pe-none\": !i.value,\n            fade: !b.value,\n            \"d-none\": !i.value && b.value,\n            [`${a.customClass}`]: a.customClass !== void 0,\n            [`bs-${Y}-${Ki(we.value)}`]: we.value !== void 0\n          }];\n        }),\n        {\n          isOutside: H\n        } = Eo(I),\n        {\n          isOutside: G\n        } = Eo(F),\n        X = Y => {\n          const re = Y ?? new Event(\"click\");\n          i.value ? de(re) : me();\n        },\n        te = (Y, re = {}) => new Rt(Y, {\n          cancelable: !1,\n          target: I.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...re,\n          componentId: u.value\n        });\n      let be;\n      const me = () => {\n          const Y = te(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", Y), Y.defaultPrevented) {\n            l(\"show-prevented\");\n            return;\n          }\n          s.value = !0, Ne(() => {\n            var re;\n            M(), be = setTimeout(() => {\n              M(), i.value = !0, Ne(() => {\n                l(\"shown\", te(\"shown\"));\n              });\n            }, typeof a.delay == \"number\" ? a.delay : ((re = a.delay) == null ? void 0 : re.show) || 0);\n          });\n        },\n        de = Y => {\n          var He;\n          const re = te(\"hide\", {\n            cancelable: !0\n          });\n          if (l(\"hide\", re), re.defaultPrevented) {\n            l(\"hide-prevented\");\n            return;\n          }\n          be && (clearTimeout(be), be = void 0);\n          const Ae = typeof a.delay == \"number\" ? a.delay : ((He = a.delay) == null ? void 0 : He.hide) || 0;\n          setTimeout(() => {\n            var Re, kt;\n            (Y == null ? void 0 : Y.type) === \"click\" || (Y == null ? void 0 : Y.type) === \"forceHide\" || (Y == null ? void 0 : Y.type) === \"update:modelValue\" && f.value || !k.value && H.value && G.value && !((Re = I.value) != null && Re.contains(document == null ? void 0 : document.activeElement)) && !((kt = F.value) != null && kt.contains(document == null ? void 0 : document.activeElement)) || k.value && G.value ? (i.value = !1, Ne(() => {\n              setTimeout(() => {\n                s.value = !1;\n              }, I.value ? La(I.value) : 150), l(\"hidden\", te(\"hidden\"));\n            })) : setTimeout(() => {\n              de(Y);\n            }, Ae < 50 ? 50 : Ae);\n          }, Ae);\n        };\n      t({\n        hide: de,\n        show: me,\n        toggle: X\n      });\n      const ie = Y => {\n          const re = v(Y);\n          if (re) {\n            if (typeof re == \"string\") {\n              const Ae = document.getElementById(re);\n              return Ae || void 0;\n            }\n            return re.$el ? re.$el : re;\n          }\n        },\n        ce = () => {\n          var Y;\n          if (a.target) {\n            const re = ie(a.target);\n            re ? F.value = re : console.warn(\"Target element not found\", a.target);\n          } else F.value = (Y = K.value) == null ? void 0 : Y.nextElementSibling;\n          if (a.reference) {\n            const re = ie(a.reference);\n            re ? T.value = re : console.warn(\"Reference element not found\", a.reference);\n          } else T.value = F.value;\n          if (!(!F.value || f.value) && Ka) {\n            if (F.value.addEventListener(\"forceHide\", de), d.value) {\n              F.value.addEventListener(\"click\", X);\n              return;\n            }\n            F.value.addEventListener(\"pointerenter\", me), F.value.addEventListener(\"pointerleave\", de), F.value.addEventListener(\"focus\", me), F.value.addEventListener(\"blur\", de);\n          }\n        },\n        Ce = () => {\n          F.value && (F.value.removeEventListener(\"forceHide\", de), F.value.removeEventListener(\"click\", X), F.value.removeEventListener(\"pointerenter\", me), F.value.removeEventListener(\"pointerleave\", de), F.value.removeEventListener(\"focus\", me), F.value.removeEventListener(\"blur\", de));\n        };\n      return Ll(I, () => {\n        i.value && d.value && !V.value && !f.value && de(new Event(\"clickOutside\"));\n      }, {\n        ignore: [F]\n      }), ue([() => a.click, () => a.target, () => a.reference], () => {\n        Ce(), ce();\n      }), st(ce), Wa(Ce), (Y, re) => (m(), N(ge, null, [ee(\"span\", {\n        ref_key: \"placeholder\",\n        ref: K\n      }, null, 512), A(Y.$slots, \"target\", {\n        show: me,\n        hide: de,\n        toggle: X,\n        showState: i.value\n      }), (m(), x(zt, {\n        to: Y.container,\n        disabled: !Y.container\n      }, [s.value || v(B) ? (m(), N(\"div\", Q({\n        key: 0,\n        id: Y.id\n      }, Y.$attrs, {\n        ref_key: \"element\",\n        ref: I,\n        class: U.value,\n        role: \"tooltip\",\n        tabindex: \"-1\",\n        style: v(fe)\n      }), [ee(\"div\", {\n        ref_key: \"arrow\",\n        ref: O,\n        class: j(`${v(_) ? \"tooltip\" : \"popover\"}-arrow`),\n        style: ze(L.value),\n        \"data-popper-arrow\": \"\"\n      }, null, 6), ee(\"div\", {\n        class: \"overflow-auto\",\n        style: ze(Be.value)\n      }, [Y.title || Y.$slots.title ? (m(), N(ge, {\n        key: 0\n      }, [v(S) ? (m(), N(\"div\", {\n        key: 1,\n        class: j([\"position-sticky top-0\", v(_) ? \"tooltip-inner\" : \"popover-header\"]),\n        innerHTML: z.value\n      }, null, 10, Wi)) : (m(), N(\"div\", {\n        key: 0,\n        class: j([\"position-sticky top-0\", v(_) ? \"tooltip-inner\" : \"popover-header\"])\n      }, [A(Y.$slots, \"title\", {}, () => [ne(Z(Y.title), 1)])], 2))], 64)) : J(\"\", !0), v(_) && !Y.$slots.title && !Y.title || !v(_) ? (m(), N(ge, {\n        key: 1\n      }, [v(S) ? (m(), N(\"div\", {\n        key: 1,\n        class: j(v(_) ? \"tooltip-inner\" : \"popover-body\"),\n        innerHTML: P.value\n      }, null, 10, Ui)) : (m(), N(\"div\", {\n        key: 0,\n        class: j(v(_) ? \"tooltip-inner\" : \"popover-body\")\n      }, [A(Y.$slots, \"default\", {}, () => [ne(Z(Y.content), 1)])], 2))], 64)) : J(\"\", !0)], 4)], 16, Gi)) : J(\"\", !0)], 8, [\"to\", \"disabled\"]))], 64));\n    }\n  }),\n  Xi = ({\n    top: e,\n    end: t,\n    start: o,\n    alignCenter: a,\n    alignEnd: l\n  }) => {\n    const n = e ? \"top\" : o ? \"left\" : t ? \"right\" : \"bottom\",\n      i = l ? \"end\" : a ? null : \"start\";\n    return `${n}${i ? `-${i}` : \"\"}`;\n  },\n  Ki = e => {\n    const [t] = e.split(\"-\");\n    switch (t) {\n      case \"left\":\n        return \"start\";\n      case \"right\":\n        return \"end\";\n      default:\n        return t;\n    }\n  },\n  Ut = e => typeof e != \"object\" || e.active !== !1,\n  ga = (e, t) => {\n    if (!Ut(e)) return {};\n    const a = typeof e > \"u\" || typeof e == \"object\" && !e.title && !e.content,\n      l = t.getAttribute(\"title\") || t.getAttribute(\"data-original-title\");\n    return a ? l ? (t.removeAttribute(\"title\"), t.setAttribute(\"data-original-title\", l), {\n      content: Ot(l, At)\n    }) : {} : typeof e == \"string\" ? {\n      content: Ot(e, At)\n    } : {\n      title: e != null && e.title ? Ot(e == null ? void 0 : e.title, At) : void 0,\n      content: e != null && e.content ? Ot(e == null ? void 0 : e.content, At) : void 0\n    };\n  },\n  Nt = (e, t) => ({\n    target: t,\n    modelValue: e.modifiers.show,\n    inline: e.modifiers.inline,\n    click: e.modifiers.click,\n    realtime: e.modifiers.realtime,\n    persistent: e.modifiers.persistent,\n    placement: e.modifiers.left ? \"left\" : e.modifiers.right ? \"right\" : e.modifiers.bottom ? \"bottom\" : e.modifiers.top ? \"top\" : void 0,\n    html: !0,\n    ...(typeof e.value == \"object\" ? e.value : {}),\n    title: null,\n    content: null\n  }),\n  ba = (e, t) => {\n    var a;\n    const o = document.createElement(\"span\");\n    t.modifiers.body ? document.body.appendChild(o) : t.modifiers.child ? e.appendChild(o) : (a = e.parentNode) == null || a.insertBefore(o, e.nextSibling), e.$__app = Mn({\n      render: () => {\n        var l;\n        return Le(ro, {\n          ...((l = e.$__state) == null ? void 0 : l.value)\n        });\n      }\n    }), e.$__app.mount(o), e.$__element = o;\n  },\n  Xl = e => {\n    var o;\n    const t = e.$__element;\n    (o = e.$__app) == null || o.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {\n      t == null || t.remove();\n    }, 0), delete e.$__element;\n  },\n  wa = (e, t, o) => t.concat([\"sm\", \"md\", \"lg\", \"xl\", \"xxl\"]).reduce((a, l) => (a[e ? `${e}${l.charAt(0).toUpperCase() + l.slice(1)}` : l] = o, a), /* @__PURE__ */Object.create(null)),\n  Kl = (e, t, o, a = o) => Object.keys(t).reduce((l, n) => (e[n] && l.push([a, n.replace(o, \"\"), e[n]].filter(i => i && typeof i != \"boolean\").join(\"-\").toLowerCase()), l), []),\n  ia = e => typeof e == \"string\" ? bo(e) : e.label !== void 0 ? e.label : typeof e.key == \"string\" ? bo(e.key) : e.key,\n  qt = (e = \"\") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`,\n  Yi = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((o, a) => (typeof a.type == \"symbol\" ? o = o.concat(a.children) : o.push(a), o), []).filter(o => {\n    var a;\n    return ((a = o.type) == null ? void 0 : a.__name) === t;\n  }),\n  Po = e => e !== null && typeof e == \"object\",\n  Zi = e => /^[0-9]*\\.?[0-9]+$/.test(String(e)),\n  Ji = e => !!(e.href || e.to),\n  Yl = Symbol(\"carousel\"),\n  Zl = Symbol(\"tabs\"),\n  Jl = Symbol(\"progress\"),\n  Ql = Symbol(\"listGroup\"),\n  en = Symbol(\"avatarGroup\"),\n  tn = Symbol(\"accordion\"),\n  an = Symbol(\"checkboxGroup\"),\n  on = Symbol(\"radioGroup\"),\n  uo = Symbol(\"collapse\"),\n  ln = Symbol(\"collapse\"),\n  co = Symbol(\"navbar\"),\n  jt = (e, t = {}, o = {}) => {\n    const a = [e];\n    let l;\n    for (let n = 0; n < a.length && !l; n++) {\n      const i = a[n];\n      l = o[i];\n    }\n    return l && typeof l == \"function\" ? l(t) : l;\n  },\n  Qi = (e, t = NaN) => {\n    const o = Number.parseInt(e, 10);\n    return Number.isNaN(o) ? t : o;\n  },\n  er = (e, t = NaN) => {\n    const o = Number.parseFloat(e.toString());\n    return Number.isNaN(o) ? t : o;\n  },\n  nn = (e, t) => Object.keys(e).filter(o => !t.map(a => a.toString()).includes(o)).reduce((o, a) => ({\n    ...o,\n    [a]: e[a]\n  }), {}),\n  fo = (e, t) => [...t].reduce((o, a) => (o[a] = e[a], o), {}),\n  No = (e, t, o) => {\n    const a = t.split(/[.[\\]]/g);\n    let l = e;\n    for (const n of a) {\n      if (l === null || l === void 0) return o;\n      n.trim() !== \"\" && (l = l[n]);\n    }\n    return l === void 0 ? o : l;\n  },\n  Io = (e, t) => {\n    const {\n        all: o,\n        ...a\n      } = e,\n      l = {};\n    o && t.forEach(i => {\n      l[i] = o;\n    });\n    const n = {\n      ...l,\n      ...a\n    };\n    return Object.entries(n).filter(([i, s]) => !!s && t.includes(i)).map(([i]) => i);\n  },\n  Lo = (e, t) => t + (e ? ts(e) : \"\"),\n  tr = [\"id\"],\n  ar = /* @__PURE__ */q({\n    __name: \"BAccordion\",\n    props: {\n      flush: {\n        type: [String, Boolean],\n        default: !1\n      },\n      free: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {\n        default: void 0\n      }\n    },\n    emits: [\"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        l = ke(o, \"modelValue\", t, {\n          passive: !0\n        }),\n        n = _e(() => o.id, \"accordion\"),\n        i = r(() => o.flush),\n        s = r(() => o.free),\n        u = w(() => ({\n          \"accordion-flush\": i.value\n        }));\n      return at(tn, {\n        openItem: Xe(l),\n        free: s,\n        setOpenItem: d => {\n          l.value = d;\n        }\n      }), (d, f) => (m(), N(\"div\", {\n        id: v(n),\n        class: j([\"accordion\", u.value])\n      }, [A(d.$slots, \"default\")], 10, tr));\n    }\n  }),\n  sn = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BCollapse\",\n    props: {\n      horizontal: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      skipAnimation: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      toggle: {\n        type: [String, Boolean],\n        default: !1\n      },\n      visible: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = (O, F = {}) => new Rt(O, {\n          cancelable: !1,\n          target: b.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...F,\n          componentId: y.value\n        }),\n        i = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = r(i),\n        u = r(() => a.toggle),\n        d = r(() => a.horizontal),\n        f = r(() => a.isNav),\n        g = r(() => a.visible),\n        p = r(() => a.skipAnimation),\n        y = _e(() => a.id, \"collapse\"),\n        b = W(null),\n        V = W(!1),\n        C = W(s.value),\n        c = w(() => ({\n          show: C.value,\n          \"navbar-collapse\": f.value,\n          collapsing: V.value,\n          closing: C.value && !s.value,\n          \"collapse-horizontal\": d.value\n        })),\n        h = () => {\n          i.value = !1;\n        },\n        B = () => {\n          i.value = !0;\n        },\n        _ = () => {\n          i.value = !s.value;\n        };\n      let k,\n        S,\n        $ = p.value;\n      const I = () => {\n          const O = n(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", O), O.defaultPrevented) {\n            l(\"show-prevented\");\n            return;\n          }\n          clearTimeout(S), clearTimeout(k), C.value = !0, !$ && (V.value = !0, Ne(() => {\n            b.value !== null && (d.value ? b.value.style.width = `${b.value.scrollWidth}px` : b.value.style.height = `${b.value.scrollHeight}px`, k = setTimeout(() => {\n              V.value = !1, l(\"shown\"), b.value !== null && (b.value.style.height = \"\", b.value.style.width = \"\");\n            }, La(b.value)));\n          }));\n        },\n        T = () => {\n          const O = n(\"hide\", {\n            cancelable: !0\n          });\n          if (l(\"hide\", O), O.defaultPrevented) {\n            l(\"hide-prevented\");\n            return;\n          }\n          if (clearTimeout(k), clearTimeout(S), b.value !== null) {\n            if ($) {\n              C.value = !1;\n              return;\n            }\n            V.value ? (b.value.style.height = \"\", b.value.style.width = \"\") : d.value ? b.value.style.width = `${b.value.scrollWidth}px` : b.value.style.height = `${b.value.scrollHeight}px`, b.value.offsetHeight, V.value = !0, Ne(() => {\n              b.value !== null && (b.value.style.height = \"\", b.value.style.width = \"\", S = setTimeout(() => {\n                C.value = !1, V.value = !1, l(\"hidden\");\n              }, La(b.value)));\n            });\n          }\n        };\n      return ue(i, () => {\n        s.value ? I() : T();\n      }), st(() => {\n        b.value !== null && !s.value && u.value && Ne(() => {\n          i.value = !0;\n        });\n      }), ue(p, O => {\n        $ = O;\n      }), g.value && ($ = !0, i.value = !0, Ne(() => {\n        $ = p.value;\n      })), ue(g, O => {\n        $ = !0, O ? B() : h(), Ne(() => {\n          $ = p.value;\n        });\n      }), Oe(b, \"bv-toggle\", () => {\n        i.value = !s.value;\n      }), t({\n        close: h,\n        isNav: f,\n        open: B,\n        toggle: _,\n        visible: Xe(C)\n      }), at(uo, {\n        id: y,\n        close: h,\n        open: B,\n        toggle: _,\n        visible: Xe(C),\n        isNav: f\n      }), (O, F) => (m(), N(ge, null, [A(O.$slots, \"header\", {\n        id: v(y),\n        visible: v(s),\n        toggle: _,\n        open: B,\n        close: h\n      }), (m(), x(se(O.tag), Q({\n        id: v(y),\n        ref_key: \"element\",\n        ref: b,\n        class: [\"collapse\", c.value],\n        \"is-nav\": v(f)\n      }, O.$attrs), {\n        default: R(() => [A(O.$slots, \"default\", {\n          visible: v(s),\n          toggle: _,\n          open: B,\n          close: h\n        })]),\n        _: 3\n      }, 16, [\"id\", \"class\", \"is-nav\"])), A(O.$slots, \"footer\", {\n        id: v(y),\n        visible: v(s),\n        toggle: _,\n        open: B,\n        close: h\n      })], 64));\n    }\n  }),\n  or = [\"aria-expanded\", \"aria-controls\", \"onClick\"],\n  lr = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BAccordionItem\",\n    props: {\n      bodyAttrs: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      buttonAttrs: {\n        default: void 0\n      },\n      buttonClass: {\n        default: void 0\n      },\n      collapseClass: {\n        default: void 0\n      },\n      headerAttrs: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"h2\"\n      },\n      horizontal: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      modelValue: {\n        type: Boolean,\n        default: !1\n      },\n      tag: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      toggle: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      visible: {\n        type: [String, Boolean],\n        default: !1\n      },\n      wrapperAttrs: {\n        default: void 0\n      }\n    },\n    emits: [\"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const {\n          class: o,\n          ...a\n        } = Kt(),\n        l = e,\n        n = t,\n        i = ke(l, \"modelValue\", n, {\n          passive: !0\n        }),\n        s = Ge(tn, null),\n        u = _e(() => l.id, \"accordion_item\");\n      return st(() => {\n        i.value && !(s != null && s.free.value) && (s == null || s.setOpenItem(u.value)), !i.value && (s == null ? void 0 : s.openItem.value) === u.value && (i.value = !0);\n      }), ue(() => s == null ? void 0 : s.openItem.value, () => i.value = (s == null ? void 0 : s.openItem.value) === u.value && !(s != null && s.free.value)), ue(i, () => {\n        i.value && !(s != null && s.free.value) && (s == null || s.setOpenItem(u.value));\n      }), (d, f) => (m(), N(\"div\", Q({\n        class: \"accordion-item\"\n      }, d.wrapperAttrs, {\n        class: v(o)\n      }), [ye(sn, Q({\n        id: v(u),\n        modelValue: v(i),\n        \"onUpdate:modelValue\": f[0] || (f[0] = g => ol(i) ? i.value = g : null),\n        class: [\"accordion-collapse\", d.collapseClass],\n        \"aria-labelledby\": `${v(u)}-heading`\n      }, a, {\n        tag: d.tag,\n        toggle: d.toggle,\n        horizontal: d.horizontal,\n        visible: d.visible,\n        \"is-nav\": d.isNav,\n        onShow: f[1] || (f[1] = g => n(\"show\", g)),\n        onShown: f[2] || (f[2] = g => n(\"shown\")),\n        onHide: f[3] || (f[3] = g => n(\"hide\", g)),\n        onHidden: f[4] || (f[4] = g => n(\"hidden\")),\n        onHidePrevented: f[5] || (f[5] = g => n(\"hide-prevented\")),\n        onShowPrevented: f[6] || (f[6] = g => n(\"show-prevented\"))\n      }), {\n        header: R(({\n          visible: g,\n          toggle: p\n        }) => [(m(), x(se(d.headerTag), Q({\n          id: `${v(u)}-heading`,\n          class: [\"accordion-header\", d.headerClass]\n        }, d.headerAttrs), {\n          default: R(() => [ee(\"button\", Q({\n            class: \"accordion-button\"\n          }, d.buttonAttrs, {\n            class: [{\n              collapsed: !g\n            }, d.buttonClass],\n            type: \"button\",\n            \"aria-expanded\": g ? \"true\" : \"false\",\n            \"aria-controls\": v(u),\n            onClick: p\n          }), [A(d.$slots, \"title\", {}, () => [ne(Z(d.title), 1)])], 16, or)]),\n          _: 2\n        }, 1040, [\"id\", \"class\"]))]),\n        default: R(() => [ee(\"div\", Q({\n          class: \"accordion-body\"\n        }, d.bodyAttrs, {\n          class: d.bodyClass\n        }), [A(d.$slots, \"default\")], 16)]),\n        _: 3\n      }, 16, [\"id\", \"modelValue\", \"class\", \"aria-labelledby\", \"tag\", \"toggle\", \"horizontal\", \"visible\", \"is-nav\"])], 16));\n    }\n  }),\n  Mt = /* @__PURE__ */q({\n    __name: \"BTransition\",\n    props: {\n      appear: {\n        type: [String, Boolean],\n        default: !1\n      },\n      mode: {\n        default: void 0\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      transProps: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.appear),\n        a = r(() => t.noFade),\n        l = w(() => {\n          const s = {\n              name: \"\",\n              enterActiveClass: \"\",\n              enterToClass: \"\",\n              leaveActiveClass: \"\",\n              leaveToClass: \"showing\",\n              enterFromClass: \"showing\",\n              leaveFromClass: \"\"\n            },\n            u = {\n              ...s,\n              enterActiveClass: \"fade showing\",\n              leaveActiveClass: \"fade showing\"\n            };\n          return a.value ? s : u;\n        }),\n        n = w(() => ({\n          mode: t.mode,\n          css: !0,\n          ...l.value\n        })),\n        i = w(() => t.transProps !== void 0 ? {\n          // Order matters here since the props.transProps would get overwritten if it came first\n          // But the goal of props.transProps is to overwrite base properties\n          ...n.value,\n          ...t.transProps\n        } : o.value ? {\n          ...n.value,\n          appear: !0,\n          appearActiveClass: l.value.enterActiveClass,\n          appearToClass: l.value.enterToClass\n        } : n.value);\n      return (s, u) => (m(), x(Dn, Se(Ee(i.value)), {\n        default: R(() => [A(s.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  });\nconst nr = [\"type\", \"disabled\", \"aria-label\"],\n  Dt = /* @__PURE__ */q({\n    __name: \"BCloseButton\",\n    props: {\n      ariaLabel: {\n        default: \"Close\"\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      type: {\n        default: \"button\"\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = r(() => o.disabled);\n      return (n, i) => (m(), N(\"button\", {\n        type: n.type,\n        class: \"btn-close\",\n        disabled: v(l),\n        \"aria-label\": n.ariaLabel,\n        onClick: i[0] || (i[0] = s => a(\"click\", s))\n      }, null, 8, nr));\n    }\n  }),\n  sr = {\n    key: 0,\n    class: \"visually-hidden\"\n  },\n  ka = /* @__PURE__ */q({\n    __name: \"BSpinner\",\n    props: {\n      label: {\n        default: void 0\n      },\n      role: {\n        default: \"status\"\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      type: {\n        default: \"border\"\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Me(),\n        a = r(() => t.small),\n        l = w(() => [`spinner-${t.type}`, {\n          [`spinner-${t.type}-sm`]: a.value,\n          [`text-${t.variant}`]: t.variant !== null\n        }]),\n        n = E(() => !Ie(o.label));\n      return (i, s) => (m(), x(se(i.tag), {\n        class: j(l.value),\n        role: i.label || n.value ? i.role : null,\n        \"aria-hidden\": i.label || n.value ? null : !0\n      }, {\n        default: R(() => [i.label || n.value ? (m(), N(\"span\", sr, [A(i.$slots, \"label\", {}, () => [ne(Z(i.label), 1)])])) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\", \"role\", \"aria-hidden\"]));\n    }\n  }),\n  Fo = \"active\",\n  rt = /* @__PURE__ */q({\n    __name: \"BLink\",\n    props: {\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: \"router-link-active\"\n      },\n      append: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      exactActiveClass: {\n        default: \"router-link-exact-active\"\n      },\n      event: {\n        default: \"click\"\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: !1\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: !1\n      },\n      routerComponentName: {\n        default: \"router-link\"\n      },\n      routerTag: {\n        default: \"a\"\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: null\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = Kt(),\n        n = r(() => o.active),\n        i = r(() => o.icon);\n      r(() => o.append);\n      const s = r(() => o.disabled);\n      r(() => o.replace);\n      const u = Ge(uo, null),\n        d = Ge(co, null),\n        f = Ht(),\n        g = w(() => {\n          const c = o.routerComponentName.split(\"-\").map(B => B.charAt(0).toUpperCase() + B.slice(1)).join(\"\");\n          return !((f == null ? void 0 : f.appContext.app.component(c)) !== void 0) || s.value || !o.to ? \"a\" : o.routerComponentName;\n        }),\n        p = w(() => {\n          const c = \"#\";\n          if (o.href) return o.href;\n          if (typeof o.to == \"string\") return o.to || c;\n          const {\n            to: h\n          } = o;\n          if (h !== void 0 && \"path\" in h) {\n            const B = h.path || \"\",\n              _ = h.query ? `?${Object.keys(h.query).map(S => {\n                var $;\n                return `${S}=${($ = h.query) == null ? void 0 : $[S]}`;\n              }).join(\"=\")}` : \"\",\n              k = !h.hash || h.hash.charAt(0) === \"#\" ? h.hash || \"\" : `#${h.hash}`;\n            return `${B}${_}${k}` || c;\n          }\n          return c;\n        }),\n        y = w(() => ({\n          [`link-${o.variant}`]: o.variant !== null,\n          [`link-opacity-${o.opacity}`]: o.opacity !== void 0,\n          [`link-opacity-${o.opacityHover}-hover`]: o.opacityHover !== void 0,\n          [`link-underline-${o.underlineVariant}`]: o.underlineVariant !== null,\n          [`link-offset-${o.underlineOffset}`]: o.underlineOffset !== void 0,\n          [`link-offset-${o.underlineOffsetHover}-hover`]: o.underlineOffsetHover !== void 0,\n          [`link-underline-opacity-${o.underlineOpacity}`]: o.underlineOpacity !== void 0,\n          [`link-underline-opacity-${o.underlineOpacityHover}-hover`]: o.underlineOpacityHover !== void 0,\n          \"icon-link\": i.value === !0\n        })),\n        b = w(() => ({\n          class: y.value,\n          to: o.to,\n          href: p.value,\n          target: o.target,\n          rel: o.target === \"_blank\" ? o.rel ?? \"noopener\" : void 0,\n          tabindex: s.value ? \"-1\" : typeof l.tabindex > \"u\" ? null : l.tabindex,\n          \"aria-disabled\": s.value ? !0 : null\n        })),\n        V = w(() => ({\n          [Fo]: n.value,\n          disabled: s.value\n        })),\n        C = c => {\n          var h, B, _;\n          if (s.value) {\n            c.preventDefault(), c.stopImmediatePropagation();\n            return;\n          }\n          (((h = u == null ? void 0 : u.isNav) == null ? void 0 : h.value) === !0 && d === null || d !== null && ((B = d.autoClose) == null ? void 0 : B.value) === !0) && ((_ = u == null ? void 0 : u.close) == null || _.call(u)), a(\"click\", c);\n        };\n      return (c, h) => g.value === \"router-link\" ? (m(), x(se(g.value), Q({\n        key: 0\n      }, b.value, {\n        custom: \"\"\n      }), {\n        default: R(({\n          href: B,\n          navigate: _,\n          isActive: k,\n          isExactActive: S\n        }) => [(m(), x(se(c.routerTag), Q({\n          href: B,\n          class: {\n            [Fo]: v(n),\n            [c.activeClass]: k,\n            [c.exactActiveClass]: S\n          }\n        }, c.$attrs, {\n          onClick: $ => {\n            _($), C($);\n          }\n        }), {\n          default: R(() => [A(c.$slots, \"default\")]),\n          _: 2\n        }, 1040, [\"href\", \"class\", \"onClick\"]))]),\n        _: 3\n      }, 16)) : (m(), x(se(g.value), Q({\n        key: 1,\n        class: V.value\n      }, b.value, {\n        onClick: C\n      }), {\n        default: R(() => [A(c.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  pt = /* @__PURE__ */q({\n    __name: \"BButton\",\n    props: {\n      loading: {\n        type: [String, Boolean],\n        default: !1\n      },\n      loadingFill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      loadingText: {\n        default: \"Loading...\"\n      },\n      pill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pressed: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      squared: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"button\"\n      },\n      type: {\n        default: \"button\"\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      event: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      routerTag: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      }\n    },\n    emits: [\"click\", \"update:pressed\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = ke(o, \"pressed\", a),\n        n = r(() => o.active),\n        i = r(() => o.disabled),\n        s = r(() => o.pill),\n        u = r(() => o.pressed),\n        d = r(() => o.squared),\n        f = r(() => o.loading),\n        g = r(() => o.loadingFill),\n        {\n          computedLink: p,\n          computedLinkProps: y\n        } = Ct(o, [\"active-class\", \"exact-active-class\", \"event\", \"replace\", \"router-component-name\", \"router-tag\"]),\n        b = E(() => typeof u.value == \"boolean\"),\n        V = E(() => o.tag === \"button\" && o.href === void 0 && o.to === void 0),\n        C = E(() => o.to !== void 0),\n        c = E(() => o.href !== void 0 ? !1 : !V.value),\n        h = w(() => C.value ? y.value : []),\n        B = w(() => [[`btn-${o.size}`], {\n          [`btn-${o.variant}`]: o.variant !== null,\n          active: n.value || u.value,\n          \"rounded-pill\": s.value,\n          \"rounded-0\": d.value,\n          disabled: i.value\n        }]),\n        _ = E(() => C.value ? rt : o.href ? \"a\" : o.tag),\n        k = S => {\n          if (i.value) {\n            S.preventDefault(), S.stopPropagation();\n            return;\n          }\n          a(\"click\", S), b.value && (l.value = !u.value);\n        };\n      return (S, $) => (m(), x(se(_.value), Q({\n        class: \"btn\"\n      }, h.value, {\n        class: B.value,\n        \"aria-disabled\": c.value ? v(i) : null,\n        \"aria-pressed\": b.value ? v(u) : null,\n        autocomplete: b.value ? \"off\" : null,\n        disabled: V.value ? v(i) : null,\n        href: S.href,\n        rel: v(p) ? S.rel : null,\n        role: c.value || v(p) ? \"button\" : null,\n        target: v(p) ? S.target : null,\n        type: V.value ? S.type : null,\n        to: V.value ? null : S.to,\n        append: v(p) ? S.append : null,\n        onClick: k\n      }), {\n        default: R(() => [v(f) ? A(S.$slots, \"loading\", {\n          key: 0\n        }, () => [v(g) ? J(\"\", !0) : (m(), N(ge, {\n          key: 0\n        }, [ne(Z(S.loadingText), 1)], 64)), A(S.$slots, \"loading-spinner\", {}, () => [ye(ka, {\n          small: S.size !== \"lg\",\n          label: v(g) ? S.loadingText : void 0\n        }, null, 8, [\"small\", \"label\"])])]) : A(S.$slots, \"default\", {\n          key: 1\n        })]),\n        _: 3\n      }, 16, [\"class\", \"aria-disabled\", \"aria-pressed\", \"autocomplete\", \"disabled\", \"href\", \"rel\", \"role\", \"target\", \"type\", \"to\", \"append\"]));\n    }\n  }),\n  ir = /* @__PURE__ */q({\n    __name: \"BAlert\",\n    props: {\n      closeClass: {\n        default: void 0\n      },\n      closeContent: {\n        default: void 0\n      },\n      closeLabel: {\n        default: \"Close\"\n      },\n      closeVariant: {\n        default: \"secondary\"\n      },\n      dismissible: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      immediate: {\n        type: [String, Boolean],\n        default: !0\n      },\n      interval: {\n        default: 1e3\n      },\n      modelValue: {\n        type: [Boolean, Number],\n        default: !1\n      },\n      noHoverPause: {\n        type: [String, Boolean],\n        default: !1\n      },\n      showOnPause: {\n        type: [String, Boolean],\n        default: !0\n      },\n      variant: {\n        default: \"info\"\n      }\n    },\n    emits: [\"close\", \"close-countdown\", \"closed\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = Me(),\n        i = W(null),\n        s = ke(a, \"modelValue\", l),\n        u = lo(i),\n        d = r(() => a.dismissible),\n        f = r(() => a.fade),\n        g = r(() => a.immediate),\n        p = r(() => a.showOnPause),\n        y = r(() => a.noHoverPause),\n        b = he(() => a.interval),\n        V = E(() => !Ie(n.close)),\n        C = E(() => typeof s.value == \"boolean\" ? 0 : s.value),\n        c = w(() => ({\n          [`alert-${a.variant}`]: a.variant !== null,\n          \"alert-dismissible\": d.value\n        })),\n        h = w(() => [a.closeClass, {\n          \"btn-close-custom\": V.value\n        }]),\n        {\n          isActive: B,\n          pause: _,\n          restart: k,\n          resume: S,\n          stop: $,\n          isPaused: I,\n          value: T\n        } = zl(C, b, {\n          immediate: typeof s.value == \"number\" && g.value\n        }),\n        O = E(() => typeof s.value == \"boolean\" ? s.value : B.value || p.value && I.value),\n        F = w(() => ({\n          variant: V.value ? a.closeVariant : void 0,\n          class: h.value\n        }));\n      Xt(() => {\n        l(\"close-countdown\", T.value);\n      });\n      const K = () => {\n          l(\"close\"), typeof s.value == \"boolean\" ? s.value = !1 : (s.value = 0, $()), l(\"closed\");\n        },\n        z = () => {\n          y.value || _();\n        };\n      return ue(u, P => {\n        if (P) {\n          z();\n          return;\n        }\n        S();\n      }), Wa($), t({\n        pause: _,\n        restart: k,\n        resume: S,\n        stop: $\n      }), (P, D) => (m(), x(Mt, {\n        \"no-fade\": !v(f),\n        \"trans-props\": {\n          enterToClass: \"show\"\n        }\n      }, {\n        default: R(() => [O.value ? (m(), N(\"div\", {\n          key: 0,\n          ref_key: \"element\",\n          ref: i,\n          class: j([\"alert\", c.value]),\n          role: \"alert\",\n          \"aria-live\": \"polite\",\n          \"aria-atomic\": \"true\"\n        }, [A(P.$slots, \"default\", {}, void 0, !0), v(d) ? (m(), N(ge, {\n          key: 0\n        }, [V.value || P.closeContent ? (m(), x(pt, Q({\n          key: 0\n        }, F.value, {\n          onClick: K\n        }), {\n          default: R(() => [A(P.$slots, \"close\", {}, () => [ne(Z(P.closeContent), 1)], !0)]),\n          _: 3\n        }, 16)) : (m(), x(Dt, Q({\n          key: 1,\n          \"aria-label\": P.closeLabel\n        }, F.value, {\n          onClick: K\n        }), null, 16, [\"aria-label\"]))], 64)) : J(\"\", !0)], 2)) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"no-fade\"]));\n    }\n  });\nconst $a = (e, t) => {\n    const o = e.__vccOpts || e;\n    for (const [a, l] of t) o[a] = l;\n    return o;\n  },\n  rr = /* @__PURE__ */$a(ir, [[\"__scopeId\", \"data-v-e683f25c\"]]),\n  ur = {\n    key: 0,\n    class: \"b-avatar-custom\"\n  },\n  dr = {\n    key: 1,\n    class: \"b-avatar-img\"\n  },\n  cr = [\"src\", \"alt\"],\n  Ra = e => {\n    const t = typeof e == \"string\" && Zi(e) ? er(e, 0) : e;\n    return typeof t == \"number\" ? `${t}px` : t || null;\n  },\n  fr = /* @__PURE__ */q({\n    __name: \"BAvatar\",\n    props: {\n      alt: {\n        default: \"avatar\"\n      },\n      badge: {\n        type: [Boolean, String],\n        default: !1\n      },\n      badgeBgVariant: {\n        default: null\n      },\n      badgeOffset: {\n        default: void 0\n      },\n      badgeStart: {\n        type: [String, Boolean],\n        default: !1\n      },\n      badgeTextVariant: {\n        default: null\n      },\n      badgeTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      badgeVariant: {\n        default: \"primary\"\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonType: {\n        default: \"button\"\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      size: {\n        default: void 0\n      },\n      square: {\n        type: [String, Boolean],\n        default: !1\n      },\n      src: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      },\n      rounded: {\n        type: [String, Number, Boolean],\n        default: !1\n      },\n      roundedTop: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedStart: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [String, Number, Boolean],\n        default: void 0\n      }\n    },\n    emits: [\"click\", \"img-error\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = Me(),\n        {\n          computedLink: n,\n          computedLinkProps: i\n        } = Ct(o),\n        s = Ge(en, null),\n        u = [\"sm\", null, \"lg\"],\n        d = 0.4,\n        f = d * 0.7,\n        g = r(() => o.badgeStart),\n        p = r(() => o.badgeTop),\n        y = r(() => o.button),\n        b = r(() => o.disabled),\n        V = r(() => o.square),\n        C = r(() => o.rounded),\n        c = r(() => o.roundedTop),\n        h = r(() => o.roundedBottom),\n        B = r(() => o.roundedStart),\n        _ = r(() => o.roundedEnd),\n        k = E(() => !Ie(l.default)),\n        S = E(() => !Ie(l.badge)),\n        $ = E(() => !!o.badge || o.badge === \"\" || S.value),\n        I = E(() => (s == null ? void 0 : s.size.value) ?? V.value),\n        T = E(() => (s == null ? void 0 : s.size.value) ?? Ra(o.size)),\n        O = E(() => (s == null ? void 0 : s.variant.value) ?? o.variant),\n        F = E(() => (s == null ? void 0 : s.rounded.value) ?? C.value),\n        K = E(() => (s == null ? void 0 : s.roundedTop.value) ?? c.value),\n        z = E(() => (s == null ? void 0 : s.roundedBottom.value) ?? h.value),\n        P = E(() => (s == null ? void 0 : s.roundedStart.value) ?? B.value),\n        D = E(() => (s == null ? void 0 : s.roundedEnd.value) ?? _.value),\n        ae = io(() => ({\n          rounded: F.value,\n          roundedTop: K.value,\n          roundedBottom: z.value,\n          roundedStart: P.value,\n          roundedEnd: D.value\n        })),\n        le = Qe(() => ({\n          variant: o.badgeVariant,\n          bgVariant: o.badgeBgVariant,\n          textVariant: o.badgeTextVariant\n        })),\n        ve = E(() => o.badge === !0 ? \"\" : o.badge),\n        Be = E(() => (s == null ? void 0 : s.textVariant.value) ?? o.textVariant),\n        Ve = E(() => (s == null ? void 0 : s.bgVariant.value) ?? o.bgVariant),\n        oe = Qe(() => ({\n          bgVariant: Ve.value,\n          textVariant: Be.value,\n          variant: O.value\n        })),\n        fe = w(() => [oe.value,\n        // Square overwrites all else\n        I.value === !0 ? void 0 : ae.value, {\n          [`b-avatar-${o.size}`]: !!o.size && u.indexOf(Ra(o.size)) !== -1,\n          [`btn-${O.value}`]: y.value ? O.value !== null : !1,\n          badge: !y.value && O.value !== null && k.value,\n          btn: y.value,\n          // Square is the same as rounded-0 class\n          \"rounded-0\": I.value === !0\n        }]),\n        $e = w(() => {\n          const X = o.badgeOffset || \"0px\";\n          return {\n            fontSize: (u.indexOf(T.value || null) === -1 ? `calc(${T.value} * ${f})` : \"\") || \"\",\n            top: p.value ? X : \"\",\n            bottom: p.value ? \"\" : X,\n            left: g.value ? X : \"\",\n            right: g.value ? \"\" : X\n          };\n        }),\n        we = w(() => {\n          const X = u.indexOf(T.value || null) === -1 ? `calc(${T.value} * ${d})` : null;\n          return X ? {\n            fontSize: X\n          } : {};\n        }),\n        M = w(() => {\n          var be;\n          const X = ((be = s == null ? void 0 : s.overlapScale) == null ? void 0 : be.value) || 0,\n            te = T.value && X ? `calc(${T.value} * -${X})` : null;\n          return te ? {\n            marginLeft: te,\n            marginRight: te\n          } : {};\n        }),\n        L = E(() => n.value ? rt : y.value ? \"button\" : \"span\"),\n        U = w(() => ({\n          ...M.value,\n          width: T.value ?? void 0,\n          height: T.value ?? void 0\n        })),\n        H = X => {\n          !b.value && (n.value || y.value) && a(\"click\", X);\n        },\n        G = X => {\n          a(\"img-error\", X);\n        };\n      return (X, te) => (m(), x(se(L.value), Q({\n        class: [\"b-avatar\", fe.value],\n        style: U.value\n      }, v(i), {\n        type: v(y) && !v(n) ? o.buttonType : void 0,\n        disabled: v(b) || null,\n        onClick: H\n      }), {\n        default: R(() => [k.value ? (m(), N(\"span\", ur, [A(X.$slots, \"default\")])) : X.src ? (m(), N(\"span\", dr, [ee(\"img\", {\n          src: X.src,\n          alt: X.alt,\n          onError: G\n        }, null, 40, cr)])) : X.text ? (m(), N(\"span\", {\n          key: 2,\n          class: \"b-avatar-text\",\n          style: ze(we.value)\n        }, Z(X.text), 5)) : J(\"\", !0), $.value ? (m(), N(\"span\", {\n          key: 3,\n          class: j([\"b-avatar-badge\", v(le)]),\n          style: ze($e.value)\n        }, [A(X.$slots, \"badge\", {}, () => [ne(Z(ve.value), 1)])], 6)) : J(\"\", !0)]),\n        _: 3\n      }, 16, [\"class\", \"style\", \"type\", \"disabled\"]));\n    }\n  }),\n  vr = /* @__PURE__ */q({\n    __name: \"BAvatarGroup\",\n    props: {\n      overlap: {\n        default: 0.3\n      },\n      size: {\n        default: void 0\n      },\n      square: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      },\n      rounded: {\n        type: [String, Number, Boolean],\n        default: !1\n      },\n      roundedTop: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedStart: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [String, Number, Boolean],\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.square),\n        a = r(() => t.rounded),\n        l = r(() => t.roundedTop),\n        n = r(() => t.roundedBottom),\n        i = r(() => t.roundedStart),\n        s = r(() => t.roundedEnd),\n        u = he(() => t.overlap),\n        d = w(() => Ra(t.size)),\n        f = E(() => Math.min(Math.max(u.value, 0), 1) / 2),\n        g = w(() => {\n          const p = d.value ? `calc(${d.value} * ${f.value})` : null;\n          return p ? {\n            paddingLeft: p,\n            paddingRight: p\n          } : {};\n        });\n      return at(en, {\n        overlapScale: f,\n        size: E(() => t.size),\n        square: o,\n        rounded: a,\n        roundedTop: l,\n        roundedBottom: n,\n        roundedStart: i,\n        roundedEnd: s,\n        variant: E(() => t.variant),\n        bgVariant: E(() => t.bgVariant),\n        textVariant: E(() => t.textVariant)\n      }), (p, y) => (m(), x(se(p.tag), {\n        class: \"b-avatar-group\",\n        role: \"group\"\n      }, {\n        default: R(() => [ee(\"div\", {\n          class: \"b-avatar-group-inner\",\n          style: ze(g.value)\n        }, [A(p.$slots, \"default\")], 4)]),\n        _: 3\n      }));\n    }\n  }),\n  pr = /* @__PURE__ */q({\n    __name: \"BBadge\",\n    props: {\n      dotIndicator: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      textIndicator: {\n        type: [String, Boolean],\n        default: !1\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.pill),\n        a = r(() => t.textIndicator),\n        l = r(() => t.dotIndicator),\n        n = r(() => t.active),\n        i = r(() => t.disabled),\n        s = Qe(t),\n        {\n          computedLink: u,\n          computedLinkProps: d\n        } = Ct(t, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"icon\"]),\n        f = E(() => u.value ? rt : t.tag),\n        g = w(() => [s.value, {\n          active: n.value,\n          disabled: i.value,\n          \"rounded-pill\": o.value,\n          \"position-absolute top-0 start-100 translate-middle\": a.value || l.value,\n          \"p-2 border border-light rounded-circle\": l.value,\n          \"text-decoration-none\": u.value\n        }]);\n      return (p, y) => (m(), x(se(f.value), Q({\n        class: [\"badge\", g.value]\n      }, v(d)), {\n        default: R(() => [A(p.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  rn = /* @__PURE__ */q({\n    __name: \"BBreadcrumbItem\",\n    props: {\n      ariaCurrent: {\n        default: \"location\"\n      },\n      text: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = r(() => o.active),\n        n = r(() => o.disabled),\n        i = w(() => ({\n          active: l.value\n        })),\n        s = E(() => l.value ? \"span\" : rt),\n        u = E(() => l.value ? o.ariaCurrent : void 0),\n        d = w(() => s.value !== \"span\" ? fo(o, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"variant\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"icon\"]) : {}),\n        f = g => {\n          if (n.value || l.value) {\n            g.preventDefault(), g.stopImmediatePropagation();\n            return;\n          }\n          n.value || a(\"click\", g);\n        };\n      return (g, p) => (m(), N(\"li\", {\n        class: j([\"breadcrumb-item\", i.value])\n      }, [(m(), x(se(s.value), Q({\n        \"aria-current\": u.value\n      }, d.value, {\n        onClick: f\n      }), {\n        default: R(() => [A(g.$slots, \"default\", {}, () => [ne(Z(g.text), 1)])]),\n        _: 3\n      }, 16, [\"aria-current\"]))], 2));\n    }\n  }),\n  mr = {\n    \"aria-label\": \"breadcrumb\"\n  },\n  gr = {\n    class: \"breadcrumb\"\n  },\n  br = /* @__PURE__ */q({\n    __name: \"BBreadcrumb\",\n    props: {\n      items: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Hl(),\n        a = w(() => {\n          const l = t.items || (o == null ? void 0 : o.items) || [];\n          let n = !1;\n          return l.map((s, u) => (typeof s == \"string\" && (s = {\n            text: s\n          }, u < l.length - 1 && (s.href = \"#\")), s.active && (n = !0), !s.active && !n && (s.active = u + 1 === l.length), s));\n        });\n      return (l, n) => (m(), N(\"nav\", mr, [ee(\"ol\", gr, [A(l.$slots, \"prepend\"), (m(!0), N(ge, null, Te(a.value, (i, s) => (m(), x(rn, Q({\n        key: s\n      }, i), {\n        default: R(() => [ne(Z(i.text), 1)]),\n        _: 2\n      }, 1040))), 128)), A(l.$slots, \"default\"), A(l.$slots, \"append\")])]));\n    }\n  }),\n  yr = /* @__PURE__ */q({\n    __name: \"BButtonGroup\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.vertical),\n        a = w(() => ({\n          \"btn-group\": !o.value,\n          [`btn-group-${t.size}`]: t.size !== \"md\",\n          \"btn-group-vertical\": o.value\n        }));\n      return (l, n) => (m(), x(se(l.tag), {\n        class: j(a.value),\n        role: \"group\",\n        \"aria-label\": l.ariaLabel\n      }, {\n        default: R(() => [A(l.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\", \"aria-label\"]));\n    }\n  }),\n  hr = [\"role\", \"aria-label\"],\n  Br = /* @__PURE__ */q({\n    __name: \"BButtonToolbar\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      justify: {\n        type: [String, Boolean],\n        default: !1\n      },\n      role: {\n        default: \"toolbar\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.justify),\n        a = w(() => ({\n          \"justify-content-between\": o.value\n        }));\n      return (l, n) => (m(), N(\"div\", {\n        class: j([a.value, \"btn-toolbar\"]),\n        role: l.role,\n        \"aria-label\": l.ariaLabel\n      }, [A(l.$slots, \"default\")], 10, hr));\n    }\n  }),\n  Sr = [\"src\", \"width\", \"height\", \"srcset\", \"sizes\", \"loading\"],\n  vo = /* @__PURE__ */q({\n    __name: \"BImg\",\n    props: {\n      blank: {\n        type: [String, Boolean],\n        default: !1\n      },\n      blankColor: {\n        default: \"transparent\"\n      },\n      block: {\n        type: [String, Boolean],\n        default: !1\n      },\n      center: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fluid: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fluidGrow: {\n        type: [String, Boolean],\n        default: !1\n      },\n      height: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      sizes: {\n        default: void 0\n      },\n      src: {\n        default: void 0\n      },\n      srcset: {\n        default: void 0\n      },\n      start: {\n        type: [String, Boolean],\n        default: !1\n      },\n      thumbnail: {\n        type: [String, Boolean],\n        default: !1\n      },\n      width: {\n        default: void 0\n      },\n      rounded: {\n        type: [String, Number, Boolean],\n        default: !1\n      },\n      roundedTop: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedStart: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [String, Number, Boolean],\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.lazy),\n        a = r(() => t.blank),\n        l = r(() => t.block),\n        n = r(() => t.center),\n        i = r(() => t.fluid),\n        s = r(() => t.fluidGrow),\n        u = r(() => t.start),\n        d = r(() => t.end),\n        f = r(() => t.thumbnail),\n        g = he(() => t.height ?? NaN),\n        p = he(() => t.width ?? NaN),\n        y = r(() => t.rounded),\n        b = r(() => t.roundedTop),\n        V = r(() => t.roundedBottom),\n        C = r(() => t.roundedStart),\n        c = r(() => t.roundedEnd),\n        h = io(() => ({\n          rounded: y.value,\n          roundedTop: b.value,\n          roundedBottom: V.value,\n          roundedStart: C.value,\n          roundedEnd: c.value\n        })),\n        B = w(() => typeof t.srcset == \"string\" ? t.srcset.split(\",\").filter(O => O).join(\",\") : Array.isArray(t.srcset) ? t.srcset.filter(O => O).join(\",\") : void 0),\n        _ = w(() => typeof t.sizes == \"string\" ? t.sizes.split(\",\").filter(O => O).join(\",\") : Array.isArray(t.sizes) ? t.sizes.filter(O => O).join(\",\") : void 0),\n        k = w(() => {\n          const O = Number.isNaN(p.value) ? void 0 : p.value,\n            F = Number.isNaN(g.value) ? void 0 : g.value;\n          return a.value ? O !== void 0 && F === void 0 ? {\n            height: O,\n            width: O\n          } : O === void 0 && F !== void 0 ? {\n            height: F,\n            width: F\n          } : {\n            height: 1,\n            width: 1\n          } : {\n            width: O,\n            height: F\n          };\n        }),\n        S = E(() => T(k.value.width, k.value.height, t.blankColor)),\n        $ = E(() => u.value ? \"float-start\" : d.value ? \"float-end\" : n.value ? \"mx-auto\" : void 0),\n        I = w(() => [h.value, {\n          \"img-thumbnail\": f.value,\n          \"img-fluid\": i.value || s.value,\n          \"w-100\": s.value,\n          [`${$.value}`]: $.value !== void 0,\n          \"d-block\": l.value || n.value\n        }]),\n        T = (O, F, K) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width=\"${O}\" height=\"${F}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${O} ${F}\" preserveAspectRatio=\"none\">\n    <rect width=\"100%\" height=\"100%\" style=\"fill:${K};\"></rect>\n    </svg>`)}`;\n      return (O, F) => (m(), N(\"img\", {\n        class: j(I.value),\n        src: v(a) ? S.value : O.src,\n        width: k.value.width || void 0,\n        height: k.value.height || void 0,\n        srcset: v(a) ? void 0 : B.value,\n        sizes: v(a) ? void 0 : _.value,\n        loading: v(o) ? \"lazy\" : \"eager\"\n      }, null, 10, Sr));\n    }\n  }),\n  ya = /* @__PURE__ */q({\n    __name: \"BCardImg\",\n    props: {\n      bottom: {\n        type: [String, Boolean],\n        default: !1\n      },\n      top: {\n        type: [String, Boolean],\n        default: !1\n      },\n      blank: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      blankColor: {\n        default: void 0\n      },\n      block: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      center: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      end: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      fluid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      fluidGrow: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      height: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      sizes: {\n        default: void 0\n      },\n      src: {\n        default: void 0\n      },\n      srcset: {\n        default: void 0\n      },\n      start: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      thumbnail: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      width: {\n        default: void 0\n      },\n      rounded: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedTop: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedStart: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [String, Number, Boolean],\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.bottom),\n        a = r(() => t.end),\n        l = r(() => t.start),\n        n = r(() => t.top),\n        i = E(() => n.value ? \"card-img-top\" : a.value ? \"card-img-right\" : o.value ? \"card-img-bottom\" : l.value ? \"card-img-left\" : \"card-img\"),\n        s = w(() => nn(t, [\"bottom\", \"top\", \"end\", \"start\"]));\n      return (u, d) => (m(), x(vo, Q(s.value, {\n        class: i.value\n      }), null, 16, [\"class\"]));\n    }\n  }),\n  Cr = [\"innerHTML\"],\n  un = /* @__PURE__ */q({\n    __name: \"BCardHeadFoot\",\n    props: {\n      borderVariant: {\n        default: null\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Qe(t),\n        a = w(() => [o.value, {\n          [`border-${t.borderVariant}`]: t.borderVariant !== null\n        }]);\n      return (l, n) => (m(), x(se(l.tag), {\n        class: j(a.value)\n      }, {\n        default: R(() => [l.html ? (m(), N(\"div\", {\n          key: 0,\n          innerHTML: l.html\n        }, null, 8, Cr)) : A(l.$slots, \"default\", {\n          key: 1\n        }, () => [ne(Z(l.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  dn = /* @__PURE__ */q({\n    __name: \"BCardHeader\",\n    props: {\n      borderVariant: {\n        default: void 0\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e;\n      return (o, a) => (m(), x(un, Q({\n        class: \"card-header\"\n      }, t), {\n        default: R(() => [A(o.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  cn = /* @__PURE__ */q({\n    __name: \"BCardTitle\",\n    props: {\n      tag: {\n        default: \"h4\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), x(se(t.tag), {\n        class: \"card-title\"\n      }, {\n        default: R(() => [A(t.$slots, \"default\", {}, () => [ne(Z(t.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  fn = /* @__PURE__ */q({\n    __name: \"BCardSubtitle\",\n    props: {\n      text: {\n        default: void 0\n      },\n      tag: {\n        default: \"h6\"\n      },\n      textVariant: {\n        default: \"body-secondary\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`text-${t.textVariant}`]: t.textVariant !== null\n        }));\n      return (a, l) => (m(), x(se(a.tag), {\n        class: j([\"card-subtitle mb-2\", o.value])\n      }, {\n        default: R(() => [A(a.$slots, \"default\", {}, () => [ne(Z(a.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  vn = /* @__PURE__ */q({\n    __name: \"BCardBody\",\n    props: {\n      overlay: {\n        type: [String, Boolean],\n        default: !1\n      },\n      subtitle: {\n        default: void 0\n      },\n      subtitleTag: {\n        default: \"h4\"\n      },\n      subtitleTextVariant: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      titleTag: {\n        default: \"h4\"\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Me(),\n        a = r(() => t.overlay),\n        l = Qe(t),\n        n = E(() => !Ie(o.title)),\n        i = E(() => !Ie(o.subtitle)),\n        s = w(() => [l.value, {\n          \"card-img-overlay\": a.value\n        }]);\n      return (u, d) => (m(), x(se(u.tag), {\n        class: j([\"card-body\", s.value])\n      }, {\n        default: R(() => [u.title || n.value ? (m(), x(cn, {\n          key: 0,\n          tag: u.titleTag\n        }, {\n          default: R(() => [A(u.$slots, \"title\", {}, () => [ne(Z(u.title), 1)])]),\n          _: 3\n        }, 8, [\"tag\"])) : J(\"\", !0), u.subtitle || i.value ? (m(), x(fn, {\n          key: 1,\n          tag: u.subtitleTag,\n          \"text-variant\": u.subtitleTextVariant\n        }, {\n          default: R(() => [A(u.$slots, \"subtitle\", {}, () => [ne(Z(u.subtitle), 1)])]),\n          _: 3\n        }, 8, [\"tag\", \"text-variant\"])) : J(\"\", !0), A(u.$slots, \"default\", {}, () => [ne(Z(u.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  pn = /* @__PURE__ */q({\n    __name: \"BCardFooter\",\n    props: {\n      borderVariant: {\n        default: void 0\n      },\n      html: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e;\n      return (o, a) => (m(), x(un, Q({\n        class: \"card-footer\"\n      }, t), {\n        default: R(() => [A(o.$slots, \"default\", {}, () => [ne(Z(o.text), 1)])]),\n        _: 3\n      }, 16));\n    }\n  }),\n  mn = /* @__PURE__ */q({\n    __name: \"BCard\",\n    props: {\n      align: {\n        default: void 0\n      },\n      bodyBgVariant: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyTag: {\n        default: \"div\"\n      },\n      bodyText: {\n        default: \"\"\n      },\n      bodyTextVariant: {\n        default: void 0\n      },\n      borderVariant: {\n        default: null\n      },\n      footer: {\n        default: void 0\n      },\n      footerBgVariant: {\n        default: void 0\n      },\n      footerBorderVariant: {\n        default: void 0\n      },\n      footerClass: {\n        default: void 0\n      },\n      footerHtml: {\n        default: \"\"\n      },\n      footerTag: {\n        default: \"div\"\n      },\n      footerTextVariant: {\n        default: void 0\n      },\n      footerVariant: {\n        default: null\n      },\n      header: {\n        default: void 0\n      },\n      headerBgVariant: {\n        default: void 0\n      },\n      headerBorderVariant: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerHtml: {\n        default: \"\"\n      },\n      headerTag: {\n        default: \"div\"\n      },\n      headerTextVariant: {\n        default: void 0\n      },\n      headerVariant: {\n        default: null\n      },\n      imgAlt: {\n        default: void 0\n      },\n      imgBottom: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgEnd: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgSrc: {\n        default: void 0\n      },\n      imgStart: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgWidth: {\n        default: void 0\n      },\n      noBody: {\n        type: [String, Boolean],\n        default: !1\n      },\n      overlay: {\n        type: [String, Boolean],\n        default: !1\n      },\n      subtitle: {\n        default: void 0\n      },\n      subtitleTag: {\n        default: \"h6\"\n      },\n      subtitleTextVariant: {\n        default: \"body-secondary\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      title: {\n        default: void 0\n      },\n      titleTag: {\n        default: \"h4\"\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Me(),\n        a = r(() => t.imgBottom),\n        l = r(() => t.imgEnd),\n        n = r(() => t.imgStart),\n        i = r(() => t.noBody),\n        s = E(() => !Ie(o.header)),\n        u = E(() => !Ie(o.footer)),\n        d = Qe(t),\n        f = w(() => [d.value, {\n          [`text-${t.align}`]: t.align !== void 0,\n          [`border-${t.borderVariant}`]: t.borderVariant !== null,\n          \"flex-row\": n.value,\n          \"flex-row-reverse\": l.value\n        }]),\n        g = w(() => ({\n          src: t.imgSrc,\n          alt: t.imgAlt,\n          height: t.imgHeight,\n          width: t.imgWidth,\n          bottom: t.imgBottom,\n          end: t.imgEnd,\n          start: t.imgStart,\n          top: t.imgTop\n        }));\n      return (p, y) => (m(), x(se(p.tag), {\n        class: j([\"card\", f.value])\n      }, {\n        default: R(() => [v(a) ? J(\"\", !0) : A(p.$slots, \"img\", {\n          key: 0\n        }, () => [p.imgSrc ? (m(), x(ya, Se(Q({\n          key: 0\n        }, g.value)), null, 16)) : J(\"\", !0)]), p.header || s.value || p.headerHtml ? (m(), x(dn, {\n          key: 1,\n          \"bg-variant\": p.headerBgVariant,\n          variant: p.headerVariant,\n          \"border-variant\": p.headerBorderVariant,\n          html: p.headerHtml,\n          tag: p.headerTag,\n          \"text-variant\": p.headerTextVariant,\n          class: j(p.headerClass)\n        }, {\n          default: R(() => [A(p.$slots, \"header\", {}, () => [ne(Z(p.header), 1)])]),\n          _: 3\n        }, 8, [\"bg-variant\", \"variant\", \"border-variant\", \"html\", \"tag\", \"text-variant\", \"class\"])) : J(\"\", !0), v(i) ? A(p.$slots, \"default\", {\n          key: 3\n        }, () => [ne(Z(p.bodyText), 1)]) : (m(), x(vn, {\n          key: 2,\n          overlay: p.overlay,\n          \"bg-variant\": p.bodyBgVariant,\n          tag: p.bodyTag,\n          \"text-variant\": p.bodyTextVariant,\n          subtitle: p.subtitle,\n          \"subtitle-tag\": p.subtitleTag,\n          \"subtitle-text-variant\": p.subtitleTextVariant,\n          title: p.title,\n          \"title-tag\": p.titleTag,\n          class: j(p.bodyClass)\n        }, {\n          default: R(() => [A(p.$slots, \"default\", {}, () => [ne(Z(p.bodyText), 1)])]),\n          _: 3\n        }, 8, [\"overlay\", \"bg-variant\", \"tag\", \"text-variant\", \"subtitle\", \"subtitle-tag\", \"subtitle-text-variant\", \"title\", \"title-tag\", \"class\"])), p.footer || u.value || p.footerHtml ? (m(), x(pn, {\n          key: 4,\n          \"bg-variant\": p.footerBgVariant,\n          \"border-variant\": p.footerBorderVariant,\n          variant: p.footerVariant,\n          html: p.footerHtml,\n          tag: p.footerTag,\n          \"text-variant\": p.footerTextVariant,\n          class: j(p.footerClass)\n        }, {\n          default: R(() => [A(p.$slots, \"footer\", {}, () => [ne(Z(p.footer), 1)])]),\n          _: 3\n        }, 8, [\"bg-variant\", \"border-variant\", \"variant\", \"html\", \"tag\", \"text-variant\", \"class\"])) : J(\"\", !0), v(a) ? A(p.$slots, \"img\", {\n          key: 5\n        }, () => [p.imgSrc ? (m(), x(ya, Se(Q({\n          key: 0\n        }, g.value)), null, 16)) : J(\"\", !0)]) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  wr = /* @__PURE__ */q({\n    __name: \"BCardGroup\",\n    props: {\n      columns: {\n        type: [String, Boolean],\n        default: !1\n      },\n      deck: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.columns),\n        a = r(() => t.deck),\n        l = E(() => a.value ? \"card-deck\" : o.value ? \"card-columns\" : \"card-group\");\n      return (n, i) => (m(), x(se(n.tag), {\n        class: j(l.value)\n      }, {\n        default: R(() => [A(n.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  kr = /* @__PURE__ */q({\n    __name: \"BCardText\",\n    props: {\n      tag: {\n        default: \"p\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), x(se(t.tag), {\n        class: \"card-text\"\n      }, {\n        default: R(() => [A(t.$slots, \"default\", {}, () => [ne(Z(t.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  $r = [\"id\"],\n  Tr = {\n    key: 0,\n    class: \"carousel-indicators\"\n  },\n  _r = [\"aria-current\", \"aria-label\", \"onClick\"],\n  Vr = /* @__PURE__ */ee(\"span\", {\n    class: \"carousel-control-prev-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  Ar = {\n    class: \"visually-hidden\"\n  },\n  Or = /* @__PURE__ */ee(\"span\", {\n    class: \"carousel-control-next-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  Er = {\n    class: \"visually-hidden\"\n  },\n  Pr = /* @__PURE__ */q({\n    __name: \"BCarousel\",\n    props: {\n      background: {\n        default: void 0\n      },\n      controls: {\n        type: [String, Boolean],\n        default: !1\n      },\n      controlsNextText: {\n        default: \"Next\"\n      },\n      controlsPrevText: {\n        default: \"Previous\"\n      },\n      fade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgWidth: {\n        default: void 0\n      },\n      indicators: {\n        type: [String, Boolean],\n        default: !1\n      },\n      indicatorsButtonLabel: {\n        default: \"Slide\"\n      },\n      interval: {\n        default: 5e3\n      },\n      keyboard: {\n        type: [String, Boolean],\n        default: !0\n      },\n      modelValue: {\n        default: 0\n      },\n      noHoverPause: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noTouch: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noWrap: {\n        type: [String, Boolean],\n        default: !1\n      },\n      ride: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rideReverse: {\n        type: [String, Boolean],\n        default: !1\n      },\n      touchThreshold: {\n        default: 50\n      }\n    },\n    emits: [\"slide\", \"slid\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = Me(),\n        i = _e(() => a.id, \"carousel\"),\n        s = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        u = r(() => a.keyboard),\n        d = r(() => a.rideReverse),\n        f = r(() => a.noHoverPause),\n        g = r(() => a.fade),\n        p = r(() => a.controls),\n        y = r(() => a.indicators),\n        b = r(() => a.noTouch),\n        V = r(() => a.noWrap),\n        C = he(() => a.touchThreshold),\n        c = he(() => a.interval),\n        h = r(() => a.ride),\n        B = W(!1),\n        _ = W(!1),\n        k = W(!0),\n        S = W(null),\n        $ = W(null),\n        I = W(s.value),\n        T = lo($),\n        O = E(() => `carousel-item carousel-item-${k.value ? \"prev\" : \"next\"} carousel-item-${k.value ? \"end\" : \"start\"}`),\n        F = E(() => `carousel-item active carousel-item-${k.value ? \"start\" : \"end\"}`),\n        {\n          pause: K,\n          resume: z\n        } = Il(() => {\n          d.value ? Be() : Ve();\n        }, c, {\n          immediate: h.value === \"carousel\"\n        }),\n        P = E(() => h.value === !0 && _.value === !0 || h.value === \"carousel\"),\n        D = w(() => Yi(n.default, \"BCarouselSlide\")),\n        ae = w(() => ({\n          \"carousel-fade\": g.value\n        })),\n        le = H => {\n          var G;\n          return new ll(H, {\n            componentId: i.value,\n            cancelable: !1,\n            target: $.value,\n            direction: k.value ? \"right\" : \"left\",\n            from: I.value,\n            to: s.value,\n            relatedTarget: ((G = S.value) == null ? void 0 : G.children[s.value]) ?? null\n          });\n        },\n        ve = H => {\n          if (B.value !== !0) {\n            if (h.value === !0 && (_.value = !0), P.value === !0 && z(), k.value = !(H < s.value), H >= D.value.length) {\n              if (V.value) return;\n              s.value = 0;\n              return;\n            }\n            if (H < 0) {\n              if (V.value) return;\n              s.value = D.value.length - 1;\n              return;\n            }\n            I.value = s.value, s.value = H;\n          }\n        },\n        Be = () => {\n          ve(s.value - 1);\n        },\n        Ve = () => {\n          ve(s.value + 1);\n        },\n        oe = H => {\n          u.value !== !1 && H();\n        },\n        fe = () => {\n          f.value || K();\n        },\n        $e = () => {\n          P.value && z();\n        },\n        {\n          lengthX: we\n        } = Fi($, {\n          passive: !0,\n          onSwipeStart() {\n            b.value !== !0 && K();\n          },\n          onSwipeEnd() {\n            if (b.value === !0) return;\n            const H = () => {\n              P.value !== !1 && z();\n            };\n            if (we.value >= C.value) {\n              Ve(), H();\n              return;\n            }\n            we.value <= -C.value && (Be(), H());\n          }\n        }),\n        M = () => {\n          l(\"slide\", le(\"slide\")), B.value = !0;\n        },\n        L = () => {\n          l(\"slid\", le(\"slid\")), B.value = !1;\n        },\n        U = H => {\n          s.value !== 0 && H.classList.add(\"carousel-item\");\n        };\n      return qe(\"ArrowLeft\", () => {\n        oe(Be);\n      }, {\n        target: $\n      }), qe(\"ArrowRight\", () => {\n        oe(Ve);\n      }, {\n        target: $\n      }), ue(h, () => {\n        _.value = !1;\n      }), ue(T, H => {\n        if (H) {\n          fe();\n          return;\n        }\n        $e();\n      }), t({\n        next: Ve,\n        pause: K,\n        prev: Be,\n        resume: z\n      }), at(Yl, {\n        background: E(() => a.background),\n        width: E(() => a.imgWidth),\n        height: E(() => a.imgHeight)\n      }), (H, G) => (m(), N(\"div\", {\n        id: v(i),\n        ref_key: \"element\",\n        ref: $,\n        class: j([\"carousel slide pointer-event\", ae.value])\n      }, [v(y) ? (m(), N(\"div\", Tr, [(m(!0), N(ge, null, Te(D.value.length, (X, te) => (m(), N(\"button\", {\n        key: te,\n        type: \"button\",\n        \"data-bs-target\": \"\",\n        class: j(te === v(s) ? \"active\" : \"\"),\n        \"aria-current\": te === v(s) ? !0 : void 0,\n        \"aria-label\": `${H.indicatorsButtonLabel} ${te}`,\n        onClick: be => ve(te)\n      }, null, 10, _r))), 128))])) : J(\"\", !0), ee(\"div\", {\n        ref_key: \"relatedTarget\",\n        ref: S,\n        class: \"carousel-inner\"\n      }, [ye(jn, {\n        \"enter-from-class\": O.value,\n        \"enter-active-class\": O.value,\n        \"enter-to-class\": O.value,\n        \"leave-from-class\": F.value,\n        \"leave-active-class\": F.value,\n        \"leave-to-class\": F.value,\n        onBeforeLeave: M,\n        onAfterLeave: L,\n        onAfterEnter: U\n      }, {\n        default: R(() => [(m(!0), N(ge, null, Te(D.value, (X, te) => ht((m(), x(se(X), {\n          key: te,\n          class: j({\n            active: te === v(s) && B.value === !1\n          })\n        }, null, 8, [\"class\"])), [[ha, te === v(s)]])), 128))]),\n        _: 1\n      }, 8, [\"enter-from-class\", \"enter-active-class\", \"enter-to-class\", \"leave-from-class\", \"leave-active-class\", \"leave-to-class\"])], 512), v(p) ? (m(), N(ge, {\n        key: 1\n      }, [ee(\"button\", {\n        class: \"carousel-control-prev\",\n        type: \"button\",\n        onClick: Be\n      }, [Vr, ee(\"span\", Ar, Z(H.controlsPrevText), 1)]), ee(\"button\", {\n        class: \"carousel-control-next\",\n        type: \"button\",\n        onClick: Ve\n      }, [Or, ee(\"span\", Er, Z(H.controlsNextText), 1)])], 64)) : J(\"\", !0)], 10, $r));\n    }\n  }),\n  Nr = [\"innerHTML\"],\n  Ir = {\n    key: 1\n  },\n  Lr = [\"innerHTML\"],\n  Fr = {\n    key: 1\n  },\n  Hr = /* @__PURE__ */q({\n    __name: \"BCarouselSlide\",\n    props: {\n      background: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      captionTag: {\n        default: \"h3\"\n      },\n      contentTag: {\n        default: \"div\"\n      },\n      contentVisibleUp: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      imgAlt: {\n        default: void 0\n      },\n      imgBlank: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgBlankColor: {\n        default: \"transparent\"\n      },\n      imgHeight: {\n        default: void 0\n      },\n      imgSrc: {\n        default: void 0\n      },\n      imgSrcset: {\n        default: void 0\n      },\n      imgWidth: {\n        default: void 0\n      },\n      interval: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      },\n      textHtml: {\n        default: void 0\n      },\n      textTag: {\n        default: \"p\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Me(),\n        a = Ge(Yl, null),\n        l = E(() => t.text || t.textHtml || !Ie(o.text)),\n        n = E(() => t.caption || t.captionHtml || !Ie(o.caption)),\n        i = E(() => l.value || n.value || !Ie(o.default)),\n        s = w(() => ({\n          background: `${t.background || (a == null ? void 0 : a.background.value) || \"rgb(171, 171, 171)\"} none repeat scroll 0% 0%`\n        })),\n        u = w(() => ({\n          \"d-none\": t.contentVisibleUp !== void 0,\n          [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0\n        }));\n      return (d, f) => (m(), N(\"div\", {\n        class: \"carousel-item\",\n        style: ze(s.value)\n      }, [A(d.$slots, \"img\", {}, () => {\n        var g, p;\n        return [ye(vo, {\n          class: \"d-block w-100\",\n          alt: d.imgAlt,\n          srcset: d.imgSrcset,\n          src: d.imgSrc,\n          width: d.imgWidth || ((g = v(a)) == null ? void 0 : g.width.value),\n          height: d.imgHeight || ((p = v(a)) == null ? void 0 : p.height.value),\n          blank: d.imgBlank,\n          \"blank-color\": d.imgBlankColor\n        }, null, 8, [\"alt\", \"srcset\", \"src\", \"width\", \"height\", \"blank\", \"blank-color\"])];\n      }), i.value ? (m(), x(se(d.contentTag), {\n        key: 0,\n        class: j([\"carousel-caption\", u.value])\n      }, {\n        default: R(() => [n.value ? (m(), x(se(d.captionTag), {\n          key: 0\n        }, {\n          default: R(() => [A(d.$slots, \"caption\", {}, () => [d.captionHtml ? (m(), N(\"span\", {\n            key: 0,\n            innerHTML: d.captionHtml\n          }, null, 8, Nr)) : (m(), N(\"span\", Ir, Z(d.caption), 1))])]),\n          _: 3\n        })) : J(\"\", !0), l.value ? (m(), x(se(d.textTag), {\n          key: 1\n        }, {\n          default: R(() => [A(d.$slots, \"text\", {}, () => [d.textHtml ? (m(), N(\"span\", {\n            key: 0,\n            innerHTML: d.textHtml\n          }, null, 8, Lr)) : (m(), N(\"span\", Fr, Z(d.text), 1))])]),\n          _: 3\n        })) : J(\"\", !0), A(d.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"])) : J(\"\", !0)], 4));\n    }\n  }),\n  Ho = wa(\"\", [], {\n    type: [Boolean, String, Number],\n    default: !1\n  }),\n  zo = wa(\"offset\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  Ro = wa(\"order\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  zr = q({\n    name: \"BCol\",\n    slots: Object,\n    props: {\n      col: {\n        type: [Boolean, String],\n        default: !1\n      },\n      // Generic flexbox .col (xs)\n      cols: {\n        type: [String, Number],\n        default: null\n      },\n      // .col-[1-12]|auto (xs)\n      ...Ho,\n      offset: {\n        type: [String, Number],\n        default: null\n      },\n      ...zo,\n      order: {\n        type: [String, Number],\n        default: null\n      },\n      ...Ro,\n      alignSelf: {\n        type: String,\n        default: null\n      },\n      tag: {\n        type: String,\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = [{\n          content: Ho,\n          propPrefix: \"cols\",\n          classPrefix: \"col\"\n        }, {\n          content: zo,\n          propPrefix: \"offset\"\n        }, {\n          content: Ro,\n          propPrefix: \"order\"\n        }],\n        o = r(() => e.col),\n        a = w(() => t.flatMap(n => Kl(e, n.content, n.propPrefix, n.classPrefix)));\n      return {\n        computedClasses: w(() => [a.value, {\n          col: o.value || !a.value.some(n => /^col-/.test(n)) && !e.cols,\n          [`col-${e.cols}`]: !!e.cols,\n          [`offset-${e.offset}`]: !!e.offset,\n          [`order-${e.order}`]: !!e.order,\n          [`align-self-${e.alignSelf}`]: !!e.alignSelf\n        }])\n      };\n    }\n  });\nfunction Rr(e, t, o, a, l, n) {\n  return m(), x(se(e.tag), {\n    class: j(e.computedClasses)\n  }, {\n    default: R(() => [A(e.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst Gt = /* @__PURE__ */$a(zr, [[\"render\", Rr]]),\n  xr = /* @__PURE__ */q({\n    __name: \"BContainer\",\n    props: {\n      fluid: {\n        type: [String, Boolean],\n        default: !1\n      },\n      gutterX: {\n        default: void 0\n      },\n      gutterY: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = he(() => t.gutterX ?? NaN, {\n          method: \"parseInt\"\n        }),\n        a = he(() => t.gutterY ?? NaN, {\n          method: \"parseInt\"\n        }),\n        l = r(() => t.fluid),\n        n = w(() => ({\n          container: l.value === !1,\n          \"container-fluid\": l.value === !0,\n          [`container-${l.value}`]: typeof l.value == \"string\",\n          [`gx-${o.value}`]: !Number.isNaN(o.value),\n          [`gy-${a.value}`]: !Number.isNaN(a.value)\n        }));\n      return (i, s) => (m(), x(se(i.tag), {\n        class: j(n.value)\n      }, {\n        default: R(() => [A(i.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Mr = {\n    class: \"visually-hidden\"\n  },\n  Dr = [\"aria-labelledby\", \"role\"],\n  gn = /* @__PURE__ */q({\n    __name: \"BDropdown\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      boundary: {\n        default: \"clippingAncestors\"\n      },\n      boundaryPadding: {\n        default: void 0\n      },\n      center: {\n        type: [String, Boolean],\n        default: !1\n      },\n      container: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropend: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropstart: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      menuClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCaret: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noSize: {\n        type: [String, Boolean],\n        default: !1\n      },\n      offset: {\n        default: 0\n      },\n      role: {\n        default: \"menu\"\n      },\n      size: {\n        default: \"md\"\n      },\n      split: {\n        type: [String, Boolean],\n        default: !1\n      },\n      splitButtonType: {\n        default: \"button\"\n      },\n      splitClass: {\n        default: void 0\n      },\n      splitDisabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      splitHref: {\n        default: void 0\n      },\n      splitTo: {\n        default: void 0\n      },\n      splitVariant: {\n        default: void 0\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      text: {\n        default: void 0\n      },\n      toggleClass: {\n        default: void 0\n      },\n      toggleText: {\n        default: \"Toggle dropdown\"\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"click\", \"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"toggle\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = _e(() => a.id, \"dropdown\"),\n        i = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = r(i),\n        u = r(() => a.dropup),\n        d = r(() => a.dropend),\n        f = r(() => a.isNav),\n        g = r(() => a.dropstart),\n        p = r(() => a.center),\n        y = r(() => a.end),\n        b = r(() => a.split),\n        V = r(() => a.noCaret),\n        C = r(() => a.noFlip),\n        c = r(() => a.noShift),\n        h = r(() => a.noSize),\n        B = r(() => a.lazy),\n        _ = r(() => a.splitDisabled),\n        k = E(() => typeof a.offset == \"string\" || typeof a.offset == \"number\" ? a.offset : NaN),\n        S = he(k),\n        $ = W(null),\n        I = W(null),\n        T = W(null),\n        O = W(null),\n        F = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? void 0 : a.boundary),\n        K = w(() => a.boundary === \"document\" || a.boundary === \"viewport\" ? a.boundary : void 0),\n        z = E(() => b.value ? I.value : T.value);\n      qe(\"Escape\", () => {\n        i.value = !s;\n      }, {\n        target: z\n      }), qe(\"Escape\", () => {\n        i.value = !s;\n      }, {\n        target: $\n      });\n      const P = (H, G) => {\n        var te, be, me, de;\n        if (H.preventDefault(), !s.value) {\n          L(), Ne(() => P(H, G));\n          return;\n        }\n        const X = (te = $.value) == null ? void 0 : te.querySelectorAll(\".dropdown-item:not(.disabled):not(:disabled)\");\n        if (X) if ((be = $.value) != null && be.contains(document.activeElement)) {\n          const ie = $.value.querySelector(\".dropdown-item:focus\"),\n            ce = Array.prototype.indexOf.call(X, ie) + G;\n          ce >= 0 && ce < (X == null ? void 0 : X.length) && ((me = X[ce]) == null || me.focus());\n        } else (de = X[G === -1 ? X.length - 1 : 0]) == null || de.focus();\n      };\n      qe(\"ArrowUp\", H => P(H, -1), {\n        target: z\n      }), qe(\"ArrowDown\", H => P(H, 1), {\n        target: z\n      }), qe(\"ArrowUp\", H => P(H, -1), {\n        target: $\n      }), qe(\"ArrowDown\", H => P(H, 1), {\n        target: $\n      });\n      const D = w(() => Xi({\n          top: u.value,\n          start: g.value,\n          end: d.value,\n          alignCenter: p.value,\n          alignEnd: y.value\n        })),\n        ae = W({}),\n        le = w(() => {\n          if (a.floatingMiddleware !== void 0) return a.floatingMiddleware;\n          const H = typeof a.offset == \"string\" || typeof a.offset == \"number\" ? S.value : a.offset,\n            G = [gl(H)];\n          return C.value === !1 && G.push(pl({\n            boundary: F.value,\n            rootBoundary: K.value,\n            padding: a.boundaryPadding\n          })), c.value === !1 && G.push(bl({\n            boundary: F.value,\n            rootBoundary: K.value,\n            padding: a.boundaryPadding\n          })), h.value === !1 && G.push(yl({\n            boundary: F.value,\n            rootBoundary: K.value,\n            padding: a.boundaryPadding,\n            apply({\n              availableWidth: X,\n              availableHeight: te\n            }) {\n              ae.value = {\n                maxHeight: te ? `${te}px` : void 0,\n                maxWidth: X ? `${X}px` : void 0\n              };\n            }\n          })), G;\n        }),\n        {\n          update: ve,\n          floatingStyles: Be\n        } = Vl(z, $, {\n          placement: D,\n          middleware: le,\n          strategy: E(() => a.strategy),\n          whileElementsMounted: Tl\n        }),\n        Ve = w(() => ({\n          dropup: u.value,\n          dropend: d.value,\n          dropstart: g.value,\n          \"position-static\": a.boundary !== \"clippingAncestors\" && !f.value\n        })),\n        oe = w(() => [b.value ? a.splitClass : a.toggleClass, {\n          \"nav-link\": f.value,\n          \"dropdown-toggle\": !b.value,\n          \"dropdown-toggle-no-caret\": V.value && !b.value,\n          show: b.value ? void 0 : s.value\n        }]),\n        fe = () => {\n          U();\n        },\n        $e = H => {\n          b.value ? l(\"click\", H) : fe();\n        };\n      Ll($, () => {\n        s.value && (a.autoClose === !0 || a.autoClose === \"outside\") && U();\n      }, {\n        ignore: [I, T]\n      });\n      const we = () => {\n          s.value && (a.autoClose === !0 || a.autoClose === \"inside\") && U();\n        },\n        M = () => {\n          i.value && U();\n        },\n        L = () => {\n          i.value || U();\n        },\n        U = () => {\n          var X;\n          l(\"toggle\");\n          const H = s.value,\n            G = new Rt(H ? \"hide\" : \"show\");\n          if (l(H ? \"hide\" : \"show\", G), G.defaultPrevented) {\n            l(H ? \"hide-prevented\" : \"show-prevented\");\n            return;\n          }\n          i.value = !H, l(H ? \"hidden\" : \"shown\"), (X = O.value) == null || X.dispatchEvent(new Event(\"forceHide\"));\n        };\n      return ue(s, () => {\n        ve();\n      }), t({\n        close: M,\n        open: L,\n        toggle: U\n      }), at(ln, {\n        id: n,\n        open: L,\n        close: M,\n        toggle: U,\n        visible: s,\n        isNav: f\n      }), (H, G) => (m(), N(\"div\", {\n        ref_key: \"wrapper\",\n        ref: O,\n        class: j([Ve.value, \"btn-group\"])\n      }, [ye(pt, {\n        id: v(n),\n        ref_key: \"splitButton\",\n        ref: T,\n        variant: H.splitVariant || H.variant,\n        size: H.size,\n        class: j(oe.value),\n        disabled: v(_) || H.disabled,\n        type: H.splitButtonType,\n        \"aria-label\": H.ariaLabel,\n        \"aria-expanded\": v(b) ? void 0 : v(s),\n        \"aria-haspopup\": v(b) ? void 0 : \"menu\",\n        href: v(b) ? H.splitHref : void 0,\n        to: v(b) && H.splitTo ? H.splitTo : void 0,\n        onClick: $e\n      }, {\n        default: R(() => [A(H.$slots, \"button-content\", {}, () => [ne(Z(H.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"variant\", \"size\", \"class\", \"disabled\", \"type\", \"aria-label\", \"aria-expanded\", \"aria-haspopup\", \"href\", \"to\"]), v(b) ? (m(), x(pt, {\n        key: 0,\n        ref_key: \"button\",\n        ref: I,\n        variant: H.variant,\n        size: H.size,\n        disabled: H.disabled,\n        class: j([[H.toggleClass, v(s) ? \"show\" : void 0], \"dropdown-toggle-split dropdown-toggle\"]),\n        \"aria-expanded\": v(s),\n        \"aria-haspopup\": \"menu\",\n        onClick: fe\n      }, {\n        default: R(() => [ee(\"span\", Mr, [A(H.$slots, \"toggle-text\", {}, () => [ne(Z(H.toggleText), 1)])])]),\n        _: 3\n      }, 8, [\"variant\", \"size\", \"disabled\", \"class\", \"aria-expanded\"])) : J(\"\", !0), (m(), x(zt, {\n        to: H.container,\n        disabled: !H.container\n      }, [!v(B) || v(s) ? ht((m(), N(\"ul\", {\n        key: 0,\n        ref_key: \"floating\",\n        ref: $,\n        style: ze([v(Be), ae.value]),\n        class: j([\"dropdown-menu show overflow-auto\", H.menuClass]),\n        \"aria-labelledby\": v(n),\n        role: H.role,\n        onClick: we\n      }, [A(H.$slots, \"default\", {\n        hide: M,\n        show: L\n      })], 14, Dr)), [[ha, v(B) || v(s)]]) : J(\"\", !0)], 8, [\"to\", \"disabled\"]))], 2));\n    }\n  }),\n  jr = {\n    role: \"presentation\"\n  },\n  qr = /* @__PURE__ */q({\n    __name: \"BDropdownDivider\",\n    props: {\n      tag: {\n        default: \"hr\"\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), N(\"li\", jr, [(m(), x(se(t.tag), {\n        class: \"dropdown-divider\",\n        role: \"separator\",\n        \"aria-orientation\": \"horizontal\"\n      }))]));\n    }\n  }),\n  Gr = {\n    role: \"presentation\"\n  },\n  Wr = {\n    class: \"px-4 py-3\"\n  },\n  Ur = /* @__PURE__ */q({\n    __name: \"BDropdownForm\",\n    setup(e) {\n      return (t, o) => (m(), N(\"li\", Gr, [ee(\"form\", Wr, [A(t.$slots, \"default\")])]));\n    }\n  }),\n  Xr = {\n    role: \"presentation\"\n  },\n  Kr = [\"id\", \"aria-describedby\"],\n  Yr = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BDropdownGroup\",\n    props: {\n      ariaDescribedby: {\n        default: void 0\n      },\n      header: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"header\"\n      },\n      headerVariant: {\n        default: null\n      },\n      id: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = E(() => t.id ? `${t.id}_group_dd_header` : void 0),\n        a = E(() => t.headerTag === \"header\" ? void 0 : \"heading\"),\n        l = w(() => [t.headerClass, {\n          [`text-${t.headerVariant}`]: t.headerVariant !== null\n        }]);\n      return (n, i) => (m(), N(\"li\", Xr, [(m(), x(se(n.headerTag), {\n        id: o.value,\n        class: j([\"dropdown-header\", l.value]),\n        role: a.value\n      }, {\n        default: R(() => [A(n.$slots, \"header\", {}, () => [ne(Z(n.header), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"role\"])), ee(\"ul\", Q({\n        id: n.id,\n        role: \"group\",\n        class: \"list-unstyled\"\n      }, n.$attrs, {\n        \"aria-describedby\": n.ariaDescribedby || o.value\n      }), [A(n.$slots, \"default\")], 16, Kr)]));\n    }\n  }),\n  Zr = {\n    class: \"dropdown-header\"\n  },\n  Jr = /* @__PURE__ */q({\n    __name: \"BDropdownHeader\",\n    setup(e) {\n      return (t, o) => (m(), N(\"li\", null, [ee(\"h6\", Zr, [A(t.$slots, \"default\")])]));\n    }\n  }),\n  Qr = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BDropdownItem\",\n    props: {\n      linkClass: {\n        default: void 0\n      },\n      wrapperAttrs: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        {\n          class: l,\n          ...n\n        } = Kt(),\n        i = r(() => o.active),\n        s = r(() => o.disabled),\n        {\n          computedLink: u,\n          computedLinkProps: d\n        } = Ct(o),\n        f = w(() => [o.linkClass, {\n          active: i.value,\n          disabled: s.value,\n          [`text-${o.variant}`]: o.variant !== null\n        }]),\n        g = E(() => u.value ? rt : o.href ? \"a\" : \"button\"),\n        p = Ge(uo, null),\n        y = Ge(ln, null),\n        b = Ge(co, null),\n        V = C => {\n          var c, h, B;\n          a(\"click\", C), b !== null && ((c = b == null ? void 0 : b.autoClose) == null ? void 0 : c.value) === !0 && ((h = p == null ? void 0 : p.close) == null || h.call(p)), (B = y == null ? void 0 : y.close) == null || B.call(y);\n        };\n      return (C, c) => (m(), N(\"li\", Q({\n        role: \"presentation\",\n        class: v(l)\n      }, C.wrapperAttrs), [(m(), x(se(g.value), Q({\n        class: [\"dropdown-item\", f.value],\n        disabled: v(s),\n        \"aria-disabled\": v(s) ? !0 : null,\n        \"aria-current\": v(i) ? !0 : null,\n        href: g.value === \"a\" ? C.href : null,\n        rel: C.rel,\n        role: \"menuitem\",\n        type: g.value === \"button\" ? \"button\" : null,\n        target: C.target\n      }, {\n        ...v(d),\n        ...n\n      }, {\n        onClick: V\n      }), {\n        default: R(() => [A(C.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"disabled\", \"aria-disabled\", \"aria-current\", \"href\", \"rel\", \"type\", \"target\"]))], 16));\n    }\n  }),\n  eu = {\n    role: \"presentation\"\n  },\n  tu = [\"disabled\"],\n  au = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BDropdownItemButton\",\n    props: {\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: \"active\"\n      },\n      buttonClass: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = r(() => o.active),\n        n = r(() => o.disabled),\n        i = w(() => [o.buttonClass, {\n          [o.activeClass]: l.value,\n          disabled: n.value,\n          [`text-${o.variant}`]: o.variant !== null\n        }]),\n        s = u => {\n          a(\"click\", u);\n        };\n      return (u, d) => (m(), N(\"li\", eu, [ee(\"button\", {\n        role: \"menu\",\n        type: \"button\",\n        class: j([\"dropdown-item\", i.value]),\n        disabled: v(n),\n        onClick: s\n      }, [A(u.$slots, \"default\")], 10, tu)]));\n    }\n  }),\n  ou = {\n    role: \"presentation\"\n  },\n  lu = {\n    class: \"px-4 py-1 mb-0 text-body-secondary\"\n  },\n  nu = /* @__PURE__ */q({\n    __name: \"BDropdownText\",\n    props: {\n      text: {\n        default: \"\"\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), N(\"li\", ou, [ee(\"p\", lu, [A(t.$slots, \"default\", {}, () => [ne(Z(t.text), 1)])])]));\n    }\n  }),\n  su = [\"id\", \"novalidate\", \"onSubmit\"],\n  bn = /* @__PURE__ */q({\n    __name: \"BForm\",\n    props: {\n      floating: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      novalidate: {\n        type: [String, Boolean],\n        default: !1\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"submit\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = W(null),\n        i = r(() => a.floating),\n        s = r(() => a.novalidate),\n        u = r(() => a.validated),\n        d = w(() => ({\n          \"form-floating\": i.value,\n          \"was-validated\": u.value\n        })),\n        f = g => {\n          l(\"submit\", g);\n        };\n      return t({\n        element: n\n      }), (g, p) => (m(), N(\"form\", {\n        id: g.id,\n        ref_key: \"element\",\n        ref: n,\n        novalidate: v(s),\n        class: j(d.value),\n        onSubmit: Bt(f, [\"prevent\"])\n      }, [A(g.$slots, \"default\")], 42, su));\n    }\n  }),\n  iu = {\n    class: \"form-floating\"\n  },\n  ru = [\"for\"],\n  uu = /* @__PURE__ */q({\n    __name: \"BFormFloatingLabel\",\n    props: {\n      label: {\n        default: void 0\n      },\n      labelFor: {\n        default: void 0\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), N(\"div\", iu, [A(t.$slots, \"default\", {}, () => [ne(Z(t.text), 1)]), ee(\"label\", {\n        for: t.labelFor\n      }, [A(t.$slots, \"label\", {}, () => [ne(Z(t.label), 1)])], 8, ru)]));\n    }\n  }),\n  xa = /* @__PURE__ */q({\n    __name: \"BFormInvalidFeedback\",\n    props: {\n      ariaLive: {\n        default: void 0\n      },\n      forceShow: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      role: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.forceShow),\n        a = r(() => t.state),\n        l = r(() => t.tooltip),\n        n = E(() => o.value === !0 || a.value === !1),\n        i = w(() => ({\n          \"d-block\": n.value,\n          \"invalid-feedback\": !l.value,\n          \"invalid-tooltip\": l.value\n        }));\n      return (s, u) => (m(), x(se(s.tag), {\n        id: s.id,\n        role: s.role,\n        \"aria-live\": s.ariaLive,\n        \"aria-atomic\": s.ariaLive ? !0 : void 0,\n        class: j(i.value)\n      }, {\n        default: R(() => [A(s.$slots, \"default\", {}, () => [ne(Z(s.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n    }\n  }),\n  ra = /* @__PURE__ */q({\n    __name: \"BFormRow\",\n    props: {\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), x(se(t.tag), {\n        class: \"row d-flex flex-wrap\"\n      }, {\n        default: R(() => [A(t.$slots, \"default\")]),\n        _: 3\n      }));\n    }\n  }),\n  Ma = /* @__PURE__ */q({\n    __name: \"BFormText\",\n    props: {\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"small\"\n      },\n      text: {\n        default: void 0\n      },\n      textVariant: {\n        default: \"body-secondary\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.inline),\n        a = w(() => ({\n          [`text-${t.textVariant}`]: t.textVariant !== null,\n          \"form-text\": !o.value\n        }));\n      return (l, n) => (m(), x(se(l.tag), {\n        id: l.id,\n        class: j(a.value)\n      }, {\n        default: R(() => [A(l.$slots, \"default\", {}, () => [ne(Z(l.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Da = /* @__PURE__ */q({\n    __name: \"BFormValidFeedback\",\n    props: {\n      ariaLive: {\n        default: void 0\n      },\n      forceShow: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      role: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      },\n      tooltip: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.forceShow),\n        a = r(() => t.state),\n        l = r(() => t.tooltip),\n        n = E(() => o.value === !0 || a.value === !0),\n        i = w(() => ({\n          \"d-block\": n.value,\n          \"valid-feedback\": !l.value,\n          \"valid-tooltip\": l.value\n        }));\n      return (s, u) => (m(), x(se(s.tag), {\n        id: s.id,\n        role: s.role,\n        \"aria-live\": s.ariaLive,\n        \"aria-atomic\": s.ariaLive ? !0 : void 0,\n        class: j(i.value)\n      }, {\n        default: R(() => [A(s.$slots, \"default\", {}, () => [ne(Z(s.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n    }\n  }),\n  yn = q({\n    name: \"ComponentOrEmpty\",\n    slots: Object,\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      to: {\n        type: [String, Object],\n        default: null\n      },\n      skip: {\n        type: Boolean,\n        default: !1\n      }\n    },\n    setup(e, {\n      slots: t,\n      attrs: o\n    }) {\n      return () => {\n        var a, l, n;\n        return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === \"Teleport\" ? Le(zt, {\n          to: e.to\n        }, [(l = t.default) == null ? void 0 : l.call(t)]) : Le(e.tag, {\n          ...o\n        }, [(n = t.default) == null ? void 0 : n.call(t)]);\n      };\n    }\n  }),\n  du = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"value\", \"true-value\", \"false-value\", \"indeterminate\"],\n  cu = [\"for\"],\n  hn = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BFormCheckbox\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledBy: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonGroup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: null\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      indeterminate: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [Array, Set, Boolean, String, Object, Number, null],\n        default: void 0\n      },\n      name: {\n        default: void 0\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      switch: {\n        type: [String, Boolean],\n        default: !1\n      },\n      uncheckedValue: {\n        type: [Array, Set, Boolean, String, Object, Number, null],\n        default: !1\n      },\n      value: {\n        type: [Array, Set, Boolean, String, Object, Number, null],\n        default: !0\n      }\n    },\n    emits: [\"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = Me(),\n        i = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = _e(() => a.id, \"form-check\"),\n        u = r(() => a.indeterminate),\n        d = r(() => a.autofocus),\n        f = r(() => a.plain),\n        g = r(() => a.button),\n        p = r(() => a.buttonGroup),\n        y = r(() => a.switch),\n        b = r(() => a.disabled),\n        V = r(() => a.inline),\n        C = r(() => a.required),\n        c = r(() => a.state),\n        h = Ge(an, null),\n        B = W(null),\n        {\n          focused: _\n        } = xe(B, {\n          initialValue: d.value\n        }),\n        k = E(() => !Ie(n.default)),\n        S = w({\n          get: () => (h == null ? void 0 : h.modelValue.value) ?? i.value,\n          set: z => {\n            if (z !== void 0) {\n              if (h !== null && Array.isArray(z)) {\n                h.modelValue.value = z;\n                return;\n              }\n              i.value = z;\n            }\n          }\n        }),\n        $ = E(() => !!(a.name ?? (h == null ? void 0 : h.name.value)) && (C.value || (h == null ? void 0 : h.required.value))),\n        I = E(() => p.value || ((h == null ? void 0 : h.buttons.value) ?? !1)),\n        T = w(() => ({\n          plain: f.value || ((h == null ? void 0 : h.plain.value) ?? !1),\n          button: g.value || ((h == null ? void 0 : h.buttons.value) ?? !1),\n          inline: V.value || ((h == null ? void 0 : h.inline.value) ?? !1),\n          switch: y.value || ((h == null ? void 0 : h.switch.value) ?? !1),\n          state: c.value || (h == null ? void 0 : h.state.value),\n          size: a.size ?? (h == null ? void 0 : h.size.value) ?? \"md\",\n          // This is where the true default is made\n          buttonVariant: a.buttonVariant ?? (h == null ? void 0 : h.buttonVariant.value) ?? \"secondary\"\n          // This is where the true default is made\n        })),\n        O = Rl(T),\n        F = xl(T),\n        K = Ml(T);\n      return t({\n        blur: () => {\n          _.value = !1;\n        },\n        element: B,\n        focus: () => {\n          _.value = !0;\n        }\n      }), (z, P) => (m(), x(yn, {\n        skip: I.value,\n        class: j(v(O))\n      }, {\n        default: R(() => {\n          var D, ae, le;\n          return [ht(ee(\"input\", Q({\n            id: v(s)\n          }, z.$attrs, {\n            ref_key: \"input\",\n            ref: B,\n            \"onUpdate:modelValue\": P[0] || (P[0] = ve => S.value = ve),\n            class: v(F),\n            type: \"checkbox\",\n            disabled: v(b) || ((D = v(h)) == null ? void 0 : D.disabled.value),\n            required: $.value || void 0,\n            name: z.name || ((ae = v(h)) == null ? void 0 : ae.name.value),\n            form: z.form || ((le = v(h)) == null ? void 0 : le.form.value),\n            \"aria-label\": z.ariaLabel,\n            \"aria-labelledby\": z.ariaLabelledBy,\n            \"aria-required\": $.value || void 0,\n            value: z.value,\n            \"true-value\": z.value,\n            \"false-value\": z.uncheckedValue,\n            indeterminate: v(u),\n            onChange: P[1] || (P[1] = ve => v(i) !== void 0 && l(\"change\", v(i))),\n            onInput: P[2] || (P[2] = ve => v(i) !== void 0 && l(\"input\", v(i)))\n          }), null, 16, du), [[qn, S.value]]), k.value || v(f) === !1 ? (m(), N(\"label\", {\n            key: 0,\n            for: v(s),\n            class: j(v(K))\n          }, [A(z.$slots, \"default\")], 10, cu)) : J(\"\", !0)];\n        }),\n        _: 3\n      }, 8, [\"skip\", \"class\"]));\n    }\n  }),\n  fu = [\"id\"],\n  vu = [\"innerHTML\"],\n  pu = [\"textContent\"],\n  mu = /* @__PURE__ */q({\n    __name: \"BFormCheckboxGroup\",\n    props: {\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {\n        default: () => []\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: !1\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      switches: {\n        type: [String, Boolean],\n        default: !1\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = ke(a, \"modelValue\", l),\n        i = _e(() => a.id, \"checkbox\"),\n        s = _e(() => a.name, \"checkbox\"),\n        u = r(() => a.autofocus),\n        d = r(() => a.buttons),\n        f = r(() => a.disabled),\n        g = r(() => a.plain),\n        p = r(() => a.required),\n        y = r(() => a.stacked),\n        b = r(() => a.state),\n        V = r(() => a.switches),\n        C = r(() => a.validated),\n        c = W(null),\n        {\n          focused: h\n        } = xe(c, {\n          initialValue: u.value\n        });\n      at(an, {\n        modelValue: n,\n        switch: V,\n        buttonVariant: E(() => a.buttonVariant),\n        form: E(() => a.form),\n        name: s,\n        state: b,\n        plain: g,\n        size: E(() => a.size),\n        inline: E(() => !y.value),\n        required: p,\n        buttons: d,\n        disabled: f\n      }), ue(n, $ => {\n        l(\"input\", $), Ne(() => {\n          l(\"change\", $);\n        });\n      });\n      const B = w(() => a.options.map(($, I) => typeof $ == \"string\" || typeof $ == \"number\" ? {\n          props: {\n            value: $,\n            disabled: f.value\n          },\n          text: $.toString(),\n          html: void 0,\n          self: Symbol(`checkboxGroupOptionItem${I}`)\n        } : {\n          props: {\n            value: $[a.valueField],\n            disabled: $[a.disabledField],\n            ...($.props ? $.props : {})\n          },\n          text: $[a.textField],\n          html: $[a.htmlField],\n          self: Symbol(`checkboxGroupOptionItem${I}`)\n        })),\n        _ = w(() => ({\n          required: p.value,\n          ariaInvalid: a.ariaInvalid,\n          state: b.value,\n          validated: C.value,\n          buttons: d.value,\n          stacked: y.value,\n          size: a.size\n        })),\n        k = Dl(_),\n        S = jl(_);\n      return t({\n        blur: () => {\n          h.value = !1;\n        },\n        focus: () => {\n          h.value = !0;\n        }\n      }), ($, I) => (m(), N(\"div\", Q(v(k), {\n        id: v(i),\n        ref_key: \"element\",\n        ref: c,\n        role: \"group\",\n        class: [v(S), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [A($.$slots, \"first\"), (m(!0), N(ge, null, Te(B.value, T => (m(), x(hn, Q({\n        key: T.self\n      }, T.props), {\n        default: R(() => [T.html ? (m(), N(\"span\", {\n          key: 0,\n          innerHTML: T.html\n        }, null, 8, vu)) : (m(), N(\"span\", {\n          key: 1,\n          textContent: Z(T.text)\n        }, null, 8, pu))]),\n        _: 2\n      }, 1040))), 128)), A($.$slots, \"default\")], 16, fu));\n    }\n  }),\n  gu = [\"for\"],\n  bu = [\"id\", \"form\", \"name\", \"multiple\", \"disabled\", \"capture\", \"accept\", \"required\", \"aria-required\", \"directory\", \"webkitdirectory\"],\n  yu = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BFormFile\",\n    props: {\n      accept: {\n        default: \"\"\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      capture: {\n        type: [String, Boolean],\n        default: !1\n      },\n      directory: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      label: {\n        default: \"\"\n      },\n      labelClass: {\n        default: void 0\n      },\n      modelValue: {\n        default: null\n      },\n      multiple: {\n        type: [String, Boolean],\n        default: !1\n      },\n      name: {\n        default: void 0\n      },\n      noDrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noTraverse: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      }\n    },\n    emits: [\"change\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = Me(),\n        l = e,\n        n = o,\n        i = ke(l, \"modelValue\", n),\n        s = _e(() => l.id),\n        u = r(() => l.autofocus),\n        d = r(() => l.directory),\n        f = r(() => l.disabled),\n        g = r(() => l.multiple),\n        p = r(() => l.noDrop);\n      r(() => l.noTraverse);\n      const y = r(() => l.required),\n        b = r(() => l.state),\n        V = r(() => l.capture),\n        C = wt(b),\n        c = W(null),\n        {\n          focused: h\n        } = xe(c, {\n          initialValue: u.value\n        }),\n        B = E(() => !Ie(a.label)),\n        _ = E(() => typeof l.accept == \"string\" ? l.accept : l.accept.join(\",\")),\n        k = w(() => [C.value, {\n          [`form-control-${l.size}`]: l.size !== void 0\n        }]),\n        S = T => {\n          var F, K;\n          const O = ((F = c.value) == null ? void 0 : F.files) === null || ((K = c.value) == null ? void 0 : K.files) === void 0 ? null : [...c.value.files];\n          i.value = O === null ? null : g.value === !0 ? O : O[0], n(\"change\", T);\n        },\n        $ = T => {\n          p.value === !0 && T.preventDefault();\n        },\n        I = () => {\n          i.value = null;\n        };\n      return ue(i, T => {\n        T === null && c.value !== null && (c.value.value = \"\");\n      }), t({\n        blur: () => {\n          h.value = !1;\n        },\n        element: c,\n        focus: () => {\n          h.value = !0;\n        },\n        reset: I\n      }), (T, O) => (m(), N(ge, null, [B.value || T.label ? (m(), N(\"label\", {\n        key: 0,\n        for: v(s),\n        class: j([\"form-label\", T.labelClass])\n      }, [A(T.$slots, \"label\", {}, () => [ne(Z(T.label), 1)])], 10, gu)) : J(\"\", !0), ee(\"input\", Q({\n        id: v(s)\n      }, T.$attrs, {\n        ref_key: \"input\",\n        ref: c,\n        type: \"file\",\n        class: [\"form-control\", k.value],\n        form: T.form,\n        name: T.name,\n        multiple: v(g),\n        disabled: v(f),\n        capture: v(V),\n        accept: _.value || void 0,\n        required: v(y) || void 0,\n        \"aria-required\": v(y) || void 0,\n        directory: v(d),\n        webkitdirectory: v(d),\n        onChange: S,\n        onDrop: $\n      }), null, 16, bu)], 64));\n    }\n  }),\n  Bn = [\"input\", \"select\", \"textarea\"],\n  hu = Bn.map(e => `${e}:not([disabled])`).join(),\n  Bu = [...Bn, \"a\", \"button\", \"label\"],\n  Su = \"label\",\n  Cu = \"invalid-feedback\",\n  wu = \"valid-feedback\",\n  ku = \"description\",\n  $u = \"default\",\n  Tu = q({\n    components: {\n      BCol: Gt,\n      BFormInvalidFeedback: xa,\n      BFormRow: ra,\n      BFormText: Ma,\n      BFormValidFeedback: Da\n    },\n    props: {\n      ariaInvalid: {\n        type: [Boolean, String],\n        default: void 0\n      },\n      contentCols: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      contentColsXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      description: {\n        type: [String],\n        default: void 0\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      feedbackAriaLive: {\n        type: String,\n        default: \"assertive\"\n      },\n      id: {\n        type: String,\n        default: void 0\n      },\n      invalidFeedback: {\n        type: String,\n        default: void 0\n      },\n      label: {\n        type: String,\n        default: void 0\n      },\n      labelAlign: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelAlignXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelClass: {\n        type: [Array, Object, String],\n        default: void 0\n      },\n      labelCols: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsLg: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsMd: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsSm: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelColsXl: {\n        type: [Boolean, String, Number],\n        default: void 0\n      },\n      labelFor: {\n        type: String,\n        default: void 0\n      },\n      labelSize: {\n        type: String,\n        default: void 0\n      },\n      labelSrOnly: {\n        type: [Boolean, String],\n        default: !1\n      },\n      state: {\n        type: [Boolean, String],\n        default: null\n      },\n      tooltip: {\n        type: [Boolean, String],\n        default: !1\n      },\n      validFeedback: {\n        type: String,\n        default: void 0\n      },\n      validated: {\n        type: [Boolean, String],\n        default: !1\n      },\n      floating: {\n        type: [Boolean, String],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = r(() => e.disabled),\n        o = r(() => e.labelSrOnly),\n        a = r(() => e.state),\n        l = r(() => e.tooltip),\n        n = r(() => e.validated),\n        i = r(() => e.floating),\n        s = null,\n        u = [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"],\n        d = (_, k) => u.reduce((S, $) => {\n          const I = Lo($ === \"xs\" ? \"\" : $, `${k}Align`),\n            T = _[I] || null;\n          return T && ($ === \"xs\" ? S.push(`text-${T}`) : S.push(`text-${$}-${T}`)), S;\n        }, []),\n        f = (_, k) =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        u.reduce((S, $) => {\n          const I = Lo($ === \"xs\" ? \"\" : $, `${k}Cols`);\n          let T = _[I];\n          return T = T === \"\" ? !0 : T || !1, typeof T != \"boolean\" && T !== \"auto\" && (T = Qi(T, 0), T = T > 0 ? T : !1), T && ($ === \"xs\" ? S[typeof T == \"boolean\" ? \"col\" : \"cols\"] = T : S[$ || (typeof T == \"boolean\" ? \"col\" : \"cols\")] = T), S;\n        }, {}),\n        g = W(null),\n        p = (_, k = null) => {\n          if (Ka && e.labelFor && g.value !== null) {\n            const S = dl(`#${ls(e.labelFor)}`, g.value);\n            if (S) {\n              const $ = \"aria-describedby\",\n                I = (_ || \"\").split(sa),\n                T = (k || \"\").split(sa),\n                O = (Ya(S, $) || \"\").split(sa).filter(F => !T.includes(F)).concat(I).filter((F, K, z) => z.indexOf(F) === K).filter(F => F).join(\" \").trim();\n              O ? hs(S, $, O) : Bs(S, $);\n            }\n          }\n        },\n        y = w(() => f(e, \"content\")),\n        b = w(() => d(e, \"label\")),\n        V = w(() => f(e, \"label\")),\n        C = w(() =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(y.value).length > 0 || Object.keys(V.value).length > 0),\n        c = wt(a),\n        h = Ca(() => e.ariaInvalid, a);\n      return ue(() => s, (_, k) => {\n        _ !== k && p(_, k);\n      }), st(() => {\n        Ne(() => {\n          p(s);\n        });\n      }), {\n        disabledBoolean: t,\n        labelSrOnlyBoolean: o,\n        stateBoolean: a,\n        tooltipBoolean: l,\n        validatedBoolean: n,\n        floatingBoolean: i,\n        ariaDescribedby: s,\n        computedAriaInvalid: h,\n        contentColProps: y,\n        isHorizontal: C,\n        labelAlignClasses: b,\n        labelColProps: V,\n        onLegendClick: _ => {\n          if (e.labelFor || g.value === null) return;\n          const {\n              target: k\n            } = _,\n            S = k ? k.tagName : \"\";\n          if (Bu.indexOf(S) !== -1) return;\n          const $ = bs(hu, g.value).filter(gs);\n          $.length === 1 && ps($[0]);\n        },\n        stateClass: c\n      };\n    },\n    render() {\n      const e = this.$props,\n        t = this.$slots,\n        o = _e(),\n        a = !e.labelFor;\n      let l = null;\n      const n = jt(Su, {}, t) || e.label,\n        i = n ? qt(\"_BV_label_\") : null;\n      if (n || this.isHorizontal) {\n        const _ = a ? \"legend\" : \"label\";\n        if (this.labelSrOnlyBoolean) n && (l = Le(_, {\n          class: \"visually-hidden\",\n          id: i,\n          for: e.labelFor || null\n        }, n)), this.isHorizontal ? l = Le(Gt, this.labelColProps, {\n          default: () => l\n        }) : l = Le(\"div\", {}, [l]);else {\n          const k = {\n            onClick: a ? this.onLegendClick : null,\n            ...(this.isHorizontal ? this.labelColProps : {}),\n            tag: this.isHorizontal ? _ : null,\n            id: i,\n            for: e.labelFor || null,\n            tabIndex: a ? \"-1\" : null,\n            class: [this.isHorizontal ? \"col-form-label\" : \"form-label\", {\n              \"bv-no-focus-ring\": a,\n              \"col-form-label\": this.isHorizontal || a,\n              \"pt-0\": !this.isHorizontal && a,\n              \"d-block\": !this.isHorizontal && !a,\n              [`col-form-label-${e.labelSize}`]: !!e.labelSize\n            }, this.labelAlignClasses, e.labelClass]\n          };\n          this.isHorizontal ? l = Le(Gt, k, {\n            default: () => n\n          }) : l = Le(_, k, n);\n        }\n      }\n      let s = null;\n      const u = jt(Cu, {}, t) || this.invalidFeedback,\n        d = u ? qt(\"_BV_feedback_invalid_\") : void 0;\n      u && (s = Le(xa, {\n        ariaLive: e.feedbackAriaLive,\n        id: d,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      }, {\n        default: () => u\n      }));\n      let f = null;\n      const g = jt(wu, {}, t) || this.validFeedback,\n        p = g ? qt(\"_BV_feedback_valid_\") : void 0;\n      g && (f = Le(Da, {\n        ariaLive: e.feedbackAriaLive,\n        id: p,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      }, {\n        default: () => g\n      }\n      // validFeedbackContent\n      ));\n      let y = null;\n      const b = jt(ku, {}, t) || this.description,\n        V = b ? qt(\"_BV_description_\") : void 0;\n      b && (y = Le(Ma, {\n        id: V\n      }, {\n        default: () => b\n      }));\n      const C = this.ariaDescribedby = [V, this.stateBoolean === !1 ? d : null, this.stateBoolean === !0 ? p : null].filter(_ => _).join(\" \") || null,\n        c = [jt($u, {\n          ariaDescribedby: C,\n          descriptionId: V,\n          id: o,\n          labelId: i\n        }, t) || \"\", s, f, y];\n      !this.isHorizontal && this.floatingBoolean && c.push(l);\n      let h = Le(\"div\", {\n        ref: \"content\",\n        class: [{\n          \"form-floating\": !this.isHorizontal && this.floatingBoolean\n        }]\n      }, c);\n      this.isHorizontal && (h = Le(Gt, {\n        ref: \"content\",\n        ...this.contentColProps\n      }, {\n        default: () => c\n      }));\n      const B = {\n        class: [this.stateClass, {\n          \"was-validated\": this.validatedBoolean\n        }],\n        id: _e(() => e.id).value,\n        disabled: a ? this.disabledBoolean : null,\n        role: a ? null : \"group\",\n        \"aria-invalid\": this.computedAriaInvalid,\n        // Only apply `aria-labelledby` if we are a horizontal fieldset\n        // as the legend is no longer a direct child of fieldset\n        \"aria-labelledby\": a && this.isHorizontal ? i : null\n      };\n      return this.isHorizontal && !a ? Le(ra, B, {\n        default: () => [l, h]\n      }) : Le(a ? \"fieldset\" : \"div\", B, this.isHorizontal && a ? [Le(ra, null, {\n        default: () => [l, h]\n      })] : this.isHorizontal || !this.floatingBoolean ? [l, h] : [h]);\n    }\n  }),\n  _u = [\"id\", \"value\", \"name\", \"form\", \"type\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"min\", \"max\", \"step\", \"list\", \"aria-required\", \"aria-invalid\"],\n  Vu = /* @__PURE__ */q({\n    __name: \"BFormInput\",\n    props: {\n      max: {\n        default: void 0\n      },\n      min: {\n        default: void 0\n      },\n      step: {\n        default: void 0\n      },\n      type: {\n        default: \"text\"\n      },\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autocomplete: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      debounce: {\n        default: 0\n      },\n      debounceMaxWait: {\n        default: NaN\n      },\n      formatter: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazyFormatter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      list: {\n        default: void 0\n      },\n      modelValue: {\n        default: \"\"\n      },\n      name: {\n        default: void 0\n      },\n      number: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placeholder: {\n        default: void 0\n      },\n      plaintext: {\n        type: [String, Boolean],\n        default: !1\n      },\n      readonly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      trim: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"blur\", \"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        {\n          input: n,\n          computedId: i,\n          computedAriaInvalid: s,\n          onInput: u,\n          onChange: d,\n          onBlur: f,\n          focus: g,\n          blur: p\n        } = ql(a, l),\n        y = r(() => a.disabled),\n        b = r(() => a.required),\n        V = r(() => a.readonly),\n        C = r(() => a.plaintext),\n        c = r(() => a.state),\n        h = wt(c),\n        B = W(!1),\n        _ = w(() => {\n          const k = a.type === \"range\",\n            S = a.type === \"color\";\n          return [h.value, {\n            \"form-control-highlighted\": B.value,\n            \"form-range\": k,\n            \"form-control\": S || !a.plaintext && !k,\n            \"form-control-color\": S,\n            \"form-control-plaintext\": a.plaintext && !k && !S,\n            [`form-control-${a.size}`]: !!a.size\n          }];\n        });\n      return t({\n        blur: p,\n        element: n,\n        focus: g\n      }), (k, S) => (m(), N(\"input\", {\n        id: v(i),\n        ref_key: \"input\",\n        ref: n,\n        value: k.modelValue,\n        class: j(_.value),\n        name: k.name || void 0,\n        form: k.form || void 0,\n        type: k.type,\n        disabled: v(y),\n        placeholder: k.placeholder,\n        required: v(b) || void 0,\n        autocomplete: k.autocomplete || void 0,\n        readonly: v(V) || v(C),\n        min: k.min,\n        max: k.max,\n        step: k.step,\n        list: k.type !== \"password\" ? k.list : void 0,\n        \"aria-required\": v(b) || void 0,\n        \"aria-invalid\": v(s),\n        onInput: S[0] || (S[0] = $ => v(u)($)),\n        onChange: S[1] || (S[1] = $ => v(d)($)),\n        onBlur: S[2] || (S[2] = $ => v(f)($))\n      }, null, 42, _u));\n    }\n  }),\n  Au = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"value\", \"aria-required\"],\n  Ou = [\"for\"],\n  Sn = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BFormRadio\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      ariaLabelledby: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonGroup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: null\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [String, Boolean, Array, Object, Number, null],\n        default: void 0\n      },\n      name: {\n        default: void 0\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      value: {\n        type: [String, Boolean, Array, Object, Number, null],\n        default: !0\n      }\n    },\n    emits: [\"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = Me(),\n        i = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = _e(() => a.id, \"form-check\"),\n        u = r(() => a.autofocus),\n        d = r(() => a.plain),\n        f = r(() => a.button),\n        g = r(() => a.buttonGroup),\n        p = r(() => a.disabled),\n        y = r(() => a.inline),\n        b = r(() => a.required),\n        V = r(() => a.state),\n        C = Ge(on, null),\n        c = W(null),\n        {\n          focused: h\n        } = xe(c, {\n          initialValue: u.value\n        }),\n        B = E(() => !Ie(n.default)),\n        _ = w({\n          get: () => (C == null ? void 0 : C.modelValue.value) ?? i.value,\n          set: F => {\n            if (F !== void 0) {\n              if (C !== null) {\n                C.modelValue.value = F;\n                return;\n              }\n              i.value = F;\n            }\n          }\n        }),\n        k = E(() => !!(a.name ?? (C == null ? void 0 : C.name.value)) && (b.value || (C == null ? void 0 : C.required.value))),\n        S = E(() => g.value || ((C == null ? void 0 : C.buttons.value) ?? !1)),\n        $ = w(() => ({\n          plain: d.value || ((C == null ? void 0 : C.plain.value) ?? !1),\n          button: f.value || ((C == null ? void 0 : C.buttons.value) ?? !1),\n          inline: y.value || ((C == null ? void 0 : C.inline.value) ?? !1),\n          state: V.value || (C == null ? void 0 : C.state.value),\n          size: a.size ?? (C == null ? void 0 : C.size.value) ?? \"md\",\n          // This is where the true default is made\n          buttonVariant: a.buttonVariant ?? (C == null ? void 0 : C.buttonVariant.value) ?? \"secondary\"\n          // This is where the true default is made\n        })),\n        I = Rl($),\n        T = xl($),\n        O = Ml($);\n      return t({\n        blur: () => {\n          h.value = !1;\n        },\n        element: c,\n        focus: () => {\n          h.value = !0;\n        }\n      }), (F, K) => (m(), x(yn, {\n        skip: S.value,\n        class: j(v(I))\n      }, {\n        default: R(() => {\n          var z, P, D;\n          return [ht(ee(\"input\", Q({\n            id: v(s)\n          }, F.$attrs, {\n            ref_key: \"input\",\n            ref: c,\n            \"onUpdate:modelValue\": K[0] || (K[0] = ae => _.value = ae),\n            class: v(T),\n            type: \"radio\",\n            disabled: v(p) || ((z = v(C)) == null ? void 0 : z.disabled.value),\n            required: k.value || void 0,\n            name: F.name || ((P = v(C)) == null ? void 0 : P.name.value),\n            form: F.form || ((D = v(C)) == null ? void 0 : D.form.value),\n            \"aria-label\": F.ariaLabel,\n            \"aria-labelledby\": F.ariaLabelledby,\n            value: F.value,\n            \"aria-required\": k.value || void 0,\n            onChange: K[1] || (K[1] = ae => v(i) !== void 0 && l(\"change\", v(i))),\n            onInput: K[2] || (K[2] = ae => v(i) !== void 0 && l(\"input\", v(i)))\n          }), null, 16, Au), [[Gn, _.value]]), B.value || v(d) === !1 ? (m(), N(\"label\", {\n            key: 0,\n            for: v(s),\n            class: j(v(O))\n          }, [A(F.$slots, \"default\")], 10, Ou)) : J(\"\", !0)];\n        }),\n        _: 3\n      }, 8, [\"skip\", \"class\"]));\n    }\n  }),\n  Eu = [\"id\"],\n  Pu = [\"innerHTML\"],\n  Nu = [\"textContent\"],\n  Iu = /* @__PURE__ */q({\n    __name: \"BFormRadioGroup\",\n    props: {\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean, Array, Object, Number, null],\n        default: null\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: !1\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = ke(a, \"modelValue\", l),\n        i = _e(() => a.id, \"radio\"),\n        s = _e(() => a.name, \"checkbox\"),\n        u = r(() => a.autofocus),\n        d = r(() => a.buttons),\n        f = r(() => a.disabled),\n        g = r(() => a.plain),\n        p = r(() => a.required),\n        y = r(() => a.stacked),\n        b = r(() => a.state),\n        V = r(() => a.validated),\n        C = W(null),\n        {\n          focused: c\n        } = xe(C, {\n          initialValue: u.value\n        });\n      at(on, {\n        modelValue: n,\n        buttonVariant: E(() => a.buttonVariant),\n        form: E(() => a.form),\n        name: s,\n        buttons: d,\n        state: b,\n        plain: g,\n        size: E(() => a.size),\n        inline: E(() => !y.value),\n        required: p,\n        disabled: f\n      }), ue(n, S => {\n        l(\"input\", S), Ne(() => {\n          l(\"change\", S);\n        });\n      });\n      const h = w(() => a.options.map((S, $) => typeof S == \"string\" || typeof S == \"number\" ? {\n          props: {\n            value: S,\n            disabled: f.value\n          },\n          text: S.toString(),\n          html: void 0,\n          self: Symbol(`radioGroupOptionItem${$}`)\n        } : {\n          props: {\n            value: S[a.valueField],\n            disabled: S[a.disabledField],\n            ...(S.props ? S.props : {})\n          },\n          text: S[a.textField],\n          html: S[a.htmlField],\n          self: Symbol(`radioGroupOptionItem${$}`)\n        })),\n        B = w(() => ({\n          required: p.value,\n          ariaInvalid: a.ariaInvalid,\n          state: b.value,\n          validated: V.value,\n          buttons: d.value,\n          stacked: y.value,\n          size: a.size\n        })),\n        _ = Dl(B),\n        k = jl(B);\n      return t({\n        blur: () => {\n          c.value = !1;\n        },\n        focus: () => {\n          c.value = !0;\n        }\n      }), (S, $) => (m(), N(\"div\", Q(v(_), {\n        id: v(i),\n        ref_key: \"element\",\n        ref: C,\n        role: \"radiogroup\",\n        class: [v(k), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [A(S.$slots, \"first\"), (m(!0), N(ge, null, Te(h.value, I => (m(), x(Sn, Q({\n        key: I.self\n      }, I.props), {\n        default: R(() => [I.html ? (m(), N(\"span\", {\n          key: 0,\n          innerHTML: I.html\n        }, null, 8, Pu)) : (m(), N(\"span\", {\n          key: 1,\n          textContent: Z(I.text)\n        }, null, 8, Nu))]),\n        _: 2\n      }, 1040))), 128)), A(S.$slots, \"default\")], 16, Eu));\n    }\n  }),\n  Lu = [\"value\", \"disabled\"],\n  po = /* @__PURE__ */q({\n    __name: \"BFormSelectOption\",\n    props: {\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      value: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.disabled);\n      return (a, l) => (m(), N(\"option\", {\n        value: a.value,\n        disabled: v(o)\n      }, [A(a.$slots, \"default\")], 8, Lu));\n    }\n  }),\n  Fu = [\"label\"],\n  Cn = /* @__PURE__ */q({\n    __name: \"BFormSelectOptionGroup\",\n    props: {\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      label: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() =>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        no(t.options, \"BFormSelectOptionGroup\", t));\n      return (a, l) => (m(), N(\"optgroup\", {\n        label: a.label\n      }, [A(a.$slots, \"first\"), (m(!0), N(ge, null, Te(o.value, (n, i) => (m(), x(po, Q({\n        key: i,\n        value: n.value,\n        disabled: n.disabled\n      }, a.$attrs, {\n        innerHTML: n.html || n.text\n      }), null, 16, [\"value\", \"disabled\", \"innerHTML\"]))), 128)), A(a.$slots, \"default\")], 8, Fu));\n    }\n  }),\n  Hu = [\"id\", \"name\", \"form\", \"multiple\", \"size\", \"disabled\", \"required\", \"aria-required\", \"aria-invalid\"],\n  zu = /* @__PURE__ */q({\n    __name: \"BFormSelect\",\n    props: {\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: {\n        default: void 0\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      id: {\n        default: void 0\n      },\n      labelField: {\n        default: \"label\"\n      },\n      modelValue: {\n        default: \"\"\n      },\n      multiple: {\n        type: [String, Boolean],\n        default: !1\n      },\n      name: {\n        default: void 0\n      },\n      options: {\n        default: () => []\n      },\n      optionsField: {\n        default: \"options\"\n      },\n      plain: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      selectSize: {\n        default: 0\n      },\n      size: {\n        default: \"md\"\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = ke(a, \"modelValue\", l),\n        i = _e(() => a.id, \"input\"),\n        s = r(() => a.autofocus),\n        u = r(() => a.disabled),\n        d = r(() => a.multiple),\n        f = r(() => a.plain),\n        g = r(() => a.required),\n        p = r(() => a.state),\n        y = he(() => a.selectSize),\n        b = wt(p),\n        V = W(null),\n        {\n          focused: C\n        } = xe(V, {\n          initialValue: s.value\n        }),\n        c = w(() => [b.value, {\n          \"form-control\": f.value,\n          [`form-control-${a.size}`]: a.size !== \"md\" && f.value,\n          \"form-select\": !f.value,\n          [`form-select-${a.size}`]: a.size !== \"md\" && !f.value\n        }]),\n        h = E(() => y.value || f.value ? y.value : void 0),\n        B = Ca(() => a.ariaInvalid, p),\n        _ = w(() => no(a.options, \"BFormSelect\", a)),\n        k = w({\n          get: () => n.value,\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          set: S => {\n            l(\"input\", S), n.value = S, Ne(() => {\n              l(\"change\", S);\n            });\n          }\n        });\n      return t({\n        blur: () => {\n          C.value = !1;\n        },\n        element: V,\n        focus: () => {\n          C.value = !0;\n        }\n      }), (S, $) => ht((m(), N(\"select\", {\n        id: v(i),\n        ref_key: \"input\",\n        ref: V,\n        \"onUpdate:modelValue\": $[0] || ($[0] = I => k.value = I),\n        class: j(c.value),\n        name: S.name,\n        form: S.form || void 0,\n        multiple: v(d) || void 0,\n        size: h.value,\n        disabled: v(u),\n        required: v(g) || void 0,\n        \"aria-required\": v(g) || void 0,\n        \"aria-invalid\": v(B)\n      }, [A(S.$slots, \"first\"), (m(!0), N(ge, null, Te(_.value, (I, T) => (m(), N(ge, {\n        key: T\n      }, [Array.isArray(I.options) ? (m(), x(Cn, {\n        key: 0,\n        label: I.label,\n        options: I.options\n      }, null, 8, [\"label\", \"options\"])) : (m(), x(po, {\n        key: 1,\n        value: I.value,\n        disabled: I.disabled,\n        innerHTML: I.html || I.text\n      }, null, 8, [\"value\", \"disabled\", \"innerHTML\"]))], 64))), 128)), A(S.$slots, \"default\")], 10, Hu)), [[Wn, k.value]]);\n    }\n  }),\n  xo = [\"ar\", \"az\", \"ckb\", \"fa\", \"he\", \"ks\", \"lrc\", \"mzn\", \"ps\", \"sd\", \"te\", \"ug\", \"ur\", \"yi\"].map(e => e.toLowerCase()),\n  Ru = e => {\n    const t = ca(e).toLowerCase().replace(Jn, \"\").split(\"-\"),\n      o = t.slice(0, 2).join(\"-\"),\n      [a] = t;\n    return xo.includes(o) || xo.includes(a);\n  },\n  xu = e => ds ? Po(e) ? e : {\n    capture: !!e || !1\n  } : !!(Po(e) ? e.capture : e),\n  Mu = (e, t, o, a) => {\n    e && e.addEventListener && e.addEventListener(t, o, xu(a));\n  },\n  Du = (e, t, o, a) => {\n    e && e.removeEventListener && e.removeEventListener(t, o, a);\n  },\n  Mo = (e, t) => {\n    (e ? Mu : Du)(...t);\n  },\n  na = (e, {\n    preventDefault: t = !0,\n    propagation: o = !0,\n    immediatePropagation: a = !1\n  } = {}) => {\n    t && e.preventDefault(), o && e.stopPropagation(), a && e.stopImmediatePropagation();\n  },\n  Na = \"ArrowDown\",\n  Do = \"End\",\n  jo = \"Home\",\n  qo = \"PageDown\",\n  Go = \"PageUp\",\n  Ia = \"ArrowUp\",\n  ju = [\"lang\", \"tabindex\", \"title\"],\n  qu = [\"name\", \"form\", \"value\"],\n  Gu = [\"id\", \"dir\", \"tabindex\", \"aria-label\", \"aria-invalid\", \"aria-required\", \"aria-valuemin\", \"aria-valuemax\", \"aria-valuenow\", \"aria-valuetext\"],\n  je = {\n    min: 1,\n    max: 100,\n    step: 1,\n    repeatDelay: 500,\n    repeatInterval: 100,\n    repeatThreshold: 10,\n    repeatMultiplier: 4\n  },\n  Wu = /* @__PURE__ */q({\n    __name: \"BFormSpinbutton\",\n    props: {\n      ariaControls: {\n        default: void 0\n      },\n      ariaLabel: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      formatterFn: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      labelDecrement: {\n        default: \"Decrement\"\n      },\n      labelIncrement: {\n        default: \"Increment\"\n      },\n      locale: {\n        default: \"locale\"\n      },\n      max: {\n        default: je.max\n      },\n      min: {\n        default: je.min\n      },\n      modelValue: {\n        default: null\n      },\n      name: {\n        default: void 0\n      },\n      placeholder: {\n        default: void 0\n      },\n      readonly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      repeatDelay: {\n        default: je.repeatDelay\n      },\n      repeatInterval: {\n        default: je.repeatInterval\n      },\n      repeatStepMultiplier: {\n        default: je.repeatMultiplier\n      },\n      repeatThreshold: {\n        default: je.repeatThreshold\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      step: {\n        default: je.step\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      },\n      wrap: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"change\", \"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = [Ia, Na, jo, Do, Go, qo],\n        a = e,\n        l = t,\n        n = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        i = W(null),\n        {\n          focused: s\n        } = xe(i),\n        u = _e(() => a.id, \"spinbutton\"),\n        d = r(() => a.disabled),\n        f = r(() => a.inline),\n        g = r(() => a.readonly),\n        p = r(() => a.vertical),\n        y = r(() => a.required),\n        b = r(() => a.wrap),\n        V = r(() => a.state),\n        C = w(() => ({\n          disabled: d.value,\n          readonly: g.value,\n          focus: s.value,\n          \"d-inline-flex\": f.value || p.value,\n          \"d-flex\": !f.value && !p.value,\n          \"align-items-stretch\": !p.value,\n          \"flex-column\": p.value,\n          [`form-control-${a.size}`]: a.size !== void 0\n        })),\n        c = w(() => ({\n          \"d-flex\": p.value,\n          \"align-self-center\": !p.value,\n          \"align-items-center\": p.value,\n          \"border-top\": p.value,\n          \"border-bottom\": p.value,\n          \"border-start\": !p.value,\n          \"border-end\": !p.value\n        }));\n      let h,\n        B,\n        _ = !1;\n      const k = he(() => a.step),\n        S = E(() => Number.isNaN(k.value) ? je.step : k.value),\n        $ = he(() => a.min),\n        I = E(() => Number.isNaN($.value) ? je.min : $.value),\n        T = he(() => a.max),\n        O = E(() => {\n          const ie = S.value,\n            ce = I.value;\n          return Math.floor((T.value - ce) / ie) * ie + ce;\n        }),\n        F = he(() => a.repeatDelay, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        K = E(() => F.value > 0 ? F.value : je.repeatDelay),\n        z = he(() => a.repeatInterval, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        P = E(() => z.value > 0 ? z.value : je.repeatInterval),\n        D = he(() => a.repeatThreshold, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        ae = E(() => Math.max(Number.isNaN(D.value) ? je.repeatThreshold : D.value, 1)),\n        le = he(() => a.repeatStepMultiplier, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        ve = E(() => Math.max(Number.isNaN(le.value) ? je.repeatMultiplier : le.value, 1)),\n        Be = E(() => {\n          const ie = S.value;\n          return Math.floor(ie) === ie ? 0 : (ie.toString().split(\".\")[1] || \"\").length;\n        }),\n        Ve = E(() => Math.pow(10, Be.value || 0)),\n        oe = E(() => n.value === null ? \"\" : n.value.toFixed(Be.value)),\n        fe = w(() => {\n          const ie = [a.locale];\n          return new Intl.NumberFormat(ie).resolvedOptions().locale;\n        }),\n        $e = w(() =>\n        // TODO\n        Ru(fe.value)),\n        we = () => new Intl.NumberFormat(fe.value, {\n          style: \"decimal\",\n          useGrouping: !1,\n          minimumIntegerDigits: 1,\n          minimumFractionDigits: Be.value,\n          maximumFractionDigits: Be.value,\n          notation: \"standard\"\n        }).format,\n        M = E(() => a.formatterFn ?? we()),\n        L = ie => {\n          let {\n            value: ce\n          } = n;\n          if (!d.value && ce !== null) {\n            const Ce = S.value * ie,\n              Y = I.value,\n              re = O.value,\n              Ae = Ve.value,\n              {\n                wrap: He\n              } = a;\n            ce = Math.round((ce - Y) / Ce) * Ce + Y + Ce, ce = Math.round(ce * Ae) / Ae, n.value = ce > re ? He ? Y : re : ce < Y ? He ? re : Y : ce;\n          }\n        },\n        U = (ie = 1) => {\n          if (n.value === null) {\n            n.value = I.value;\n            return;\n          }\n          L(1 * ie);\n        },\n        H = (ie = 1) => {\n          if (n.value === null) {\n            n.value = b.value ? O.value : I.value;\n            return;\n          }\n          L(-1 * ie);\n        };\n      qe(o, ie => {\n        const {\n          code: ce,\n          altKey: Ce,\n          ctrlKey: Y,\n          metaKey: re\n        } = ie;\n        if (!(d.value || g.value || Ce || Y || re) && (na(ie, {\n          propagation: !1\n        }), !_)) {\n          if (me(), [Ia, Na].includes(ce)) {\n            if (_ = !0, ce === Ia) {\n              G(ie, U);\n              return;\n            }\n            ce === Na && G(ie, H);\n            return;\n          }\n          if (ce === Go) {\n            U(ve.value);\n            return;\n          }\n          if (ce === qo) {\n            H(ve.value);\n            return;\n          }\n          if (ce === jo) {\n            n.value = I.value;\n            return;\n          }\n          ce === Do && (n.value = O.value);\n        }\n      }, {\n        target: i,\n        eventName: \"keydown\"\n      }), qe(o, ie => {\n        const {\n          altKey: ce,\n          ctrlKey: Ce,\n          metaKey: Y\n        } = ie;\n        d.value || g.value || ce || Ce || Y || (na(ie, {\n          propagation: !1\n        }), me(), _ = !1, l(\"change\", n.value));\n      }, {\n        target: i,\n        eventName: \"keyup\"\n      });\n      const G = (ie, ce) => {\n          const {\n            type: Ce\n          } = ie || {};\n          if (!d.value && !g.value) {\n            if (X(ie) && Ce === \"mousedown\" && ie.button) return;\n            me(), ce(1);\n            const Y = ae.value,\n              re = ve.value,\n              Ae = K.value,\n              He = P.value;\n            h = setTimeout(() => {\n              let Re = 0;\n              B = setInterval(() => {\n                ce(Re < Y ? 1 : re), Re++;\n              }, He);\n            }, Ae);\n          }\n        },\n        X = ie => ie.type === \"mouseup\" || ie.type === \"mousedown\",\n        te = ie => {\n          X(ie) && ie.type === \"mouseup\" && ie.button || (na(ie, {\n            propagation: !1\n          }), me(), be(!1), l(\"change\", n.value));\n        },\n        be = ie => {\n          try {\n            Mo(ie, [document.body, \"mouseup\", te, !1]), Mo(ie, [document.body, \"touchend\", te, !1]);\n          } catch {}\n        },\n        me = () => {\n          clearTimeout(h), clearInterval(B), h = void 0, B = void 0;\n        },\n        de = w(() => {\n          const ie = {\n              svg: {\n                xmlns: \"http://www.w3.org/2000/svg\",\n                width: \"16\",\n                height: \"16\",\n                fill: \"currentColor\",\n                class: \"bi bi-plus\",\n                viewBox: \"0 0 16 16\"\n              },\n              path: {\n                d: \"M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z\"\n              }\n            },\n            ce = {\n              svg: {\n                xmlns: \"http://www.w3.org/2000/svg\",\n                width: \"16\",\n                height: \"16\",\n                fill: \"currentColor\",\n                class: \"bi bi-dash\",\n                viewBox: \"0 0 16 16\"\n              },\n              path: {\n                d: \"M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z\"\n              }\n            },\n            Ce = {\n              class: [{\n                \"py-0\": !p.value\n              }, \"btn\", \"btn-sm\", \"border-0\", \"rounded-0\"],\n              tabindex: \"-1\",\n              type: \"button\",\n              disabled: d.value || g.value,\n              \"aria-disabled\": d.value || g.value ? !0 : void 0,\n              \"aria-controls\": u.value\n            },\n            Y = {\n              \"aria-hidden\": !0,\n              scale: s.value ? 1.5 : 1.25\n            },\n            re = (Re, kt) => {\n              !d.value && !g.value && (na(Re, {\n                propagation: !1\n              }), be(!0), s.value = !0, G(Re, kt));\n            },\n            Ae = {\n              button: {\n                ...Ce,\n                \"aria-label\": a.labelIncrement || void 0,\n                \"aria-keyshortcuts\": \"ArrowUp\"\n              },\n              svg: {\n                ...Y,\n                ...ie.svg\n              },\n              path: {\n                ...ie.path\n              },\n              slot: {\n                name: \"increment\"\n              },\n              handler: Re => re(Re, U)\n            },\n            He = {\n              button: {\n                ...Ce,\n                \"aria-label\": a.labelDecrement || void 0,\n                \"aria-keyshortcuts\": \"ArrowDown\"\n              },\n              svg: {\n                ...Y,\n                ...ce.svg\n              },\n              path: {\n                ...ce.path\n              },\n              slot: {\n                name: \"decrement\"\n              },\n              handler: Re => re(Re, H)\n            };\n          return {\n            top: {\n              ...(p.value ? Ae : He)\n            },\n            bottom: {\n              ...(p.value ? He : Ae)\n            }\n          };\n        });\n      return (ie, ce) => (m(), N(\"div\", {\n        ref_key: \"element\",\n        ref: i,\n        class: j([\"b-form-spinbutton form-control\", C.value]),\n        role: \"group\",\n        lang: fe.value,\n        tabindex: v(d) ? void 0 : \"-1\",\n        title: ie.ariaLabel,\n        onClick: ce[4] || (ce[4] = Ce => s.value = !0)\n      }, [A(ie.$slots, de.value.top.slot.name, {\n        hasFocus: v(s)\n      }, () => [ee(\"button\", Q(de.value.top.button, {\n        onMousedown: ce[0] || (ce[0] =\n        //@ts-ignore\n        (...Ce) => de.value.top.handler && de.value.top.handler(...Ce)),\n        onTouchstart: ce[1] || (ce[1] =\n        //@ts-ignore\n        (...Ce) => de.value.top.handler && de.value.top.handler(...Ce))\n      }), [(m(), N(\"svg\", Se(Ee(de.value.top.svg)), [ee(\"path\", Se(Ee(de.value.top.path)), null, 16)], 16))], 16)]), ie.name && !v(d) ? (m(), N(\"input\", {\n        key: \"hidden\",\n        type: \"hidden\",\n        name: ie.name,\n        form: ie.form,\n        value: oe.value\n      }, null, 8, qu)) : J(\"\", !0), ee(\"output\", {\n        id: v(u),\n        key: \"output\",\n        class: j([\"flex-grow-1\", c.value]),\n        dir: $e.value ? \"rtl\" : \"ltr\",\n        tabindex: v(d) ? void 0 : \"0\",\n        role: \"spinbutton\",\n        \"aria-live\": \"off\",\n        \"aria-label\": ie.ariaLabel || void 0,\n        \"aria-invalid\": v(V) === !1 || !v(n) !== null && v(y) ? !0 : void 0,\n        \"aria-required\": v(y) ? !0 : void 0,\n        \"aria-valuemin\": I.value,\n        \"aria-valuemax\": O.value,\n        \"aria-valuenow\": v(n) !== null ? v(n) : void 0,\n        \"aria-valuetext\": v(n) !== null ? M.value(v(n)) : void 0\n      }, [ee(\"bdi\", null, Z((v(n) !== null ? M.value(v(n)) : ie.placeholder) || \"\"), 1)], 10, Gu), A(ie.$slots, de.value.bottom.slot.name, {\n        hasFocus: v(s)\n      }, () => [ee(\"button\", Q(de.value.bottom.button, {\n        onMousedown: ce[2] || (ce[2] =\n        //@ts-ignore\n        (...Ce) => de.value.bottom.handler && de.value.bottom.handler(...Ce)),\n        onTouchstart: ce[3] || (ce[3] =\n        //@ts-ignore\n        (...Ce) => de.value.bottom.handler && de.value.bottom.handler(...Ce))\n      }), [(m(), N(\"svg\", Se(Ee(de.value.bottom.svg)), [ee(\"path\", Se(Ee(de.value.bottom.path)), null, 16)], 16))], 16)])], 10, ju));\n    }\n  }),\n  Uu = [\"id\"],\n  wn = /* @__PURE__ */q({\n    __name: \"BFormTag\",\n    props: {\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      noRemove: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      removeLabel: {\n        default: \"Remove tag\"\n      },\n      tag: {\n        default: \"span\"\n      },\n      title: {\n        default: void 0\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"remove\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = Me(),\n        n = _e(() => o.id),\n        i = r(() => o.disabled),\n        s = r(() => o.noRemove),\n        u = r(() => o.pill),\n        d = w(() => {\n          var p;\n          return ((((p = l.default) == null ? void 0 : p.call(l, {})[0].children) ?? \"\").toString() || o.title) ?? \"\";\n        }),\n        f = E(() => `${n.value}taglabel__`),\n        g = w(() => ({\n          [`text-bg-${o.variant}`]: o.variant !== null,\n          \"rounded-pill\": u.value,\n          disabled: i.value\n        }));\n      return (p, y) => (m(), x(se(p.tag), {\n        id: v(n),\n        title: d.value,\n        class: j([\"badge b-form-tag d-inline-flex align-items-center mw-100\", g.value]),\n        \"aria-labelledby\": f.value\n      }, {\n        default: R(() => [ee(\"span\", {\n          id: f.value,\n          class: \"b-form-tag-content flex-grow-1 text-truncate\"\n        }, [A(p.$slots, \"default\", {}, () => [ne(Z(d.value), 1)])], 8, Uu), !v(i) && !v(s) ? (m(), x(Dt, {\n          key: 0,\n          \"aria-keyshortcuts\": \"Delete\",\n          \"aria-label\": p.removeLabel,\n          class: \"b-form-tag-remove\",\n          \"aria-describedby\": f.value,\n          \"aria-controls\": p.id,\n          onClick: y[0] || (y[0] = b => a(\"remove\", d.value))\n        }, null, 8, [\"aria-label\", \"aria-describedby\", \"aria-controls\"])) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"title\", \"class\", \"aria-labelledby\"]));\n    }\n  }),\n  Xu = [\"id\"],\n  Ku = [\"id\", \"for\", \"aria-live\"],\n  Yu = [\"id\", \"aria-live\"],\n  Zu = [\"id\"],\n  Ju = [\"aria-controls\"],\n  Qu = {\n    role: \"group\",\n    class: \"d-flex\"\n  },\n  ed = [\"id\", \"disabled\", \"value\", \"type\", \"placeholder\", \"form\", \"required\", \"aria-required\"],\n  td = [\"disabled\"],\n  ad = {\n    \"aria-live\": \"polite\",\n    \"aria-atomic\": \"true\"\n  },\n  od = {\n    key: 0,\n    class: \"d-block invalid-feedback\"\n  },\n  ld = {\n    key: 1,\n    class: \"form-text text-body-secondary\"\n  },\n  nd = {\n    key: 2,\n    class: \"form-text text-body-secondary\"\n  },\n  sd = [\"name\", \"value\"],\n  id = /* @__PURE__ */q({\n    __name: \"BFormTags\",\n    props: {\n      addButtonText: {\n        default: \"Add\"\n      },\n      addButtonVariant: {\n        default: \"outline-secondary\"\n      },\n      addOnChange: {\n        type: [String, Boolean],\n        default: !1\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      duplicateTagText: {\n        default: \"Duplicate tag(s)\"\n      },\n      form: {\n        default: void 0\n      },\n      inputAttrs: {\n        default: void 0\n      },\n      inputClass: {\n        default: void 0\n      },\n      inputId: {\n        default: void 0\n      },\n      inputType: {\n        default: \"text\"\n      },\n      invalidTagText: {\n        default: \"Invalid tag(s)\"\n      },\n      limit: {\n        default: void 0\n      },\n      limitTagsText: {\n        default: \"Tag limit reached\"\n      },\n      modelValue: {\n        default: () => []\n      },\n      name: {\n        default: void 0\n      },\n      noAddOnEnter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noOuterFocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noTagRemove: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placeholder: {\n        default: \"Add tag...\"\n      },\n      removeOnDelete: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      separator: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      tagClass: {\n        default: void 0\n      },\n      tagPills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tagRemoveLabel: {\n        default: void 0\n      },\n      tagRemovedLabel: {\n        default: \"Tag removed\"\n      },\n      tagValidator: {\n        type: Function,\n        default: () => !0\n      },\n      tagVariant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"blur\", \"focus\", \"focusin\", \"focusout\", \"input\", \"tag-state\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = ke(a, \"modelValue\", l),\n        i = _e(),\n        s = r(() => a.addOnChange),\n        u = r(() => a.autofocus),\n        d = r(() => a.disabled),\n        f = r(() => a.noAddOnEnter),\n        g = r(() => a.noOuterFocus),\n        p = r(() => a.noTagRemove),\n        y = r(() => a.removeOnDelete),\n        b = r(() => a.required),\n        V = r(() => a.state),\n        C = r(() => a.tagPills),\n        c = he(() => a.limit ?? NaN),\n        h = wt(V),\n        B = W(null),\n        {\n          focused: _\n        } = xe(B, {\n          initialValue: u.value\n        }),\n        k = E(() => a.inputId || `${i.value}input__`),\n        S = W(n.value),\n        $ = W(\"\"),\n        I = W(n.value.length > 0),\n        T = W(\"\"),\n        O = W([]),\n        F = W([]),\n        K = W([]),\n        z = w(() => [h.value, {\n          [`form-control-${a.size}`]: a.size !== \"md\",\n          disabled: d.value,\n          focus: _.value\n        }]),\n        P = w(() => S.value.includes($.value)),\n        D = w(() => $.value === \"\" ? !1 : !a.tagValidator($.value)),\n        ae = E(() => S.value.length === c.value),\n        le = E(() => !D.value && !P.value),\n        ve = w(() => ({\n          addButtonText: a.addButtonText,\n          addButtonVariant: a.addButtonVariant,\n          addTag: U,\n          disableAddButton: le.value,\n          disabled: d.value,\n          duplicateTagText: a.duplicateTagText,\n          duplicateTags: K.value,\n          form: a.form,\n          inputAttrs: {\n            ...a.inputAttrs,\n            disabled: d.value,\n            form: a.form,\n            id: k,\n            value: $\n          },\n          inputHandlers: {\n            input: fe,\n            keydown: we,\n            change: $e\n          },\n          inputId: k,\n          inputType: a.inputType,\n          invalidTagText: a.invalidTagText,\n          invalidTags: F.value,\n          isDuplicate: P.value,\n          isInvalid: D.value,\n          isLimitReached: ae.value,\n          limitTagsText: a.limitTagsText,\n          limit: c.value,\n          noTagRemove: p.value,\n          placeholder: a.placeholder,\n          removeTag: H,\n          required: b.value,\n          separator: a.separator,\n          size: a.size,\n          state: V.value,\n          tagClass: a.tagClass,\n          tagPills: C.value,\n          tagRemoveLabel: a.tagRemoveLabel,\n          tagVariant: a.tagVariant,\n          tags: S.value\n        }));\n      ue(n, G => {\n        S.value = G;\n      });\n      const Be = G => {\n          if (d.value) {\n            G.target.blur();\n            return;\n          }\n          l(\"focusin\", G);\n        },\n        Ve = G => {\n          d.value || g.value || (_.value = !0, l(\"focus\", G));\n        },\n        oe = G => {\n          _.value = !1, l(\"blur\", G);\n        },\n        fe = G => {\n          var te, be;\n          const X = typeof G == \"string\" ? G : G.target.value;\n          if (I.value = !1, (te = a.separator) != null && te.includes(X.charAt(0)) && X.length > 0) {\n            B.value && (B.value.value = \"\");\n            return;\n          }\n          if ($.value = X, (be = a.separator) != null && be.includes(X.charAt(X.length - 1))) {\n            U(X.slice(0, X.length - 1));\n            return;\n          }\n          O.value = a.tagValidator(X) && !P.value ? [X] : [], F.value = a.tagValidator(X) ? [] : [X], K.value = P.value ? [X] : [], l(\"tag-state\", O.value, F.value, K.value);\n        },\n        $e = G => {\n          s.value && (fe(G), P.value || U($.value));\n        },\n        we = G => {\n          if (G.key === \"Enter\" && !f.value) {\n            U($.value);\n            return;\n          }\n          (G.key === \"Backspace\" || G.key === \"Delete\") && y.value && $.value === \"\" && I.value && S.value.length > 0 ? H(S.value[S.value.length - 1]) : I.value = !0;\n        };\n      qe(we, {\n        target: B\n      });\n      const M = w(() => {\n          if (a.separator) return typeof a.separator == \"string\" ? a.separator : a.separator.join(\"\");\n        }),\n        L = w(() => {\n          if (M.value) return new RegExp(`[${os(M.value)}]+`);\n        }),\n        U = G => {\n          G = (G ?? $.value).trim();\n          const X = L.value ? G.split(L.value).map(me => me.trim()) : [G],\n            te = [];\n          for (const me of X) if (!(me === \"\" || P.value || !a.tagValidator(me))) {\n            if (c.value && ae.value) break;\n            te.push(me);\n          }\n          const be = [...n.value, ...te];\n          $.value = \"\", I.value = !0, n.value = be, l(\"input\", be), _.value = !0;\n        },\n        H = G => {\n          const X = S.value.indexOf((G == null ? void 0 : G.toString()) ?? \"\");\n          T.value = S.value.splice(X, 1).toString(), n.value = S.value;\n        };\n      return t({\n        blur: () => {\n          _.value = !1;\n        },\n        element: B,\n        focus: () => {\n          _.value = !0;\n        }\n      }), (G, X) => (m(), N(\"div\", {\n        id: v(i),\n        class: j([\"b-form-tags form-control h-auto\", z.value]),\n        role: \"group\",\n        tabindex: \"-1\",\n        onFocusin: Be,\n        onFocusout: X[1] || (X[1] = te => l(\"focusout\", te))\n      }, [ee(\"output\", {\n        id: `${v(i)}selected_tags__`,\n        class: \"visually-hidden\",\n        for: k.value,\n        \"aria-live\": v(_) ? \"polite\" : \"off\",\n        \"aria-atomic\": \"true\",\n        \"aria-relevant\": \"additions text\"\n      }, Z(S.value.join(\", \")), 9, Ku), ee(\"div\", {\n        id: `${v(i)}removed_tags__`,\n        role: \"status\",\n        \"aria-live\": v(_) ? \"assertive\" : \"off\",\n        \"aria-atomic\": \"true\",\n        class: \"visually-hidden\"\n      }, \" (\" + Z(G.tagRemovedLabel) + \") \" + Z(T.value), 9, Yu), A(G.$slots, \"default\", Se(Ee(ve.value)), () => [ee(\"ul\", {\n        id: `${v(i)}tag_list__`,\n        class: \"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      }, [(m(!0), N(ge, null, Te(S.value, (te, be) => A(G.$slots, \"tag\", {\n        key: be,\n        tag: te,\n        tagClass: G.tagClass,\n        tagVariant: G.tagVariant,\n        tagPills: v(C),\n        removeTag: H\n      }, () => [(m(), x(wn, {\n        key: te,\n        class: j(G.tagClass),\n        tag: \"li\",\n        variant: G.tagVariant,\n        pill: G.tagPills,\n        onRemove: H\n      }, {\n        default: R(() => [ne(Z(te), 1)]),\n        _: 2\n      }, 1032, [\"class\", \"variant\", \"pill\"]))])), 128)), ee(\"li\", {\n        role: \"none\",\n        \"aria-live\": \"off\",\n        class: \"b-from-tags-field flex-grow-1\",\n        \"aria-controls\": `${v(i)}tag_list__`\n      }, [ee(\"div\", Qu, [ee(\"input\", Q({\n        id: k.value,\n        ref_key: \"input\",\n        ref: B,\n        disabled: v(d),\n        value: $.value,\n        type: G.inputType,\n        placeholder: G.placeholder,\n        class: \"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\",\n        style: {\n          outline: \"currentcolor none 0px\",\n          \"min-width\": \"5rem\"\n        }\n      }, G.inputAttrs, {\n        form: G.form,\n        required: v(b) || void 0,\n        \"aria-required\": v(b) || void 0,\n        onInput: fe,\n        onChange: $e,\n        onFocus: Ve,\n        onBlur: oe\n      }), null, 16, ed), le.value ? (m(), N(\"button\", {\n        key: 0,\n        type: \"button\",\n        class: j([\"btn b-form-tags-button py-0\", [G.inputClass, {\n          [`btn-${G.addButtonVariant}`]: G.addButtonVariant !== null,\n          \"disabled invisible\": $.value.length === 0\n        }]]),\n        style: {\n          \"font-size\": \"90%\"\n        },\n        disabled: v(d) || $.value.length === 0 || ae.value,\n        onClick: X[0] || (X[0] = te => U($.value))\n      }, [A(G.$slots, \"add-button-text\", {}, () => [ne(Z(G.addButtonText), 1)])], 10, td)) : J(\"\", !0)])], 8, Ju)], 8, Zu), ee(\"div\", ad, [D.value ? (m(), N(\"div\", od, Z(G.invalidTagText) + \": \" + Z($.value), 1)) : J(\"\", !0), P.value ? (m(), N(\"small\", ld, Z(G.duplicateTagText) + \": \" + Z($.value), 1)) : J(\"\", !0), S.value.length === G.limit ? (m(), N(\"small\", nd, \"Tag limit reached\")) : J(\"\", !0)])]), G.name ? (m(!0), N(ge, {\n        key: 0\n      }, Te(S.value, (te, be) => (m(), N(\"input\", {\n        key: be,\n        type: \"hidden\",\n        name: G.name,\n        value: te\n      }, null, 8, sd))), 128)) : J(\"\", !0)], 42, Xu));\n    }\n  }),\n  rd = [\"id\", \"name\", \"form\", \"value\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"aria-required\", \"aria-invalid\", \"rows\", \"wrap\"],\n  ud = /* @__PURE__ */q({\n    __name: \"BFormTextarea\",\n    props: {\n      noResize: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rows: {\n        default: 2\n      },\n      wrap: {\n        default: \"soft\"\n      },\n      ariaInvalid: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      autocomplete: {\n        default: void 0\n      },\n      autofocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      form: {\n        default: void 0\n      },\n      debounce: {\n        default: 0\n      },\n      debounceMaxWait: {\n        default: NaN\n      },\n      formatter: {\n        type: Function,\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazyFormatter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      list: {\n        default: void 0\n      },\n      modelValue: {\n        default: \"\"\n      },\n      name: {\n        default: void 0\n      },\n      number: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placeholder: {\n        default: void 0\n      },\n      plaintext: {\n        type: [String, Boolean],\n        default: !1\n      },\n      readonly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      required: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: void 0\n      },\n      state: {\n        type: [String, Boolean, null],\n        default: null\n      },\n      trim: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"blur\", \"change\", \"input\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        {\n          input: n,\n          computedId: i,\n          computedAriaInvalid: s,\n          onInput: u,\n          onChange: d,\n          onBlur: f,\n          focus: g,\n          blur: p\n        } = ql(a, l),\n        y = r(() => a.disabled),\n        b = r(() => a.required),\n        V = r(() => a.readonly),\n        C = r(() => a.plaintext),\n        c = r(() => a.noResize),\n        h = r(() => a.state),\n        B = wt(h),\n        _ = w(() => [B.value, {\n          \"form-control\": !a.plaintext,\n          \"form-control-plaintext\": a.plaintext,\n          [`form-control-${a.size}`]: !!a.size\n        }]),\n        k = w(() => ({\n          resize: c.value ? \"none\" : void 0\n        }));\n      return t({\n        blur: p,\n        element: n,\n        focus: g\n      }), (S, $) => (m(), N(\"textarea\", {\n        id: v(i),\n        ref_key: \"input\",\n        ref: n,\n        class: j(_.value),\n        name: S.name || void 0,\n        form: S.form || void 0,\n        value: S.modelValue,\n        disabled: v(y),\n        placeholder: S.placeholder,\n        required: v(b) || void 0,\n        autocomplete: S.autocomplete || void 0,\n        readonly: v(V) || v(C),\n        \"aria-required\": S.required || void 0,\n        \"aria-invalid\": v(s),\n        rows: S.rows,\n        style: ze(k.value),\n        wrap: S.wrap || void 0,\n        onInput: $[0] || ($[0] = I => v(u)(I)),\n        onChange: $[1] || ($[1] = I => v(d)(I)),\n        onBlur: $[2] || ($[2] = I => v(f)(I))\n      }, null, 46, rd));\n    }\n  }),\n  dd = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  cd = [\"innerHTML\"],\n  fd = {\n    key: 1\n  },\n  vd = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  pd = [\"innerHTML\"],\n  md = {\n    key: 1\n  },\n  gd = /* @__PURE__ */q({\n    __name: \"BInputGroup\",\n    props: {\n      append: {\n        default: void 0\n      },\n      appendHtml: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      prepend: {\n        default: void 0\n      },\n      prependHtml: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`input-group-${t.size}`]: t.size !== \"md\"\n        })),\n        a = E(() => !!t.append || !!t.appendHtml),\n        l = E(() => !!t.prepend || !!t.prependHtml);\n      return (n, i) => (m(), x(se(n.tag), {\n        id: n.id,\n        class: j([\"input-group\", o.value]),\n        role: \"group\"\n      }, {\n        default: R(() => [A(n.$slots, \"prepend\", {}, () => [l.value ? (m(), N(\"span\", dd, [n.prependHtml ? (m(), N(\"span\", {\n          key: 0,\n          innerHTML: n.prependHtml\n        }, null, 8, cd)) : (m(), N(\"span\", fd, Z(n.prepend), 1))])) : J(\"\", !0)]), A(n.$slots, \"default\"), A(n.$slots, \"append\", {}, () => [a.value ? (m(), N(\"span\", vd, [n.appendHtml ? (m(), N(\"span\", {\n          key: 0,\n          innerHTML: n.appendHtml\n        }, null, 8, pd)) : (m(), N(\"span\", md, Z(n.append), 1))])) : J(\"\", !0)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  kn = /* @__PURE__ */q({\n    __name: \"BInputGroupText\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), x(se(t.tag), {\n        class: \"input-group-text\"\n      }, {\n        default: R(() => [A(t.$slots, \"default\", {}, () => [ne(Z(t.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  mo = /* @__PURE__ */q({\n    __name: \"BInputGroupAddon\",\n    props: {\n      isText: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.isText);\n      return (a, l) => v(o) ? (m(), x(kn, {\n        key: 0\n      }, {\n        default: R(() => [A(a.$slots, \"default\")]),\n        _: 3\n      })) : A(a.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  bd = /* @__PURE__ */q({\n    __name: \"BInputGroupAppend\",\n    props: {\n      isText: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), x(mo, Se(Ee(t.$props)), {\n        default: R(() => [A(t.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  yd = /* @__PURE__ */q({\n    __name: \"BInputGroupPrepend\",\n    props: {\n      isText: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), x(mo, Se(Ee(t.$props)), {\n        default: R(() => [A(t.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  hd = /* @__PURE__ */q({\n    __name: \"BListGroup\",\n    props: {\n      flush: {\n        type: [String, Boolean],\n        default: !1\n      },\n      horizontal: {\n        type: [String, Boolean],\n        default: !1\n      },\n      numbered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.flush),\n        a = r(() => t.numbered),\n        l = r(() => t.horizontal),\n        n = w(() => {\n          const s = o.value ? !1 : l.value;\n          return {\n            \"list-group-flush\": o.value,\n            \"list-group-horizontal\": s === !0,\n            [`list-group-horizontal-${s}`]: typeof s == \"string\",\n            \"list-group-numbered\": a.value\n          };\n        }),\n        i = E(() => a.value === !0 ? \"ol\" : t.tag);\n      return at(Ql, {\n        numbered: a\n      }), (s, u) => (m(), x(se(i.value), {\n        class: j([\"list-group\", n.value])\n      }, {\n        default: R(() => [A(s.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Bd = /* @__PURE__ */q({\n    __name: \"BListGroupItem\",\n    props: {\n      action: {\n        type: [String, Boolean],\n        default: !1\n      },\n      button: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Kt(),\n        a = Ge(Ql, null),\n        l = r(() => t.action),\n        n = r(() => t.active),\n        i = r(() => t.button),\n        s = r(() => t.disabled),\n        {\n          computedLink: u\n        } = Ct(t),\n        d = E(() => !i.value && u.value),\n        f = E(() => a != null && a.numbered.value ? \"li\" : i.value ? \"button\" : d.value ? rt : t.tag),\n        g = w(() => l.value || d.value || i.value || [\"a\", \"router-link\", \"button\", \"b-link\"].includes(t.tag)),\n        p = w(() => ({\n          [`list-group-item-${t.variant}`]: t.variant !== null && t.variant !== void 0,\n          \"list-group-item-action\": g.value,\n          active: n.value,\n          disabled: s.value\n        })),\n        y = w(() => {\n          const b = {};\n          return i.value && ((!o || !o.type) && (b.type = \"button\"), s.value && (b.disabled = !0)), b;\n        });\n      return (b, V) => (m(), x(se(f.value), Q({\n        class: [\"list-group-item\", p.value],\n        \"aria-current\": v(n) ? !0 : void 0,\n        \"aria-disabled\": v(s) ? !0 : void 0,\n        target: d.value ? b.target : void 0,\n        href: v(i) ? void 0 : b.href,\n        to: v(i) ? void 0 : b.to\n      }, y.value), {\n        default: R(() => [A(b.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"aria-current\", \"aria-disabled\", \"target\", \"href\", \"to\"]));\n    }\n  }),\n  Ta = /* @__PURE__ */q({\n    __name: \"BOverlay\",\n    props: {\n      bgColor: {\n        default: void 0\n      },\n      blur: {\n        default: \"2px\"\n      },\n      fixed: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCenter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noSpinner: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noWrap: {\n        type: [String, Boolean],\n        default: !1\n      },\n      opacity: {\n        default: 0.85\n      },\n      overlayTag: {\n        default: \"div\"\n      },\n      show: {\n        type: [String, Boolean],\n        default: !1\n      },\n      spinnerSmall: {\n        type: [String, Boolean],\n        default: !1\n      },\n      spinnerType: {\n        default: \"border\"\n      },\n      spinnerVariant: {\n        default: void 0\n      },\n      variant: {\n        default: \"light\"\n      },\n      wrapTag: {\n        default: \"div\"\n      },\n      zIndex: {\n        default: 10\n      },\n      rounded: {\n        type: [String, Number, Boolean],\n        default: !1\n      },\n      roundedTop: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedBottom: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedStart: {\n        type: [String, Number, Boolean],\n        default: void 0\n      },\n      roundedEnd: {\n        type: [String, Number, Boolean],\n        default: void 0\n      }\n    },\n    emits: [\"click\", \"hidden\", \"shown\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = {\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0\n        },\n        n = r(() => o.fixed),\n        i = r(() => o.noSpinner),\n        s = r(() => o.noCenter),\n        u = r(() => o.noWrap),\n        d = r(() => o.show),\n        f = r(() => o.spinnerSmall),\n        g = r(() => o.rounded),\n        p = r(() => o.roundedTop),\n        y = r(() => o.roundedBottom),\n        b = r(() => o.roundedStart),\n        V = r(() => o.roundedEnd),\n        C = io(() => ({\n          rounded: g.value,\n          roundedTop: p.value,\n          roundedBottom: y.value,\n          roundedStart: b.value,\n          roundedEnd: V.value\n        })),\n        c = E(() => o.variant !== null && !o.bgColor ? `bg-${o.variant}` : \"\"),\n        h = E(() => d.value ? !0 : null),\n        B = w(() => ({\n          type: o.spinnerType,\n          variant: o.spinnerVariant,\n          small: f.value\n        })),\n        _ = w(() => ({\n          ...l,\n          zIndex: o.zIndex || 10\n        })),\n        k = w(() => ({\n          \"position-absolute\": !u.value || !n.value,\n          \"position-fixed\": u.value && n.value\n        })),\n        S = w(() => [c.value, C.value]),\n        $ = w(() => ({\n          ...l,\n          opacity: o.opacity,\n          backgroundColor: o.bgColor || void 0,\n          backdropFilter: o.blur ? `blur(${o.blur})` : void 0\n        })),\n        I = w(() => s.value ? l : {\n          top: \"50%\",\n          left: \"50%\",\n          transform: \"translateX(-50%) translateY(-50%)\"\n        });\n      return (T, O) => (m(), x(se(T.wrapTag), {\n        class: \"b-overlay-wrap position-relative\",\n        \"aria-busy\": h.value\n      }, {\n        default: R(() => [A(T.$slots, \"default\"), ye(Mt, {\n          \"no-fade\": T.noFade,\n          \"trans-props\": {\n            enterToClass: \"show\"\n          },\n          name: \"fade\",\n          onOnAfterEnter: O[1] || (O[1] = F => a(\"shown\")),\n          onOnAfterLeave: O[2] || (O[2] = F => a(\"hidden\"))\n        }, {\n          default: R(() => [v(d) ? (m(), x(se(T.overlayTag), {\n            key: 0,\n            class: j([\"b-overlay\", k.value]),\n            style: ze(_.value),\n            onClick: O[0] || (O[0] = F => a(\"click\", F))\n          }, {\n            default: R(() => [ee(\"div\", {\n              class: j([\"position-absolute\", S.value]),\n              style: ze($.value)\n            }, null, 6), ee(\"div\", {\n              class: \"position-absolute\",\n              style: ze(I.value)\n            }, [A(T.$slots, \"overlay\", Se(Ee(B.value)), () => [v(i) ? J(\"\", !0) : (m(), x(ka, Se(Q({\n              key: 0\n            }, B.value)), null, 16))])], 4)]),\n            _: 3\n          }, 8, [\"class\", \"style\"])) : J(\"\", !0)]),\n          _: 3\n        }, 8, [\"no-fade\"])]),\n        _: 3\n      }, 8, [\"aria-busy\"]));\n    }\n  }),\n  Sd = [\"id\", \"aria-labelledby\", \"aria-describedby\"],\n  Cd = [\"id\"],\n  Wo = 1056,\n  wd = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BModal\",\n    props: {\n      autoFocus: {\n        type: [String, Boolean],\n        default: !0\n      },\n      autoFocusButton: {\n        default: void 0\n      },\n      backdropVariant: {\n        default: void 0\n      },\n      bodyBgVariant: {\n        default: null\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyScrolling: {\n        type: [String, Boolean],\n        default: !1\n      },\n      bodyTextVariant: {\n        default: null\n      },\n      bodyVariant: {\n        default: null\n      },\n      busy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonSize: {\n        default: \"md\"\n      },\n      cancelDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      cancelTitle: {\n        default: \"Cancel\"\n      },\n      cancelVariant: {\n        default: \"secondary\"\n      },\n      centered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      contentClass: {\n        default: void 0\n      },\n      dialogClass: {\n        default: void 0\n      },\n      footerBgVariant: {\n        default: null\n      },\n      footerBorderVariant: {\n        default: null\n      },\n      footerClass: {\n        default: void 0\n      },\n      footerTextVariant: {\n        default: null\n      },\n      footerVariant: {\n        default: null\n      },\n      fullscreen: {\n        type: [String, Boolean],\n        default: !1\n      },\n      headerBgVariant: {\n        default: null\n      },\n      headerBorderVariant: {\n        default: null\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerCloseClass: {\n        default: void 0\n      },\n      headerCloseLabel: {\n        default: \"Close\"\n      },\n      headerCloseVariant: {\n        default: \"secondary\"\n      },\n      headerTextVariant: {\n        default: null\n      },\n      headerVariant: {\n        default: null\n      },\n      hideBackdrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideFooter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideHeaderClose: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modalClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnBackdrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnEsc: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      okDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      okOnly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      okTitle: {\n        default: \"Ok\"\n      },\n      okVariant: {\n        default: \"primary\"\n      },\n      scrollable: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      teleportDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      },\n      title: {\n        default: void 0\n      },\n      titleClass: {\n        default: void 0\n      },\n      titleSrOnly: {\n        type: [String, Boolean],\n        default: !1\n      },\n      titleTag: {\n        default: \"h5\"\n      }\n    },\n    emits: [\"cancel\", \"close\", \"hidden\", \"hide\", \"hide-prevented\", \"ok\", \"show\", \"show-prevented\", \"shown\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = Me(),\n        i = _e(() => a.id, \"modal\"),\n        s = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        u = r(() => a.busy),\n        d = r(() => a.lazy),\n        f = r(() => a.cancelDisabled),\n        g = r(() => a.centered),\n        p = r(() => a.hideBackdrop),\n        y = r(() => a.hideFooter),\n        b = r(() => a.hideHeader),\n        V = r(() => a.hideHeaderClose),\n        C = r(s),\n        c = r(() => a.noCloseOnBackdrop),\n        h = r(() => a.noCloseOnEsc),\n        B = r(() => a.noFade),\n        _ = r(() => a.autoFocus),\n        k = r(() => a.okDisabled),\n        S = r(() => a.okOnly),\n        $ = r(() => a.scrollable),\n        I = r(() => a.titleSrOnly),\n        T = r(() => a.teleportDisabled),\n        O = r(() => a.bodyScrolling),\n        F = r(() => a.fullscreen),\n        K = W(null),\n        z = W(null),\n        P = W(null),\n        D = W(null),\n        ae = W(C.value),\n        le = W(!1);\n      qe(\"Escape\", () => {\n        Y(\"esc\");\n      }, {\n        target: K\n      }), Wl(C, O);\n      const {\n          focused: ve\n        } = xe(K, {\n          initialValue: C.value && a.autoFocusButton === void 0\n        }),\n        {\n          focused: Be\n        } = xe(z, {\n          initialValue: C.value && a.autoFocusButton === \"ok\"\n        }),\n        {\n          focused: Ve\n        } = xe(P, {\n          initialValue: C.value && a.autoFocusButton === \"cancel\"\n        }),\n        {\n          focused: oe\n        } = xe(D, {\n          initialValue: C.value && a.autoFocusButton === \"close\"\n        }),\n        fe = w(() => [a.modalClass, {\n          fade: !B.value,\n          show: ae.value\n        }]),\n        $e = E(() => d.value === !1 || d.value === !0 && le.value === !0 || d.value === !0 && C.value === !0),\n        we = E(() => a.backdropVariant !== void 0 ? a.backdropVariant : p.value ? \"transparent\" : \"dark\"),\n        M = E(() => !Ie(n[\"header-close\"])),\n        L = w(() => [a.dialogClass, {\n          \"modal-fullscreen\": F.value === !0,\n          [`modal-fullscreen-${F.value}-down`]: typeof F.value == \"string\",\n          [`modal-${a.size}`]: a.size !== \"md\",\n          \"modal-dialog-centered\": g.value,\n          \"modal-dialog-scrollable\": $.value\n        }]),\n        U = Qe(() => ({\n          bgVariant: a.bodyBgVariant,\n          textVariant: a.bodyTextVariant,\n          variant: a.bodyVariant\n        })),\n        H = w(() => [a.bodyClass, U.value]),\n        G = Qe(() => ({\n          bgVariant: a.headerBgVariant,\n          textVariant: a.headerTextVariant,\n          variant: a.headerVariant\n        })),\n        X = w(() => [a.headerClass, G.value, {\n          [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null\n        }]),\n        te = w(() => ({\n          variant: M.value ? a.headerCloseVariant : void 0,\n          class: a.headerCloseClass\n        })),\n        be = Qe(() => ({\n          bgVariant: a.footerBgVariant,\n          textVariant: a.footerTextVariant,\n          variant: a.footerVariant\n        })),\n        me = w(() => [a.footerClass, be.value, {\n          [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null\n        }]),\n        de = w(() => [a.titleClass, {\n          \"visually-hidden\": I.value\n        }]),\n        ie = E(() => f.value || u.value),\n        ce = E(() => k.value || u.value),\n        Ce = (pe, Pe = {}) => new Rt(pe, {\n          cancelable: !1,\n          target: K.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...Pe,\n          componentId: i.value\n        });\n      ue(C, (pe, Pe) => {\n        pe !== Pe && (pe === !0 ? re() : Y());\n      });\n      const Y = (pe = \"\") => {\n          if (pe === \"backdrop\" && c.value || pe === \"esc\" && h.value) {\n            l(\"hide-prevented\");\n            return;\n          }\n          const Pe = Ce(\"hide\", {\n            cancelable: pe !== \"\",\n            trigger: pe\n          });\n          if (pe === \"ok\" && l(pe, Pe), pe === \"cancel\" && l(pe, Pe), pe === \"close\" && l(pe, Pe), l(\"hide\", Pe), Pe.defaultPrevented) {\n            l(\"hide-prevented\"), s.value || (s.value = !0);\n            return;\n          }\n          s.value && (s.value = !1);\n        },\n        re = () => {\n          const pe = Ce(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", pe), pe.defaultPrevented) {\n            s.value && (s.value = !1), l(\"show-prevented\");\n            return;\n          }\n          s.value || (s.value = !0);\n        },\n        Ae = () => {\n          _.value !== !1 && (a.autoFocusButton === \"ok\" ? Be.value = !0 : a.autoFocusButton === \"close\" ? oe.value = !0 : a.autoFocusButton === \"cancel\" ? Ve.value = !0 : ve.value = !0);\n        },\n        He = () => re(),\n        Re = () => {\n          ae.value = !0, Ae(), l(\"shown\", Ce(\"shown\")), d.value === !0 && (le.value = !0);\n        },\n        kt = () => {\n          ae.value = !1;\n        },\n        Nn = () => {\n          l(\"hidden\", Ce(\"hidden\")), d.value === !0 && (le.value = !1);\n        },\n        {\n          activePosition: In,\n          activeModalCount: Ln\n        } = Mi(ae),\n        Fn = w(() => ({\n          // Make sure that newly opened modals have a higher z-index than currently active ones.\n          // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').\n          //\n          // This means inactive modals will already be higher than active ones when opened.\n          \"z-index\": ae.value ? Wo - (Ln.value - In.value) : Wo\n        }));\n      Oe(K, \"bv-toggle\", () => {\n        C.value ? Y() : re();\n      });\n      const $t = da({\n        cancel: () => {\n          Y(\"cancel\");\n        },\n        close: () => {\n          Y(\"close\");\n        },\n        hide: Y,\n        ok: () => {\n          Y(\"ok\");\n        },\n        visible: C\n      });\n      return t({\n        hide: Y,\n        id: i,\n        show: re\n      }), (pe, Pe) => (m(), x(zt, {\n        to: pe.teleportTo,\n        disabled: v(T)\n      }, [ye(Mt, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"show\"\n        },\n        onBeforeEnter: He,\n        onAfterEnter: Re,\n        onLeave: kt,\n        onAfterLeave: Nn\n      }, {\n        default: R(() => [ht(ee(\"div\", Q({\n          id: v(i),\n          ref_key: \"element\",\n          ref: K,\n          class: [\"modal\", fe.value],\n          role: \"dialog\",\n          \"aria-labelledby\": v(b) ? void 0 : `${v(i)}-label`,\n          \"aria-describedby\": `${v(i)}-body`,\n          tabindex: \"-1\"\n        }, pe.$attrs, {\n          style: Fn.value\n        }), [ee(\"div\", {\n          class: j([\"modal-dialog\", L.value])\n        }, [$e.value ? (m(), N(\"div\", {\n          key: 0,\n          class: j([\"modal-content\", pe.contentClass])\n        }, [v(b) ? J(\"\", !0) : (m(), N(\"div\", {\n          key: 0,\n          class: j([\"modal-header\", X.value])\n        }, [A(pe.$slots, \"header\", Se(Ee($t)), () => [(m(), x(se(pe.titleTag), {\n          id: `${v(i)}-label`,\n          class: j([\"modal-title\", de.value])\n        }, {\n          default: R(() => [A(pe.$slots, \"title\", Se(Ee($t)), () => [ne(Z(pe.title), 1)], !0)]),\n          _: 3\n        }, 8, [\"id\", \"class\"])), v(V) ? J(\"\", !0) : (m(), N(ge, {\n          key: 0\n        }, [M.value ? (m(), x(pt, Q({\n          key: 0\n        }, te.value, {\n          onClick: Pe[0] || (Pe[0] = Jt => Y(\"close\"))\n        }), {\n          default: R(() => [A(pe.$slots, \"header-close\", {}, void 0, !0)]),\n          _: 3\n        }, 16)) : (m(), x(Dt, Q({\n          key: 1,\n          \"aria-label\": pe.headerCloseLabel\n        }, te.value, {\n          onClick: Pe[1] || (Pe[1] = Jt => Y(\"close\"))\n        }), null, 16, [\"aria-label\"]))], 64))], !0)], 2)), ee(\"div\", {\n          id: `${v(i)}-body`,\n          class: j([\"modal-body\", H.value])\n        }, [A(pe.$slots, \"default\", Se(Ee($t)), void 0, !0)], 10, Cd), v(y) ? J(\"\", !0) : (m(), N(\"div\", {\n          key: 1,\n          class: j([\"modal-footer\", me.value])\n        }, [A(pe.$slots, \"footer\", Se(Ee($t)), () => [A(pe.$slots, \"cancel\", Se(Ee($t)), () => [v(S) ? J(\"\", !0) : (m(), x(pt, {\n          key: 0,\n          ref_key: \"cancelButton\",\n          ref: P,\n          disabled: ie.value,\n          size: pe.buttonSize,\n          variant: pe.cancelVariant,\n          onClick: Pe[2] || (Pe[2] = Jt => Y(\"cancel\"))\n        }, {\n          default: R(() => [ne(Z(pe.cancelTitle), 1)]),\n          _: 1\n        }, 8, [\"disabled\", \"size\", \"variant\"]))], !0), A(pe.$slots, \"ok\", Se(Ee($t)), () => [ye(pt, {\n          ref_key: \"okButton\",\n          ref: z,\n          disabled: ce.value,\n          size: pe.buttonSize,\n          variant: pe.okVariant,\n          onClick: Pe[3] || (Pe[3] = Jt => Y(\"ok\"))\n        }, {\n          default: R(() => [ne(Z(pe.okTitle), 1)]),\n          _: 1\n        }, 8, [\"disabled\", \"size\", \"variant\"])], !0)], !0)], 2))], 2)) : J(\"\", !0)], 2), A(pe.$slots, \"backdrop\", {}, () => [ye(Ta, {\n          variant: we.value,\n          show: v(C),\n          \"no-spinner\": \"\",\n          fixed: \"\",\n          \"no-wrap\": \"\",\n          blur: null,\n          onClick: Pe[4] || (Pe[4] = Jt => Y(\"backdrop\"))\n        }, null, 8, [\"variant\", \"show\"])], !0)], 16, Sd), [[ha, v(C)]])]),\n        _: 3\n      })], 8, [\"to\", \"disabled\"]));\n    }\n  });\nconst kd = /* @__PURE__ */$a(wd, [[\"__scopeId\", \"data-v-2a759028\"]]),\n  $d = /* @__PURE__ */q({\n    __name: \"BNav\",\n    props: {\n      align: {\n        default: void 0\n      },\n      cardHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      justified: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tabs: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      },\n      underline: {\n        type: [String, Boolean],\n        default: !1\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.cardHeader),\n        a = r(() => t.fill),\n        l = r(() => t.justified),\n        n = r(() => t.pills),\n        i = r(() => t.small),\n        s = r(() => t.tabs),\n        u = r(() => t.vertical),\n        d = Zt(() => t.align),\n        f = r(() => t.underline),\n        g = w(() => ({\n          \"nav-tabs\": s.value,\n          \"nav-pills\": n.value && !s.value,\n          \"card-header-tabs\": !u.value && o.value && s.value,\n          \"card-header-pills\": !u.value && o.value && n.value && !s.value,\n          \"flex-column\": u.value,\n          \"nav-fill\": !u.value && a.value,\n          \"nav-justified\": !u.value && l.value,\n          [d.value]: !u.value && t.align !== void 0,\n          small: i.value,\n          \"nav-underline\": f.value\n        }));\n      return (p, y) => (m(), x(se(p.tag), {\n        class: j([\"nav\", g.value])\n      }, {\n        default: R(() => [A(p.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Td = {\n    class: \"d-flex flex-row align-items-center flex-wrap\"\n  },\n  _d = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BNavForm\",\n    props: {\n      role: {\n        default: void 0\n      },\n      floating: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      novalidate: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      validated: {\n        type: [String, Boolean],\n        default: void 0\n      }\n    },\n    emits: [\"submit\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = t,\n        a = l => {\n          o(\"submit\", l);\n        };\n      return (l, n) => (m(), N(\"li\", Td, [ye(bn, Q(l.$attrs, {\n        id: l.id,\n        floating: l.floating,\n        role: l.role,\n        novalidate: l.novalidate,\n        validated: l.validated,\n        class: \"d-flex\",\n        onSubmit: Bt(a, [\"prevent\"])\n      }), {\n        default: R(() => [A(l.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"id\", \"floating\", \"role\", \"novalidate\", \"validated\", \"onSubmit\"])]));\n    }\n  }),\n  Vd = {\n    class: \"nav-item\"\n  },\n  Ad = /* @__PURE__ */q({\n    __name: \"BNavItem\",\n    props: {\n      linkAttrs: {\n        default: void 0\n      },\n      linkClass: {\n        default: void 0\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = r(() => o.disabled),\n        n = w(() => fo(o, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"icon\", \"opacity\", \"opacityHover\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"underlineVariant\", \"variant\"]));\n      return n.value.activeClass, (i, s) => (m(), N(\"li\", Vd, [ye(rt, Q({\n        class: [\"nav-link\", i.linkClass],\n        tabindex: v(l) ? -1 : void 0,\n        \"aria-disabled\": v(l) ? !0 : void 0\n      }, {\n        ...n.value,\n        ...i.linkAttrs\n      }, {\n        onClick: s[0] || (s[0] = u => a(\"click\", u))\n      }), {\n        default: R(() => [A(i.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"tabindex\", \"aria-disabled\"])]));\n    }\n  }),\n  Od = {\n    class: \"nav-item dropdown\"\n  },\n  Ed = /* @__PURE__ */q({\n    __name: \"BNavItemDropdown\",\n    props: {\n      ariaLabel: {\n        default: void 0\n      },\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      boundary: {\n        default: \"clippingAncestors\"\n      },\n      boundaryPadding: {\n        default: void 0\n      },\n      center: {\n        type: [String, Boolean],\n        default: !1\n      },\n      container: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropend: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropstart: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dropup: {\n        type: [String, Boolean],\n        default: !1\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      isNav: {\n        type: [String, Boolean],\n        default: !0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      menuClass: {\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCaret: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noSize: {\n        type: [String, Boolean],\n        default: !1\n      },\n      offset: {\n        default: 0\n      },\n      role: {\n        default: \"menu\"\n      },\n      size: {\n        default: \"md\"\n      },\n      split: {\n        type: [String, Boolean],\n        default: !1\n      },\n      splitButtonType: {\n        default: \"button\"\n      },\n      splitClass: {\n        default: void 0\n      },\n      splitDisabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      splitHref: {\n        default: void 0\n      },\n      splitTo: {\n        default: void 0\n      },\n      splitVariant: {\n        default: void 0\n      },\n      strategy: {\n        default: \"absolute\"\n      },\n      text: {\n        default: void 0\n      },\n      toggleClass: {\n        default: void 0\n      },\n      toggleText: {\n        default: \"Toggle dropdown\"\n      },\n      variant: {\n        default: \"link\"\n      }\n    },\n    emits: [\"click\", \"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"toggle\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = W(null),\n        i = () => {\n          var d;\n          (d = n.value) == null || d.close();\n        },\n        s = () => {\n          var d;\n          (d = n.value) == null || d.open();\n        };\n      return t({\n        close: i,\n        open: s,\n        toggle: () => {\n          var d;\n          (d = n.value) == null || d.toggle();\n        }\n      }), (d, f) => (m(), N(\"li\", Od, [ye(gn, Q({\n        ref_key: \"dropdown\",\n        ref: n\n      }, a, {\n        \"is-nav\": \"\",\n        onShow: f[0] || (f[0] = g => l(\"show\", g)),\n        onShown: f[1] || (f[1] = g => l(\"shown\")),\n        onHide: f[2] || (f[2] = g => l(\"hide\", g)),\n        onHidden: f[3] || (f[3] = g => l(\"hidden\")),\n        onHidePrevented: f[4] || (f[4] = g => l(\"hide-prevented\")),\n        onShowPrevented: f[5] || (f[5] = g => l(\"show-prevented\")),\n        onClick: f[6] || (f[6] = g => l(\"click\", g)),\n        onToggle: f[7] || (f[7] = g => l(\"toggle\")),\n        \"onUpdate:modelValue\": f[8] || (f[8] = g => l(\"update:modelValue\", g))\n      }), {\n        \"button-content\": R(() => [A(d.$slots, \"button-content\")]),\n        \"toggle-text\": R(() => [A(d.$slots, \"toggle-text\")]),\n        default: R(() => [A(d.$slots, \"default\", {\n          hide: i,\n          show: s\n        })]),\n        _: 3\n      }, 16)]));\n    }\n  }),\n  Pd = {\n    class: \"navbar-text\"\n  },\n  Nd = /* @__PURE__ */q({\n    __name: \"BNavText\",\n    props: {\n      text: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      return (t, o) => (m(), N(\"li\", Pd, [A(t.$slots, \"default\", {}, () => [ne(Z(t.text), 1)])]));\n    }\n  }),\n  Id = /* @__PURE__ */q({\n    __name: \"BNavbar\",\n    props: {\n      autoClose: {\n        type: [String, Boolean],\n        default: !0\n      },\n      container: {\n        type: [String, Boolean],\n        default: \"fluid\"\n      },\n      fixed: {\n        default: void 0\n      },\n      print: {\n        type: [String, Boolean],\n        default: !1\n      },\n      sticky: {\n        default: void 0\n      },\n      tag: {\n        default: \"nav\"\n      },\n      toggleable: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.container),\n        a = r(() => t.autoClose),\n        l = r(() => t.print),\n        n = r(() => t.toggleable),\n        i = E(() => t.tag === \"nav\" ? void 0 : \"navigation\"),\n        s = xi(o),\n        u = w(() => ({\n          \"d-print\": l.value,\n          [`sticky-${t.sticky}`]: t.sticky !== void 0,\n          [`bg-${t.variant}`]: t.variant !== null,\n          [`fixed-${t.fixed}`]: t.fixed !== void 0,\n          \"navbar-expand\": n.value === !1,\n          [`navbar-expand-${n.value}`]: typeof n.value == \"string\"\n        }));\n      return at(co, {\n        tag: E(() => t.tag),\n        autoClose: a\n      }), (d, f) => (m(), x(se(d.tag), {\n        class: j([\"navbar\", u.value]),\n        role: i.value\n      }, {\n        default: R(() => [d.container !== !1 ? (m(), N(\"div\", {\n          key: 0,\n          class: j(v(s))\n        }, [A(d.$slots, \"default\")], 2)) : A(d.$slots, \"default\", {\n          key: 1\n        })]),\n        _: 3\n      }, 8, [\"class\", \"role\"]));\n    }\n  }),\n  Ld = /* @__PURE__ */q({\n    __name: \"BNavbarBrand\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        {\n          computedLink: o,\n          computedLinkProps: a\n        } = Ct(t, [\"active\", \"activeClass\", \"append\", \"disabled\", \"href\", \"rel\", \"replace\", \"routerComponentName\", \"target\", \"to\", \"variant\", \"opacity\", \"opacityHover\", \"underlineVariant\", \"underlineOffset\", \"underlineOffsetHover\", \"underlineOpacity\", \"underlineOpacityHover\", \"icon\"]),\n        l = E(() => o.value ? rt : t.tag);\n      return (n, i) => (m(), x(se(l.value), Q({\n        class: \"navbar-brand\"\n      }, v(a)), {\n        default: R(() => [A(n.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  Fd = /* @__PURE__ */q({\n    __name: \"BNavbarNav\",\n    props: {\n      align: {\n        default: void 0\n      },\n      fill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      justified: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.fill),\n        a = r(() => t.justified),\n        l = r(() => t.small),\n        n = Zt(() => t.align),\n        i = w(() => ({\n          \"nav-fill\": o.value,\n          \"nav-justified\": a.value,\n          [n.value]: t.align !== void 0,\n          small: l.value\n        }));\n      return (s, u) => (m(), N(\"ul\", {\n        class: j([\"navbar-nav\", i.value])\n      }, [A(s.$slots, \"default\")], 2));\n    }\n  }),\n  Uo = (e, t) => e.setAttribute(\"data-bs-theme\", t),\n  Hd = {\n    mounted(e, t) {\n      Uo(e, t.value);\n    },\n    updated(e, t) {\n      Uo(e, t.value);\n    }\n  },\n  zd = (e, t) => {\n    const {\n        modifiers: o,\n        arg: a,\n        value: l\n      } = e,\n      n = Object.keys(o || {}),\n      i = typeof l == \"string\" ? l.split(sa) : l;\n    if (Ss(t.tagName, \"a\")) {\n      const s = Ya(t, \"href\") || \"\";\n      Zn.test(s) && n.push(s.replace(Yn, \"\"));\n    }\n    return Array.prototype.concat.apply([], [a, i]).forEach(s => typeof s == \"string\" && n.push(s)), n.filter((s, u, d) => s && d.indexOf(s) === u);\n  },\n  Rd = (e, t) => {\n    e.forEach(o => {\n      const a = document.getElementById(o);\n      a !== null && a.dispatchEvent(new Event(\"bv-toggle\"));\n    }), setTimeout(() => $n(e, t), 50);\n  },\n  $n = (e, t) => {\n    let o = !1;\n    e.forEach(a => {\n      const l = document.getElementById(a);\n      l != null && l.classList.contains(\"show\") && (o = !0), l != null && l.classList.contains(\"closing\") && (o = !1);\n    }), t.setAttribute(\"aria-expanded\", o ? \"true\" : \"false\"), t.classList.remove(o ? \"collapsed\" : \"not-collapsed\"), t.classList.add(o ? \"not-collapsed\" : \"collapsed\");\n  },\n  Xo = (e, t) => {\n    if (t.value === void 0 && Object.keys(t.modifiers || {}).length === 0) return;\n    const o = zd(t, e);\n    e.__toggle && e.removeEventListener(\"click\", e.__toggle), e.__toggle = () => Rd(o, e), e.addEventListener(\"click\", e.__toggle), e.setAttribute(\"aria-controls\", o.join(\" \")), $n(o, e);\n  },\n  ja = {\n    mounted: Xo,\n    updated: Xo,\n    unmounted(e) {\n      e.removeEventListener(\"click\", e.__toggle), e.removeAttribute(\"aria-controls\"), e.removeAttribute(\"aria-expanded\");\n    }\n  },\n  xd = {\n    mounted(e, t) {\n      if (!Ut(t.value)) return;\n      const a = ga(t.value, e);\n      !a.content && !a.title || (e.$__state = W({\n        ...Nt(t, e),\n        ...a\n      }), ba(e, t));\n    },\n    updated(e, t) {\n      if (!Ut(t.value)) return;\n      const a = ga(t.value, e);\n      if (!(!a.content && !a.title)) {\n        if (!e.$__state) {\n          e.$__state = W({\n            ...Nt(t, e),\n            ...a\n          }), ba(e, t);\n          return;\n        }\n        e.$__state.value = {\n          ...Nt(t, e),\n          ...a\n        };\n      }\n    },\n    beforeUnmount(e) {\n      Xl(e);\n    }\n  },\n  Md = {\n    mounted(e, t) {\n      const o = Ut(t.value);\n      if (!o) return;\n      const a = ga(t.value, e);\n      !a.content && !a.title || (e.$__state = W({\n        noninteractive: !0,\n        ...Nt(t, e),\n        title: a.title ?? a.content ?? \"\",\n        tooltip: o\n      }), ba(e, t));\n    },\n    updated(e, t) {\n      const o = Ut(t.value);\n      if (!o) return;\n      const a = ga(t.value, e);\n      if (!(!a.content && !a.title)) {\n        if (!e.$__state) {\n          e.$__state = W({\n            noninteractive: !0,\n            ...Nt(t, e),\n            title: a.title ?? a.content ?? \"\",\n            tooltip: o\n          }), ba(e, t);\n          return;\n        }\n        e.$__state.value = {\n          noninteractive: !0,\n          ...Nt(t, e),\n          title: a.title ?? a.content ?? \"\",\n          tooltip: o\n        };\n      }\n    },\n    beforeUnmount(e) {\n      Xl(e);\n    }\n  },\n  Ko = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    vBColorMode: Hd,\n    vBModal: ja,\n    vBPopover: xd,\n    vBToggle: ja,\n    vBTooltip: Md\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Dd = [\"disabled\", \"aria-label\"],\n  jd = /* @__PURE__ */ee(\"span\", {\n    class: \"navbar-toggler-icon\"\n  }, null, -1),\n  qd = /* @__PURE__ */q({\n    __name: \"BNavbarToggle\",\n    props: {\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      label: {\n        default: \"Toggle navigation\"\n      },\n      target: {\n        default: void 0\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = r(() => o.disabled),\n        n = w(() => ({\n          disabled: l.value\n        })),\n        i = s => {\n          l.value || a(\"click\", s);\n        };\n      return (s, u) => ht((m(), N(\"button\", {\n        class: j([\"navbar-toggler\", n.value]),\n        type: \"button\",\n        disabled: v(l),\n        \"aria-label\": s.label,\n        onClick: i\n      }, [A(s.$slots, \"default\", {}, () => [jd])], 10, Dd)), [[v(ja), v(l) ? void 0 : s.target]]);\n    }\n  }),\n  Gd = [\"id\", \"aria-labelledby\"],\n  Wd = [\"id\"],\n  Ud = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BOffcanvas\",\n    props: {\n      backdrop: {\n        type: [String, Boolean],\n        default: !0\n      },\n      backdropVariant: {\n        default: \"dark\"\n      },\n      bodyClass: {\n        default: void 0\n      },\n      bodyScrolling: {\n        type: [String, Boolean],\n        default: !1\n      },\n      footerClass: {\n        default: void 0\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerCloseClass: {\n        default: void 0\n      },\n      headerCloseLabel: {\n        default: \"Close\"\n      },\n      headerCloseVariant: {\n        default: \"secondary\"\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnBackdrop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noCloseOnEsc: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFocus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noHeaderClose: {\n        type: [String, Boolean],\n        default: !1\n      },\n      placement: {\n        default: \"start\"\n      },\n      teleportDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      },\n      title: {\n        default: void 0\n      }\n    },\n    emits: [\"close\", \"esc\", \"hidden\", \"hide\", \"hide-prevented\", \"show\", \"show-prevented\", \"shown\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = Me(),\n        i = ke(a, \"modelValue\", l, {\n          passive: !0\n        }),\n        s = r(i),\n        u = r(() => a.bodyScrolling),\n        d = r(() => a.backdrop),\n        f = r(() => a.noHeaderClose),\n        g = r(() => a.noHeader),\n        p = r(() => a.noFocus),\n        y = r(() => a.noCloseOnBackdrop),\n        b = r(() => a.noCloseOnEsc),\n        V = r(() => a.lazy),\n        C = r(() => a.teleportDisabled),\n        c = _e(() => a.id, \"offcanvas\");\n      Wl(s, u);\n      const h = W(null);\n      qe(\"Escape\", () => {\n        P(\"esc\");\n      }, {\n        target: h\n      });\n      const {\n          focused: B\n        } = xe(h, {\n          initialValue: s.value && p.value === !1\n        }),\n        _ = W(s.value),\n        k = W(!1),\n        S = E(() => d.value === !0 && s.value === !0),\n        $ = E(() => V.value === !1 || V.value === !0 && k.value === !0 || V.value === !0 && s.value === !0),\n        I = E(() => !Ie(n[\"header-close\"])),\n        T = w(() => [{\n          \"text-reset\": !I.value\n        }, a.headerCloseClass]),\n        O = w(() => ({\n          variant: I.value ? a.headerCloseVariant : void 0,\n          class: T.value\n        })),\n        F = E(() => !Ie(n.footer)),\n        K = w(() => [\n        // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n        \"offcanvas\",\n        // Remove when above check is fixed\n        `offcanvas-${a.placement}`, {\n          show: s.value && _.value === !0\n        }]),\n        z = (oe, fe = {}) => new Rt(oe, {\n          cancelable: !1,\n          target: h.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...fe,\n          componentId: c.value\n        }),\n        P = (oe = \"\") => {\n          if (oe === \"backdrop\" && y.value || oe === \"esc\" && b.value) {\n            l(\"hide-prevented\");\n            return;\n          }\n          const fe = z(\"hide\", {\n            cancelable: oe !== \"\",\n            trigger: oe\n          });\n          if (oe === \"close\" && l(oe, fe), oe === \"esc\" && l(oe, fe), l(\"hide\", fe), fe.defaultPrevented) {\n            l(\"hide-prevented\");\n            return;\n          }\n          i.value = !1;\n        },\n        D = () => {\n          const oe = z(\"show\", {\n            cancelable: !0\n          });\n          if (l(\"show\", oe), oe.defaultPrevented) {\n            i.value = !1, l(\"show-prevented\");\n            return;\n          }\n          i.value = !0;\n        },\n        ae = () => {\n          Ne(() => {\n            p.value === !1 && (B.value = !0);\n          });\n        },\n        le = () => D(),\n        ve = () => {\n          _.value = !0, ae(), l(\"shown\", z(\"shown\")), V.value === !0 && (k.value = !0);\n        },\n        Be = () => {\n          _.value = !1;\n        },\n        Ve = () => {\n          l(\"hidden\", z(\"hidden\")), V.value === !0 && (k.value = !1);\n        };\n      return Oe(h, \"bv-toggle\", () => {\n        s.value ? P() : D();\n      }), t({\n        hide: P,\n        show: D\n      }), (oe, fe) => (m(), x(zt, {\n        to: oe.teleportTo,\n        disabled: v(C)\n      }, [ye(Mt, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"showing\",\n          enterFromClass: \"\",\n          leaveToClass: \"hiding show\",\n          leaveFromClass: \"show\"\n        },\n        onBeforeEnter: le,\n        onAfterEnter: ve,\n        onLeave: Be,\n        onAfterLeave: Ve\n      }, {\n        default: R(() => [ht(ee(\"div\", Q({\n          id: v(c),\n          ref_key: \"element\",\n          ref: h,\n          \"aria-modal\": \"true\",\n          role: \"dialog\",\n          class: K.value,\n          tabindex: \"-1\",\n          \"aria-labelledby\": `${v(c)}-offcanvas-label`,\n          \"data-bs-backdrop\": \"false\"\n        }, oe.$attrs), [$.value ? (m(), N(ge, {\n          key: 0\n        }, [v(g) ? J(\"\", !0) : (m(), N(\"div\", {\n          key: 0,\n          class: j([\"offcanvas-header\", oe.headerClass])\n        }, [A(oe.$slots, \"header\", {\n          visible: v(s),\n          placement: oe.placement,\n          hide: P\n        }, () => [ee(\"h5\", {\n          id: `${v(c)}-offcanvas-label`,\n          class: \"offcanvas-title\"\n        }, [A(oe.$slots, \"title\", {\n          visible: v(s),\n          placement: oe.placement,\n          hide: P\n        }, () => [ne(Z(oe.title), 1)])], 8, Wd), v(f) ? J(\"\", !0) : (m(), N(ge, {\n          key: 0\n        }, [I.value ? (m(), x(pt, Q({\n          key: 0\n        }, O.value, {\n          onClick: fe[0] || (fe[0] = $e => P(\"close\"))\n        }), {\n          default: R(() => [A(oe.$slots, \"header-close\")]),\n          _: 3\n        }, 16)) : (m(), x(Dt, Q({\n          key: 1,\n          \"aria-label\": oe.headerCloseLabel\n        }, O.value, {\n          onClick: fe[1] || (fe[1] = $e => P(\"close\"))\n        }), null, 16, [\"aria-label\"]))], 64))])], 2)), ee(\"div\", {\n          class: j([\"offcanvas-body\", oe.bodyClass])\n        }, [A(oe.$slots, \"default\", {\n          visible: v(s),\n          placement: oe.placement,\n          hide: P\n        })], 2), F.value ? (m(), N(\"div\", {\n          key: 1,\n          class: j(oe.footerClass)\n        }, [A(oe.$slots, \"footer\", {\n          visible: v(s),\n          placement: oe.placement,\n          hide: P\n        })], 2)) : J(\"\", !0)], 64)) : J(\"\", !0)], 16, Gd), [[ha, v(i)]])]),\n        _: 3\n      }), A(oe.$slots, \"backdrop\", {}, () => [ye(Ta, {\n        variant: oe.backdropVariant,\n        show: S.value,\n        fixed: \"\",\n        \"no-wrap\": \"\",\n        \"no-spinner\": \"\",\n        onClick: fe[2] || (fe[2] = $e => P(\"backdrop\"))\n      }, null, 8, [\"variant\", \"show\"])])], 8, [\"to\", \"disabled\"]));\n    }\n  }),\n  Xd = [\"aria-disabled\", \"aria-label\"],\n  Kd = [\"aria-hidden\"],\n  Yo = 20,\n  Zo = 0,\n  Yd = /* @__PURE__ */q({\n    __name: \"BPagination\",\n    props: {\n      align: {\n        default: \"start\"\n      },\n      ariaControls: {\n        default: void 0\n      },\n      ariaLabel: {\n        default: \"Pagination\"\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      ellipsisClass: {\n        default: void 0\n      },\n      ellipsisText: {\n        default: \"â¦\"\n      },\n      firstClass: {\n        default: void 0\n      },\n      firstNumber: {\n        type: [String, Boolean],\n        default: !1\n      },\n      firstText: {\n        default: \"Â«\"\n      },\n      hideEllipsis: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hideGotoEndButtons: {\n        type: [String, Boolean],\n        default: !1\n      },\n      labelFirstPage: {\n        default: \"Go to first page\"\n      },\n      labelLastPage: {\n        default: \"Go to last page\"\n      },\n      labelNextPage: {\n        default: \"Go to next page\"\n      },\n      labelPage: {\n        default: \"Go to page\"\n      },\n      labelPrevPage: {\n        default: \"Go to previous page\"\n      },\n      lastClass: {\n        default: void 0\n      },\n      lastNumber: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lastText: {\n        default: \"Â»\"\n      },\n      limit: {\n        default: 5\n      },\n      modelValue: {\n        default: 1\n      },\n      nextClass: {\n        default: void 0\n      },\n      nextText: {\n        default: \"âº\"\n      },\n      pageClass: {\n        default: void 0\n      },\n      perPage: {\n        default: Yo\n      },\n      pills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      prevClass: {\n        default: void 0\n      },\n      prevText: {\n        default: \"â¹\"\n      },\n      size: {\n        default: void 0\n      },\n      totalRows: {\n        default: Zo\n      }\n    },\n    emits: [\"update:modelValue\", \"page-click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = t,\n        n = ke(a, \"modelValue\", l),\n        i = r(() => a.disabled),\n        s = r(() => a.firstNumber),\n        u = r(() => a.hideEllipsis),\n        d = r(() => a.hideGotoEndButtons),\n        f = r(() => a.lastNumber),\n        g = r(() => a.pills),\n        p = he(() => a.perPage, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        y = he(() => a.totalRows, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        b = he(n, {\n          nanToZero: !0,\n          method: \"parseInt\"\n        }),\n        V = E(() => Math.max(p.value || Yo, 1)),\n        C = E(() => Math.max(y.value || Zo, 0)),\n        c = E(() => Math.ceil(C.value / V.value)),\n        h = E(() => a.align === \"fill\"),\n        B = E(() => a.align === \"fill\" ? \"start\" : a.align),\n        _ = Zt(B),\n        k = L => L === b.value,\n        S = L => i.value ? null : k(L) ? \"0\" : \"-1\",\n        $ = L => i.value || k(L) || b.value < 1 ||\n        // Check if the number is out of bounds\n        L < 1 || L > c.value,\n        I = w(() => $(1)),\n        T = w(() => $(b.value - 1)),\n        O = w(() => $(c.value)),\n        F = w(() => $(b.value + 1)),\n        K = (L, U) => ({\n          li: {\n            class: [\"page-item\", {\n              disabled: L,\n              \"flex-fill\": h.value,\n              \"d-flex\": h.value && !L\n            }, U]\n          },\n          button: {\n            is: L ? \"span\" : \"button\",\n            class: [\"page-link\", {\n              \"flex-grow-1\": !L && h.value\n            }],\n            \"aria-label\": a.labelFirstPage,\n            \"aria-controls\": a.ariaControls || void 0,\n            \"aria-disabled\": L ? !0 : void 0,\n            role: \"menuitem\",\n            type: L ? void 0 : \"button\",\n            tabindex: L ? void 0 : \"-1\"\n          }\n        }),\n        z = w(() => K(I.value, a.firstClass)),\n        P = w(() => K(T.value, a.prevClass)),\n        D = w(() => K(F.value, a.nextClass)),\n        ae = w(() => K(O.value, a.lastClass)),\n        le = w(() => ({\n          li: {\n            class: [\"page-item\", \"disabled\", \"bv-d-xs-down-none\", h.value ? \"flex-fill\" : \"\", a.ellipsisClass],\n            role: \"separator\"\n          },\n          span: {\n            class: [\"page-link\"]\n          }\n        })),\n        ve = w(() => [_.value, {\n          [`pagination-${a.size}`]: a.size !== void 0,\n          \"b-pagination-pills\": g.value\n        }]),\n        Be = w(() => {\n          let L;\n          return c.value - b.value + 2 < a.limit && a.limit > 3 ? L = c.value - oe.value + 1 : L = b.value - Math.floor(oe.value / 2), L < 1 ? L = 1 : L > c.value - oe.value && (L = c.value - oe.value + 1), a.limit <= 3 && f.value && c.value === L + oe.value - 1 && (L = Math.max(L - 1, 1)), L;\n        }),\n        Ve = w(() => {\n          const L = c.value - b.value;\n          let U = !1;\n          return L + 2 < a.limit && a.limit > 3 ? a.limit > 3 && (U = !0) : a.limit > 3 && (U = !!(!u.value || s.value)), Be.value <= 1 && (U = !1), U && s.value && Be.value < 4 && (U = !1), U;\n        }),\n        oe = w(() => {\n          let L = a.limit;\n          return c.value <= a.limit ? L = c.value : b.value < a.limit - 1 && a.limit > 3 ? ((!u.value || f.value) && (L = a.limit - (s.value ? 0 : 1)), L = Math.min(L, a.limit)) : c.value - b.value + 2 < a.limit && a.limit > 3 ? (!u.value || s.value) && (L = a.limit - (f.value ? 0 : 1)) : a.limit > 3 && (L = a.limit - (u.value ? 0 : 2)), L;\n        }),\n        fe = w(() => {\n          const L = c.value - oe.value;\n          let U = !1;\n          b.value < a.limit - 1 && a.limit > 3 ? (!u.value || f.value) && (U = !0) : a.limit > 3 && (U = !!(!u.value || f.value)), Be.value > L && (U = !1);\n          const H = Be.value + oe.value - 1;\n          return U && f.value && H > c.value - 3 && (U = !1), U;\n        }),\n        $e = w(() => ({\n          pageSize: V.value,\n          totalRows: y.value,\n          numberOfPages: c.value\n        })),\n        we = (L, U) => {\n          if (U === b.value) return;\n          const H = new dt(\"page-click\", {\n            cancelable: !0,\n            target: L.target\n          });\n          l(\"page-click\", H, U), !H.defaultPrevented && (n.value = U);\n        };\n      ue(b, L => {\n        const H = ((G, X) => {\n          const te = G || 1;\n          return te > X ? X : te < 1 ? 1 : te;\n        })(L, c.value);\n        H !== n.value && (n.value = H);\n      }), ue($e, (L, U) => {\n        (U.pageSize !== L.pageSize && U.totalRows === L.totalRows || U.numberOfPages !== L.numberOfPages && b.value > U.numberOfPages) && (n.value = 1);\n      });\n      const M = w(() => Array.from({\n        length: oe.value\n      }, (L, U) => ({\n        number: Be.value + U\n      })));\n      return (L, U) => (m(), N(\"ul\", {\n        class: j([\"pagination\", ve.value]),\n        role: \"menubar\",\n        \"aria-disabled\": v(i),\n        \"aria-label\": L.ariaLabel || void 0\n      }, [!v(d) && !v(s) ? (m(), N(\"li\", Se(Q({\n        key: 0\n      }, z.value.li)), [(m(), x(se(z.value.button.is), Q(z.value.button, {\n        onClick: U[0] || (U[0] = H => we(H, 1))\n      }), {\n        default: R(() => [A(L.$slots, \"first-text\", {}, () => [ne(Z(L.firstText), 1)])]),\n        _: 3\n      }, 16))], 16)) : J(\"\", !0), ee(\"li\", Se(Ee(P.value.li)), [(m(), x(se(P.value.button.is), Q(P.value.button, {\n        onClick: U[1] || (U[1] = H => we(H, v(b) - 1))\n      }), {\n        default: R(() => [A(L.$slots, \"prev-text\", {}, () => [ne(Z(L.prevText), 1)])]),\n        _: 3\n      }, 16))], 16), Ve.value ? (m(), N(\"li\", Se(Q({\n        key: 1\n      }, le.value.li)), [ee(\"span\", Se(Ee(le.value.span)), [A(L.$slots, \"ellipsis-text\", {}, () => [ne(Z(L.ellipsisText || \"...\"), 1)])], 16)], 16)) : J(\"\", !0), (m(!0), N(ge, null, Te(M.value, H => (m(), N(\"li\", {\n        key: `page-${H.number}`,\n        class: j([\"page-item\", {\n          disabled: v(i),\n          active: k(H.number),\n          \"flex-fill\": h.value,\n          \"d-flex\": h.value && !v(i)\n        }, L.pageClass]),\n        role: \"presentation\",\n        \"aria-hidden\": v(i) || void 0\n      }, [(m(), x(se(v(i) ? \"span\" : \"button\"), {\n        key: `page-${H.number}`,\n        class: j([\"page-link\", {\n          \"flex-grow-1\": !v(i) && h.value\n        }]),\n        \"aria-controls\": L.ariaControls || void 0,\n        \"aria-disabled\": v(i) ? !0 : void 0,\n        \"aria-label\": L.labelPage ? `${L.labelPage} ${H.number}` : void 0,\n        \"aria-posinset\": H.number,\n        \"aria-checked\": k(H.number),\n        \"aria-setsize\": c.value,\n        role: \"menuitemradio\",\n        type: v(i) ? void 0 : \"button\",\n        tabindex: S(H.number),\n        onClick: G => we(G, H.number)\n      }, {\n        default: R(() => [A(L.$slots, \"page\", {\n          active: k(H.number),\n          disabled: v(i),\n          page: H.number,\n          index: H.number - 1,\n          content: H.number\n        }, () => [ne(Z(H.number), 1)])]),\n        _: 2\n      }, 1032, [\"class\", \"aria-controls\", \"aria-disabled\", \"aria-label\", \"aria-posinset\", \"aria-checked\", \"aria-setsize\", \"type\", \"tabindex\", \"onClick\"]))], 10, Kd))), 128)), fe.value ? (m(), N(\"li\", Se(Q({\n        key: 2\n      }, le.value.li)), [ee(\"span\", Se(Ee(le.value.span)), [A(L.$slots, \"ellipsis-text\", {}, () => [ne(Z(L.ellipsisText || \"...\"), 1)])], 16)], 16)) : J(\"\", !0), ee(\"li\", Se(Ee(D.value.li)), [(m(), x(se(D.value.button.is), Q(D.value.button, {\n        onClick: U[2] || (U[2] = H => we(H, v(b) + 1))\n      }), {\n        default: R(() => [A(L.$slots, \"next-text\", {}, () => [ne(Z(L.nextText), 1)])]),\n        _: 3\n      }, 16))], 16), !v(f) && !v(d) ? (m(), N(\"li\", Se(Q({\n        key: 3\n      }, ae.value.li)), [(m(), x(se(ae.value.button.is), Q(ae.value.button, {\n        onClick: U[3] || (U[3] = H => we(H, c.value))\n      }), {\n        default: R(() => [A(L.$slots, \"last-text\", {}, () => [ne(Z(L.lastText), 1)])]),\n        _: 3\n      }, 16))], 16)) : J(\"\", !0)], 10, Xd));\n    }\n  }),\n  Ue = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BPlaceholder\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      cols: {\n        default: 12\n      },\n      size: {\n        default: \"md\"\n      },\n      tag: {\n        default: \"span\"\n      },\n      variant: {\n        default: null\n      },\n      width: {\n        default: void 0\n      },\n      wrapperTag: {\n        default: \"span\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = E(() => t.width === void 0 ? void 0 : typeof t.width == \"number\" ? t.width.toString() : t.width.replace(\"%\", \"\")),\n        a = E(() => t.cols === void 0 ? void 0 : typeof t.cols == \"number\" ? t.cols.toString() : t.cols),\n        l = w(() => ({\n          [`col-${a.value}`]: a.value !== void 0 && o.value === void 0,\n          [`bg-${t.variant}`]: t.variant !== null,\n          [`placeholder-${t.size}`]: t.size !== \"md\"\n        })),\n        n = w(() => ({\n          [`placeholder-${t.animation}`]: t.animation !== void 0\n        })),\n        i = w(() => ({\n          width: o.value === void 0 ? void 0 : `${o.value}%`\n        }));\n      return (s, u) => (m(), x(se(s.wrapperTag), {\n        class: j(n.value)\n      }, {\n        default: R(() => [(m(), x(se(s.tag), Q(s.$attrs, {\n          class: [\"placeholder\", l.value],\n          style: i.value\n        }), null, 16, [\"class\", \"style\"]))]),\n        _: 1\n      }, 8, [\"class\"]));\n    }\n  }),\n  Tn = /* @__PURE__ */q({\n    __name: \"BPlaceholderButton\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      cols: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      variant: {\n        default: \"primary\"\n      },\n      width: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`btn-${t.variant}`]: t.variant !== null\n        }));\n      return (a, l) => (m(), x(Ue, {\n        class: j([\"btn disabled\", o.value]),\n        animation: a.animation,\n        width: a.width,\n        cols: a.cols,\n        tag: a.tag,\n        style: {\n          cursor: \"wait\",\n          \"pointer-events\": \"auto\"\n        }\n      }, null, 8, [\"class\", \"animation\", \"width\", \"cols\", \"tag\"]));\n    }\n  }),\n  Zd = /* @__PURE__ */q({\n    __name: \"BPlaceholderCard\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      footerAnimation: {\n        default: void 0\n      },\n      footerSize: {\n        default: \"md\"\n      },\n      footerVariant: {\n        default: void 0\n      },\n      footerWidth: {\n        default: 100\n      },\n      headerAnimation: {\n        default: void 0\n      },\n      headerSize: {\n        default: \"md\"\n      },\n      headerVariant: {\n        default: void 0\n      },\n      headerWidth: {\n        default: 100\n      },\n      imgBlankColor: {\n        default: \"#868e96\"\n      },\n      imgBottom: {\n        type: [String, Boolean],\n        default: !1\n      },\n      imgHeight: {\n        default: 100\n      },\n      imgSrc: {\n        default: void 0\n      },\n      noButton: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFooter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noImg: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.noButton),\n        a = r(() => t.noHeader),\n        l = r(() => t.noFooter),\n        n = r(() => t.noImg),\n        i = w(() => ({\n          animation: t.animation,\n          size: t.size,\n          variant: t.variant\n        })),\n        s = E(() => o.value ? Ue : Tn);\n      return (u, d) => (m(), x(mn, {\n        \"img-bottom\": u.imgBottom\n      }, Ua({\n        default: R(() => [A(u.$slots, \"default\", {}, () => [ye(Ue, Q({\n          cols: \"7\"\n        }, i.value), null, 16), ye(Ue, Q({\n          cols: \"4\"\n        }, i.value), null, 16), ye(Ue, Q({\n          cols: \"4\"\n        }, i.value), null, 16), ye(Ue, Q({\n          cols: \"6\"\n        }, i.value), null, 16), ye(Ue, Q({\n          cols: \"8\"\n        }, i.value), null, 16)])]),\n        _: 2\n      }, [v(n) ? void 0 : {\n        name: \"img\",\n        fn: R(() => [A(u.$slots, \"img\", {}, () => [ye(ya, {\n          blank: !u.imgSrc,\n          \"blank-color\": u.imgBlankColor,\n          height: u.imgSrc ? void 0 : u.imgHeight,\n          src: u.imgSrc,\n          top: !u.imgBottom,\n          bottom: u.imgBottom,\n          style: {\n            cursor: \"wait\"\n          }\n        }, null, 8, [\"blank\", \"blank-color\", \"height\", \"src\", \"top\", \"bottom\"])])]),\n        key: \"0\"\n      }, v(a) ? void 0 : {\n        name: \"header\",\n        fn: R(() => [A(u.$slots, \"header\", {}, () => [ye(Ue, {\n          width: u.headerWidth,\n          variant: u.headerVariant,\n          animation: u.headerAnimation,\n          size: u.headerSize\n        }, null, 8, [\"width\", \"variant\", \"animation\", \"size\"])])]),\n        key: \"1\"\n      }, v(l) ? void 0 : {\n        name: \"footer\",\n        fn: R(() => [A(u.$slots, \"footer\", {}, () => [(m(), x(se(s.value), {\n          width: u.footerWidth,\n          animation: u.footerAnimation,\n          size: v(o) ? u.footerSize : void 0,\n          variant: u.footerVariant\n        }, null, 8, [\"width\", \"animation\", \"size\", \"variant\"]))])]),\n        key: \"2\"\n      }]), 1032, [\"img-bottom\"]));\n    }\n  }),\n  go = /* @__PURE__ */q({\n    __name: \"BTableSimple\",\n    props: {\n      bordered: {\n        type: [String, Boolean],\n        default: !1\n      },\n      borderless: {\n        type: [String, Boolean],\n        default: !1\n      },\n      borderVariant: {\n        default: null\n      },\n      captionTop: {\n        type: [String, Boolean],\n        default: !1\n      },\n      dark: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fixed: {\n        type: [String, Boolean],\n        default: !1\n      },\n      hover: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      noBorderCollapse: {\n        type: [String, Boolean],\n        default: !1\n      },\n      outlined: {\n        type: [String, Boolean],\n        default: !1\n      },\n      responsive: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stickyHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      striped: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stripedColumns: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tableClass: {\n        default: void 0\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.captionTop),\n        a = r(() => t.borderless),\n        l = r(() => t.bordered),\n        n = r(() => t.dark),\n        i = r(() => t.hover),\n        s = r(() => t.small),\n        u = r(() => t.striped),\n        d = r(() => t.stickyHeader),\n        f = r(() => t.stripedColumns),\n        g = r(() => t.responsive),\n        p = r(() => t.stacked),\n        y = w(() => [t.tableClass, \"table\", \"b-table\", {\n          \"table-bordered\": l.value,\n          \"table-borderless\": a.value,\n          [`border-${t.borderVariant}`]: t.borderVariant !== null,\n          \"caption-top\": o.value,\n          \"table-dark\": n.value,\n          \"table-hover\": i.value,\n          \"b-table-stacked\": p.value === !0,\n          [`b-table-stacked-${p.value}`]: typeof p.value == \"string\",\n          \"table-striped\": u.value,\n          \"table-sm\": s.value,\n          [`table-${t.variant}`]: t.variant !== null,\n          \"table-striped-columns\": f.value\n        }]),\n        b = w(() => ({\n          \"table-responsive\": g.value === !0,\n          [`table-responsive-${g.value}`]: typeof g.value == \"string\",\n          \"b-table-sticky-header\": d.value\n        }));\n      return (V, C) => V.responsive ? (m(), N(\"div\", {\n        key: 1,\n        class: j(b.value)\n      }, [ee(\"table\", {\n        class: j(y.value)\n      }, [A(V.$slots, \"default\")], 2)], 2)) : (m(), N(\"table\", {\n        key: 0,\n        class: j(y.value)\n      }, [A(V.$slots, \"default\")], 2));\n    }\n  }),\n  Jd = /* @__PURE__ */q({\n    __name: \"BPlaceholderTable\",\n    props: {\n      animation: {\n        default: void 0\n      },\n      cellWidth: {\n        default: 100\n      },\n      columns: {\n        default: 5\n      },\n      footerAnimation: {\n        default: void 0\n      },\n      footerCellWidth: {\n        default: 100\n      },\n      footerColumns: {\n        default: void 0\n      },\n      footerSize: {\n        default: \"md\"\n      },\n      footerVariant: {\n        default: void 0\n      },\n      headerAnimation: {\n        default: void 0\n      },\n      headerCellWidth: {\n        default: 100\n      },\n      headerColumns: {\n        default: void 0\n      },\n      headerSize: {\n        default: \"md\"\n      },\n      headerVariant: {\n        default: void 0\n      },\n      hideHeader: {\n        type: [String, Boolean],\n        default: !1\n      },\n      rows: {\n        default: 3\n      },\n      showFooter: {\n        type: [String, Boolean],\n        default: !1\n      },\n      size: {\n        default: \"md\"\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = he(() => t.columns),\n        a = he(() => t.rows),\n        l = E(() => t.headerColumns ?? NaN),\n        n = E(() => t.footerColumns ?? NaN),\n        i = he(l),\n        s = he(n),\n        u = E(() => o.value || 5),\n        d = E(() => a.value || 3),\n        f = E(() => t.headerColumns === void 0 ? u.value : i.value),\n        g = E(() => t.footerColumns === void 0 ? u.value : s.value),\n        p = r(() => t.hideHeader),\n        y = r(() => t.showFooter);\n      return (b, V) => (m(), x(go, null, {\n        default: R(() => [v(p) ? J(\"\", !0) : A(b.$slots, \"thead\", {\n          key: 0\n        }, () => [ee(\"thead\", null, [ee(\"tr\", null, [(m(!0), N(ge, null, Te(f.value, (C, c) => (m(), N(\"th\", {\n          key: c\n        }, [ye(Ue, {\n          size: b.headerSize,\n          variant: b.headerVariant,\n          animation: b.headerAnimation,\n          width: b.headerCellWidth\n        }, null, 8, [\"size\", \"variant\", \"animation\", \"width\"])]))), 128))])])]), A(b.$slots, \"default\", {}, () => [ee(\"tbody\", null, [(m(!0), N(ge, null, Te(d.value, (C, c) => (m(), N(\"tr\", {\n          key: c\n        }, [(m(!0), N(ge, null, Te(u.value, (h, B) => (m(), N(\"td\", {\n          key: B\n        }, [ye(Ue, {\n          size: b.size,\n          variant: b.variant,\n          animation: b.animation,\n          width: b.cellWidth\n        }, null, 8, [\"size\", \"variant\", \"animation\", \"width\"])]))), 128))]))), 128))])]), v(y) ? A(b.$slots, \"tfoot\", {\n          key: 1\n        }, () => [ee(\"tfoot\", null, [ee(\"tr\", null, [(m(!0), N(ge, null, Te(g.value, (C, c) => (m(), N(\"th\", {\n          key: c\n        }, [ye(Ue, {\n          size: b.footerSize,\n          variant: b.footerVariant,\n          animation: b.footerAnimation,\n          width: b.footerCellWidth\n        }, null, 8, [\"size\", \"variant\", \"animation\", \"width\"])]))), 128))])])]) : J(\"\", !0)]),\n        _: 3\n      }));\n    }\n  }),\n  Qd = /* @__PURE__ */q({\n    __name: \"BPlaceholderWrapper\",\n    props: {\n      loading: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.loading);\n      return (a, l) => v(o) ? A(a.$slots, \"loading\", {\n        key: 0\n      }) : A(a.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  ec = [\"aria-valuenow\", \"aria-valuemax\"],\n  _n = /* @__PURE__ */q({\n    __name: \"BProgressBar\",\n    props: {\n      animated: {\n        type: [String, Boolean],\n        default: !1\n      },\n      label: {\n        default: void 0\n      },\n      labelHtml: {\n        default: void 0\n      },\n      max: {\n        default: void 0\n      },\n      precision: {\n        default: 0\n      },\n      showProgress: {\n        type: [String, Boolean],\n        default: !1\n      },\n      showValue: {\n        type: [String, Boolean],\n        default: !1\n      },\n      striped: {\n        type: [String, Boolean],\n        default: !1\n      },\n      value: {\n        default: 0\n      },\n      variant: {\n        default: null\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = Ge(Jl, null),\n        a = r(() => t.animated),\n        l = r(() => t.showProgress),\n        n = r(() => t.showValue),\n        i = r(() => t.striped),\n        s = Qe(t),\n        u = w(() => [s.value, {\n          \"progress-bar-animated\": a.value || (o == null ? void 0 : o.animated.value),\n          \"progress-bar-striped\": i.value || (o == null ? void 0 : o.striped.value) || a.value || (o == null ? void 0 : o.animated.value)\n        }]),\n        d = he(() => t.precision),\n        f = he(() => t.value),\n        g = he(() => t.max ?? NaN),\n        p = he(() => (o == null ? void 0 : o.max.value) ?? NaN),\n        y = w(() => t.labelHtml !== void 0 ? t.labelHtml : n.value || o != null && o.showValue.value ? f.value.toFixed(d.value) : l.value || o != null && o.showProgress.value ? (f.value * 100 / (g.value || 100)).toFixed(d.value) : t.label !== void 0 ? t.label : \"\"),\n        b = w(() => p.value ? `${f.value * 100 / p.value}%` : g.value ? `${f.value * 100 / g.value}%` : typeof t.value == \"string\" ? t.value : `${t.value}%`);\n      return (V, C) => (m(), N(\"div\", {\n        class: j([\"progress-bar\", u.value]),\n        role: \"progressbar\",\n        \"aria-valuenow\": V.value,\n        \"aria-valuemin\": \"0\",\n        \"aria-valuemax\": V.max,\n        style: ze({\n          width: b.value\n        })\n      }, [A(V.$slots, \"default\", {}, () => [ne(Z(y.value), 1)])], 14, ec));\n    }\n  }),\n  Vn = /* @__PURE__ */q({\n    __name: \"BProgress\",\n    props: {\n      height: {\n        default: void 0\n      },\n      animated: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      max: {\n        default: 100\n      },\n      precision: {\n        default: void 0\n      },\n      showProgress: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      showValue: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      striped: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      value: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: void 0\n      },\n      textVariant: {\n        default: void 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.animated),\n        a = r(() => t.showProgress),\n        l = r(() => t.showValue),\n        n = r(() => t.striped);\n      return at(Jl, {\n        animated: o,\n        max: E(() => t.max),\n        showProgress: a,\n        showValue: l,\n        striped: n\n      }), (i, s) => (m(), N(\"div\", {\n        class: \"progress\",\n        style: ze({\n          height: i.height\n        })\n      }, [A(i.$slots, \"default\", {}, () => [ye(_n, {\n        animated: i.animated,\n        max: i.max,\n        precision: i.precision,\n        \"show-progress\": i.showProgress,\n        \"show-value\": i.showValue,\n        striped: i.striped,\n        value: i.value,\n        variant: i.variant,\n        \"text-variant\": i.textVariant,\n        \"bg-variant\": i.bgVariant\n      }, null, 8, [\"animated\", \"max\", \"precision\", \"show-progress\", \"show-value\", \"striped\", \"value\", \"variant\", \"text-variant\", \"bg-variant\"])])], 4));\n    }\n  }),\n  Jo = wa(\"cols\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  tc = q({\n    name: \"BRow\",\n    slots: Object,\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      gutterX: {\n        type: String,\n        default: null\n      },\n      gutterY: {\n        type: String,\n        default: null\n      },\n      noGutters: {\n        type: [Boolean, String],\n        default: !1\n      },\n      alignV: {\n        type: String,\n        default: null\n      },\n      alignH: {\n        type: String,\n        default: null\n      },\n      alignContent: {\n        type: String,\n        default: null\n      },\n      ...Jo\n    },\n    setup(e) {\n      const t = r(() => e.noGutters),\n        o = Zt(() => e.alignH),\n        a = w(() => Kl(e, Jo, \"cols\", \"row-cols\"));\n      return {\n        computedClasses: w(() => [a.value, {\n          [`gx-${e.gutterX}`]: e.gutterX !== null,\n          [`gy-${e.gutterY}`]: e.gutterY !== null,\n          \"g-0\": t.value,\n          [`align-items-${e.alignV}`]: e.alignV !== null,\n          [o.value]: e.alignH !== null,\n          [`align-content-${e.alignContent}`]: e.alignContent !== null\n        }])\n      };\n    }\n  });\nfunction ac(e, t, o, a, l, n) {\n  return m(), x(se(e.tag), {\n    class: j([\"row\", e.computedClasses])\n  }, {\n    default: R(() => [A(e.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst oc = /* @__PURE__ */$a(tc, [[\"render\", ac]]),\n  An = /* @__PURE__ */q({\n    __name: \"BTbody\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`thead-${t.variant}`]: t.variant !== null\n        }));\n      return (a, l) => (m(), N(\"tbody\", {\n        class: j(o.value)\n      }, [A(a.$slots, \"default\")], 2));\n    }\n  }),\n  lc = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  nc = {\n    key: 0\n  },\n  Et = /* @__PURE__ */q({\n    __name: \"BTd\",\n    props: {\n      colspan: {\n        default: void 0\n      },\n      rowspan: {\n        default: void 0\n      },\n      stackedHeading: {\n        default: void 0\n      },\n      stickyColumn: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.stickyColumn),\n        a = w(() => ({\n          [`table-${t.variant}`]: t.variant !== null,\n          \"b-table-sticky-column\": o.value,\n          \"table-b-table-default\": o.value && t.variant === null\n        })),\n        l = E(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n      return (n, i) => (m(), N(\"td\", {\n        scope: l.value,\n        class: j(a.value),\n        colspan: n.colspan,\n        rowspan: n.rowspan,\n        \"data-label\": n.stackedHeading\n      }, [n.stackedHeading ? (m(), N(\"div\", nc, [A(n.$slots, \"default\")])) : A(n.$slots, \"default\", {\n        key: 1\n      })], 10, lc));\n    }\n  }),\n  qa = /* @__PURE__ */q({\n    __name: \"BTfoot\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`table-${t.variant}`]: t.variant !== null\n        }));\n      return (a, l) => (m(), N(\"tfoot\", {\n        class: j(o.value)\n      }, [A(a.$slots, \"default\")], 2));\n    }\n  }),\n  sc = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  ic = {\n    key: 0\n  },\n  Ga = /* @__PURE__ */q({\n    __name: \"BTh\",\n    props: {\n      colspan: {\n        default: void 0\n      },\n      rowspan: {\n        default: void 0\n      },\n      stackedHeading: {\n        default: void 0\n      },\n      stickyColumn: {\n        type: [String, Boolean],\n        default: !1\n      },\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = r(() => t.stickyColumn),\n        a = w(() => ({\n          [`table-${t.variant}`]: t.variant !== null,\n          \"b-table-sticky-column\": o.value,\n          \"table-b-table-default\": o.value && t.variant === null\n        })),\n        l = E(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n      return (n, i) => (m(), N(\"th\", {\n        scope: l.value,\n        class: j(a.value),\n        colspan: n.colspan,\n        rowspan: n.rowspan,\n        \"data-label\": n.stackedHeading\n      }, [n.stackedHeading !== void 0 ? (m(), N(\"div\", ic, [A(n.$slots, \"default\")])) : A(n.$slots, \"default\", {\n        key: 1\n      })], 10, sc));\n    }\n  }),\n  On = /* @__PURE__ */q({\n    __name: \"BThead\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`table-${t.variant}`]: t.variant !== null\n        }));\n      return (a, l) => (m(), N(\"thead\", {\n        class: j(o.value)\n      }, [A(a.$slots, \"default\")], 2));\n    }\n  }),\n  lt = /* @__PURE__ */q({\n    __name: \"BTr\",\n    props: {\n      variant: {\n        default: null\n      }\n    },\n    setup(e) {\n      const t = e,\n        o = w(() => ({\n          [`table-${t.variant}`]: t.variant !== null\n        }));\n      return (a, l) => (m(), N(\"tr\", {\n        class: j(o.value)\n      }, [A(a.$slots, \"default\")], 2));\n    }\n  }),\n  rc = {\n    key: 0,\n    class: \"b-table-stacked-label\"\n  },\n  uc = {\n    class: \"d-inline-flex flex-nowrap align-items-center gap-1\"\n  },\n  dc = {\n    key: 2\n  },\n  En = /* @__PURE__ */q({\n    __name: \"BTableLite\",\n    props: {\n      align: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      detailsTdClass: {\n        default: void 0\n      },\n      emptyFilteredText: {\n        default: \"There are no records matching your request\"\n      },\n      emptyText: {\n        default: \"There are no records to show\"\n      },\n      fieldColumnClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      fields: {\n        default: () => []\n      },\n      footClone: {\n        type: [String, Boolean],\n        default: !1\n      },\n      footRowVariant: {\n        default: void 0\n      },\n      footVariant: {\n        default: void 0\n      },\n      headRowVariant: {\n        default: void 0\n      },\n      headVariant: {\n        default: void 0\n      },\n      items: {\n        default: () => []\n      },\n      labelStacked: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        default: void 0\n      },\n      primaryKey: {\n        default: void 0\n      },\n      showEmpty: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tbodyClass: {\n        default: void 0\n      },\n      tbodyTrAttr: {\n        default: void 0\n      },\n      tbodyTrClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      tfootClass: {\n        default: void 0\n      },\n      tfootTrClass: {\n        default: void 0\n      },\n      theadClass: {\n        default: void 0\n      },\n      theadTrClass: {\n        default: void 0\n      },\n      bordered: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      borderless: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      borderVariant: {\n        default: void 0\n      },\n      captionTop: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      dark: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      fixed: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      hover: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      noBorderCollapse: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      outlined: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      responsive: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      small: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      stickyHeader: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      striped: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      stripedColumns: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      tableClass: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"head-clicked\", \"row-clicked\", \"row-dbl-clicked\", \"row-hovered\", \"row-unhovered\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = r(() => o.footClone),\n        n = r(() => o.labelStacked),\n        i = r(() => o.showEmpty),\n        s = r(() => o.stacked),\n        u = w(() => [o.tableClass, {\n          [`align-${o.align}`]: o.align !== void 0\n        }]),\n        d = w(() => !o.fields.length && o.items.length ? Object.keys(o.items[0]).map(c => {\n          const h = _a(c);\n          return {\n            key: c,\n            label: h,\n            tdAttr: s.value === !0 ? {\n              \"data-label\": h\n            } : void 0\n          };\n        }) : o.fields.map(c => {\n          if (typeof c == \"string\") {\n            const h = _a(c);\n            return {\n              key: c,\n              label: h,\n              tdAttr: s.value === !0 ? {\n                \"data-label\": h\n              } : void 0\n            };\n          }\n          return {\n            ...c,\n            tdAttr: s.value === !0 ? {\n              \"data-label\": _a(c.key),\n              ...c.tdAttr\n            } : c.tdAttr\n          };\n        })),\n        f = E(() => d.value.length),\n        g = (c, h, B) => {\n          const _ = No(c, h);\n          return B && typeof B == \"function\" ? B(_, h, c) : _;\n        },\n        p = (c, h, B = !1) => {\n          const _ = typeof c == \"string\" ? c : c.key;\n          a(\"head-clicked\", _, c, h, B);\n        },\n        y = c => {\n          c._showDetails = !c._showDetails;\n        },\n        b = c => [c.class, c.thClass, {\n          \"b-table-sticky-column\": c.stickyColumn\n        }, o.fieldColumnClass ? typeof o.fieldColumnClass == \"function\" ? o.fieldColumnClass(c) : o.fieldColumnClass : null],\n        V = (c, h) => {\n          var B;\n          return [c.class, c.tdClass, (B = h._cellVariants) != null && B[c.key] ? `table-${h._cellVariants[c.key]}` : null, {\n            \"b-table-sticky-column\": c.stickyColumn\n          }];\n        },\n        C = (c, h) => o.tbodyTrClass ? typeof o.tbodyTrClass == \"function\" ? o.tbodyTrClass(c, h) : o.tbodyTrClass : null;\n      return (c, h) => (m(), x(go, {\n        id: c.id,\n        bordered: c.bordered,\n        borderless: c.borderless,\n        \"border-variant\": c.borderVariant,\n        \"caption-top\": c.captionTop,\n        dark: c.dark,\n        fixed: c.fixed,\n        hover: c.hover,\n        \"no-border-collapse\": c.noBorderCollapse,\n        outlined: c.outlined,\n        responsive: c.responsive,\n        small: c.small,\n        stacked: v(s),\n        \"sticky-header\": c.stickyHeader,\n        striped: c.striped,\n        \"table-class\": u.value,\n        variant: c.variant,\n        \"striped-columns\": c.stripedColumns\n      }, {\n        default: R(() => [ye(On, {\n          variant: c.headVariant,\n          class: j(c.theadClass)\n        }, {\n          default: R(() => [c.$slots[\"thead-top\"] ? A(c.$slots, \"thead-top\", {\n            key: 0\n          }) : J(\"\", !0), ye(lt, {\n            variant: c.headRowVariant,\n            class: j(c.theadTrClass)\n          }, {\n            default: R(() => [(m(!0), N(ge, null, Te(d.value, B => (m(), x(Ga, Q({\n              key: B.key,\n              scope: \"col\",\n              class: b(B),\n              title: B.headerTitle,\n              variant: B.variant,\n              abbr: B.headerAbbr,\n              style: B.thStyle\n            }, B.thAttr, {\n              onClick: _ => p(B, _)\n            }), {\n              default: R(() => [A(c.$slots, c.$slots[`head(${B.key})`] ? `head(${B.key})` : \"head()\", {\n                label: B.label,\n                column: B.key,\n                field: B,\n                isFoot: !1\n              }, () => [ne(Z(v(ia)(B)), 1)])]),\n              _: 2\n            }, 1040, [\"class\", \"title\", \"variant\", \"abbr\", \"style\", \"onClick\"]))), 128))]),\n            _: 3\n          }, 8, [\"variant\", \"class\"]), c.$slots[\"thead-sub\"] ? (m(), x(lt, {\n            key: 1\n          }, {\n            default: R(() => [(m(!0), N(ge, null, Te(d.value, B => (m(), x(Et, {\n              key: B.key,\n              scope: \"col\",\n              variant: B.variant,\n              class: j([B.class, B.thClass])\n            }, {\n              default: R(() => [A(c.$slots, \"thead-sub\", Q({\n                items: d.value\n              }, B), () => [ne(Z(B.label), 1)])]),\n              _: 2\n            }, 1032, [\"variant\", \"class\"]))), 128))]),\n            _: 3\n          })) : J(\"\", !0)]),\n          _: 3\n        }, 8, [\"variant\", \"class\"]), ye(An, {\n          class: j(c.tbodyClass)\n        }, {\n          default: R(() => [A(c.$slots, \"custom-body\", {\n            fields: d.value,\n            items: c.items,\n            columns: d.value.length\n          }, () => [!v(s) && c.$slots[\"top-row\"] ? (m(), x(lt, {\n            key: 0\n          }, {\n            default: R(() => [A(c.$slots, \"top-row\")]),\n            _: 3\n          })) : J(\"\", !0), (m(!0), N(ge, null, Te(c.items, (B, _) => (m(), N(ge, {\n            key: _\n          }, [ye(lt, {\n            class: j(C(B, \"row\")),\n            variant: B._rowVariant,\n            onClick: k => !v(ea)(k) && a(\"row-clicked\", B, _, k),\n            onDblclick: k => !v(ea)(k) && a(\"row-dbl-clicked\", B, _, k),\n            onMouseenter: k => !v(ea)(k) && a(\"row-hovered\", B, _, k),\n            onMouseleave: k => !v(ea)(k) && a(\"row-unhovered\", B, _, k)\n          }, {\n            default: R(() => [(m(!0), N(ge, null, Te(d.value, k => {\n              var S;\n              return m(), x(Et, Q({\n                key: k.key,\n                variant: (S = B._cellVariants) != null && S[k.key] ? null : k.variant,\n                class: V(k, B)\n              }, k.tdAttr), {\n                default: R(() => [v(s) && v(n) ? (m(), N(\"label\", rc, Z(v(ia)(k)), 1)) : J(\"\", !0), A(c.$slots, c.$slots[`cell(${k.key})`] ? `cell(${k.key})` : \"cell()\", {\n                  value: v(No)(B, k.key),\n                  index: _,\n                  item: B,\n                  field: k,\n                  items: c.items,\n                  toggleDetails: () => {\n                    y(B);\n                  },\n                  detailsShowing: B._showDetails ?? !1\n                }, () => [ne(Z(g(B, k.key, k.formatter)), 1)])]),\n                _: 2\n              }, 1040, [\"variant\", \"class\"]);\n            }), 128))]),\n            _: 2\n          }, 1032, [\"class\", \"variant\", \"onClick\", \"onDblclick\", \"onMouseenter\", \"onMouseleave\"]), B._showDetails === !0 && c.$slots[\"row-details\"] ? (m(), x(lt, {\n            key: 0,\n            class: j(C(B, \"row-details\")),\n            variant: B._rowVariant\n          }, {\n            default: R(() => [ye(Et, {\n              colspan: f.value\n            }, {\n              default: R(() => [A(c.$slots, \"row-details\", {\n                item: B,\n                toggleDetails: () => {\n                  y(B);\n                },\n                fields: c.fields,\n                index: _\n              })]),\n              _: 2\n            }, 1032, [\"colspan\"])]),\n            _: 2\n          }, 1032, [\"class\", \"variant\"])) : J(\"\", !0)], 64))), 128)), v(i) && c.items.length === 0 ? (m(), x(lt, {\n            key: 1,\n            class: \"b-table-empty-slot\"\n          }, {\n            default: R(() => [ye(Et, {\n              colspan: f.value\n            }, {\n              default: R(() => [A(c.$slots, \"empty\", {\n                items: c.items\n              }, () => [ne(Z(c.emptyText), 1)])]),\n              _: 3\n            }, 8, [\"colspan\"])]),\n            _: 3\n          })) : J(\"\", !0), !v(s) && c.$slots[\"bottom-row\"] ? (m(), x(lt, {\n            key: 2\n          }, {\n            default: R(() => [A(c.$slots, \"bottom-row\")]),\n            _: 3\n          })) : J(\"\", !0)])]),\n          _: 3\n        }, 8, [\"class\"]), v(l) ? (m(), x(qa, {\n          key: 0,\n          variant: c.footVariant,\n          class: j(c.tfootClass)\n        }, {\n          default: R(() => [ye(lt, {\n            variant: c.footRowVariant,\n            class: j(c.tfootTrClass)\n          }, {\n            default: R(() => [(m(!0), N(ge, null, Te(d.value, B => (m(), x(Ga, Q({\n              key: B.key,\n              scope: \"col\",\n              class: b(B),\n              title: B.headerTitle,\n              abbr: B.headerAbbr,\n              style: B.thStyle,\n              variant: B.variant\n            }, B.thAttr, {\n              onClick: _ => p(B, _, !0)\n            }), {\n              default: R(() => [ee(\"div\", uc, [ee(\"div\", null, [A(c.$slots, c.$slots[`foot(${B.key})`] ? `foot(${B.key})` : \"foot()\", {\n                label: B.label,\n                column: B.key,\n                field: B,\n                isFoot: !0\n              }, () => [ne(Z(v(ia)(B)), 1)])])])]),\n              _: 2\n            }, 1040, [\"class\", \"title\", \"abbr\", \"style\", \"variant\", \"onClick\"]))), 128))]),\n            _: 3\n          }, 8, [\"variant\", \"class\"])]),\n          _: 3\n        }, 8, [\"variant\", \"class\"])) : c.$slots[\"custom-foot\"] ? (m(), x(qa, {\n          key: 1\n        }, {\n          default: R(() => [A(c.$slots, \"custom-foot\", {\n            fields: d.value,\n            items: c.items,\n            columns: d.value.length\n          })]),\n          _: 3\n        })) : J(\"\", !0), c.$slots[\"table-caption\"] || c.caption ? (m(), N(\"caption\", dc, [A(c.$slots, \"table-caption\", {}, () => [ne(Z(c.caption), 1)])])) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"bordered\", \"borderless\", \"border-variant\", \"caption-top\", \"dark\", \"fixed\", \"hover\", \"no-border-collapse\", \"outlined\", \"responsive\", \"small\", \"stacked\", \"sticky-header\", \"striped\", \"table-class\", \"variant\", \"striped-columns\"]));\n    }\n  }),\n  cc = /* @__PURE__ */ee(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    d: \"M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z\"\n  }, null, -1),\n  fc = [cc],\n  vc = /* @__PURE__ */ee(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    d: \"M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z\"\n  }, null, -1),\n  pc = [vc],\n  mc = {\n    class: \"d-flex align-items-center gap-2 mt-5\"\n  },\n  gc = /* @__PURE__ */q({\n    __name: \"BTable\",\n    props: {\n      provider: {\n        type: Function,\n        default: void 0\n      },\n      sortCompare: {\n        type: Function,\n        default: void 0\n      },\n      noProvider: {\n        default: void 0\n      },\n      noProviderPaging: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noProviderSorting: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noProviderFiltering: {\n        type: [String, Boolean],\n        default: !1\n      },\n      sortBy: {\n        default: void 0\n      },\n      sortDesc: {\n        type: [String, Boolean],\n        default: !1\n      },\n      selectable: {\n        type: [String, Boolean],\n        default: !1\n      },\n      stickySelect: {\n        type: [String, Boolean],\n        default: !1\n      },\n      selectHead: {\n        type: [Boolean, String],\n        default: !0\n      },\n      selectMode: {\n        default: \"multi\"\n      },\n      selectionVariant: {\n        default: \"primary\"\n      },\n      busy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      busyLoadingText: {\n        default: \"Loading...\"\n      },\n      perPage: {\n        default: 1 / 0\n      },\n      currentPage: {\n        default: 1\n      },\n      filter: {\n        default: void 0\n      },\n      filterable: {\n        default: void 0\n      },\n      selectedItems: {\n        default: () => []\n      },\n      noSortableIcon: {\n        type: [String, Boolean],\n        default: !1\n      },\n      align: {\n        default: void 0\n      },\n      caption: {\n        default: void 0\n      },\n      captionHtml: {\n        default: void 0\n      },\n      detailsTdClass: {\n        default: void 0\n      },\n      emptyFilteredText: {\n        default: void 0\n      },\n      emptyText: {\n        default: void 0\n      },\n      fieldColumnClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      fields: {\n        default: () => []\n      },\n      footClone: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      footRowVariant: {\n        default: void 0\n      },\n      footVariant: {\n        default: void 0\n      },\n      headRowVariant: {\n        default: void 0\n      },\n      headVariant: {\n        default: void 0\n      },\n      items: {\n        default: () => []\n      },\n      labelStacked: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      modelValue: {\n        default: void 0\n      },\n      primaryKey: {\n        default: void 0\n      },\n      showEmpty: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      tbodyClass: {\n        default: void 0\n      },\n      tbodyTrAttr: {\n        default: void 0\n      },\n      tbodyTrClass: {\n        type: [Function, String, Object, Array],\n        default: void 0\n      },\n      tfootClass: {\n        default: void 0\n      },\n      tfootTrClass: {\n        default: void 0\n      },\n      theadClass: {\n        default: void 0\n      },\n      theadTrClass: {\n        default: void 0\n      },\n      bordered: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      borderless: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      borderVariant: {\n        default: void 0\n      },\n      captionTop: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      dark: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      fixed: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      hover: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      noBorderCollapse: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      outlined: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      responsive: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      small: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      stacked: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      stickyHeader: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      striped: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      stripedColumns: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    emits: [\"filtered\", \"head-clicked\", \"row-clicked\", \"row-dbl-clicked\", \"row-hovered\", \"row-selected\", \"row-unhovered\", \"row-unselected\", \"selection\", \"sorted\", \"update:busy\", \"update:selectedItems\", \"update:sortDesc\", \"update:sortBy\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = ke(a, \"sortBy\", l, {\n          passive: !0\n        }),\n        i = ke(a, \"busy\", l, {\n          passive: !0\n        }),\n        s = ke(a, \"sortDesc\", l, {\n          passive: !0\n        }),\n        u = ke(a, \"selectedItems\", l, {\n          passive: !0\n        }),\n        d = w({\n          get: () => /* @__PURE__ */new Set([...u.value]),\n          set: M => {\n            u.value = [...M];\n          }\n        }),\n        f = {\n          add: M => {\n            const L = new Set(d.value);\n            L.add(M), d.value = L, l(\"row-selected\", M);\n          },\n          clear: () => {\n            d.value.forEach(M => {\n              l(\"row-unselected\", M);\n            }), d.value = /* @__PURE__ */new Set();\n          },\n          delete: M => {\n            const L = new Set(d.value);\n            L.delete(M), d.value = L, l(\"row-unselected\", M);\n          },\n          /* TODO\n          This has method and the delete method suffer from an error when using a non-reactive source as the items prop\n          ```ts\n          const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]\n          ```\n          For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine\n          Getting the reference properly will fix all outstanding issues\n          */\n          has: M => d.value.has(M)\n        },\n        g = W([]),\n        p = r(s),\n        y = r(i),\n        b = r(() => a.noProviderPaging),\n        V = r(() => a.noProviderSorting),\n        C = r(() => a.noProviderFiltering),\n        c = r(() => a.selectable),\n        h = r(() => a.noSortableIcon),\n        B = he(() => a.perPage, {\n          method: \"parseInt\"\n        }),\n        _ = he(() => a.currentPage, {\n          method: \"parseInt\"\n        }),\n        k = E(() => !!a.filter),\n        S = E(() => a.provider !== void 0),\n        $ = E(() => d.value.size > 0),\n        I = w(() => n.value !== void 0 || a.fields.some(M => typeof M == \"string\" ? !1 : M.sortable)),\n        T = w(() => a.fields.map(M => typeof M == \"string\" ? M : {\n          ...M,\n          thAttr: {\n            \"aria-sort\": I.value === !1 ? void 0 : n.value !== M.key ? \"none\" : p.value === !0 ? \"descending\" : \"ascending\",\n            ...M.thAttr\n          }\n        })),\n        O = w(() => ({\n          \"b-table-busy\": y.value,\n          \"b-table-selectable\": c.value,\n          \"user-select-none\": c.value && $.value\n        })),\n        F = w(() => [a.tbodyTrClass ? typeof a.tbodyTrClass == \"function\" ? a.tbodyTrClass(null, \"table-busy\") : a.tbodyTrClass : null]),\n        K = M => [{\n          \"b-table-sortable-column\": I.value && M.sortable\n        }],\n        z = (M, L) => [{\n          [`selected table-${a.selectionVariant}`]: c.value && M && f.has(M)\n        }, a.tbodyTrClass ? typeof a.tbodyTrClass == \"function\" ? a.tbodyTrClass(M, L) : a.tbodyTrClass : null],\n        P = M => n.value !== M.key ? {\n          opacity: 0.5\n        } : {},\n        D = w(() => {\n          const M = H => {\n              const G = n.value;\n              if (G === void 0) return H;\n              const X = T.value.find(te => typeof te == \"string\" ? !1 : te.key === G);\n              return typeof X != \"string\" && (X == null ? void 0 : X.sortable) === !1 ? H : [...H].sort((te, be) => {\n                if (a.sortCompare !== void 0) return a.sortCompare(te, be, G, p.value);\n                const me = de => typeof de == \"object\" && de !== null ? JSON.stringify(de) : (de == null ? void 0 : de.toString()) ?? \"\";\n                return me(te[G]) > me(be[G]) ? p.value ? -1 : 1 : me(be[G]) > me(te[G]) ? p.value ? 1 : -1 : 0;\n              });\n            },\n            L = H => H.filter(G => Object.entries(G).some(([X, te]) => {\n              var me, de;\n              return !te || X[0] === \"_\" || !((me = a.filterable) != null && me.includes(X)) ? !1 : (typeof te == \"object\" ? JSON.stringify(Object.values(te)) : te.toString()).toLowerCase().includes(((de = a.filter) == null ? void 0 : de.toLowerCase()) ?? \"\");\n            }));\n          let U = S.value ? g.value : a.items;\n          return (k.value === !0 && !S.value || k.value === !0 && S.value && C.value) && (U = L(U)), (I.value === !0 && !S.value || I.value === !0 && S.value && V.value) && (U = M(U)), U;\n        }),\n        ae = w(() => Number.isNaN(B.value) || S.value && !b.value ? D.value : D.value.slice((_.value - 1) * (B.value || 1 / 0), _.value * (B.value || 1 / 0))),\n        le = (M, L, U = !1, H = !1, G = !1) => {\n          if (c.value) {\n            if (a.selectMode === \"single\" || a.selectMode === \"multi\") {\n              if (U || H) return;\n              f.has(M) ? f.delete(M) : (a.selectMode === \"single\" && f.clear(), f.add(M));\n            } else if (H || G) f.has(M) ? f.delete(M) : f.add(M);else if (U) {\n              const X = [...d.value].pop(),\n                te = a.items.findIndex(de => de === X),\n                be = Math.min(te, L),\n                me = Math.max(te, L);\n              a.items.slice(be, me + 1).forEach(de => {\n                f.has(de) || f.add(de);\n              });\n            } else f.clear(), f.add(M);\n            fe();\n          }\n        },\n        ve = (M, L, U) => {\n          le(M, L, U.shiftKey, U.ctrlKey, U.metaKey), l(\"row-clicked\", M, L, U);\n        },\n        Be = M => {\n          if (!I.value) return;\n          const L = typeof M == \"string\" ? M : M.key,\n            U = typeof M == \"string\" ? !1 : M.sortable;\n          I.value === !0 && U === !0 && (n.value !== L ? (n.value = L, s.value = !1) : p.value === !1 ? s.value = !0 : (n.value = void 0, s.value = !1), l(\"sorted\", L, n.value === void 0 ? !1 : !p.value));\n        },\n        Ve = (M, L, U, H = !1) => {\n          l(\"head-clicked\", M, L, U, H), Be(L);\n        },\n        oe = async () => {\n          if (!S.value || a.provider === void 0 || y.value) return;\n          i.value = !0;\n          const M = a.provider({\n            currentPage: _.value,\n            filter: a.filter,\n            sortBy: n.value,\n            sortDesc: a.sortDesc,\n            perPage: B.value\n          });\n          try {\n            const L = M instanceof Promise ? await M : M;\n            if (L === void 0) return;\n            g.value = L;\n          } finally {\n            i.value = !1;\n          }\n        },\n        fe = () => {\n          c.value && l(\"selection\", [...d.value]);\n        },\n        $e = async () => {\n          if (S.value) {\n            await oe();\n            return;\n          }\n          l(\"filtered\", D.value);\n        },\n        we = async (M, L, U) => {\n          if (L === U) return;\n          const H = be => {\n              var me;\n              return ((me = a.noProvider) == null ? void 0 : me.includes(be)) === !0;\n            },\n            G = (M === \"currentPage\" || M === \"perPage\") && (H(\"paging\") || b.value === !0),\n            X = M === \"filter\" && (H(\"filtering\") || C.value === !0),\n            te = (M === \"sortBy\" || M === \"sortDesc\") && (H(\"sorting\") || V.value === !0);\n          G || X || te || (await oe(), M === \"currentPage\" || M === \"perPage\" || $e());\n        };\n      return ue(() => a.filter, (M, L) => {\n        we(\"filter\", M, L), !(M === L || S.value) && (M || l(\"filtered\", D.value));\n      }), ue(_, (M, L) => {\n        we(\"currentPage\", M, L);\n      }), ue(B, (M, L) => {\n        we(\"perPage\", M, L);\n      }), ue(n, (M, L) => {\n        we(\"sortBy\", M, L);\n      }), ue(p, (M, L) => {\n        we(\"sortDesc\", M, L);\n      }), ue(() => a.provider, M => {\n        if (M === void 0) {\n          g.value = [];\n          return;\n        }\n        oe();\n      }), st(oe), t({\n        // The row selection methods are really for compat. Users should probably use the v-model though\n        clearSelected: () => {\n          c.value && (f.clear(), fe());\n        },\n        refresh: oe,\n        selectAllRows: () => {\n          if (!c.value) return;\n          const M = d.value.size > 0 ? [...d.value] : [];\n          d.value = /* @__PURE__ */new Set([...D.value]), d.value.forEach(L => {\n            M.includes(L) || l(\"row-selected\", L);\n          }), fe();\n        },\n        selectRow: M => {\n          if (!c.value) return;\n          const L = D.value[M];\n          !L || f.has(L) || (f.add(L), fe());\n        },\n        unselectRow: M => {\n          if (!c.value) return;\n          const L = D.value[M];\n          !L || !f.has(L) || (f.delete(L), fe());\n        }\n      }), (M, L) => (m(), x(En, Q(a, {\n        \"aria-busy\": v(y),\n        items: ae.value,\n        fields: T.value,\n        \"table-class\": O.value,\n        \"tbody-tr-class\": z,\n        \"field-column-class\": K,\n        onHeadClicked: Ve,\n        onRowClicked: ve\n      }), Ua({\n        \"head()\": R(U => [ne(Z(v(ia)(U.field)) + \" \", 1), I.value && U.field.sortable && v(h) === !1 ? (m(), N(ge, {\n          key: 0\n        }, [v(p) ? A(M.$slots, \"sortDesc\", Se(Q({\n          key: 1\n        }, {\n          ...U\n        })), () => [(m(), N(\"svg\", {\n          style: ze(P(U.field)),\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          fill: \"currentColor\",\n          class: \"bi bi-arrow-down-short\",\n          viewBox: \"0 0 16 16\",\n          \"aria-hidden\": \"\"\n        }, pc, 4))]) : A(M.$slots, \"sortAsc\", Se(Q({\n          key: 0\n        }, {\n          ...U\n        })), () => [(m(), N(\"svg\", {\n          style: ze(P(U.field)),\n          xmlns: \"http://www.w3.org/2000/svg\",\n          width: \"16\",\n          height: \"16\",\n          fill: \"currentColor\",\n          class: \"bi bi-arrow-up-short\",\n          viewBox: \"0 0 16 16\",\n          \"aria-hidden\": \"\"\n        }, fc, 4))])], 64)) : J(\"\", !0)]),\n        \"custom-body\": R(U => [v(y) ? (m(), x(lt, {\n          key: 0,\n          class: j([\"b-table-busy-slot\", F.value])\n        }, {\n          default: R(() => [ye(Et, {\n            colspan: U.fields.length\n          }, {\n            default: R(() => [A(M.$slots, \"table-busy\", {}, () => [ye(Ta, {\n              show: \"\"\n            }, {\n              overlay: R(() => [ee(\"div\", mc, [ye(ka), ee(\"strong\", null, Z(M.busyLoadingText), 1)])]),\n              _: 1\n            })])]),\n            _: 2\n          }, 1032, [\"colspan\"])]),\n          _: 2\n        }, 1032, [\"class\"])) : J(\"\", !0)]),\n        _: 2\n      }, [Te(M.$slots, (U, H) => ({\n        name: H,\n        fn: R(G => [A(M.$slots, H, Se(Ee(G)))])\n      }))]), 1040, [\"aria-busy\", \"items\", \"fields\", \"table-class\"]));\n    }\n  }),\n  bc = /* @__PURE__ */q({\n    inheritAttrs: !1,\n    __name: \"BTab\",\n    props: {\n      active: {\n        type: [String, Boolean],\n        default: !1\n      },\n      buttonId: {\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      lazyOnce: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noBody: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      title: {\n        default: void 0\n      },\n      titleItemClass: {\n        default: void 0\n      },\n      titleLinkAttributes: {\n        default: void 0\n      },\n      titleLinkClass: {\n        default: void 0\n      }\n    },\n    emits: [\"update:active\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = Me(),\n        l = t,\n        n = Ge(Zl, null),\n        i = _e(() => o.id, \"tabpane\"),\n        s = _e(() => o.buttonId, \"tab\"),\n        u = r(() => o.active),\n        d = r(() => o.disabled),\n        f = r(() => o.lazyOnce ?? o.lazy),\n        g = r(() => o.noBody),\n        p = W(!1),\n        y = W(null),\n        {\n          onClick: b,\n          ...V\n        } = Kt(),\n        C = w(() => ({\n          id: i.value,\n          buttonId: s.value,\n          disabled: d.value,\n          title: o.title,\n          titleComponent: a.title,\n          titleItemClass: o.titleItemClass,\n          titleLinkAttributes: o.titleLinkAttributes,\n          titleLinkClass: o.titleLinkClass,\n          onClick: b,\n          el: y.value\n        }));\n      st(() => {\n        n && (n.registerTab(C), u.value && n.activateTab(i.value));\n      }), Un(() => {\n        n && n.unregisterTab(i.value);\n      });\n      const c = E(() => (n == null ? void 0 : n.activeId.value) === i.value),\n        h = W(c.value),\n        B = E(() => !!(n != null && n.lazy.value || f.value)),\n        _ = E(() => o.lazyOnce !== void 0),\n        k = E(() => c.value && !d.value),\n        S = E(() => k.value || !B.value || B.value && _.value && p.value);\n      ue(c, I => {\n        if (I) {\n          l(\"update:active\", !0), setTimeout(() => {\n            h.value = !0;\n          }, 0);\n          return;\n        }\n        h.value = !1, l(\"update:active\", !1);\n      }), ue(u, I => {\n        if (n) {\n          if (!I) {\n            c.value && n.activateTab(void 0);\n            return;\n          }\n          n.activateTab(i.value);\n        }\n      });\n      const $ = w(() => [{\n        active: c.value,\n        show: h.value,\n        \"card-body\": (n == null ? void 0 : n.card.value) && g.value === !1,\n        fade: !(n != null && n.noFade.value)\n      }, h.value && n != null && n.activeTabClass ? n.activeTabClass : null]);\n      return ue(S, I => {\n        I && !p.value && (p.value = !0);\n      }), (I, T) => (m(), x(se(I.tag), Q({\n        id: v(i),\n        ref_key: \"el\",\n        ref: y,\n        class: [\"tab-pane\", $.value],\n        role: \"tabpanel\",\n        \"aria-labelledby\": v(s)\n      }, V), {\n        default: R(() => [S.value ? A(I.$slots, \"default\", {\n          key: 0\n        }) : J(\"\", !0)]),\n        _: 3\n      }, 16, [\"id\", \"class\", \"aria-labelledby\"]));\n    }\n  }),\n  yc = [\"aria-orientation\"],\n  hc = [\"id\", \"aria-controls\", \"aria-selected\", \"onClick\"],\n  Bc = /* @__PURE__ */q({\n    __name: \"BTabs\",\n    props: {\n      activeId: {\n        default: void 0\n      },\n      activeNavItemClass: {\n        default: void 0\n      },\n      activeTabClass: {\n        default: void 0\n      },\n      align: {\n        default: void 0\n      },\n      card: {\n        type: [String, Boolean],\n        default: !1\n      },\n      contentClass: {\n        default: void 0\n      },\n      end: {\n        type: [String, Boolean],\n        default: !1\n      },\n      fill: {\n        type: [String, Boolean],\n        default: !1\n      },\n      id: {\n        default: void 0\n      },\n      justified: {\n        type: [String, Boolean],\n        default: !1\n      },\n      lazy: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        default: -1\n      },\n      navClass: {\n        default: void 0\n      },\n      navWrapperClass: {\n        default: void 0\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noNavStyle: {\n        type: [String, Boolean],\n        default: !1\n      },\n      pills: {\n        type: [String, Boolean],\n        default: !1\n      },\n      small: {\n        type: [String, Boolean],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        type: [String, Boolean],\n        default: !1\n      }\n    },\n    emits: [\"activate-tab\", \"click\", \"update:activeId\", \"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const o = e,\n        a = t,\n        l = ke(o, \"modelValue\", a, {\n          passive: !0\n        }),\n        n = ke(o, \"activeId\", a, {\n          passive: !0\n        }),\n        i = r(() => o.card),\n        s = r(() => o.end),\n        u = r(() => o.fill),\n        d = r(() => o.justified),\n        f = r(() => o.lazy),\n        g = r(() => o.noFade),\n        p = r(() => o.noNavStyle),\n        y = r(() => o.pills),\n        b = r(() => o.small),\n        V = r(() => o.vertical),\n        C = W([]),\n        c = w(() => C.value.map(z => {\n          const P = v(z),\n            D = P.id === n.value;\n          return {\n            ...P,\n            active: D,\n            navItemClasses: [{\n              active: D,\n              disabled: P.disabled\n            }, D && o.activeNavItemClass ? o.activeNavItemClass : null, P.titleLinkClass]\n          };\n        })),\n        h = E(() => !(c != null && c.value && c.value.length > 0)),\n        B = w(() => ({\n          \"d-flex\": V.value,\n          \"align-items-start\": V.value\n        })),\n        _ = Zt(() => o.align),\n        k = w(() => ({\n          \"nav-pills\": y.value,\n          \"flex-column me-3\": V.value,\n          [_.value]: o.align !== void 0,\n          \"nav-fill\": u.value,\n          \"card-header-tabs\": i.value,\n          \"nav-justified\": d.value,\n          \"nav-tabs\": !p.value && !y.value,\n          small: b.value\n        })),\n        S = z => {\n          var P;\n          if (z !== void 0) {\n            const D = (P = c.value[z]) == null ? void 0 : P.id;\n            if (z > -1 && z < c.value.length && !c.value[z].disabled && (l.value < 0 || n.value !== D || l.value !== z)) {\n              const ae = new dt(\"activate-tab\", {\n                cancelable: !0\n              });\n              a(\"activate-tab\", z, l.value, ae), ae.defaultPrevented || (n.value !== D && (n.value = D), l.value !== z && (l.value = z));\n            }\n          }\n        },\n        $ = (z, P) => {\n          var D, ae, le;\n          S(P), P >= 0 && !c.value[P].disabled && (D = c.value[P]) != null && D.onClick && typeof c.value[P].onClick == \"function\" && ((le = (ae = c.value[P]).onClick) == null || le.call(ae, z));\n        },\n        I = z => {\n          var P, D;\n          c.value.length <= 0 || (l.value = T(l.value + z, z), (D = document.getElementById((P = c.value[l.value]) == null ? void 0 : P.buttonId)) == null || D.focus());\n        },\n        T = (z, P) => {\n          if (c.value.length <= 0) return -1;\n          let D = z;\n          const ae = c.value.map(ve => !ve.disabled).lastIndexOf(!0),\n            le = c.value.map(ve => !ve.disabled).indexOf(!0);\n          for (; D >= le && D <= ae && c.value[D].disabled;) D += P;\n          return D < le && (D = le), D >= ae && (D = ae), D;\n        };\n      ue(l, (z, P) => {\n        if (z === P || c.value.length <= 0) return;\n        const D = T(z, z > P ? 1 : -1);\n        Ne(() => {\n          S(D);\n        });\n      }), ue(n, (z, P) => {\n        const D = c.value.findIndex(ae => ae.id === z);\n        if (z !== P && !(c.value.length <= 0)) {\n          if (D === -1) {\n            S(T(0, 1));\n            return;\n          }\n          S(D);\n        }\n      });\n      const O = z => {\n          C.value.find(P => P.value.id === z.value.id) ? C.value[C.value.findIndex(P => P.value.id === z.value.id)] = z : C.value.push(z), C.value = C.value.sort((P, D) => {\n            if (!Node || !P.value.el || !D.value.el) return 0;\n            const ae = P.value.el.compareDocumentPosition(D.value.el);\n            return ae & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : ae & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;\n          });\n        },\n        F = z => {\n          C.value.find(P => P.value.id === z) && C.value.splice(C.value.findIndex(P => P.value.id === z), 1);\n        };\n      ue(C, () => {\n        K();\n      }, {\n        deep: !0\n      });\n      const K = () => {\n        var z;\n        if (c.value.length === 0) {\n          l.value = -1, n.value = void 0;\n          return;\n        }\n        if (l.value >= 0 && !n.value && (n.value = (z = c.value[l.value]) == null ? void 0 : z.id), c.value.find(P => P.id === n.value)) {\n          S(c.value.findIndex(P => P.id === n.value));\n          return;\n        }\n        S(c.value.map(P => !P.disabled).indexOf(!0));\n      };\n      return at(Zl, {\n        lazy: f,\n        card: i,\n        noFade: g,\n        activeTabClass: E(() => o.activeTabClass),\n        registerTab: O,\n        unregisterTab: F,\n        activeId: n,\n        activateTab: z => {\n          const P = c.value.findIndex(D => D.id === z);\n          if (z === void 0 || P === -1) {\n            S(T(0, 1));\n            return;\n          }\n          S(P);\n        }\n      }), (z, P) => (m(), x(se(z.tag), {\n        id: z.id,\n        class: j([\"tabs\", B.value])\n      }, {\n        default: R(() => [v(s) ? (m(), N(\"div\", {\n          key: 0,\n          class: j([\"tab-content\", z.contentClass])\n        }, [A(z.$slots, \"default\"), h.value ? (m(), N(\"div\", {\n          key: \"bv-empty-tab\",\n          class: j([\"tab-pane active\", {\n            \"card-body\": v(i)\n          }])\n        }, [A(z.$slots, \"empty\")], 2)) : J(\"\", !0)], 2)) : J(\"\", !0), ee(\"div\", {\n          class: j([z.navWrapperClass, {\n            \"card-header\": v(i),\n            \"ms-auto\": z.vertical && v(s)\n          }])\n        }, [ee(\"ul\", {\n          class: j([\"nav\", [k.value, z.navClass]]),\n          role: \"tablist\",\n          \"aria-orientation\": z.vertical ? \"vertical\" : \"horizontal\"\n        }, [A(z.$slots, \"tabs-start\"), (m(!0), N(ge, null, Te(c.value, (D, ae) => (m(), N(\"li\", {\n          key: D.id,\n          class: j([\"nav-item\", D.titleItemClass]),\n          role: \"presentation\"\n        }, [ee(\"button\", Q({\n          id: D.buttonId,\n          class: [\"nav-link\", D.navItemClasses],\n          role: \"tab\",\n          \"aria-controls\": D.id,\n          \"aria-selected\": D.active\n        }, D.titleLinkAttributes, {\n          onKeydown: [P[0] || (P[0] = Qt(Bt(le => I(-1), [\"stop\", \"prevent\"]), [\"left\"])), P[1] || (P[1] = Qt(Bt(le => I(1), [\"stop\", \"prevent\"]), [\"right\"])), P[2] || (P[2] = Qt(Bt(le => I(-999), [\"stop\", \"prevent\"]), [\"page-up\"])), P[3] || (P[3] = Qt(Bt(le => I(999), [\"stop\", \"prevent\"]), [\"page-down\"]))],\n          onClick: Bt(le => $(le, ae), [\"stop\", \"prevent\"])\n        }), [D.titleComponent ? (m(), x(se(D.titleComponent), {\n          key: 0\n        })) : (m(), N(ge, {\n          key: 1\n        }, [ne(Z(D.title), 1)], 64))], 16, hc)], 2))), 128)), A(z.$slots, \"tabs-end\")], 10, yc)], 2), v(s) ? J(\"\", !0) : (m(), N(\"div\", {\n          key: 1,\n          class: j([\"tab-content\", z.contentClass])\n        }, [A(z.$slots, \"default\"), h.value ? (m(), N(\"div\", {\n          key: \"bv-empty-tab\",\n          class: j([\"tab-pane active\", {\n            \"card-body\": v(i)\n          }])\n        }, [A(z.$slots, \"empty\")], 2)) : J(\"\", !0)], 2))]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Sc = [\"id\", \"role\", \"aria-live\", \"aria-atomic\"],\n  Cc = {\n    class: \"me-auto\"\n  },\n  Pn = /* @__PURE__ */q({\n    __name: \"BToast\",\n    props: {\n      animation: {\n        type: [String, Boolean],\n        default: !0\n      },\n      autoHide: {\n        type: [String, Boolean],\n        default: !0\n      },\n      body: {\n        default: void 0\n      },\n      bodyClass: {\n        default: void 0\n      },\n      delay: {\n        default: 5e3\n      },\n      headerClass: {\n        default: void 0\n      },\n      headerTag: {\n        default: \"div\"\n      },\n      id: {\n        default: void 0\n      },\n      interval: {\n        default: 1e3\n      },\n      isStatus: {\n        type: [String, Boolean],\n        default: !1\n      },\n      modelValue: {\n        type: [Boolean, Number],\n        default: !1\n      },\n      noCloseButton: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: !1\n      },\n      noHoverPause: {\n        type: [String, Boolean],\n        default: !1\n      },\n      progressProps: {\n        default: void 0\n      },\n      showOnPause: {\n        type: [String, Boolean],\n        default: !0\n      },\n      solid: {\n        type: [String, Boolean],\n        default: !1\n      },\n      title: {\n        default: void 0\n      },\n      toastClass: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      },\n      bgVariant: {\n        default: null\n      },\n      textVariant: {\n        default: null\n      },\n      active: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      activeClass: {\n        default: void 0\n      },\n      append: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      disabled: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      exactActiveClass: {\n        default: void 0\n      },\n      href: {\n        default: void 0\n      },\n      icon: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      opacity: {\n        default: void 0\n      },\n      opacityHover: {\n        default: void 0\n      },\n      rel: {\n        default: void 0\n      },\n      replace: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      routerComponentName: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      to: {\n        default: void 0\n      },\n      underlineOffset: {\n        default: void 0\n      },\n      underlineOffsetHover: {\n        default: void 0\n      },\n      underlineOpacity: {\n        default: void 0\n      },\n      underlineOpacityHover: {\n        default: void 0\n      },\n      underlineVariant: {\n        default: void 0\n      }\n    },\n    emits: [\"close\", \"close-countdown\", \"closed\", \"destroyed\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: o\n    }) {\n      const a = e,\n        l = o,\n        n = W(null),\n        i = lo(n),\n        s = ke(a, \"modelValue\", l),\n        {\n          computedLink: u,\n          computedLinkProps: d\n        } = Ct(a);\n      r(() => a.animation);\n      const f = r(() => a.isStatus);\n      r(() => a.autoHide);\n      const g = r(() => a.noCloseButton),\n        p = r(() => a.noFade),\n        y = r(() => a.noHoverPause),\n        b = r(() => a.showOnPause),\n        V = he(() => a.interval);\n      r(() => a.solid);\n      const C = Qe(a),\n        c = E(() => typeof s.value == \"boolean\" ? 0 : s.value),\n        {\n          isActive: h,\n          pause: B,\n          restart: _,\n          resume: k,\n          stop: S,\n          isPaused: $,\n          value: I\n        } = zl(c, V, {\n          immediate: typeof s.value == \"number\"\n        });\n      Xt(() => {\n        l(\"close-countdown\", I.value);\n      });\n      const T = E(() => u.value ? rt : \"div\"),\n        O = E(() => typeof s.value == \"boolean\" ? s.value : h.value || b.value && $.value);\n      ue(h, P => {\n        P === !1 && $.value === !1 && l(\"destroyed\");\n      });\n      const F = w(() => [C.value, {\n          show: O.value\n        }]),\n        K = () => {\n          l(\"close\"), typeof s.value == \"boolean\" ? s.value = !1 : (s.value = 0, S()), l(\"closed\");\n        },\n        z = () => {\n          y.value || B();\n        };\n      return ue(i, P => {\n        if (P) {\n          z();\n          return;\n        }\n        k();\n      }), Wa(S), t({\n        pause: B,\n        restart: _,\n        resume: k,\n        stop: S\n      }), (P, D) => (m(), x(Mt, {\n        \"no-fade\": v(p)\n      }, {\n        default: R(() => [O.value ? (m(), N(\"div\", {\n          key: 0,\n          id: P.id,\n          ref_key: \"element\",\n          ref: n,\n          class: j([\"toast\", [P.toastClass, F.value]]),\n          tabindex: \"0\",\n          role: O.value ? v(f) ? \"status\" : \"alert\" : void 0,\n          \"aria-live\": O.value ? v(f) ? \"polite\" : \"assertive\" : void 0,\n          \"aria-atomic\": O.value ? !0 : void 0\n        }, [P.$slots.title || P.title ? (m(), x(se(P.headerTag), {\n          key: 0,\n          class: \"toast-header\"\n        }, {\n          default: R(() => [A(P.$slots, \"title\", {\n            hide: K\n          }, () => [ee(\"strong\", Cc, Z(P.title), 1)]), v(g) ? J(\"\", !0) : (m(), x(Dt, {\n            key: 0,\n            onClick: K\n          }))]),\n          _: 3\n        })) : J(\"\", !0), P.$slots.default || P.body ? (m(), x(se(T.value), Q({\n          key: 1,\n          class: [\"toast-body\", P.bodyClass],\n          style: {\n            display: \"block\"\n          }\n        }, v(d), {\n          onClick: D[0] || (D[0] = ae => v(u) ? K : () => {})\n        }), {\n          default: R(() => [A(P.$slots, \"default\", {\n            hide: K\n          }, () => [ne(Z(P.body), 1)])]),\n          _: 3\n        }, 16, [\"class\"])) : J(\"\", !0), typeof v(s) == \"number\" && P.progressProps !== void 0 ? (m(), x(Vn, {\n          key: 2,\n          animated: P.progressProps.animated,\n          precision: P.progressProps.precision,\n          \"show-progress\": P.progressProps.showProgress,\n          \"show-value\": P.progressProps.showValue,\n          striped: P.progressProps.striped,\n          variant: P.progressProps.variant,\n          max: v(s),\n          value: v(I),\n          height: \"4px\"\n        }, null, 8, [\"animated\", \"precision\", \"show-progress\", \"show-value\", \"striped\", \"variant\", \"max\", \"value\"])) : J(\"\", !0)], 10, Sc)) : J(\"\", !0)]),\n        _: 3\n      }, 8, [\"no-fade\"]));\n    }\n  }),\n  wc = {\n    id: \"__BVID__toaster-container\"\n  },\n  kc = /* @__PURE__ */q({\n    __name: \"BToaster\",\n    props: {\n      teleportDisabled: {\n        type: [String, Boolean],\n        default: !1\n      },\n      teleportTo: {\n        default: \"body\"\n      }\n    },\n    setup(e, {\n      expose: t\n    }) {\n      const o = e,\n        a = r(() => o.teleportDisabled),\n        l = {\n          \"top-left\": \"top-0 start-0\",\n          \"top-center\": \"top-0 start-50 translate-middle-x\",\n          \"top-right\": \"top-0 end-0\",\n          \"middle-left\": \"top-50 start-0 translate-middle-y\",\n          \"middle-center\": \"top-50 start-50 translate-middle\",\n          \"middle-right\": \"top-50 end-0 translate-middle-y\",\n          \"bottom-left\": \"bottom-0 start-0\",\n          \"bottom-center\": \"bottom-0 start-50 translate-middle-x\",\n          \"bottom-right\": \"bottom-0 end-0\"\n        },\n        {\n          hide: n,\n          toasts: i,\n          show: s\n        } = Ul(),\n        u = d => nn(d, [\"value\", \"self\", \"pos\"]);\n      return t({\n        hide: n,\n        show: s\n      }), (d, f) => (m(), x(zt, {\n        to: d.teleportTo,\n        disabled: v(a)\n      }, [ee(\"div\", wc, [(m(), N(ge, null, Te(l, (g, p) => ee(\"div\", {\n        key: p,\n        class: j([g, \"toast-container position-fixed p-3\"])\n      }, [(m(!0), N(ge, null, Te(v(i).filter(y => y.pos === p), y => (m(), x(Pn, Q({\n        key: y.self,\n        modelValue: y.value,\n        \"onUpdate:modelValue\": b => y.value = b\n      }, u(y), {\n        onDestroyed: b => v(n)(y.self)\n      }), null, 16, [\"modelValue\", \"onUpdate:modelValue\", \"onDestroyed\"]))), 128))], 2)), 64))])], 8, [\"to\", \"disabled\"]));\n    }\n  }),\n  $c = /* @__PURE__ */q({\n    __name: \"BTooltip\",\n    props: {\n      boundary: {},\n      boundaryPadding: {},\n      click: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      container: {\n        default: void 0\n      },\n      content: {\n        default: void 0\n      },\n      customClass: {\n        default: void 0\n      },\n      delay: {\n        default: void 0\n      },\n      floatingMiddleware: {\n        default: void 0\n      },\n      hide: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      html: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      id: {\n        default: void 0\n      },\n      inline: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      manual: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      modelValue: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noAutoClose: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noFade: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noFlip: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noHide: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noShift: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      noSize: {\n        type: [String, Boolean]\n      },\n      noninteractive: {\n        type: [String, Boolean],\n        default: !0\n      },\n      offset: {\n        default: void 0\n      },\n      placement: {\n        default: void 0\n      },\n      persistent: {\n        type: [String, Boolean]\n      },\n      realtime: {\n        type: [String, Boolean],\n        default: void 0\n      },\n      reference: {\n        default: void 0\n      },\n      strategy: {\n        default: void 0\n      },\n      target: {\n        default: void 0\n      },\n      title: {\n        default: void 0\n      },\n      variant: {\n        default: void 0\n      }\n    },\n    setup(e, {\n      expose: t\n    }) {\n      var a, l, n;\n      const o = W(null);\n      return t({\n        hide: (a = o.value) == null ? void 0 : a.hide,\n        show: (l = o.value) == null ? void 0 : l.show,\n        toggle: (n = o.value) == null ? void 0 : n.toggle\n      }), (i, s) => (m(), x(ro, Q({\n        ref_key: \"popover\",\n        ref: o,\n        tooltip: \"\"\n      }, i.$props), Ua({\n        _: 2\n      }, [Te(i.$slots, (u, d) => ({\n        name: d,\n        fn: R(f => [A(i.$slots, d, Se(Ee(f)))])\n      }))]), 1040));\n    }\n  }),\n  Qo = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BAccordion: ar,\n    BAccordionItem: lr,\n    BAlert: rr,\n    BAvatar: fr,\n    BAvatarGroup: vr,\n    BBadge: pr,\n    BBreadcrumb: br,\n    BBreadcrumbItem: rn,\n    BButton: pt,\n    BButtonGroup: yr,\n    BButtonToolbar: Br,\n    BCard: mn,\n    BCardBody: vn,\n    BCardFooter: pn,\n    BCardGroup: wr,\n    BCardHeader: dn,\n    BCardImg: ya,\n    BCardSubtitle: fn,\n    BCardText: kr,\n    BCardTitle: cn,\n    BCarousel: Pr,\n    BCarouselSlide: Hr,\n    BCloseButton: Dt,\n    BCol: Gt,\n    BCollapse: sn,\n    BContainer: xr,\n    BDropdown: gn,\n    BDropdownDivider: qr,\n    BDropdownForm: Ur,\n    BDropdownGroup: Yr,\n    BDropdownHeader: Jr,\n    BDropdownItem: Qr,\n    BDropdownItemButton: au,\n    BDropdownText: nu,\n    BForm: bn,\n    BFormCheckbox: hn,\n    BFormCheckboxGroup: mu,\n    BFormFile: yu,\n    BFormFloatingLabel: uu,\n    BFormGroup: Tu,\n    BFormInput: Vu,\n    BFormInvalidFeedback: xa,\n    BFormRadio: Sn,\n    BFormRadioGroup: Iu,\n    BFormRow: ra,\n    BFormSelect: zu,\n    BFormSelectOption: po,\n    BFormSelectOptionGroup: Cn,\n    BFormSpinbutton: Wu,\n    BFormTag: wn,\n    BFormTags: id,\n    BFormText: Ma,\n    BFormTextarea: ud,\n    BFormValidFeedback: Da,\n    BImg: vo,\n    BInputGroup: gd,\n    BInputGroupAddon: mo,\n    BInputGroupAppend: bd,\n    BInputGroupPrepend: yd,\n    BInputGroupText: kn,\n    BLink: rt,\n    BListGroup: hd,\n    BListGroupItem: Bd,\n    BModal: kd,\n    BNav: $d,\n    BNavForm: _d,\n    BNavItem: Ad,\n    BNavItemDropdown: Ed,\n    BNavText: Nd,\n    BNavbar: Id,\n    BNavbarBrand: Ld,\n    BNavbarNav: Fd,\n    BNavbarToggle: qd,\n    BOffcanvas: Ud,\n    BOverlay: Ta,\n    BPagination: Yd,\n    BPlaceholder: Ue,\n    BPlaceholderButton: Tn,\n    BPlaceholderCard: Zd,\n    BPlaceholderTable: Jd,\n    BPlaceholderWrapper: Qd,\n    BPopover: ro,\n    BProgress: Vn,\n    BProgressBar: _n,\n    BRow: oc,\n    BSpinner: ka,\n    BTab: bc,\n    BTable: gc,\n    BTableLite: En,\n    BTableSimple: go,\n    BTabs: Bc,\n    BTbody: An,\n    BTd: Et,\n    BTfoot: qa,\n    BTh: Ga,\n    BThead: On,\n    BToast: Pn,\n    BToaster: kc,\n    BTooltip: $c,\n    BTr: lt,\n    BTransition: Mt\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Vc = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    useBreadcrumb: Hl,\n    useColorMode: Ri,\n    useModal: Di,\n    useModalController: ji,\n    useToast: Ul\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Ac = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BvCarouselEvent: ll,\n    BvEvent: dt,\n    BvTriggerableEvent: Rt\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Oc = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n    __proto__: null\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Ec = {\n    install(e, t = {\n      components: !0,\n      directives: !0\n    }) {\n      const o = typeof t.components == \"boolean\" || typeof t.components > \"u\" ? {\n          all: !0\n        } : t.components,\n        a = Object.keys(Qo);\n      Io(o, a).forEach(i => {\n        const s = Qo[i];\n        e.component(i, s);\n      });\n      const l = typeof (t == null ? void 0 : t.directives) == \"boolean\" || typeof t.directives > \"u\" ? {\n          all: !0\n        } : t == null ? void 0 : t.directives,\n        n = Object.keys(Ko);\n      Io(l, n).forEach(i => {\n        const s = i.toLowerCase().startsWith(\"v\") ? i.slice(1) : i,\n          u = Ko[i];\n        e.directive(s, u);\n      });\n    }\n  };\nexport { ar as BAccordion, lr as BAccordionItem, rr as BAlert, fr as BAvatar, vr as BAvatarGroup, pr as BBadge, br as BBreadcrumb, rn as BBreadcrumbItem, pt as BButton, yr as BButtonGroup, Br as BButtonToolbar, mn as BCard, vn as BCardBody, pn as BCardFooter, wr as BCardGroup, dn as BCardHeader, ya as BCardImg, fn as BCardSubtitle, kr as BCardText, cn as BCardTitle, Pr as BCarousel, Hr as BCarouselSlide, Dt as BCloseButton, Gt as BCol, sn as BCollapse, xr as BContainer, gn as BDropdown, qr as BDropdownDivider, Ur as BDropdownForm, Yr as BDropdownGroup, Jr as BDropdownHeader, Qr as BDropdownItem, au as BDropdownItemButton, nu as BDropdownText, bn as BForm, hn as BFormCheckbox, mu as BFormCheckboxGroup, yu as BFormFile, uu as BFormFloatingLabel, Tu as BFormGroup, Vu as BFormInput, xa as BFormInvalidFeedback, Sn as BFormRadio, Iu as BFormRadioGroup, ra as BFormRow, zu as BFormSelect, po as BFormSelectOption, Cn as BFormSelectOptionGroup, Wu as BFormSpinbutton, wn as BFormTag, id as BFormTags, Ma as BFormText, ud as BFormTextarea, Da as BFormValidFeedback, vo as BImg, gd as BInputGroup, mo as BInputGroupAddon, bd as BInputGroupAppend, yd as BInputGroupPrepend, kn as BInputGroupText, rt as BLink, hd as BListGroup, Bd as BListGroupItem, kd as BModal, $d as BNav, _d as BNavForm, Ad as BNavItem, Ed as BNavItemDropdown, Nd as BNavText, Id as BNavbar, Ld as BNavbarBrand, Fd as BNavbarNav, qd as BNavbarToggle, Ud as BOffcanvas, Ta as BOverlay, Yd as BPagination, Ue as BPlaceholder, Tn as BPlaceholderButton, Zd as BPlaceholderCard, Jd as BPlaceholderTable, Qd as BPlaceholderWrapper, ro as BPopover, Vn as BProgress, _n as BProgressBar, oc as BRow, ka as BSpinner, bc as BTab, gc as BTable, En as BTableLite, go as BTableSimple, Bc as BTabs, An as BTbody, Et as BTd, qa as BTfoot, Ga as BTh, On as BThead, Pn as BToast, kc as BToaster, $c as BTooltip, lt as BTr, Mt as BTransition, Ec as BootstrapVueNext, ll as BvCarouselEvent, dt as BvEvent, Rt as BvTriggerableEvent, Qo as Components, Vc as Composables, Ko as Directives, Oc as Types, Ac as Utils, Ec as default, Hl as useBreadcrumb, Ri as useColorMode, Di as useModal, ji as useModalController, Ul as useToast, Hd as vBColorMode, ja as vBModal, xd as vBPopover, ja as vBToggle, Md as vBTooltip };","map":{"version":3,"names":["dt","constructor","t","o","De","TypeError","name","arguments","length","Object","assign","Defaults","eventType","_preventDefault","cancelable","defaultPrevented","_defaultPrevented","preventDefault","componentId","nativeEvent","relatedTarget","target","Rt","a","trigger","ll","from","l","direction","n","to","i","nl","sl","Xn","Kn","sa","Yn","Zn","Jn","Qn","es","ca","toString","e","Array","isArray","prototype","call","JSON","stringify","String","_a","replace","toUpperCase","bo","ts","trim","charAt","slice","as","os","Va","ls","charCodeAt","split","reduce","s","il","window","rl","document","ns","Element","ss","navigator","is","_t","Xa","passive","addEventListener","removeEventListener","ul","rs","us","Ka","yo","ds","Aa","ot","nodeType","Node","ELEMENT_NODE","cs","getBoundingClientRect","fs","getActiveElement","activeElement","some","vs","ps","attemptFocus","focus","console","error","ms","getStyle","getAttribute","gs","height","width","Ie","dl","select","querySelector","bs","selectAll","querySelectorAll","Ya","getAttr","ys","getElementById","test","hs","setAttr","setAttribute","Bs","removeAttr","removeAttribute","Ss","isTag","toLowerCase","Cs","matches","ws","closest","parentElement","parentNode","ho","La","getComputedStyle","transitionDelay","transitionDuration","Number","ks","$s","join","ea","disabled","indexOf","tagName","cl","Bo","So","concat","et","Math","min","Fe","max","fa","round","ta","floor","mt","x","y","Ts","left","right","bottom","top","_s","start","end","Fa","ft","Ye","Je","fl","Za","xt","includes","Ja","vl","reference","floating","pa","Vs","va","As","Os","map","Es","Qa","It","Co","u","d","f","g","p","Ps","computePosition","placement","strategy","middleware","platform","filter","Boolean","isRTL","getElementRects","b","V","C","fn","c","h","B","data","_","reset","k","initialPlacement","middlewareData","rects","elements","Lt","boundary","rootBoundary","elementContext","altBoundary","padding","getClippingRect","element","isElement","contextElement","getDocumentElement","getOffsetParent","getScale","convertOffsetParentRelativeRectToViewportRelativeRect","rect","offsetParent","Ns","options","getDimensions","S","$","I","T","O","F","K","z","P","D","ae","arrow","le","centerOffset","alignmentOffset","Is","Ls","autoPlacement","crossAxis","alignment","allowedPlacements","autoAlignment","index","overflows","sort","every","pl","flip","mainAxis","fallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","push","ve","wo","ko","Fs","hide","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","ml","Hs","zs","inline","getClientRects","find","Rs","alignmentAxis","gl","offset","bl","shift","limiter","yl","size","apply","availableWidth","availableHeight","gt","hl","nodeName","We","ownerDocument","defaultView","vt","documentElement","ct","nt","HTMLElement","$o","ShadowRoot","Yt","overflow","overflowX","overflowY","display","Ze","xs","eo","transform","perspective","containerType","backdropFilter","willChange","contain","Ms","Ft","Ba","CSS","supports","Sa","scrollLeft","scrollTop","pageXOffset","pageYOffset","assignedSlot","host","Bl","body","Wt","visualViewport","frameElement","Sl","parseFloat","offsetWidth","offsetHeight","ao","Pt","isFinite","Ds","Cl","offsetLeft","offsetTop","js","St","clientLeft","paddingLeft","clientTop","paddingTop","qs","Gs","wl","Ws","scrollWidth","clientWidth","scrollHeight","clientHeight","Us","Xs","To","kl","position","Ks","get","set","Ys","_c","Zs","Js","_o","$l","Qs","ei","ti","ai","clearTimeout","disconnect","rootMargin","threshold","intersectionRatio","setTimeout","IntersectionObserver","root","observe","Tl","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","animationFrame","forEach","unobserve","cancelAnimationFrame","requestAnimationFrame","oi","Map","Ha","$el","li","v","_l","devicePixelRatio","Vo","Vl","whileElementsMounted","w","open","value","W","ua","then","ue","flush","el","tl","Tt","isPositioned","floatingStyles","update","ni","Set","si","ii","ri","ui","allowedAttribute","has","nodeValue","RegExp","At","area","br","col","code","div","em","hr","h1","h2","h3","h4","h5","h6","img","ol","pre","small","span","sub","sup","strong","Ot","sanitizeHtml","DOMParser","parseFromString","keys","remove","attributes","innerHTML","bt","Al","al","run","di","dispose","stop","Ke","ma","WorkerGlobalScope","globalThis","ci","fi","vi","yt","noop","za","pi","userAgent","Ol","Promise","resolve","thisArg","args","catch","El","mi","maxWait","rejectOnCancel","gi","eventFilter","isActive","Xe","pause","resume","Pl","E","Rn","bi","yi","hi","Nl","Ht","st","Ne","Il","immediate","immediateCallback","clearInterval","setInterval","he","method","radix","nanToZero","isNaN","ut","tt","Oe","cleanup","register","flatMap","Ao","Ll","ignore","capture","detectIframe","children","composedPath","detail","contains","Bi","key","qe","eventName","dedupe","repeat","Si","Ci","wi","matchMedia","removeListener","Xt","addListener","ki","parse","aa","global","self","oa","$i","Ti","oo","_i","Date","Vi","boolean","read","write","object","number","any","string","entries","date","toISOString","Oo","Ai","deep","listenToStorageChanges","writeDefaults","mergeDefaults","shallow","onError","initOnMounted","localStorage","serializer","removeItem","getItem","setItem","dispatchEvent","CustomEvent","oldValue","newValue","storageArea","Oi","Ei","selector","attribute","initialValue","storage","storageKey","storageRef","emitAuto","disableTransition","auto","light","dark","modes","createElement","appendChild","createTextNode","head","values","classList","add","opacity","removeChild","onChanged","store","system","state","lo","delayEnter","delayLeave","xe","focusVisible","blur","focused","Oa","Window","Document","Pi","page","pageX","pageY","client","clientX","clientY","screen","screenX","screenY","movement","Touch","movementX","movementY","Ni","type","touch","resetOnTouchEnds","scroll","touches","scrollHandler","MouseEvent","scrollX","scrollY","sourceType","Eo","handleOutside","elementX","elementY","elementPositionX","elementPositionY","elementHeight","elementWidth","isOutside","Fl","Ii","event","la","WeakMap","Li","style","lock","unlock","delete","Fi","onSwipe","onSwipeEnd","onSwipeStart","da","abs","updateCoordsStart","updateCoordsEnd","Hi","isPassiveEventSupported","isSwiping","coordsStart","coordsEnd","lengthX","lengthY","ke","clone","defaultValue","shouldEmit","emit","$emit","bind","proxy","getValue","Zt","it","zi","r","Ca","useAriaInvalid","Ct","useBLinkHelper","Ji","fo","computedLink","computedLinkProps","Hl","items","splice","Ri","useColorMode","persist","Qe","variant","textVariant","bgVariant","xi","container","zl","useCountdown","ceil","restart","myPause","myResume","isPaused","wt","Rl","plain","button","switch","xl","Ml","btn","buttonVariant","Dl","ariaInvalid","required","jl","validated","buttons","stacked","_e","useId","qt","ql","useFormInput","id","autofocus","lazy","lazyFormatter","debounce","debounceMaxWait","NaN","updateModelValue","_formatValue","formatter","xn","input","computedId","computedAriaInvalid","onInput","onChange","onBlur","Vt","_getNested","Ea","_normalizeOption","valueField","textField","htmlField","disabledField","optionsField","label","labelField","no","text","html","normalizeOptions","warn","Pa","so","uid","toggle","registry","stack","lastStack","countStack","pushStack","removeStack","pushRegistry","removeRegistry","Mi","__name","Error","activePosition","findIndex","exposed","activeModalCount","Di","useModal","Gl","show","modal","parent","ji","useModalController","hideAll","io","resolveRadiusElement","rounded","roundedTop","roundedBottom","roundedStart","roundedEnd","Wl","useSafeScrollLock","qi","Ul","toasts","pos","Symbol","Gi","Wi","Ui","ro","q","modelValue","me","de","Event","click","manual","noShift","noSize","noFlip","noFade","noAutoClose","noHide","realtime","persistent","tooltip","noninteractive","title","content","startsWith","Be","Ve","floatingMiddleware","Y","re","boundaryPadding","Ae","He","maxHeight","maxWidth","oe","fe","$e","we","M","L","U","fade","customClass","Ki","H","G","X","te","buildTriggerableEvent","be","delay","Re","kt","ie","ce","nextElementSibling","Ce","unbind","Wa","m","N","ge","Xi","resolveFloatingPlacement","alignCenter","alignEnd","Ut","active","ga","resolveContent","Nt","resolveDirectiveProps","modifiers","ba","child","insertBefore","nextSibling","$__app","Mn","render","Le","$__state","mount","$__element","Xl","unmount","wa","getBreakpointProps","create","Kl","getClasses","ia","getId","random","Yi","getSlotElements","Po","Zi","href","Yl","Zl","Jl","Ql","en","tn","an","on","uo","ln","co","jt","normalizeSlot","Qi","stringToInteger","parseInt","er","toFloat","nn","omit","pick","No","Io","parseActiveImports","all","Lo","suffixPropName","tr","ar","free","at","openItem","setOpenItem","horizontal","isNav","visible","skipAnimation","collapsing","closing","close","toggleFn","reveal","class","Kt","Ge","Q","wrapperAttrs","appear","enterActiveClass","enterToClass","leaveActiveClass","leaveToClass","enterFromClass","leaveFromClass","mode","css","transProps","appearActiveClass","appearToClass","Me","Fo","rt","icon","append","routerComponentName","appContext","app","component","path","query","hash","opacityHover","underlineVariant","underlineOffset","underlineOffsetHover","underlineOpacity","underlineOpacityHover","rel","tabindex","stopImmediatePropagation","autoClose","pill","pressed","squared","loading","loadingFill","tag","stopPropagation","dismissible","showOnPause","noHoverPause","interval","closeClass","closeVariant","onMouseEnter","Mt","Ra","fr","badgeStart","badgeTop","square","default","badge","badgeVariant","badgeBgVariant","badgeTextVariant","badgeOffset","fontSize","overlapScale","marginLeft","marginRight","overlap","paddingRight","se","textIndicator","dotIndicator","ariaCurrent","vertical","justify","blank","block","center","fluid","fluidGrow","thumbnail","srcset","sizes","blankColor","makeBlankImgSrc","encodeURIComponent","borderVariant","overlay","subtitle","imgBottom","imgEnd","imgStart","noBody","header","footer","align","src","imgSrc","alt","imgAlt","imgHeight","imgWidth","imgTop","columns","deck","keyboard","rideReverse","controls","indicators","noTouch","noWrap","touchThreshold","ride","prev","next","onMouseLeave","resumeRiding","onBeforeLeave","onAfterLeave","background","textHtml","caption","captionHtml","contentVisibleUp","Ho","zo","Ro","zr","slots","props","cols","order","alignSelf","setup","propPrefix","classPrefix","computedClasses","Rr","j","R","gutterX","gutterY","dropup","dropend","dropstart","noCaret","splitDisabled","keynav","splitClass","toggleClass","onButtonClick","onClickInside","headerTag","headerClass","headerVariant","linkClass","buttonClass","activeClass","novalidate","forceShow","yn","skip","attrs","zt","du","cu","hn","indeterminate","buttonGroup","switches","form","directory","multiple","noDrop","noTraverse","accept","files","Bn","hu","Bu","Su","Cu","wu","ku","$u","Tu","components","BCol","Gt","BFormInvalidFeedback","xa","BFormRow","ra","BFormText","Ma","BFormValidFeedback","Da","contentCols","contentColsLg","contentColsMd","contentColsSm","contentColsXl","description","feedbackAriaLive","invalidFeedback","labelAlign","labelAlignLg","labelAlignMd","labelAlignSm","labelAlignXl","labelClass","labelCols","labelColsLg","labelColsMd","labelColsSm","labelColsXl","labelFor","labelSize","labelSrOnly","validFeedback","getAlignClasses","getColProps","updateAriaDescribedby","disabledBoolean","labelSrOnlyBoolean","stateBoolean","tooltipBoolean","validatedBoolean","floatingBoolean","ariaDescribedby","contentColProps","isHorizontal","labelAlignClasses","labelColProps","onLegendClick","stateClass","$props","$slots","for","onClick","tabIndex","ariaLive","descriptionId","labelId","ref","role","_u","Vu","readonly","plaintext","selectSize","ht","xo","Ru","xu","Mu","eventOn","Du","eventOff","Mo","eventOnOff","na","stopEvent","propagation","immediatePropagation","Na","Do","jo","qo","Go","Ia","ju","qu","Gu","je","step","repeatDelay","repeatInterval","repeatThreshold","repeatMultiplier","Wu","wrap","repeatStepMultiplier","pow","toFixed","locale","Intl","NumberFormat","resolvedOptions","defaultFormatter","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","notation","format","formatterFn","stepUp","stepDown","altKey","ctrlKey","metaKey","handleStepRepeat","resetTimers","svg","xmlns","fill","viewBox","scale","handler","labelIncrement","slot","labelDecrement","noRemove","addOnChange","noAddOnEnter","noOuterFocus","noTagRemove","removeOnDelete","tagPills","limit","inputId","tagValidator","addButtonText","addButtonVariant","addTag","disableAddButton","duplicateTagText","duplicateTags","inputAttrs","inputHandlers","keydown","change","inputType","invalidTagText","invalidTags","isDuplicate","isInvalid","isLimitReached","limitTagsText","placeholder","removeTag","separator","tagClass","tagRemoveLabel","tagVariant","tags","noResize","resize","appendHtml","prepend","prependHtml","isText","numbered","action","fixed","noSpinner","noCenter","spinnerSmall","bgColor","spinnerType","spinnerVariant","zIndex","backgroundColor","Wo","wd","busy","cancelDisabled","centered","hideBackdrop","hideFooter","hideHeader","hideHeaderClose","noCloseOnBackdrop","noCloseOnEsc","autoFocus","okDisabled","okOnly","scrollable","titleSrOnly","teleportDisabled","bodyScrolling","fullscreen","autoFocusButton","modalClass","backdropVariant","dialogClass","bodyBgVariant","bodyTextVariant","bodyVariant","bodyClass","headerBgVariant","headerTextVariant","headerBorderVariant","headerCloseVariant","headerCloseClass","footerBgVariant","footerTextVariant","footerVariant","footerClass","footerBorderVariant","titleClass","pe","Pe","showFn","pickFocusItem","onBeforeEnter","onAfterEnter","onLeave","Nn","In","Ln","Fn","$t","cancel","ok","cardHeader","justified","pills","tabs","underline","Vd","Od","print","toggleable","sticky","Uo","setTheme","Hd","mounted","updated","zd","getTargets","arg","Rd","$n","checkVisibility","Xo","handleUpdate","__toggle","ja","unmounted","xd","beforeUnmount","Md","Ko","freeze","defineProperty","backdrop","noHeaderClose","noHeader","noFocus","OnBeforeEnter","OnAfterEnter","OnAfterLeave","Yo","Zo","Yd","firstNumber","hideEllipsis","hideGotoEndButtons","lastNumber","perPage","totalRows","getEndButtonProps","labelFirstPage","ariaControls","firstClass","prevClass","nextClass","lastClass","ellipsisClass","pageSize","numberOfPages","pageClick","animation","noButton","noFooter","noImg","Ue","Tn","captionTop","borderless","bordered","hover","striped","stickyHeader","stripedColumns","responsive","tableClass","rows","headerColumns","footerColumns","showFooter","animated","showProgress","showValue","precision","labelHtml","Jo","tc","noGutters","alignV","alignH","alignContent","ac","stickyColumn","colspan","rowspan","footClone","labelStacked","showEmpty","fields","tdAttr","formatItem","headerClicked","_showDetails","thClass","fieldColumnClass","getFieldRowClasses","tdClass","_cellVariants","getRowClasses","tbodyTrClass","clear","noProviderPaging","noProviderSorting","noProviderFiltering","selectable","noSortableIcon","currentPage","provider","sortable","thAttr","selectionVariant","sortCompare","filterable","handleRowSelection","selectMode","pop","onRowClick","shiftKey","onFieldHeadClick","callItemsProvider","sortBy","sortDesc","notifySelectionEvent","notifyFilteredItems","providerPropsWatch","noProvider","clearSelected","refresh","selectAllRows","selectRow","unselectRow","En","buttonId","lazyOnce","titleComponent","titleItemClass","titleLinkAttributes","titleLinkClass","registerTab","activateTab","Un","unregisterTab","activeId","card","activeTabClass","noNavStyle","navItemClasses","activeNavItemClass","handleClick","nextIndex","lastIndexOf","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_PRECEDING","findActive","isStatus","autoHide","noCloseButton","solid","Ec","install","directives","Qo","directive"],"sources":["../src/utils/classes/BvEvent.ts","../src/utils/classes/BvTriggerableEvent.ts","../src/utils/classes/BvCarouselEvent.ts","../src/constants/regex.ts","../src/utils/stringUtils.ts","../src/utils/cssEscape.ts","../src/constants/env.ts","../src/utils/env.ts","../src/utils/dom.ts","../src/utils/filterEvent.ts","../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../../../node_modules/.pnpm/@floating-ui+core@1.5.0/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../node_modules/.pnpm/@floating-ui+utils@0.1.6/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs","../../../node_modules/.pnpm/@floating-ui+dom@1.5.3/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../node_modules/.pnpm/@floating-ui+vue@1.0.2_vue@3.3.8/node_modules/@floating-ui/vue/dist/floating-ui.vue.esm.js","../src/utils/sanitizer.ts","../../../node_modules/.pnpm/@vueuse+shared@10.6.0_vue@3.3.8/node_modules/@vueuse/shared/index.mjs","../../../node_modules/.pnpm/@vueuse+core@10.6.0_vue@3.3.8/node_modules/@vueuse/core/index.mjs","../src/composables/useAlignment.ts","../src/composables/useBooleanish.ts","../src/composables/useAriaInvalid.ts","../src/composables/useBLinkHelper.ts","../src/composables/useBreadcrumb.ts","../src/composables/useColorMode.ts","../src/composables/useColorVariantClasses.ts","../src/composables/useContainerClasses.ts","../src/composables/useCountdown.ts","../src/composables/useStateClass.ts","../src/composables/useFormCheck.ts","../src/composables/useId.ts","../src/composables/useFormInput.ts","../src/composables/useFormSelect.ts","../src/composables/useModalManager.ts","../src/composables/useModal.ts","../src/composables/useModalController.ts","../src/composables/useRadiusElementClasses.ts","../src/composables/useSafeScrollLock.ts","../src/composables/useToast.ts","../src/components/BPopover.vue","../src/utils/floatingUi.ts","../src/utils/getBreakpointProps.ts","../src/utils/getClasses.ts","../src/utils/getTableFieldHeadLabel.ts","../src/utils/getId.ts","../src/utils/getSlotElements.ts","../src/utils/inspect.ts","../src/utils/isLink.ts","../src/utils/keys.ts","../src/utils/normalizeSlot.ts","../src/utils/number.ts","../src/utils/object.ts","../src/utils/parseActiveImports.ts","../src/utils/props.ts","../src/components/BAccordion/BAccordion.vue","../src/components/BCollapse.vue","../src/components/BAccordion/BAccordionItem.vue","../src/components/BTransition/BTransition.vue","../src/components/BButton/BCloseButton.vue","../src/components/BSpinner.vue","../src/components/BLink/BLink.vue","../src/components/BButton/BButton.vue","../src/components/BAlert/BAlert.vue","../src/components/BAvatar/BAvatar.vue","../src/components/BAvatar/BAvatarGroup.vue","../src/components/BBadge/BBadge.vue","../src/components/BBreadcrumb/BBreadcrumbItem.vue","../src/components/BBreadcrumb/BBreadcrumb.vue","../src/components/BButton/BButtonGroup.vue","../src/components/BButton/BButtonToolbar.vue","../src/components/BImg.vue","../src/components/BCard/BCardImg.vue","../src/components/BCard/BCardHeadFoot.vue","../src/components/BCard/BCardHeader.vue","../src/components/BCard/BCardSubtitle.vue","../src/components/BCard/BCardBody.vue","../src/components/BCard/BCardFooter.vue","../src/components/BCard/BCard.vue","../src/components/BCard/BCardGroup.vue","../src/components/BCarousel/BCarousel.vue","../src/components/BCarousel/BCarouselSlide.vue","../src/components/BCol.vue","../src/components/BContainer.vue","../src/components/BDropdown/BDropdown.vue","../src/components/BDropdown/BDropdownGroup.vue","../src/components/BDropdown/BDropdownItem.vue","../src/components/BDropdown/BDropdownItemButton.vue","../src/components/BForm/BForm.vue","../src/components/BForm/BFormInvalidFeedback.vue","../src/components/BForm/BFormText.vue","../src/components/BForm/BFormValidFeedback.vue","../src/components/RenderComponentOrSkip.vue","../src/components/BFormCheckbox/BFormCheckbox.vue","../src/components/BFormCheckbox/BFormCheckboxGroup.vue","../src/components/BFormFile/BFormFile.vue","../src/components/BFormGroup/BFormGroup.vue","../src/components/BFormInput/BFormInput.vue","../src/components/BFormRadio/BFormRadio.vue","../src/components/BFormRadio/BFormRadioGroup.vue","../src/components/BFormSelect/BFormSelectOption.vue","../src/components/BFormSelect/BFormSelectOptionGroup.vue","../src/components/BFormSelect/BFormSelect.vue","../src/utils/locale.ts","../src/utils/event.ts","../src/constants/codes.ts","../src/components/BFormSpinbutton/BFormSpinbutton.vue","../src/components/BFormTags/BFormTag.vue","../src/components/BFormTags/BFormTags.vue","../src/components/BFormTextarea/BFormTextarea.vue","../src/components/BInputGroup/BInputGroup.vue","../src/components/BInputGroup/BInputGroupAddon.vue","../src/components/BListGroup/BListGroup.vue","../src/components/BListGroup/BListGroupItem.vue","../src/components/BOverlay/BOverlay.vue","../src/components/BModal.vue","../src/components/BNav/BNav.vue","../src/components/BNav/BNavForm.vue","../src/components/BNav/BNavItem.vue","../src/components/BNav/BNavItemDropdown.vue","../src/components/BNavbar/BNavbar.vue","../src/components/BNavbar/BNavbarBrand.vue","../src/components/BNavbar/BNavbarNav.vue","../src/directives/BColorMode.ts","../src/directives/BToggle.ts","../src/directives/BPopover.ts","../src/directives/BTooltip.ts","../src/components/BNavbar/BNavbarToggle.vue","../src/components/BOffcanvas/BOffcanvas.vue","../src/components/BPagination/BPagination.vue","../src/components/BPlaceholder/BPlaceholder.vue","../src/components/BPlaceholder/BPlaceholderButton.vue","../src/components/BPlaceholder/BPlaceholderCard.vue","../src/components/BTable/BTableSimple.vue","../src/components/BPlaceholder/BPlaceholderTable.vue","../src/components/BPlaceholder/BPlaceholderWrapper.vue","../src/components/BProgress/BProgressBar.vue","../src/components/BProgress/BProgress.vue","../src/components/BRow.vue","../src/components/BTable/BTbody.vue","../src/components/BTable/BTd.vue","../src/components/BTable/BTfoot.vue","../src/components/BTable/BTh.vue","../src/components/BTable/BThead.vue","../src/components/BTable/BTr.vue","../src/components/BTable/BTableLite.vue","../src/components/BTable/BTable.vue","../src/components/BTabs/BTab.vue","../src/components/BTabs/BTabs.vue","../src/components/BToast/BToast.vue","../src/components/BToast/BToaster.vue","../src/components/BTooltip.vue","../src/BootstrapVue.ts"],"sourcesContent":["/**\n * Items that are omitted from the BvEventInit constructor arg\n */\nexport type BvEventConstructorOmittables = 'eventType' | 'defaultPrevented'\n\nexport default class BvEvent {\n  readonly cancelable: boolean = true\n  readonly componentId: string | null = null\n  private _defaultPrevented = false\n  readonly eventType: string = ''\n  readonly nativeEvent: string | null = null\n  private _preventDefault: () => void\n  readonly relatedTarget: EventTarget | null = null\n  readonly target: EventTarget | null = null\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  public get defaultPrevented() {\n    return this._defaultPrevented\n  }\n  protected set defaultPrevented(prop) {\n    this._defaultPrevented = prop\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  public get preventDefault() {\n    return this._preventDefault\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  protected set preventDefault(setter: () => void) {\n    this._preventDefault = setter\n  }\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    if (!eventType) {\n      throw new TypeError(\n        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`\n      )\n    }\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n\n    this._preventDefault = function _preventDefault() {\n      if (this.cancelable) {\n        this.defaultPrevented = true\n      }\n    }\n  }\n\n  static get Defaults() {\n    return {\n      cancelable: true,\n      componentId: null,\n      eventType: '',\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvTriggerableEvent extends BvEvent {\n  readonly trigger: string | null = null\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvTriggerableEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    super(eventType, eventInit)\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvCarouselEvent extends BvEvent {\n  readonly from: number\n  readonly to: number\n  readonly direction: 'left' | 'right'\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> & {\n      from: number\n      to: number\n      direction: 'left' | 'right'\n    }\n  ) {\n    super(eventType, eventInit)\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n    const {from, direction, to} = eventInit\n    this.from = from\n    this.to = to\n    this.direction = direction\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n    }\n  }\n}\n","export const RX_UNDERSCORE = /_/g\nexport const RX_LOWER_UPPER = /([a-z])([A-Z])/g\nexport const RX_START_SPACE_WORD = /(\\s|^)(\\w)/g\nexport const RX_FIRST_START_SPACE_WORD = /(\\s|^)(\\w)/\nexport const RX_SPACE_SPLIT = /\\s+/\nexport const RX_HASH = /^#/\nexport const RX_HASH_ID = /^#[A-Za-z]+[\\w\\-:.]*$/\n\nexport const RX_STRIP_LOCALE_MODS = /-u-.+/\nexport const RX_REGEXP_REPLACE = /[-/\\\\^$*+?.()|[\\]{}]/g\nexport const RX_SPACES = /[\\s\\uFEFF\\xA0]+/g\n","import {\n  RX_FIRST_START_SPACE_WORD,\n  RX_LOWER_UPPER,\n  RX_REGEXP_REPLACE,\n  RX_SPACES,\n  RX_START_SPACE_WORD,\n  RX_UNDERSCORE,\n} from '../constants/regex'\n\n/**\n * Convert a value to a string that can be rendered `undefined`/`null` will be converted to `''` Plain objects and arrays will be JSON stringified\n *\n * @param val\n * @param spaces\n * @returns\n * @deprecated\n */\nexport const toString = (val: unknown, spaces = 2): string =>\n  typeof val === 'string'\n    ? val\n    : val === undefined || val === null\n    ? ''\n    : Array.isArray(val) ||\n      (Object.prototype.toString.call(val) === '[object Object]' &&\n        val.toString === Object.prototype.toString)\n    ? JSON.stringify(val, null, spaces)\n    : String(val)\n\n/**\n * @param str\n * @returns\n */\nexport const startCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_FIRST_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * @param str\n * @returns\n */\nexport const titleCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * Uppercases the first letter of a string and returns a new string\n *\n * @param str\n * @returns\n */\nexport const upperFirst = (str: string): string => {\n  const trim = str.trim()\n  return trim.charAt(0).toUpperCase() + trim.slice(1)\n}\n\n/**\n * Escapes a string for RegExp usage.\n *\n * @param str\n * @returns\n */\nexport const escapeRegExp = (str: string): string => str.replace(RX_REGEXP_REPLACE, '\\\\$&')\n\n/**\n * Escapes special chars in string and replaces\n * contiguous spaces with a whitespace match\n *\n * @param str\n * @returns\n */\nexport const escapeRegExpChars = (str: string): string =>\n  escapeRegExp(str).replace(RX_SPACES, '\\\\s')\n","import {toString} from './stringUtils'\n\nconst escapeChar = (value: string) => `\\\\${value}`\n\n/**\n * The `cssEscape()` util is based on this `CSS.escape()` polyfill: https://github.com/mathiasbynens/CSS.escape\n *\n * @param {unknown} value\n * @deprecated\n */\nexport default (value: unknown): string => {\n  const val = toString(value)\n\n  const {length} = val\n  const firstCharCode = val.charCodeAt(0)\n\n  return val.split('').reduce((result: string, char: string, index: number) => {\n    const charCode = val.charCodeAt(index)\n\n    // If the character is NULL (U+0000), use (U+FFFD) as replacement\n    if (charCode === 0x0000) {\n      return `${result}\\uFFFD`\n    }\n\n    // If the character ...\n    if (\n      // ... is U+007F OR\n      charCode === 0x007f ||\n      // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      (charCode >= 0x0001 && charCode <= 0x001f) ||\n      // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      (index === 0 && charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      (index === 1 && charCode >= 0x0030 && charCode <= 0x0039 && firstCharCode === 0x002d)\n    ) {\n      // ... https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      return result + escapeChar(`${charCode.toString(16)} `)\n    }\n\n    // If the character ...\n    if (\n      // ... is the first character AND ...\n      index === 0 &&\n      // ... is a `-` (U+002D) AND ...\n      charCode === 0x002d &&\n      // ... there is no second character ...\n      length === 1\n    ) {\n      // ... use the escaped character\n      return result + escapeChar(char)\n    }\n\n    // If the character ...\n    if (\n      // ... is greater than or equal to U+0080 OR ...\n      charCode >= 0x0080 ||\n      // ... is `-` (U+002D) OR ...\n      charCode === 0x002d ||\n      // ... is `_` (U+005F) OR ...\n      charCode === 0x005f ||\n      // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n      (charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n      (charCode >= 0x0041 && charCode <= 0x005a) ||\n      // ... is in the range [a-z] (U+0061 to U+007A) ...\n      (charCode >= 0x0061 && charCode <= 0x007a)\n    ) {\n      // ... use the character itself\n      return result + char\n    }\n\n    // Otherwise use the escaped character\n    // See: https://drafts.csswg.org/cssom/#escape-a-character\n    return result + escapeChar(char)\n  }, '')\n}\n","/**\n * @deprecated\n */\nexport const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\n/**\n * @deprecated\n */\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\n/**\n * @deprecated\n */\nexport const HAS_ELEMENT_SUPPORT = typeof Element !== 'undefined'\n/**\n * @deprecated\n */\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\n/**\n * @deprecated\n */\nexport const HAS_PROMISE_SUPPORT = typeof Promise !== 'undefined'\n\n/**\n * @deprecated\n */\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\n\n/**\n * @deprecated\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : ({} as Record<string, any>)\n/**\n * @deprecated\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : ({} as Record<string, any>)\n\n// Determine if the browser supports the option passive for events\n/**\n * @deprecated\n */\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (!IS_BROWSER) return passiveEventSupported\n  try {\n    const options = {\n      // This function will be called when the browser\n      // attempts to access the passive property\n      get passive() {\n        passiveEventSupported = true\n        return passiveEventSupported\n      },\n    }\n    if ('addEventListener' in WINDOW && typeof WINDOW.addEventListener === 'function') {\n      WINDOW.addEventListener('test', options, options)\n    }\n    if ('removeEventListener' in WINDOW && typeof WINDOW.removeEventListener === 'function') {\n      WINDOW.removeEventListener('test', options, options)\n    }\n  } catch {\n    passiveEventSupported = false\n  }\n})()\n","/**\n * @deprecated\n */\nexport const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\n/**\n * @deprecated\n */\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\n/**\n * @deprecated\n */\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\n/**\n * @deprecated\n */\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\n/**\n * @deprecated\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : ({} as Record<string, any>)\n\n// Determine if the browser supports the option passive for events\n/**\n * @deprecated\n */\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          // eslint-disable-next-line no-useless-return\n          return\n        },\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.addEventListener('test', options, options)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n","import type {Slot} from 'vue'\nimport {DOCUMENT, HAS_ELEMENT_SUPPORT} from '../constants/env'\nimport type {AnimationFrame} from '../types/safeTypes'\nimport {HAS_WINDOW_SUPPORT} from './env'\nimport {toString} from './stringUtils'\n\n/**\n * @deprecated\n */\nconst ELEMENT_PROTO = HAS_ELEMENT_SUPPORT ? Element.prototype : undefined\n\n/**\n * @deprecated\n */\nexport const isElement = (el: unknown): el is HTMLElement =>\n  !!(el && typeof el === 'object' && 'nodeType' in el && el.nodeType === Node.ELEMENT_NODE)\n\n/**\n * @deprecated\n */\nexport const getBCR = (el: HTMLElement) => (isElement(el) ? el.getBoundingClientRect() : null)\n\n/**\n * @deprecated\n */\nexport const getActiveElement = (excludes = []): Element | null => {\n  const {activeElement} = document\n  return activeElement && !excludes.some((el: HTMLElement) => el === activeElement)\n    ? activeElement\n    : null\n}\n\n/**\n * @deprecated\n */\nexport const isActiveElement = (el: HTMLElement): boolean =>\n  isElement(el) && el === getActiveElement()\n\n/**\n * @deprecated\n */\nexport const attemptFocus = (el: HTMLElement, options = {}): boolean => {\n  try {\n    el.focus(options)\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e)\n  }\n  return isActiveElement(el)\n}\n\n/**\n * Attempt to blur an element, and return `true` if successful\n *\n * @param el\n * @returns\n * @deprecated\n */\nexport const attemptBlur = (el: HTMLElement): boolean => {\n  try {\n    el.blur()\n  } catch (e) {\n    // eslint-disable-next-line no-console\n    console.error(e)\n  }\n  return !isActiveElement(el)\n}\n\n/**\n * @deprecated\n */\nexport const getStyle = (el: HTMLElement, prop: string) =>\n  prop && isElement(el) ? el.getAttribute(prop) || null : null\n\n/**\n * @deprecated\n */\nexport const contains = (parent: Node, child: Node): boolean => parent.contains(child)\n\n/**\n * @deprecated\n */\nexport const isVisible = (el: HTMLElement): boolean => {\n  //if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {\n  // Note this can fail for shadow dom elements since they\n  // are not a direct descendant of document.body\n  //return false\n  //}\n  if (getStyle(el, 'display') === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = getBCR(el)\n  return !!(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\n/**\n * @deprecated\n */\nexport const isEmptySlot = (el: Slot | undefined): boolean => (el?.() ?? []).length === 0\n\n/**\n * Select a single element, returns `null` if not found\n *\n * @param selector\n * @param root\n * @returns\n * @deprecated\n */\nexport const select = (selector: string, root: Element) =>\n  (isElement(root) ? root : DOCUMENT).querySelector(selector) || null\n\n/**\n * @deprecated\n */\nexport const selectAll = (selector: string, root: Element) =>\n  Array.from([(isElement(root) ? root : DOCUMENT).querySelectorAll(selector)])\n\n/**\n * @deprecated\n */\nexport const getAttr = (el: HTMLElement | Element, attr: string): string | null =>\n  attr && isElement(el) ? el.getAttribute(attr) : null\n\n/**\n * Get an element given an ID\n * @deprecated\n */\nexport const getById = (id: string) =>\n  DOCUMENT.getElementById(/^#/.test(id) ? id.slice(1) : id) || null\n\n/**\n * @deprecated\n */\nexport const setAttr = (el: HTMLElement, attr: string, value: string): void => {\n  if (attr && isElement(el)) {\n    el.setAttribute(attr, value)\n  }\n}\n\n/**\n * Remove an attribute from an element\n *\n * @param el\n * @param attr\n * @deprecated\n */\nexport const removeAttr = (el: HTMLElement, attr: string): void => {\n  if (attr && isElement(el)) {\n    el.removeAttribute(attr)\n  }\n}\n\n/**\n * @deprecated\n */\nexport const isTag = (tag: string, name: string): boolean =>\n  toString(tag).toLowerCase() === toString(name).toLowerCase()\n\n/**\n * @deprecated\n */\nexport const requestAF: AnimationFrame = HAS_WINDOW_SUPPORT\n  ? window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    // Fallback, but not a true polyfill\n    // Only needed for Opera Mini\n    ((cb) => setTimeout(cb, 16))\n  : (cb) => setTimeout(cb, 0)\n\n/**\n * @deprecated\n */\nexport const matches = (el: Element, selector: string) =>\n  isElement(el) ? el.matches(selector) : false\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n * @deprecated\n */\n/* eslint-disable @typescript-eslint/no-this-alias */\nexport const closestEl =\n  ELEMENT_PROTO?.closest ||\n  function (this: Element, sel: string) {\n    let el: ParentNode | null | Element = this\n    if (!el) return null\n    do {\n      // Use our \"patched\" matches function\n      if (isElement(el) && el.matches(sel)) return el\n\n      el = el.parentElement || el.parentNode\n    } while (el !== null && el.nodeType === Node.ELEMENT_NODE)\n    return null\n  }\n\n/**\n * Finds closest element matching selector. Returns `null` if not found\n *\n * @param selector\n * @param root\n * @param includeRoot\n * @deprecated\n */\nexport const closest = (selector: string, root: Element, includeRoot = false) => {\n  if (!isElement(root)) {\n    return null\n  }\n  const el = closestEl.call(root, selector)\n  // Native closest behaviour when `includeRoot` is truthy,\n  // else emulate jQuery closest and return `null` if match is\n  // the passed in root element when `includeRoot` is falsey\n  return includeRoot ? el : el === root ? null : el\n}\n\n/**\n * @deprecated\n */\nexport const getTransitionDelay = (element: HTMLElement) => {\n  const style = window.getComputedStyle(element)\n  // if multiple durations are defined, we take the first\n  const transitionDelay = style.transitionDelay.split(',')[0] || ''\n  const transitionDuration = style.transitionDuration.split(',')[0] || ''\n  const transitionDelayMs = Number(transitionDelay.slice(0, -1)) * 1000\n  const transitionDurationMs = Number(transitionDuration.slice(0, -1)) * 1000\n  return transitionDelayMs + transitionDurationMs\n}\n","import {closest, getAttr, getById, matches, select} from './dom'\n\nconst TABLE_TAG_NAMES = ['TD', 'TH', 'TR']\n\n// Filter CSS selector for click/dblclick/etc. events\n// If any of these selectors match the clicked element, we ignore the event\nconst eventFilter = [\n  'a',\n  'a *', // Include content inside links\n  'button',\n  'button *', // Include content inside buttons\n  'input:not(.disabled):not([disabled])',\n  'select:not(.disabled):not([disabled])',\n  'textarea:not(.disabled):not([disabled])',\n  '[role=\"link\"]',\n  '[role=\"link\"] *',\n  '[role=\"button\"]',\n  '[role=\"button\"] *',\n  '[tabindex]:not(.disabled):not([disabled])',\n].join(',')\n\n// Returns `true` if we should ignore the click/double-click/keypress event\n// Avoids having the user need to use `@click.stop` on the form control\nexport default (event: Event) => {\n  // Exit early when we don't have a target element\n  if (!event || !event.target) {\n    return false\n  }\n  const el = event.target as HTMLElement\n  // Exit early when element is disabled or a table element\n  if (('disabled' in el && el.disabled) || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {\n    return false\n  }\n  // Ignore the click when it was inside a dropdown menu\n  if (closest('.dropdown-menu', el)) {\n    return true\n  }\n  const label = el.tagName === 'LABEL' ? el : closest('label', el)\n  // If the label's form control is not disabled then we don't propagate event\n  // Modern browsers have `label.control` that references the associated input, but IE 11\n  // does not have this property on the label element, so we resort to DOM lookups\n  if (label) {\n    const labelFor = getAttr(label, 'for')\n    const input = labelFor ? getById(labelFor) : select('input, select, textarea', label)\n    if (input && !input.disabled) {\n      return true\n    }\n  }\n  // Otherwise check if the event target matches one of the selectors in the\n  // event filter (i.e. anchors, non disabled inputs, etc.)\n  // Return `true` if we should ignore the event\n  return matches(el, eventFilter)\n}\n","const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n","import { arrow as arrow$1, computePosition } from '@floating-ui/dom';\nexport { autoPlacement, autoUpdate, computePosition, detectOverflow, flip, getOverflowAncestors, hide, inline, limitShift, offset, platform, shift, size } from '@floating-ui/dom';\nimport { unref, computed, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly } from 'vue-demi';\n\nfunction unwrapElement(element) {\n  var _$el;\n  return (_$el = element == null ? void 0 : element.$el) != null ? _$el : element;\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered to the reference element.\n * @param options The arrow options.\n * @see https://floating-ui.com/docs/arrow\n */\nfunction arrow(options) {\n  return {\n    name: 'arrow',\n    options,\n    fn(args) {\n      const element = unwrapElement(unref(options.element));\n      if (element == null) {\n        return {};\n      }\n      return arrow$1({\n        element,\n        padding: options.padding\n      }).fn(args);\n    }\n  };\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element next to a reference element when it is given a certain CSS positioning strategy.\n * @param reference The reference template ref.\n * @param floating The floating template ref.\n * @param options The floating options.\n * @see https://floating-ui.com/docs/vue\n */\nfunction useFloating(reference, floating, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const whileElementsMountedOption = options.whileElementsMounted;\n  const openOption = computed(() => {\n    var _unref;\n    return (_unref = unref(options.open)) != null ? _unref : true;\n  });\n  const middlewareOption = computed(() => unref(options.middleware));\n  const placementOption = computed(() => {\n    var _unref2;\n    return (_unref2 = unref(options.placement)) != null ? _unref2 : 'bottom';\n  });\n  const strategyOption = computed(() => {\n    var _unref3;\n    return (_unref3 = unref(options.strategy)) != null ? _unref3 : 'absolute';\n  });\n  const transformOption = computed(() => {\n    var _unref4;\n    return (_unref4 = unref(options.transform)) != null ? _unref4 : true;\n  });\n  const referenceElement = computed(() => unwrapElement(reference.value));\n  const floatingElement = computed(() => unwrapElement(floating.value));\n  const x = ref(0);\n  const y = ref(0);\n  const strategy = ref(strategyOption.value);\n  const placement = ref(placementOption.value);\n  const middlewareData = shallowRef({});\n  const isPositioned = ref(false);\n  const floatingStyles = computed(() => {\n    const initialStyles = {\n      position: strategy.value,\n      left: '0',\n      top: '0'\n    };\n    if (!floatingElement.value) {\n      return initialStyles;\n    }\n    const xVal = roundByDPR(floatingElement.value, x.value);\n    const yVal = roundByDPR(floatingElement.value, y.value);\n    if (transformOption.value) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + xVal + \"px, \" + yVal + \"px)\",\n        ...(getDPR(floatingElement.value) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy.value,\n      left: xVal + \"px\",\n      top: yVal + \"px\"\n    };\n  });\n  let whileElementsMountedCleanup;\n  function update() {\n    if (referenceElement.value == null || floatingElement.value == null) {\n      return;\n    }\n    computePosition(referenceElement.value, floatingElement.value, {\n      middleware: middlewareOption.value,\n      placement: placementOption.value,\n      strategy: strategyOption.value\n    }).then(position => {\n      x.value = position.x;\n      y.value = position.y;\n      strategy.value = position.strategy;\n      placement.value = position.placement;\n      middlewareData.value = position.middlewareData;\n      isPositioned.value = true;\n    });\n  }\n  function cleanup() {\n    if (typeof whileElementsMountedCleanup === 'function') {\n      whileElementsMountedCleanup();\n      whileElementsMountedCleanup = undefined;\n    }\n  }\n  function attach() {\n    cleanup();\n    if (whileElementsMountedOption === undefined) {\n      update();\n      return;\n    }\n    if (referenceElement.value != null && floatingElement.value != null) {\n      whileElementsMountedCleanup = whileElementsMountedOption(referenceElement.value, floatingElement.value, update);\n      return;\n    }\n  }\n  function reset() {\n    if (!openOption.value) {\n      isPositioned.value = false;\n    }\n  }\n  watch([middlewareOption, placementOption, strategyOption], update, {\n    flush: 'sync'\n  });\n  watch([referenceElement, floatingElement], attach, {\n    flush: 'sync'\n  });\n  watch(openOption, reset, {\n    flush: 'sync'\n  });\n  if (getCurrentScope()) {\n    onScopeDispose(cleanup);\n  }\n  return {\n    x: shallowReadonly(x),\n    y: shallowReadonly(y),\n    strategy: shallowReadonly(strategy),\n    placement: shallowReadonly(placement),\n    middlewareData: shallowReadonly(middlewareData),\n    isPositioned: shallowReadonly(isPositioned),\n    floatingStyles,\n    update\n  };\n}\n\nexport { arrow, useFloating };\n","/**\n * --------------------------------------------------------------------------\n * Bootstrap (v5.2.3): util/sanitizer.js\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n * --------------------------------------------------------------------------\n */\n\nconst uriAttributes = new Set([\n  'background',\n  'cite',\n  'href',\n  'itemtype',\n  'longdesc',\n  'poster',\n  'src',\n  'xlink:href',\n])\n\nconst ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i\n\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n *\n * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n */\nconst DATA_URL_PATTERN =\n  /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i\n\nconst allowedAttribute = (attribute: Attr, allowedAttributeList: (string | RegExp)[]) => {\n  const attributeName = attribute.nodeName.toLowerCase()\n\n  if (allowedAttributeList.includes(attributeName)) {\n    if (uriAttributes.has(attributeName)) {\n      return Boolean(\n        SAFE_URL_PATTERN.test(attribute.nodeValue || '') ||\n          DATA_URL_PATTERN.test(attribute.nodeValue || '')\n      )\n    }\n\n    return true\n  }\n\n  // Check if a regular expression validates the attribute.\n  return allowedAttributeList\n    .filter((attributeRegex): attributeRegex is RegExp => attributeRegex instanceof RegExp)\n    .some((regex) => regex.test(attributeName))\n}\n\nexport const DefaultAllowlist = {\n  // Global attributes allowed on any supplied element below.\n  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n  'a': ['target', 'href', 'title', 'rel'],\n  'area': [],\n  'b': [],\n  'br': [],\n  'col': [],\n  'code': [],\n  'div': [],\n  'em': [],\n  'hr': [],\n  'h1': [],\n  'h2': [],\n  'h3': [],\n  'h4': [],\n  'h5': [],\n  'h6': [],\n  'i': [],\n  'img': ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n  'li': [],\n  'ol': [],\n  'p': [],\n  'pre': [],\n  's': [],\n  'small': [],\n  'span': [],\n  'sub': [],\n  'sup': [],\n  'strong': [],\n  'u': [],\n  'ul': [],\n}\n\nexport const sanitizeHtml = (\n  unsafeHtml: string,\n  allowList: Record<string, (string | RegExp)[]>,\n  sanitizeFunction?: (unsafeHtml: string) => string\n) => {\n  if (!unsafeHtml.length) {\n    return unsafeHtml\n  }\n\n  if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n    return sanitizeFunction(unsafeHtml)\n  }\n\n  const domParser = new window.DOMParser()\n  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html')\n  const elements: NodeListOf<Element> = createdDocument.body.querySelectorAll('*')\n\n  for (const element of elements) {\n    const elementName = element.nodeName.toLowerCase()\n\n    if (!Object.keys(allowList).includes(elementName)) {\n      element.remove()\n\n      continue\n    }\n\n    const attributeList = element.attributes\n    const allowedAttributes = [...(allowList['*'] || []), ...(allowList[elementName] || [])]\n\n    for (const attribute of attributeList) {\n      if (!allowedAttribute(attribute, allowedAttributes)) {\n        element.removeAttribute(attribute.nodeName)\n      }\n    }\n  }\n\n  return createdDocument.body.innerHTML\n}\n","import { shallowRef, watchEffect, readonly, ref, watch, customRef, getCurrentScope, onScopeDispose, effectScope, getCurrentInstance, provide, inject, isVue3, version, isRef, unref, computed, reactive, toRefs as toRefs$1, toRef as toRef$1, isVue2, set as set$1, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, {\n    ...options,\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  });\n  return readonly(result);\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = typeof fn === \"function\" ? fn : fn.get;\n  const set = typeof fn === \"function\" ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = /* @__PURE__ */ new Set();\n  const off = (fn) => {\n    fns.delete(fn);\n  };\n  const on = (fn) => {\n    fns.add(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (param) => {\n    return Promise.all(Array.from(fns).map((fn) => param ? fn(param) : fn()));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return (...args) => {\n    if (!initialized) {\n      state = scope.run(() => stateFactory(...args));\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nconst localProvidedStateMap = /* @__PURE__ */ new WeakMap();\n\nconst provideLocal = (key, value) => {\n  var _a;\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"provideLocal must be called in setup\");\n  if (!localProvidedStateMap.has(instance))\n    localProvidedStateMap.set(instance, /* @__PURE__ */ Object.create(null));\n  const localProvidedState = localProvidedStateMap.get(instance);\n  localProvidedState[key] = value;\n  provide(key, value);\n};\n\nconst injectLocal = (...args) => {\n  var _a;\n  const key = args[0];\n  const instance = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy;\n  if (instance == null)\n    throw new Error(\"injectLocal must be called in setup\");\n  if (localProvidedStateMap.has(instance) && key in localProvidedStateMap.get(instance))\n    return localProvidedStateMap.get(instance)[key];\n  return inject(...args);\n};\n\nfunction createInjectionState(composable, options) {\n  const key = (options == null ? void 0 : options.injectionKey) || Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provideLocal(key, state);\n    return state;\n  };\n  const useInjectedState = () => injectLocal(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] extendRef only works in Vue 2.7 or above.\");\n    return;\n  }\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = { ...obj };\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction toValue(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\nconst resolveUnref = toValue;\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : toValue;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(\n    keys.map((key) => {\n      const value = obj[key];\n      return [\n        key,\n        typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n      ];\n    })\n  );\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => !predicate(toValue(v), k))) : Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nconst isClient = typeof window !== \"undefined\" && typeof document !== \"undefined\";\nconst isWorker = typeof WorkerGlobalScope !== \"undefined\" && globalThis instanceof WorkerGlobalScope;\nconst isDef = (val) => typeof val !== \"undefined\";\nconst notNullish = (val) => val != null;\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\nconst isIOS = /* @__PURE__ */ getIsIOS();\nfunction getIsIOS() {\n  var _a;\n  return isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = toValue(ms);\n    const maxDuration = toValue(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = toValue(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      lastValue = new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, Math.max(0, duration - elapsed));\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive: readonly(isActive), pause, resume, eventFilter };\n}\n\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction cacheStringFunction(fn) {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n}\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, \"-$1\").toLowerCase());\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = Number.parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction objectOmit(obj, keys, omitUndefined = false) {\n  return Object.fromEntries(Object.entries(obj).filter(([key, value]) => {\n    return (!omitUndefined || value !== void 0) && !keys.includes(key);\n  }));\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\n\nfunction toRef(...args) {\n  if (args.length !== 1)\n    return toRef$1(...args);\n  const r = args[0];\n  return typeof r === \"function\" ? readonly(customRef(() => ({ get: r, set: noop }))) : ref(r);\n}\nconst resolveRef = toRef;\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  const predicate = flatKeys[0];\n  return reactiveComputed(() => typeof predicate === \"function\" ? Object.fromEntries(Object.entries(toRefs$1(obj)).filter(([k, v]) => predicate(toValue(v), k))) : Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = toValue(defaultValue);\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = toValue(defaultValue);\n      trigger();\n    }, toValue(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(\n    debounceFilter(ms, options),\n    fn\n  );\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(\n    throttleFilter(ms, trailing, leading, rejectOnCancel),\n    fn\n  );\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(\n    ref,\n    {\n      get,\n      set,\n      untrackedGet,\n      silentSet,\n      peek,\n      lay\n    },\n    { enumerable: true }\n  );\n}\nconst controlledRef = refWithControl;\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction watchWithFilter(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  return watch(\n    source,\n    createFilterWrapper(\n      eventFilter,\n      cb\n    ),\n    watchOptions\n  );\n}\n\nfunction watchPausable(source, cb, options = {}) {\n  const {\n    eventFilter: filter,\n    ...watchOptions\n  } = options;\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter\n    }\n  );\n  return { stop, pause, resume, isActive };\n}\n\nfunction syncRef(left, right, ...[options]) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options || {};\n  const watchers = [];\n  const transformLTR = \"ltr\" in transform && transform.ltr || ((v) => v);\n  const transformRTL = \"rtl\" in transform && transform.rtl || ((v) => v);\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchers.push(watchPausable(\n      left,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        right.value = transformLTR(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchers.push(watchPausable(\n      right,\n      (newValue) => {\n        watchers.forEach((w) => w.pause());\n        left.value = transformRTL(newValue);\n        watchers.forEach((w) => w.resume());\n      },\n      { flush, deep, immediate }\n    ));\n  }\n  const stop = () => {\n    watchers.forEach((w) => w.stop());\n  };\n  return stop;\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(\n    source,\n    (newValue) => targets.forEach((target) => target.value = newValue),\n    { flush, deep, immediate }\n  );\n}\n\nfunction toRefs(objectRef, options = {}) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        var _a;\n        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;\n        if (replaceRef) {\n          if (Array.isArray(objectRef.value)) {\n            const copy = [...objectRef.value];\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            const newObject = { ...objectRef.value, [key]: v };\n            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));\n            objectRef.value = newObject;\n          }\n        } else {\n          objectRef.value[key] = v;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        r,\n        (v) => {\n          if (condition(v) !== isNot) {\n            stop == null ? void 0 : stop();\n            resolve(v);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => stop == null ? void 0 : stop())\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(\n        [r, value],\n        ([v1, v2]) => {\n          if (isNot !== (v1 === v2)) {\n            stop == null ? void 0 : stop();\n            resolve(v1);\n          }\n        },\n        {\n          flush,\n          deep,\n          immediate: true\n        }\n      );\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(\n        promiseTimeout(timeout, throwOnTimeout).then(() => toValue(r)).finally(() => {\n          stop == null ? void 0 : stop();\n          return toValue(r);\n        })\n      );\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(toValue(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(toValue(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction defaultComparator(value, othVal) {\n  return value === othVal;\n}\nfunction useArrayDifference(...args) {\n  var _a;\n  const list = args[0];\n  const values = args[1];\n  let compareFn = (_a = args[2]) != null ? _a : defaultComparator;\n  if (typeof compareFn === \"string\") {\n    const key = compareFn;\n    compareFn = (value, othVal) => value[key] === othVal[key];\n  }\n  return computed(() => toValue(list).filter((x) => toValue(values).findIndex((y) => compareFn(x, y)) === -1));\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => toValue(list).every((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => toValue(\n    toValue(list).find((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => toValue(list).findIndex((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction findLast(arr, cb) {\n  let index = arr.length;\n  while (index-- > 0) {\n    if (cb(arr[index], index, arr))\n      return arr[index];\n  }\n  return void 0;\n}\nfunction useArrayFindLast(list, fn) {\n  return computed(() => toValue(\n    !Array.prototype.findLast ? findLast(toValue(list), (element, index, array) => fn(toValue(element), index, array)) : toValue(list).findLast((element, index, array) => fn(toValue(element), index, array))\n  ));\n}\n\nfunction isArrayIncludesOptions(obj) {\n  return isObject(obj) && containsProp(obj, \"formIndex\", \"comparator\");\n}\nfunction useArrayIncludes(...args) {\n  var _a;\n  const list = args[0];\n  const value = args[1];\n  let comparator = args[2];\n  let formIndex = 0;\n  if (isArrayIncludesOptions(comparator)) {\n    formIndex = (_a = comparator.fromIndex) != null ? _a : 0;\n    comparator = comparator.comparator;\n  }\n  if (typeof comparator === \"string\") {\n    const key = comparator;\n    comparator = (element, value2) => element[key] === toValue(value2);\n  }\n  comparator = comparator != null ? comparator : (element, value2) => element === toValue(value2);\n  return computed(() => toValue(list).slice(formIndex).some((element, index, array) => comparator(\n    toValue(element),\n    toValue(value),\n    index,\n    toValue(array)\n  )));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => toValue(list).map((i) => toValue(i)).join(toValue(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => toValue(list).map((i) => toValue(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(toValue(sum), toValue(value), index);\n  return computed(() => {\n    const resolved = toValue(list);\n    return args.length ? resolved.reduce(reduceCallback, toValue(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => toValue(list).some((element, index, array) => fn(toValue(element), index, array)));\n}\n\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction uniqueElementsBy(array, fn) {\n  return array.reduce((acc, v) => {\n    if (!acc.some((x) => fn(v, x, array)))\n      acc.push(v);\n    return acc;\n  }, []);\n}\nfunction useArrayUnique(list, compareFn) {\n  return computed(() => {\n    const resolvedList = toValue(list).map((element) => toValue(element));\n    return compareFn ? uniqueElementsBy(resolvedList, compareFn) : uniq(resolvedList);\n  });\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  let _initialValue = unref(initialValue);\n  const count = ref(initialValue);\n  const {\n    max = Number.POSITIVE_INFINITY,\n    min = Number.NEGATIVE_INFINITY\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = _initialValue) => {\n    _initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /[YMDHhms]o|\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nfunction defaultMeridiem(hours, minutes, isLowercase, hasPeriod) {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n}\nfunction formatOrdinal(num) {\n  const suffixes = [\"th\", \"st\", \"nd\", \"rd\"];\n  const v = num % 100;\n  return num + (suffixes[(v - 20) % 10] || suffixes[v] || suffixes[0]);\n}\nfunction formatDate(date, formatStr, options = {}) {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    Yo: () => formatOrdinal(years),\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    Mo: () => formatOrdinal(month + 1),\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    Do: () => formatOrdinal(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    Ho: () => formatOrdinal(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    ho: () => formatOrdinal(hours % 12 || 12),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mo: () => formatOrdinal(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    so: () => formatOrdinal(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => {\n    var _a2, _b;\n    return (_b = $1 != null ? $1 : (_a2 = matches[match]) == null ? void 0 : _a2.call(matches)) != null ? _b : match;\n  });\n}\nfunction normalizeDate(date) {\n  if (date === null)\n    return new Date(Number.NaN);\n  if (date === void 0)\n    return /* @__PURE__ */ new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n}\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(toValue(date)), toValue(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    const intervalValue = toValue(interval);\n    if (intervalValue <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, intervalValue);\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || typeof interval === \"function\") {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const reset = () => {\n    counter.value = 0;\n  };\n  const controls = useIntervalFn(\n    callback ? () => {\n      update();\n      callback(counter.value);\n    } : update,\n    interval,\n    { immediate }\n  );\n  if (exposeControls) {\n    return {\n      counter,\n      reset,\n      ...controls\n    };\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(\n    source,\n    () => ms.value = timestamp(),\n    options\n  );\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, toValue(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending: readonly(isPending),\n    start,\n    stop\n  };\n}\n\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(\n    callback != null ? callback : noop,\n    interval,\n    options\n  );\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return {\n      ready,\n      ...controls\n    };\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = toValue(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && Number.isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${toValue(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = toValue(truthyValue);\n      _value.value = _value.value === truthy ? toValue(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [...source instanceof Function ? source() : Array.isArray(source) ? source : toValue(source)];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = Array.from({ length: oldList.length });\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nfunction watchAtMost(source, cb, options) {\n  const {\n    count,\n    ...watchOptions\n  } = options;\n  const current = ref(0);\n  const stop = watchWithFilter(\n    source,\n    (...args) => {\n      current.value += 1;\n      if (current.value >= toValue(count))\n        nextTick(() => stop());\n      cb(...args);\n    },\n    watchOptions\n  );\n  return { count: current, stop };\n}\n\nfunction watchDebounced(source, cb, options = {}) {\n  const {\n    debounce = 0,\n    maxWait = void 0,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: debounceFilter(debounce, { maxWait })\n    }\n  );\n}\n\nfunction watchDeep(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      deep: true\n    }\n  );\n}\n\nfunction watchIgnorable(source, cb, options = {}) {\n  const {\n    eventFilter = bypassFilter,\n    ...watchOptions\n  } = options;\n  const filteredCb = createFilterWrapper(\n    eventFilter,\n    cb\n  );\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(\n      source,\n      (...args) => {\n        if (!ignore.value)\n          filteredCb(...args);\n      },\n      watchOptions\n    );\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(\n      watch(\n        source,\n        () => {\n          syncCounter.value++;\n        },\n        { ...watchOptions, flush: \"sync\" }\n      )\n    );\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(\n      watch(\n        source,\n        (...args) => {\n          const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n          ignoreCounter.value = 0;\n          syncCounter.value = 0;\n          if (ignore)\n            return;\n          filteredCb(...args);\n        },\n        watchOptions\n      )\n    );\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchImmediate(source, cb, options) {\n  return watch(\n    source,\n    cb,\n    {\n      ...options,\n      immediate: true\n    }\n  );\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n  return stop;\n}\n\nfunction watchThrottled(source, cb, options = {}) {\n  const {\n    throttle = 0,\n    trailing = true,\n    leading = true,\n    ...watchOptions\n  } = options;\n  return watchWithFilter(\n    source,\n    cb,\n    {\n      ...watchOptions,\n      eventFilter: throttleFilter(throttle, trailing, leading)\n    }\n  );\n}\n\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return {\n    ...res,\n    trigger\n  };\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => toValue(item));\n  return toValue(sources);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(\n    source,\n    (v, ov, onInvalidate) => {\n      if (v)\n        cb(v, ov, onInvalidate);\n    },\n    options\n  );\n}\n\nexport { assert, refAutoReset as autoResetRef, bypassFilter, camelize, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, hyphenate, identity, watchIgnorable as ignorableWatch, increaseWithUnit, injectLocal, invoke, isClient, isDef, isDefined, isIOS, isObject, isWorker, makeDestructurable, noop, normalizeDate, notNullish, now, objectEntries, objectOmit, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, provideLocal, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRef, toRefs, toValue, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayDifference, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayFindLast, useArrayIncludes, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchDeep, watchIgnorable, watchImmediate, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, makeDestructurable, camelize, toValue, isClient, isObject, tryOnScopeDispose, isIOS, tryOnMounted, computedWithControl, objectOmit, promiseTimeout, until, increaseWithUnit, objectEntries, createSingletonPromise, useTimeoutFn, pausableWatch, toRef, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, toRefs, useIntervalFn, notNullish, containsProp, hasOwn, throttleFilter, useDebounceFn, useThrottleFn, clamp, syncRef, objectPick, tryOnUnmounted, watchWithFilter, identity, isDef, isWorker } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, isVue3, version, defineComponent, h, TransitionGroup, shallowReactive, Fragment, watch, getCurrentInstance, customRef, onUpdated, onMounted, readonly, nextTick, reactive, markRaw, unref, getCurrentScope, isVue2, set, del, isReadonly, onBeforeUpdate } from 'vue-demi';\nimport { useEventListener as useEventListener$1 } from '@vueuse/core';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = true,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nfunction createReusableTemplate(options = {}) {\n  if (!isVue3 && !version.startsWith(\"2.7.\")) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createReusableTemplate only works in Vue 2.7 or above.\");\n    return;\n  }\n  const {\n    inheritAttrs = true\n  } = options;\n  const render = shallowRef();\n  const define = /* #__PURE__ */ defineComponent({\n    setup(_, { slots }) {\n      return () => {\n        render.value = slots.default;\n      };\n    }\n  });\n  const reuse = /* #__PURE__ */ defineComponent({\n    inheritAttrs,\n    setup(_, { attrs, slots }) {\n      return () => {\n        var _a;\n        if (!render.value && process.env.NODE_ENV !== \"production\")\n          throw new Error(\"[VueUse] Failed to find the definition of reusable template\");\n        const vnode = (_a = render.value) == null ? void 0 : _a.call(render, { ...keysToCamelKebabCase(attrs), $slots: slots });\n        return inheritAttrs && (vnode == null ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;\n      };\n    }\n  });\n  return makeDestructurable(\n    { define, reuse },\n    [define, reuse]\n  );\n}\nfunction keysToCamelKebabCase(obj) {\n  const newObj = {};\n  for (const key in obj)\n    newObj[camelize(key)] = obj[key];\n  return newObj;\n}\n\nfunction createTemplatePromise(options = {}) {\n  if (!isVue3) {\n    if (process.env.NODE_ENV !== \"production\")\n      throw new Error(\"[VueUse] createTemplatePromise only works in Vue 3 or above.\");\n    return;\n  }\n  let index = 0;\n  const instances = ref([]);\n  function create(...args) {\n    const props = shallowReactive({\n      key: index++,\n      args,\n      promise: void 0,\n      resolve: () => {\n      },\n      reject: () => {\n      },\n      isResolving: false,\n      options\n    });\n    instances.value.push(props);\n    props.promise = new Promise((_resolve, _reject) => {\n      props.resolve = (v) => {\n        props.isResolving = true;\n        return _resolve(v);\n      };\n      props.reject = _reject;\n    }).finally(() => {\n      props.promise = void 0;\n      const index2 = instances.value.indexOf(props);\n      if (index2 !== -1)\n        instances.value.splice(index2, 1);\n    });\n    return props.promise;\n  }\n  function start(...args) {\n    if (options.singleton && instances.value.length > 0)\n      return instances.value[0].promise;\n    return create(...args);\n  }\n  const component = /* #__PURE__ */ defineComponent((_, { slots }) => {\n    const renderList = () => instances.value.map((props) => {\n      var _a;\n      return h(Fragment, { key: props.key }, (_a = slots.default) == null ? void 0 : _a.call(slots, props));\n    });\n    if (options.transition)\n      return () => h(TransitionGroup, options.transition, renderList);\n    return renderList;\n  });\n  component.start = start;\n  return component;\n}\n\nfunction createUnrefFn(fn) {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => toValue(i)));\n  };\n}\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = toValue(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (typeof args[0] === \"string\" || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener, options2) => {\n    el.addEventListener(event, listener, options2);\n    return () => el.removeEventListener(event, listener, options2);\n  };\n  const stopWatch = watch(\n    () => [unrefElement(target), toValue(options)],\n    ([el, options2]) => {\n      cleanup();\n      if (!el)\n        return;\n      const optionsClone = isObject(options2) ? { ...options2 } : options2;\n      cleanups.push(\n        ...events.flatMap((event) => {\n          return listeners.map((listener) => register(el, event, listener, optionsClone));\n        })\n      );\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nlet _iOSWorkaround = false;\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return;\n  if (isIOS && !_iOSWorkaround) {\n    _iOSWorkaround = true;\n    Array.from(window.document.body.children).forEach((el) => el.addEventListener(\"click\", noop));\n    window.document.documentElement.addEventListener(\"click\", noop);\n  }\n  let shouldListen = true;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      setTimeout(() => {\n        var _a;\n        const el = unrefElement(target);\n        if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n          handler(event);\n      }, 0);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction createKeyPredicate(keyFilter) {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n}\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const {\n    target = defaultWindow,\n    eventName = \"keydown\",\n    passive = false,\n    dedupe = false\n  } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (e.repeat && toValue(dedupe))\n      return;\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keydown\" });\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keypress\" });\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, { ...options, eventName: \"keyup\" });\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    timeout = setTimeout(\n      () => handler(ev),\n      (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY\n    );\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  const cleanup = [\n    useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions),\n    useEventListener(elementRef, [\"pointerup\", \"pointerleave\"], clear, listenerOptions)\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nfunction isFocusedElementEditable() {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n}\nfunction isTypedCharValid({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  if (keyCode >= 97 && keyCode <= 122)\n    return true;\n  return false;\n}\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const {\n    window = defaultWindow,\n    deep = true\n  } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const getDeepActiveElement = () => {\n    var _a2;\n    let element = document == null ? void 0 : document.activeElement;\n    if (deep) {\n      while (element == null ? void 0 : element.shadowRoot)\n        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;\n    }\n    return element;\n  };\n  const activeElement = computedWithControl(\n    () => null,\n    () => getDeepActiveElement()\n  );\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      activeElement.trigger();\n    }, true);\n    useEventListener(window, \"focus\", activeElement.trigger, true);\n  }\n  return activeElement;\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  if (getCurrentInstance()) {\n    onMounted(() => {\n      isMounted.value = true;\n    });\n  }\n  return isMounted;\n}\n\nfunction useSupported(callback) {\n  const isMounted = useMounted();\n  return computed(() => {\n    isMounted.value;\n    return Boolean(callback());\n  });\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    fpsLimit = void 0,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  const intervalLimit = fpsLimit ? 1e3 / fpsLimit : null;\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    const delta = timestamp - (previousFrameTimestamp || timestamp);\n    if (intervalLimit && delta < intervalLimit) {\n      rafId = window.requestAnimationFrame(loop);\n      return;\n    }\n    fn({ delta, timestamp });\n    previousFrameTimestamp = timestamp;\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: readonly(isActive),\n    pause,\n    resume\n  };\n}\n\nfunction useAnimate(target, keyframes, options) {\n  let config;\n  let animateOptions;\n  if (isObject(options)) {\n    config = options;\n    animateOptions = objectOmit(options, [\"window\", \"immediate\", \"commitStyles\", \"persist\", \"onReady\", \"onError\"]);\n  } else {\n    config = { duration: options };\n    animateOptions = options;\n  }\n  const {\n    window = defaultWindow,\n    immediate = true,\n    commitStyles,\n    persist,\n    playbackRate: _playbackRate = 1,\n    onReady,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = config;\n  const isSupported = useSupported(() => window && HTMLElement && \"animate\" in HTMLElement.prototype);\n  const animate = shallowRef(void 0);\n  const store = shallowReactive({\n    startTime: null,\n    currentTime: null,\n    timeline: null,\n    playbackRate: _playbackRate,\n    pending: false,\n    playState: immediate ? \"idle\" : \"paused\",\n    replaceState: \"active\"\n  });\n  const pending = computed(() => store.pending);\n  const playState = computed(() => store.playState);\n  const replaceState = computed(() => store.replaceState);\n  const startTime = computed({\n    get() {\n      return store.startTime;\n    },\n    set(value) {\n      store.startTime = value;\n      if (animate.value)\n        animate.value.startTime = value;\n    }\n  });\n  const currentTime = computed({\n    get() {\n      return store.currentTime;\n    },\n    set(value) {\n      store.currentTime = value;\n      if (animate.value) {\n        animate.value.currentTime = value;\n        syncResume();\n      }\n    }\n  });\n  const timeline = computed({\n    get() {\n      return store.timeline;\n    },\n    set(value) {\n      store.timeline = value;\n      if (animate.value)\n        animate.value.timeline = value;\n    }\n  });\n  const playbackRate = computed({\n    get() {\n      return store.playbackRate;\n    },\n    set(value) {\n      store.playbackRate = value;\n      if (animate.value)\n        animate.value.playbackRate = value;\n    }\n  });\n  const play = () => {\n    if (animate.value) {\n      try {\n        animate.value.play();\n        syncResume();\n      } catch (e) {\n        syncPause();\n        onError(e);\n      }\n    } else {\n      update();\n    }\n  };\n  const pause = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.pause();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const reverse = () => {\n    var _a;\n    !animate.value && update();\n    try {\n      (_a = animate.value) == null ? void 0 : _a.reverse();\n      syncResume();\n    } catch (e) {\n      syncPause();\n      onError(e);\n    }\n  };\n  const finish = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.finish();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  const cancel = () => {\n    var _a;\n    try {\n      (_a = animate.value) == null ? void 0 : _a.cancel();\n      syncPause();\n    } catch (e) {\n      onError(e);\n    }\n  };\n  watch(() => unrefElement(target), (el) => {\n    el && update();\n  });\n  watch(() => keyframes, (value) => {\n    !animate.value && update();\n    if (!unrefElement(target) && animate.value) {\n      animate.value.effect = new KeyframeEffect(\n        unrefElement(target),\n        toValue(value),\n        animateOptions\n      );\n    }\n  }, { deep: true });\n  tryOnMounted(() => {\n    nextTick(() => update(true));\n  });\n  tryOnScopeDispose(cancel);\n  function update(init) {\n    const el = unrefElement(target);\n    if (!isSupported.value || !el)\n      return;\n    animate.value = el.animate(toValue(keyframes), animateOptions);\n    if (commitStyles)\n      animate.value.commitStyles();\n    if (persist)\n      animate.value.persist();\n    if (_playbackRate !== 1)\n      animate.value.playbackRate = _playbackRate;\n    if (init && !immediate)\n      animate.value.pause();\n    else\n      syncResume();\n    onReady == null ? void 0 : onReady(animate.value);\n  }\n  useEventListener(animate, [\"cancel\", \"finish\", \"remove\"], syncPause);\n  const { resume: resumeRef, pause: pauseRef } = useRafFn(() => {\n    if (!animate.value)\n      return;\n    store.pending = animate.value.pending;\n    store.playState = animate.value.playState;\n    store.replaceState = animate.value.replaceState;\n    store.startTime = animate.value.startTime;\n    store.currentTime = animate.value.currentTime;\n    store.timeline = animate.value.timeline;\n    store.playbackRate = animate.value.playbackRate;\n  }, { immediate: false });\n  function syncResume() {\n    if (isSupported.value)\n      resumeRef();\n  }\n  function syncPause() {\n    if (isSupported.value && window)\n      window.requestAnimationFrame(pauseRef);\n  }\n  return {\n    isSupported,\n    animate,\n    // actions\n    play,\n    pause,\n    reverse,\n    finish,\n    cancel,\n    // state\n    pending,\n    playState,\n    replaceState,\n    startTime,\n    currentTime,\n    timeline,\n    playbackRate\n  };\n}\n\nfunction useAsyncQueue(tasks, options) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop,\n    signal\n  } = options || {};\n  const promiseState = {\n    aborted: \"aborted\",\n    fulfilled: \"fulfilled\",\n    pending: \"pending\",\n    rejected: \"rejected\"\n  };\n  const initialResult = Array.from(Array.from({ length: tasks.length }), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, new Error(\"aborted\"));\n        return;\n      }\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      const done = curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n      if (!signal)\n        return done;\n      return Promise.race([done, whenAborted(signal)]);\n    }).catch((e) => {\n      if (signal == null ? void 0 : signal.aborted) {\n        updateResult(promiseState.aborted, e);\n        return e;\n      }\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\nfunction whenAborted(signal) {\n  return new Promise((resolve, reject) => {\n    const error = new Error(\"aborted\");\n    if (signal.aborted)\n      reject(error);\n    else\n      signal.addEventListener(\"abort\", () => reject(error), { once: true });\n  });\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = shallowRef(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw e;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  const shell = {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n  function waitUntilIsLoaded() {\n    return new Promise((resolve, reject) => {\n      until(isLoading).toBe(false).then(() => resolve(shell)).catch(reject);\n    });\n  }\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilIsLoaded().then(onFulfilled, onRejected);\n    }\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = toValue(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || typeof target === \"function\")\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useBattery(options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      useEventListener(battery, events, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    // Device:\n    device,\n    requestDevice,\n    // Server:\n    server,\n    // Errors:\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const handler = (event) => {\n    matches.value = event.matches;\n  };\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", handler);\n    else\n      mediaQuery.removeListener(handler);\n  };\n  const stopWatch = watchEffect(() => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(toValue(query));\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", handler);\n    else\n      mediaQuery.addListener(handler);\n    matches.value = mediaQuery.matches;\n  });\n  tryOnScopeDispose(() => {\n    stopWatch();\n    cleanup();\n    mediaQuery = void 0;\n  });\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  xs: 0,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\nconst breakpointsPrimeFlex = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200\n};\n\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greaterOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return Object.assign(shortcutMethods, {\n    greater(k) {\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    greaterOrEqual,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    smallerOrEqual(k) {\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    },\n    current() {\n      const points = Object.keys(breakpoints).map((i) => [i, greaterOrEqual(i)]);\n      return computed(() => points.filter(([, v]) => v.value).map(([k]) => k));\n    }\n  });\n}\n\nfunction useBroadcastChannel(options) {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = shallowRef(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n}\n\nconst WRITABLE_PROPERTIES = [\n  \"hash\",\n  \"host\",\n  \"hostname\",\n  \"href\",\n  \"pathname\",\n  \"port\",\n  \"protocol\",\n  \"search\"\n];\nfunction useBrowserLocation(options = {}) {\n  const { window = defaultWindow } = options;\n  const refs = Object.fromEntries(\n    WRITABLE_PROPERTIES.map((key) => [key, ref()])\n  );\n  for (const [key, ref2] of objectEntries(refs)) {\n    watch(ref2, (value) => {\n      if (!(window == null ? void 0 : window.location) || window.location[key] === value)\n        return;\n      window.location[key] = value;\n    });\n  }\n  const buildState = (trigger) => {\n    var _a;\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { origin } = (window == null ? void 0 : window.location) || {};\n    for (const key of WRITABLE_PROPERTIES)\n      refs[key].value = (_a = window == null ? void 0 : window.location) == null ? void 0 : _a[key];\n    return reactive({\n      trigger,\n      state: state2,\n      length,\n      origin,\n      ...refs\n    });\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const permissionRead = usePermission(\"clipboard-read\");\n  const permissionWrite = usePermission(\"clipboard-write\");\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value && permissionRead.value !== \"denied\") {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateText);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value && permissionWrite.value !== \"denied\")\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nfunction useClipboardItems(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500\n  } = options;\n  const isSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const content = ref([]);\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateContent() {\n    if (isSupported.value) {\n      navigator.clipboard.read().then((items) => {\n        content.value = items;\n      });\n    }\n  }\n  if (isSupported.value && read)\n    useEventListener([\"copy\", \"cut\"], updateContent);\n  async function copy(value = toValue(source)) {\n    if (isSupported.value && value != null) {\n      await navigator.clipboard.write(value);\n      content.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  return {\n    isSupported,\n    content,\n    copied,\n    copy\n  };\n}\n\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    // watch options\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(toValue(source));\n  }\n  if (!manual && (isRef(source) || typeof source === \"function\")) {\n    watch(source, sync, {\n      ...options,\n      deep,\n      immediate\n    });\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\nconst handlers = /* @__PURE__ */ getHandlers();\nfunction getHandlers() {\n  if (!(globalKey in _global))\n    _global[globalKey] = _global[globalKey] || {};\n  return _global[globalKey];\n}\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nconst customStorageEventName = \"vueuse-storage\";\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    },\n    initOnMounted\n  } = options;\n  const data = (shallow ? shallowRef : ref)(typeof defaults === \"function\" ? defaults() : defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = toValue(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(\n    data,\n    () => write(data.value),\n    { flush, deep, eventFilter }\n  );\n  if (window && listenToStorageChanges) {\n    tryOnMounted(() => {\n      useEventListener(window, \"storage\", update);\n      useEventListener(window, customStorageEventName, updateFromCustomEvent);\n      if (initOnMounted)\n        update();\n    });\n  }\n  if (!initOnMounted)\n    update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null) {\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        const oldValue = storage.getItem(key);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          if (window) {\n            window.dispatchEvent(new CustomEvent(customStorageEventName, {\n              detail: {\n                key,\n                oldValue,\n                newValue: serialized,\n                storageArea: storage\n              }\n            }));\n          }\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit !== null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (typeof mergeDefaults === \"function\")\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return { ...rawInit, ...value };\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function updateFromCustomEvent(event) {\n    update(event.detail);\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      if ((event == null ? void 0 : event.newValue) !== serializer.write(data.value))\n        data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto,\n    disableTransition = true\n  } = options;\n  const modes = {\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\",\n    ...options.modes || {}\n  };\n  const preferredDark = usePreferredDark({ window });\n  const system = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? toRef(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed(() => store.value === \"auto\" ? system.value : store.value);\n  const updateHTMLAttrs = getSSRHandler(\n    \"updateHTMLAttrs\",\n    (selector2, attribute2, value) => {\n      const el = typeof selector2 === \"string\" ? window == null ? void 0 : window.document.querySelector(selector2) : unrefElement(selector2);\n      if (!el)\n        return;\n      let style;\n      if (disableTransition) {\n        style = window.document.createElement(\"style\");\n        const styleString = \"*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}\";\n        style.appendChild(document.createTextNode(styleString));\n        window.document.head.appendChild(style);\n      }\n      if (attribute2 === \"class\") {\n        const current = value.split(/\\s/g);\n        Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n          if (current.includes(v))\n            el.classList.add(v);\n          else\n            el.classList.remove(v);\n        });\n      } else {\n        el.setAttribute(attribute2, value);\n      }\n      if (disableTransition) {\n        window.getComputedStyle(style).opacity;\n        document.head.removeChild(style);\n      }\n    }\n  );\n  function defaultOnChanged(mode) {\n    var _a;\n    updateHTMLAttrs(selector, attribute, (_a = modes[mode]) != null ? _a : mode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  tryOnMounted(() => onChanged(state.value));\n  const auto = computed({\n    get() {\n      return emitAuto ? store.value : state.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  try {\n    return Object.assign(auto, { store, system, state });\n  } catch (e) {\n    return auto;\n  }\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useMutationObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...mutationOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(\n    () => unrefElement(target),\n    (el) => {\n      cleanup();\n      if (isSupported.value && window && el) {\n        observer = new MutationObserver(callback);\n        observer.observe(el, mutationOptions);\n      }\n    },\n    { immediate: true }\n  );\n  const takeRecords = () => {\n    return observer == null ? void 0 : observer.takeRecords();\n  };\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop,\n    takeRecords\n  };\n}\n\nfunction useCssVar(prop, target, options = {}) {\n  const { window = defaultWindow, initialValue = \"\", observe = false } = options;\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  function updateCssVar() {\n    var _a;\n    const key = toValue(prop);\n    const el = toValue(elRef);\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(key)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }\n  if (observe) {\n    useMutationObserver(elRef, updateCssVar, {\n      attributeFilter: [\"style\", \"class\"],\n      window\n    });\n  }\n  watch(\n    [elRef, () => toValue(prop)],\n    updateCssVar,\n    { immediate: true }\n  );\n  watch(\n    variable,\n    (val) => {\n      var _a;\n      if ((_a = elRef.value) == null ? void 0 : _a.style)\n        elRef.value.style.setProperty(toValue(prop), val);\n    }\n  );\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(\n    () => null,\n    () => vm.proxy.$el\n  );\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  const state = shallowRef(getInitialValue());\n  const listRef = toRef(list);\n  const index = computed({\n    get() {\n      var _a;\n      const targetList = listRef.value;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, targetList) : targetList.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a = options == null ? void 0 : options.fallbackIndex) != null ? _a : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const targetList = listRef.value;\n    const length = targetList.length;\n    const index2 = (i % length + length) % length;\n    const value = targetList[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  function getInitialValue() {\n    var _a, _b;\n    return (_b = toValue((_a = options == null ? void 0 : options.initialValue) != null ? _a : toValue(list)[0])) != null ? _b : void 0;\n  }\n  watch(listRef, () => set(index.value));\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\"\n  } = options;\n  const mode = useColorMode({\n    ...options,\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\", defaultHandler, mode2);\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      const modeVal = v ? \"dark\" : \"light\";\n      if (mode.system.value === modeVal)\n        mode.value = \"auto\";\n      else\n        mode.value = modeVal;\n    }\n  });\n  return isDark;\n}\n\nfunction fnBypass(v) {\n  return v;\n}\nfunction fnSetSource(source, value) {\n  return source.value = value;\n}\nfunction defaultDump(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? typeof clone === \"function\" ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Number.POSITIVE_INFINITY);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(\n    source,\n    commit,\n    { deep, flush, eventFilter: composedFilter }\n  );\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, { ...options, clone: options.clone || deep, setSource });\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return {\n    ...manualHistory,\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  };\n}\n\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(\n      eventFilter,\n      (event) => {\n        acceleration.value = event.acceleration;\n        accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n        rotationRate.value = event.rotationRate;\n        interval.value = event.interval;\n      }\n    );\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const pixelRatio = ref(1);\n  if (window) {\n    let observe2 = function() {\n      pixelRatio.value = window.devicePixelRatio;\n      cleanup2();\n      media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n      media.addEventListener(\"change\", observe2, { once: true });\n    }, cleanup2 = function() {\n      media == null ? void 0 : media.removeEventListener(\"change\", observe2);\n    };\n    let media;\n    observe2();\n    tryOnScopeDispose(cleanup2);\n  }\n  return { pixelRatio };\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  let stream;\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n    if (stream) {\n      stream.getTracks().forEach((t) => t.stop());\n      stream = null;\n    }\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      stream = await navigator.mediaDevices.getUserMedia(constraints);\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility(options = {}) {\n  const { document = defaultDocument } = options;\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nfunction useDraggable(target, options = {}) {\n  var _a, _b;\n  const {\n    pointerTypes,\n    preventDefault,\n    stopPropagation,\n    exact,\n    onMove,\n    onEnd,\n    onStart,\n    initialValue,\n    axis = \"both\",\n    draggingElement = defaultWindow,\n    containerElement,\n    handle: draggingHandle = target\n  } = options;\n  const position = ref(\n    (_a = toValue(initialValue)) != null ? _a : { x: 0, y: 0 }\n  );\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (pointerTypes)\n      return pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (toValue(preventDefault))\n      e.preventDefault();\n    if (toValue(stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (toValue(exact) && e.target !== toValue(target))\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - (container ? targetRect.left - containerRect.left : targetRect.left),\n      y: e.clientY - (container ? targetRect.top - containerRect.top : targetRect.top)\n    };\n    if ((onStart == null ? void 0 : onStart(pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    const container = toValue(containerElement);\n    const containerRect = (_a2 = container == null ? void 0 : container.getBoundingClientRect) == null ? void 0 : _a2.call(container);\n    const targetRect = toValue(target).getBoundingClientRect();\n    let { x, y } = position.value;\n    if (axis === \"x\" || axis === \"both\") {\n      x = e.clientX - pressedDelta.value.x;\n      if (container)\n        x = Math.min(Math.max(0, x), containerRect.width - targetRect.width);\n    }\n    if (axis === \"y\" || axis === \"both\") {\n      y = e.clientY - pressedDelta.value.y;\n      if (container)\n        y = Math.min(Math.max(0, y), containerRect.height - targetRect.height);\n    }\n    position.value = {\n      x,\n      y\n    };\n    onMove == null ? void 0 : onMove(position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    onEnd == null ? void 0 : onEnd(position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    const config = { capture: (_b = options.capture) != null ? _b : true };\n    useEventListener(draggingHandle, \"pointerdown\", start, config);\n    useEventListener(draggingElement, \"pointermove\", move, config);\n    useEventListener(draggingElement, \"pointerup\", end, config);\n  }\n  return {\n    ...toRefs(position),\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(\n      () => `left:${position.value.x}px;top:${position.value.y}px;`\n    )\n  };\n}\n\nfunction useDropZone(target, options = {}) {\n  const isOverDropZone = ref(false);\n  const files = shallowRef(null);\n  let counter = 0;\n  let isDataTypeIncluded = true;\n  if (isClient) {\n    const _options = typeof options === \"function\" ? { onDrop: options } : options;\n    const getFiles = (event) => {\n      var _a, _b;\n      const list = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      return files.value = list.length === 0 ? null : list;\n    };\n    useEventListener$1(target, \"dragenter\", (event) => {\n      var _a;\n      if (_options.dataTypes && event.dataTransfer) {\n        const dataTypes = unref(_options.dataTypes);\n        isDataTypeIncluded = typeof dataTypes === \"function\" ? dataTypes(event.dataTransfer.types) : dataTypes ? dataTypes.some((item) => event.dataTransfer.types.includes(item)) : true;\n        if (!isDataTypeIncluded)\n          return;\n      }\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n      (_a = _options.onEnter) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener$1(target, \"dragover\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      (_a = _options.onOver) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener$1(target, \"dragleave\", (event) => {\n      var _a;\n      if (!isDataTypeIncluded)\n        return;\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n      (_a = _options.onLeave) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n    useEventListener$1(target, \"drop\", (event) => {\n      var _a;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      (_a = _options.onDrop) == null ? void 0 : _a.call(_options, getFiles(event), event);\n    });\n  }\n  return {\n    files,\n    isOverDropZone\n  };\n}\n\nfunction useResizeObserver(target, callback, options = {}) {\n  const { window = defaultWindow, ...observerOptions } = options;\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const targets = computed(() => Array.isArray(target) ? target.map((el) => unrefElement(el)) : [unrefElement(target)]);\n  const stopWatch = watch(\n    targets,\n    (els) => {\n      cleanup();\n      if (isSupported.value && window) {\n        observer = new ResizeObserver(callback);\n        for (const _el of els)\n          _el && observer.observe(_el, observerOptions);\n      }\n    },\n    { immediate: true, flush: \"post\", deep: true }\n  );\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useElementByPoint(options) {\n  const {\n    x,\n    y,\n    document = defaultDocument,\n    multiple,\n    interval = \"requestAnimationFrame\",\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => {\n    if (toValue(multiple))\n      return document && \"elementsFromPoint\" in document;\n    return document && \"elementFromPoint\" in document;\n  });\n  const element = ref(null);\n  const cb = () => {\n    var _a, _b;\n    element.value = toValue(multiple) ? (_a = document == null ? void 0 : document.elementsFromPoint(toValue(x), toValue(y))) != null ? _a : [] : (_b = document == null ? void 0 : document.elementFromPoint(toValue(x), toValue(y))) != null ? _b : null;\n  };\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  return {\n    isSupported,\n    element,\n    ...controls\n  };\n}\n\nfunction useElementHover(el, options = {}) {\n  const {\n    delayEnter = 0,\n    delayLeave = 0,\n    window = defaultWindow\n  } = options;\n  const isHovered = ref(false);\n  let timer;\n  const toggle = (entering) => {\n    const delay = entering ? delayEnter : delayLeave;\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n    if (delay)\n      timer = setTimeout(() => isHovered.value = entering, delay);\n    else\n      isHovered.value = entering;\n  };\n  if (!window)\n    return isHovered;\n  useEventListener(el, \"mouseenter\", () => toggle(true), { passive: true });\n  useEventListener(el, \"mouseleave\", () => toggle(false), { passive: true });\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { window = defaultWindow, box = \"content-box\" } = options;\n  const isSVG = computed(() => {\n    var _a, _b;\n    return (_b = (_a = unrefElement(target)) == null ? void 0 : _a.namespaceURI) == null ? void 0 : _b.includes(\"svg\");\n  });\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  const { stop: stop1 } = useResizeObserver(\n    target,\n    ([entry]) => {\n      const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n      if (window && isSVG.value) {\n        const $elem = unrefElement(target);\n        if ($elem) {\n          const styles = window.getComputedStyle($elem);\n          width.value = Number.parseFloat(styles.width);\n          height.value = Number.parseFloat(styles.height);\n        }\n      } else {\n        if (boxSize) {\n          const formatBoxSize = Array.isArray(boxSize) ? boxSize : [boxSize];\n          width.value = formatBoxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n          height.value = formatBoxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n        } else {\n          width.value = entry.contentRect.width;\n          height.value = entry.contentRect.height;\n        }\n      }\n    },\n    options\n  );\n  tryOnMounted(() => {\n    const ele = unrefElement(target);\n    if (ele) {\n      width.value = \"offsetWidth\" in ele ? ele.offsetWidth : initialSize.width;\n      height.value = \"offsetHeight\" in ele ? ele.offsetHeight : initialSize.height;\n    }\n  });\n  const stop2 = watch(\n    () => unrefElement(target),\n    (ele) => {\n      width.value = ele ? initialSize.width : 0;\n      height.value = ele ? initialSize.height : 0;\n    }\n  );\n  function stop() {\n    stop1();\n    stop2();\n  }\n  return {\n    width,\n    height,\n    stop\n  };\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  const targets = computed(() => {\n    const _target = toValue(target);\n    return (Array.isArray(_target) ? _target : [_target]).map(unrefElement).filter(notNullish);\n  });\n  let cleanup = noop;\n  const isActive = ref(immediate);\n  const stopWatch = isSupported.value ? watch(\n    () => [targets.value, unrefElement(root), isActive.value],\n    ([targets2, root2]) => {\n      cleanup();\n      if (!isActive.value)\n        return;\n      if (!targets2.length)\n        return;\n      const observer = new IntersectionObserver(\n        callback,\n        {\n          root: unrefElement(root2),\n          rootMargin,\n          threshold\n        }\n      );\n      targets2.forEach((el) => el && observer.observe(el));\n      cleanup = () => {\n        observer.disconnect();\n        cleanup = noop;\n      };\n    },\n    { immediate, flush: \"post\" }\n  ) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n    isActive.value = false;\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    isActive,\n    pause() {\n      cleanup();\n      isActive.value = false;\n    },\n    resume() {\n      isActive.value = true;\n    },\n    stop\n  };\n}\n\nfunction useElementVisibility(element, options = {}) {\n  const { window = defaultWindow, scrollTarget } = options;\n  const elementIsVisible = ref(false);\n  useIntersectionObserver(\n    element,\n    ([{ isIntersecting }]) => {\n      elementIsVisible.value = isIntersecting;\n    },\n    {\n      root: scrollTarget,\n      window,\n      threshold: 0\n    }\n  );\n  return elementIsVisible;\n}\n\nconst events = /* @__PURE__ */ new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || /* @__PURE__ */ new Set();\n    listeners.add(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    listeners.delete(listener);\n    if (!listeners.size)\n      reset();\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = shallowRef(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = toRef(newIcon);\n  const applyIcon = (icon) => {\n    const elements = document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`);\n    if (!elements || elements.length === 0) {\n      const link = document == null ? void 0 : document.createElement(\"link\");\n      if (link) {\n        link.rel = rel;\n        link.href = `${baseUrl}${icon}`;\n        link.type = `image/${icon.split(\".\").pop()}`;\n        document == null ? void 0 : document.head.append(link);\n      }\n      return;\n    }\n    elements == null ? void 0 : elements.forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(\n    favicon,\n    (i, o) => {\n      if (typeof i === \"string\" && i !== o)\n        applyIcon(i);\n    },\n    { immediate: true }\n  );\n  return favicon;\n}\n\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return obj && containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\", \"updateDataOnError\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback)\n        return { ...ctx, ...await callback(ctx) };\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      for (const callback of callbacks) {\n        if (callback)\n          ctx = { ...ctx, ...await callback(ctx) };\n      }\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = toValue(config.baseUrl);\n      const targetUrl = toValue(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = {\n          ...options,\n          ...args[0],\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        };\n      } else {\n        fetchOptions = {\n          ...fetchOptions,\n          ...args[0],\n          headers: {\n            ...headersToObject(fetchOptions.headers) || {},\n            ...headersToObject(args[0].headers) || {}\n          }\n        };\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = {\n        ...options,\n        ...args[1],\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      };\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = {\n    immediate: true,\n    refetch: false,\n    timeout: 0,\n    updateDataOnError: false\n  };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = { ...options, ...args[0] };\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = { ...options, ...args[1] };\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData || null);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort) {\n      controller == null ? void 0 : controller.abort();\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = {\n        ...fetchOptions,\n        signal: controller.signal\n      };\n    }\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  let executeCounter = 0;\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    abort();\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    executeCounter += 1;\n    const currentExecuteCounter = executeCounter;\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      const payload = toValue(config.payload);\n      if (!config.payloadType && payload && Object.getPrototypeOf(payload) === Object.prototype && !(payload instanceof FormData))\n        config.payloadType = \"json\";\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: toValue(url),\n      options: {\n        ...defaultFetchOptions,\n        ...fetchOptions\n      },\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(\n        context.url,\n        {\n          ...defaultFetchOptions,\n          ...context.options,\n          headers: {\n            ...headersToObject(defaultFetchOptions.headers),\n            ...headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers)\n          }\n        }\n      ).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (!fetchResponse.ok) {\n          data.value = initialData || null;\n          throw new Error(fetchResponse.statusText);\n        }\n        if (options.afterFetch) {\n          ({ data: responseData } = await options.afterFetch({\n            data: responseData,\n            response: fetchResponse\n          }));\n        }\n        data.value = responseData;\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError) {\n          ({ error: errorData, data: responseData } = await options.onFetchError({\n            data: responseData,\n            error: fetchError,\n            response: response.value\n          }));\n        }\n        error.value = errorData;\n        if (options.updateDataOnError)\n          data.value = responseData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        if (currentExecuteCounter === executeCounter)\n          loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  const refetch = toRef(options.refetch);\n  watch(\n    [\n      refetch,\n      toRef(url)\n    ],\n    ([refetch2]) => refetch2 && execute(),\n    { deep: true }\n  );\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    // method\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    // type\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch(\n            [\n              refetch,\n              toRef(config.payload)\n            ],\n            ([refetch2]) => refetch2 && execute(),\n            { deep: true }\n          );\n        }\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return {\n          ...shell,\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        };\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    Promise.resolve().then(() => execute());\n  return {\n    ...shell,\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  };\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\",\n  reset: false,\n  directory: false\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  const { on: onChange, trigger } = createEventHook();\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n      trigger(files.value);\n    };\n  }\n  const reset = () => {\n    files.value = null;\n    if (input)\n      input.value = \"\";\n  };\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = {\n      ...DEFAULT_OPTIONS,\n      ...options,\n      ...localOptions\n    };\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    input.webkitdirectory = _options.directory;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    if (_options.reset)\n      reset();\n    input.click();\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset,\n    onChange\n  };\n}\n\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = options;\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker({ ...toValue(options), ..._options });\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker({ ...options, ..._options });\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    const type = toValue(dataType);\n    if (type === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    else if (type === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    else if (type === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => toValue(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false, focusVisible = false } = options;\n  const innerFocused = ref(false);\n  const targetElement = computed(() => unrefElement(target));\n  useEventListener(targetElement, \"focus\", (event) => {\n    var _a, _b;\n    if (!focusVisible || ((_b = (_a = event.target).matches) == null ? void 0 : _b.call(_a, \":focus-visible\")))\n      innerFocused.value = true;\n  });\n  useEventListener(targetElement, \"blur\", () => innerFocused.value = false);\n  const focused = computed({\n    get: () => innerFocused.value,\n    set(value) {\n      var _a, _b;\n      if (!value && innerFocused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      else if (value && !innerFocused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(\n    targetElement,\n    () => {\n      focused.value = initialValue;\n    },\n    { immediate: true, flush: \"post\" }\n  );\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst eventHandlers = [\n  \"fullscreenchange\",\n  \"webkitfullscreenchange\",\n  \"webkitendfullscreen\",\n  \"mozfullscreenchange\",\n  \"MSFullscreenChange\"\n];\nfunction useFullscreen(target, options = {}) {\n  const {\n    document = defaultDocument,\n    autoExit = false\n  } = options;\n  const targetRef = computed(() => {\n    var _a;\n    return (_a = unrefElement(target)) != null ? _a : document == null ? void 0 : document.querySelector(\"html\");\n  });\n  const isFullscreen = ref(false);\n  const requestMethod = computed(() => {\n    return [\n      \"requestFullscreen\",\n      \"webkitRequestFullscreen\",\n      \"webkitEnterFullscreen\",\n      \"webkitEnterFullScreen\",\n      \"webkitRequestFullScreen\",\n      \"mozRequestFullScreen\",\n      \"msRequestFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const exitMethod = computed(() => {\n    return [\n      \"exitFullscreen\",\n      \"webkitExitFullscreen\",\n      \"webkitExitFullScreen\",\n      \"webkitCancelFullScreen\",\n      \"mozCancelFullScreen\",\n      \"msExitFullscreen\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenEnabled = computed(() => {\n    return [\n      \"fullScreen\",\n      \"webkitIsFullScreen\",\n      \"webkitDisplayingFullscreen\",\n      \"mozFullScreen\",\n      \"msFullscreenElement\"\n    ].find((m) => document && m in document || targetRef.value && m in targetRef.value);\n  });\n  const fullscreenElementMethod = [\n    \"fullscreenElement\",\n    \"webkitFullscreenElement\",\n    \"mozFullScreenElement\",\n    \"msFullscreenElement\"\n  ].find((m) => document && m in document);\n  const isSupported = useSupported(() => targetRef.value && document && requestMethod.value !== void 0 && exitMethod.value !== void 0 && fullscreenEnabled.value !== void 0);\n  const isCurrentElementFullScreen = () => {\n    if (fullscreenElementMethod)\n      return (document == null ? void 0 : document[fullscreenElementMethod]) === targetRef.value;\n    return false;\n  };\n  const isElementFullScreen = () => {\n    if (fullscreenEnabled.value) {\n      if (document && document[fullscreenEnabled.value] != null) {\n        return document[fullscreenEnabled.value];\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[fullscreenEnabled.value]) != null) {\n          return Boolean(target2[fullscreenEnabled.value]);\n        }\n      }\n    }\n    return false;\n  };\n  async function exit() {\n    if (!isSupported.value || !isFullscreen.value)\n      return;\n    if (exitMethod.value) {\n      if ((document == null ? void 0 : document[exitMethod.value]) != null) {\n        await document[exitMethod.value]();\n      } else {\n        const target2 = targetRef.value;\n        if ((target2 == null ? void 0 : target2[exitMethod.value]) != null)\n          await target2[exitMethod.value]();\n      }\n    }\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value || isFullscreen.value)\n      return;\n    if (isElementFullScreen())\n      await exit();\n    const target2 = targetRef.value;\n    if (requestMethod.value && (target2 == null ? void 0 : target2[requestMethod.value]) != null) {\n      await target2[requestMethod.value]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    await (isFullscreen.value ? exit() : enter());\n  }\n  const handlerCallback = () => {\n    const isElementFullScreenValue = isElementFullScreen();\n    if (!isElementFullScreenValue || isElementFullScreenValue && isCurrentElementFullScreen())\n      isFullscreen.value = isElementFullScreenValue;\n  };\n  useEventListener(document, eventHandlers, handlerCallback, false);\n  useEventListener(() => unrefElement(targetRef), eventHandlers, handlerCallback, false);\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      ...gamepad,\n      id: gamepad.id,\n      hapticActuators,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = shallowRef(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Number.POSITIVE_INFINITY,\n    longitude: Number.POSITIVE_INFINITY,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(\n        updatePosition,\n        (err) => error.value = err,\n        {\n          enableHighAccuracy,\n          maximumAge,\n          timeout\n        }\n      );\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const reset = () => {\n    idle.value = false;\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  };\n  const onEvent = createFilterWrapper(\n    eventFilter,\n    () => {\n      lastActive.value = timestamp();\n      reset();\n    }\n  );\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n    reset();\n  }\n  return {\n    idle,\n    lastActive,\n    reset\n  };\n}\n\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes, class: clazz, loading, crossorigin, referrerPolicy } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    if (clazz)\n      img.className = clazz;\n    if (loading)\n      img.loading = loading;\n    if (crossorigin)\n      img.crossOrigin = crossorigin;\n    if (referrerPolicy)\n      img.referrerPolicy = referrerPolicy;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nfunction useImage(options, asyncStateOptions = {}) {\n  const state = useAsyncState(\n    () => loadImage(toValue(options)),\n    void 0,\n    {\n      resetOnExecute: true,\n      ...asyncStateOptions\n    }\n  );\n  watch(\n    () => toValue(options),\n    () => state.execute(asyncStateOptions.delay),\n    { deep: true }\n  );\n  return state;\n}\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\",\n    window = defaultWindow\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    if (!window)\n      return;\n    const _element = toValue(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? window.document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = toValue(_y)) != null ? _a : y.value,\n      left: (_b = toValue(_x)) != null ? _b : x.value,\n      behavior: toValue(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = (e) => {\n    if (!isScrolling.value)\n      return;\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  };\n  const onScrollEndDebounced = useDebounceFn(onScrollEnd, throttle + idle);\n  const setArrivedState = (target) => {\n    var _a;\n    if (!window)\n      return;\n    const el = target.document ? target.document.documentElement : (_a = target.documentElement) != null ? _a : target;\n    const { display, flexDirection } = getComputedStyle(el);\n    const scrollLeft = el.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalX.value;\n    const left = Math.abs(scrollLeft) <= 0 + (offset.left || 0);\n    const right = Math.abs(scrollLeft) + el.clientWidth >= el.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"row-reverse\") {\n      arrivedState.left = right;\n      arrivedState.right = left;\n    } else {\n      arrivedState.left = left;\n      arrivedState.right = right;\n    }\n    internalX.value = scrollLeft;\n    let scrollTop = el.scrollTop;\n    if (target === window.document && !scrollTop)\n      scrollTop = window.document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    const top = Math.abs(scrollTop) <= 0 + (offset.top || 0);\n    const bottom = Math.abs(scrollTop) + el.clientHeight >= el.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    if (display === \"flex\" && flexDirection === \"column-reverse\") {\n      arrivedState.top = bottom;\n      arrivedState.bottom = top;\n    } else {\n      arrivedState.top = top;\n      arrivedState.bottom = bottom;\n    }\n    internalY.value = scrollTop;\n  };\n  const onScrollHandler = (e) => {\n    var _a;\n    if (!window)\n      return;\n    const eventTarget = (_a = e.target.documentElement) != null ? _a : e.target;\n    setArrivedState(eventTarget);\n    isScrolling.value = true;\n    onScrollEndDebounced(e);\n    onScroll(e);\n  };\n  useEventListener(\n    element,\n    \"scroll\",\n    throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler,\n    eventListenerOptions\n  );\n  tryOnMounted(() => {\n    setArrivedState(toValue(element));\n  });\n  useEventListener(\n    element,\n    \"scrollend\",\n    onScrollEnd,\n    eventListenerOptions\n  );\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions,\n    measure() {\n      const _element = toValue(element);\n      if (window && _element)\n        setArrivedState(_element);\n    }\n  };\n}\n\nfunction resolveElement(el) {\n  if (typeof Window !== \"undefined\" && el instanceof Window)\n    return el.document.documentElement;\n  if (typeof Document !== \"undefined\" && el instanceof Document)\n    return el.documentElement;\n  return el;\n}\n\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a;\n  const {\n    direction = \"bottom\",\n    interval = 100\n  } = options;\n  const state = reactive(useScroll(\n    element,\n    {\n      ...options,\n      offset: {\n        [direction]: (_a = options.distance) != null ? _a : 0,\n        ...options.offset\n      }\n    }\n  ));\n  const promise = ref();\n  const isLoading = computed(() => !!promise.value);\n  const observedElement = computed(() => {\n    return resolveElement(toValue(element));\n  });\n  const isElementVisible = useElementVisibility(observedElement);\n  function checkAndLoad() {\n    state.measure();\n    if (!observedElement.value || !isElementVisible.value)\n      return;\n    const { scrollHeight, clientHeight, scrollWidth, clientWidth } = observedElement.value;\n    const isNarrower = direction === \"bottom\" || direction === \"top\" ? scrollHeight <= clientHeight : scrollWidth <= clientWidth;\n    if (state.arrivedState[direction] || isNarrower) {\n      if (!promise.value) {\n        promise.value = Promise.all([\n          onLoadMore(state),\n          new Promise((resolve) => setTimeout(resolve, interval))\n        ]).finally(() => {\n          promise.value = null;\n          nextTick(() => checkAndLoad());\n        });\n      }\n    }\n  }\n  watch(\n    () => [state.arrivedState[direction], isElementVisible.value],\n    checkAndLoad,\n    { immediate: true }\n  );\n  return {\n    isLoading\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(/* @__PURE__ */ new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = /* @__PURE__ */ new Set();\n  const usedKeys = /* @__PURE__ */ new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(\n    refs,\n    {\n      get(target2, prop, rec) {\n        if (typeof prop !== \"string\")\n          return Reflect.get(target2, prop, rec);\n        prop = prop.toLowerCase();\n        if (prop in aliasMap)\n          prop = aliasMap[prop];\n        if (!(prop in refs)) {\n          if (/[+_-]/.test(prop)) {\n            const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n            refs[prop] = computed(() => keys.every((key) => toValue(proxy[key])));\n          } else {\n            refs[prop] = ref(false);\n          }\n        }\n        const r = Reflect.get(target2, prop, rec);\n        return useReactive ? toValue(r) : r;\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction usingElRef(source, cb) {\n  if (toValue(source))\n    cb(toValue(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = {\n    ...defaultOptions,\n    ...options\n  };\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = typeof track === \"number\" ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = typeof track === \"number\" ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = toValue(target);\n    if (!el)\n      return;\n    const src = toValue(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (typeof src === \"string\")\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch([target, volume], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.volume = volume.value;\n  });\n  watch([target, muted], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.muted = muted.value;\n  });\n  watch([target, rate], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.playbackRate = rate.value;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = toValue(options.tracks);\n    const el = toValue(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = toValue(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = toValue(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(toValue(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, [\"waiting\", \"loadstart\"], () => {\n    waiting.value = true;\n    ignorePlayingUpdates(() => playing.value = false);\n  });\n  useEventListener(target, \"loadeddata\", () => waiting.value = false);\n  useEventListener(target, \"playing\", () => {\n    waiting.value = false;\n    ended.value = false;\n    ignorePlayingUpdates(() => playing.value = true);\n  });\n  useEventListener(target, \"ratechange\", () => rate.value = toValue(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = toValue(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    // Volume\n    volume,\n    muted,\n    // Tracks\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    // Picture in Picture\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    // Events\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nfunction getMapVue2Compat() {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n}\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(/* @__PURE__ */ new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nconst UseMouseBuiltinExtractors = {\n  page: (event) => [event.pageX, event.pageY],\n  client: (event) => [event.clientX, event.clientY],\n  screen: (event) => [event.screenX, event.screenY],\n  movement: (event) => event instanceof Touch ? null : [event.movementX, event.movementY]\n};\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    target = window,\n    scroll = true,\n    eventFilter\n  } = options;\n  let _prevMouseEvent = null;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const extractor = typeof type === \"function\" ? type : UseMouseBuiltinExtractors[type];\n  const mouseHandler = (event) => {\n    const result = extractor(event);\n    _prevMouseEvent = event;\n    if (result) {\n      [x.value, y.value] = result;\n      sourceType.value = \"mouse\";\n    }\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const result = extractor(event.touches[0]);\n      if (result) {\n        [x.value, y.value] = result;\n        sourceType.value = \"touch\";\n      }\n    }\n  };\n  const scrollHandler = () => {\n    if (!_prevMouseEvent || !window)\n      return;\n    const pos = extractor(_prevMouseEvent);\n    if (_prevMouseEvent instanceof MouseEvent && pos) {\n      x.value = pos[0] + window.scrollX;\n      y.value = pos[1] + window.scrollY;\n    }\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const mouseHandlerWrapper = eventFilter ? (event) => eventFilter(() => mouseHandler(event), {}) : (event) => mouseHandler(event);\n  const touchHandlerWrapper = eventFilter ? (event) => eventFilter(() => touchHandler(event), {}) : (event) => touchHandler(event);\n  const scrollHandlerWrapper = eventFilter ? () => eventFilter(() => scrollHandler(), {}) : () => scrollHandler();\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"mousemove\", \"dragover\"], mouseHandlerWrapper, listenerOptions);\n    if (touch && type !== \"movement\") {\n      useEventListener(target, [\"touchstart\", \"touchmove\"], touchHandlerWrapper, listenerOptions);\n      if (resetOnTouchEnds)\n        useEventListener(target, \"touchend\", reset, listenerOptions);\n    }\n    if (scroll && type === \"page\")\n      useEventListener(window, \"scroll\", scrollHandlerWrapper, { passive: true });\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const type = options.type || \"page\";\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch(\n      [targetRef, x, y],\n      () => {\n        const el = unrefElement(targetRef);\n        if (!el)\n          return;\n        const {\n          left,\n          top,\n          width,\n          height\n        } = el.getBoundingClientRect();\n        elementPositionX.value = left + (type === \"page\" ? window.pageXOffset : 0);\n        elementPositionY.value = top + (type === \"page\" ? window.pageYOffset : 0);\n        elementHeight.value = height;\n        elementWidth.value = width;\n        const elX = x.value - elementPositionX.value;\n        const elY = y.value - elementPositionY.value;\n        isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n        if (handleOutside || !isOutside.value) {\n          elementX.value = elX;\n          elementY.value = elY;\n        }\n      },\n      { immediate: true }\n    );\n    useEventListener(document, \"mouseleave\", () => {\n      isOutside.value = true;\n    });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    capture = false,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true, capture });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true, capture });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true, capture });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true, capture });\n    useEventListener(window, \"drop\", onReleased, { passive: true, capture });\n    useEventListener(window, \"dragend\", onReleased, { passive: true, capture });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true, capture });\n    useEventListener(window, \"touchend\", onReleased, { passive: true, capture });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true, capture });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nfunction useNavigatorLanguage(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n}\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(/* @__PURE__ */ new Date());\n  const update = () => now.value = /* @__PURE__ */ new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return {\n      now,\n      ...controls\n    };\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(\n    () => toValue(object),\n    (newObject) => {\n      release();\n      if (newObject)\n        url.value = URL.createObjectURL(newObject);\n    },\n    { immediate: true }\n  );\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  if (typeof value === \"function\" || isReadonly(value))\n    return computed(() => clamp(toValue(value), toValue(min), toValue(max)));\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, toValue(min), toValue(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, toValue(min), toValue(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Number.POSITIVE_INFINITY,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Number.POSITIVE_INFINITY);\n  const pageCount = computed(() => Math.max(\n    1,\n    Math.ceil(toValue(total) / toValue(currentPageSize))\n  ));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nfunction useParentElement(element = useCurrentElement()) {\n  const parentElement = shallowRef();\n  const update = () => {\n    const el = unrefElement(element);\n    if (el)\n      parentElement.value = el.parentElement;\n  };\n  tryOnMounted(update);\n  watch(() => toValue(element), update);\n  return parentElement;\n}\n\nfunction usePerformanceObserver(options, callback) {\n  const {\n    window = defaultWindow,\n    immediate = true,\n    ...performanceOptions\n  } = options;\n  const isSupported = useSupported(() => window && \"PerformanceObserver\" in window);\n  let observer;\n  const stop = () => {\n    observer == null ? void 0 : observer.disconnect();\n  };\n  const start = () => {\n    if (isSupported.value) {\n      stop();\n      observer = new PerformanceObserver(callback);\n      observer.observe(performanceOptions);\n    }\n  };\n  tryOnScopeDispose(stop);\n  if (immediate)\n    start();\n  return {\n    isSupported,\n    start,\n    stop\n  };\n}\n\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    const listenerOptions = { passive: true };\n    useEventListener(target, [\"pointerdown\", \"pointermove\", \"pointerup\"], handler, listenerOptions);\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, listenerOptions);\n  }\n  return {\n    ...toRefs(state),\n    isInside\n  };\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument, pointerLockOptions } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e, options2) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock(options2 != null ? options2 : pointerLockOptions);\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = toRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return distanceY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePrevious(value, initialValue) {\n  const previous = shallowRef(initialValue);\n  watch(\n    toRef(value),\n    (_, oldValue) => {\n      previous.value = oldValue;\n    },\n    { flush: \"sync\" }\n  );\n  return readonly(previous);\n}\n\nfunction useScreenOrientation(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported.value)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n}\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = toValue(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${toValue(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\" || style.overflowX === \"auto\" && ele.clientWidth < ele.scrollWidth || style.overflowY === \"auto\" && ele.clientHeight < ele.scrollHeight) {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nconst elInitialOverflow = /* @__PURE__ */ new WeakMap();\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(toRef(element), (el) => {\n    const target = resolveElement(toValue(el));\n    if (target) {\n      const ele = target;\n      if (!elInitialOverflow.get(ele))\n        elInitialOverflow.set(ele, initialOverflow);\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const el = resolveElement(toValue(element));\n    if (!el || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(\n        el,\n        \"touchmove\",\n        (e) => {\n          preventDefault(e);\n        },\n        { passive: false }\n      );\n    }\n    el.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    var _a;\n    const el = resolveElement(toValue(element));\n    if (!el || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    el.style.overflow = (_a = elInitialOverflow.get(el)) != null ? _a : \"\";\n    elInitialOverflow.delete(el);\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = {\n        ...toValue(shareOptions),\n        ...toValue(overrideOptions)\n      };\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...toValue(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(toValue(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = toRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = toValue(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = toValue(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = toRef(text || \"\");\n  const lang = toRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = toValue(lang);\n    utterance2.voice = toValue(options.voice) || null;\n    utterance2.pitch = toValue(pitch);\n    utterance2.rate = toValue(rate);\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  const stop = () => {\n    synth.cancel();\n    isPlaying.value = false;\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    stop,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = toValue(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else if (mergeDefaults) {\n        const value = await serializer.read(rawValue);\n        if (typeof mergeDefaults === \"function\")\n          data.value = mergeDefaults(value, rawInit);\n        else if (type === \"object\" && !Array.isArray(value))\n          data.value = { ...rawInit, ...value };\n        else\n          data.value = value;\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => Promise.resolve().then(() => read(e)));\n  if (storage) {\n    watchWithFilter(\n      data,\n      async () => {\n        try {\n          if (data.value == null)\n            await storage.removeItem(key);\n          else\n            await storage.setItem(key, await serializer.write(data.value));\n        } catch (e) {\n          onError(e);\n        }\n      },\n      {\n        flush,\n        deep,\n        eventFilter\n      }\n    );\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(\n      cssRef,\n      (value) => {\n        el.textContent = value;\n      },\n      { immediate: true }\n    );\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return \"none\";\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? \"left\" : \"right\";\n    } else {\n      return diffY.value > 0 ? \"up\" : \"down\";\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      if (e.touches.length !== 1)\n        return;\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, [\"touchend\", \"touchcancel\"], onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(\n      document.querySelector(selector),\n      () => dir.value = getValue(),\n      { attributes: true }\n    );\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  return Array.from({ length: rangeCount }, (_, i) => selection.getRangeAt(i));\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  const textareaScrollHeight = ref(1);\n  function triggerResize() {\n    var _a, _b;\n    if (!textarea.value)\n      return;\n    let height = \"\";\n    textarea.value.style.height = \"1px\";\n    textareaScrollHeight.value = (_a = textarea.value) == null ? void 0 : _a.scrollHeight;\n    if (options == null ? void 0 : options.styleTarget)\n      toValue(options.styleTarget).style.height = `${textareaScrollHeight.value}px`;\n    else\n      height = `${textareaScrollHeight.value}px`;\n    textarea.value.style.height = height;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], () => nextTick(triggerResize), { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, { ...options, eventFilter: filter });\n  return {\n    ...history\n  };\n}\n\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Number.POSITIVE_INFINITY, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nfunction DEFAULT_FORMATTER(date) {\n  return date.toISOString().slice(0, 10);\n}\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const { now, ...controls } = useNow({ interval: updateInterval, controls: true });\n  const timeAgo = computed(() => formatTimeAgo(new Date(toValue(time)), options, toValue(now)));\n  if (exposeControls) {\n    return {\n      timeAgo,\n      ...controls\n    };\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval, { immediate: false });\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return {\n      timestamp: ts,\n      ...controls\n    };\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument\n  } = options;\n  const title = toRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  const isReadonly = newTitle && typeof newTitle === \"function\";\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return typeof template === \"function\" ? template(t) : toValue(template).replace(/%s/g, t);\n  }\n  watch(\n    title,\n    (t, o) => {\n      if (t !== o && document)\n        document.title = format(typeof t === \"string\" ? t : \"\");\n    },\n    { immediate: true }\n  );\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver(\n      (_b = document.head) == null ? void 0 : _b.querySelector(\"title\"),\n      () => {\n        if (document && document.title !== title.value)\n          title.value = format(document.title);\n      },\n      { childList: true }\n    );\n  }\n  return title;\n}\n\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = /* @__PURE__ */ Object.assign({}, { linear: identity }, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction lerp(a, b, alpha) {\n  return a + alpha * (b - a);\n}\nfunction toVec(t) {\n  return (typeof t === \"number\" ? [t] : t) || [];\n}\nfunction executeTransition(source, from, to, options = {}) {\n  var _a, _b;\n  const fromVal = toValue(from);\n  const toVal = toValue(to);\n  const v1 = toVec(fromVal);\n  const v2 = toVec(toVal);\n  const duration = (_a = toValue(options.duration)) != null ? _a : 1e3;\n  const startedAt = Date.now();\n  const endAt = Date.now() + duration;\n  const trans = typeof options.transition === \"function\" ? options.transition : (_b = toValue(options.transition)) != null ? _b : identity;\n  const ease = typeof trans === \"function\" ? trans : createEasingFunction(trans);\n  return new Promise((resolve) => {\n    source.value = fromVal;\n    const tick = () => {\n      var _a2;\n      if ((_a2 = options.abort) == null ? void 0 : _a2.call(options)) {\n        resolve();\n        return;\n      }\n      const now = Date.now();\n      const alpha = ease((now - startedAt) / duration);\n      const arr = toVec(source.value).map((n, i) => lerp(v1[i], v2[i], alpha));\n      if (Array.isArray(source.value))\n        source.value = arr.map((n, i) => {\n          var _a3, _b2;\n          return lerp((_a3 = v1[i]) != null ? _a3 : 0, (_b2 = v2[i]) != null ? _b2 : 0, alpha);\n        });\n      else if (typeof source.value === \"number\")\n        source.value = arr[0];\n      if (now < endAt) {\n        requestAnimationFrame(tick);\n      } else {\n        source.value = toVal;\n        resolve();\n      }\n    };\n    tick();\n  });\n}\nfunction useTransition(source, options = {}) {\n  let currentId = 0;\n  const sourceVal = () => {\n    const v = toValue(source);\n    return typeof v === \"number\" ? v : v.map(toValue);\n  };\n  const outputRef = ref(sourceVal());\n  watch(sourceVal, async (to) => {\n    var _a, _b;\n    if (toValue(options.disabled))\n      return;\n    const id = ++currentId;\n    if (options.delay)\n      await promiseTimeout(toValue(options.delay));\n    if (id !== currentId)\n      return;\n    const toVal = Array.isArray(to) ? to.map(toValue) : toValue(to);\n    (_a = options.onStarted) == null ? void 0 : _a.call(options);\n    await executeTransition(outputRef, outputRef.value, toVal, {\n      ...options,\n      abort: () => {\n        var _a2;\n        return id !== currentId || ((_a2 = options.abort) == null ? void 0 : _a2.call(options));\n      }\n    });\n    (_b = options.onFinished) == null ? void 0 : _b.call(options);\n  }, { deep: true });\n  watch(() => toValue(options.disabled), (disabled) => {\n    if (disabled) {\n      currentId++;\n      outputRef.value = sourceVal();\n    }\n  });\n  tryOnScopeDispose(() => {\n    currentId++;\n  });\n  return computed(() => toValue(options.disabled) ? sourceVal() : outputRef.value);\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(\n    state,\n    () => {\n      const params = new URLSearchParams(\"\");\n      Object.keys(state).forEach((key) => {\n        const mapEntry = state[key];\n        if (Array.isArray(mapEntry))\n          mapEntry.forEach((value) => params.append(key, value));\n        else if (removeNullishValues && mapEntry == null)\n          params.delete(key);\n        else if (removeFalsyValues && !mapEntry)\n          params.delete(key);\n        else\n          params.set(key, mapEntry);\n      });\n      write(params);\n    },\n    { deep: true }\n  );\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(\n      window.history.state,\n      window.document.title,\n      window.location.pathname + constructQuery(params)\n    );\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const constraints = ref(options.constraints);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(type) {\n    switch (type) {\n      case \"video\": {\n        if (constraints.value)\n          return constraints.value.video || false;\n        break;\n      }\n      case \"audio\": {\n        if (constraints.value)\n          return constraints.value.audio || false;\n        break;\n      }\n    }\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(\"video\"),\n      audio: getDeviceOptions(\"audio\")\n    });\n    return stream.value;\n  }\n  function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(\n    enabled,\n    (v) => {\n      if (v)\n        _start();\n      else\n        _stop();\n    },\n    { immediate: true }\n  );\n  watch(\n    constraints,\n    () => {\n      if (autoSwitch.value && stream.value)\n        restart();\n    },\n    { immediate: true }\n  );\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    constraints,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue,\n    shouldEmit\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : typeof clone === \"function\" ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  const triggerEmit = (value) => {\n    if (shouldEmit) {\n      if (shouldEmit(value))\n        _emit(event, value);\n    } else {\n      _emit(event, value);\n    }\n  };\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    let isUpdating = false;\n    watch(\n      () => props[key],\n      (v) => {\n        if (!isUpdating) {\n          isUpdating = true;\n          proxy.value = cloneFn(v);\n          nextTick(() => isUpdating = false);\n        }\n      }\n    );\n    watch(\n      proxy,\n      (v) => {\n        if (!isUpdating && (v !== props[key] || deep))\n          triggerEmit(v);\n      },\n      { deep }\n    );\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        triggerEmit(value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props) {\n    ret[key] = useVModel(\n      props,\n      key,\n      emit,\n      options\n    );\n  }\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = toRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(\n      vibrate,\n      interval,\n      {\n        immediate: false,\n        immediateCallback: false\n      }\n    );\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nfunction useWakeLock(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n}\n\nfunction useWebNotification(options = {}) {\n  const {\n    window = defaultWindow,\n    requestPermissions: _requestForPermissions = true\n  } = options;\n  const defaultWebNotificationOptions = options;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const permissionGranted = ref(isSupported.value && \"permission\" in Notification && Notification.permission === \"granted\");\n  const notification = ref(null);\n  const ensurePermissions = async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionGranted.value && Notification.permission !== \"denied\") {\n      const result = await Notification.requestPermission();\n      if (result === \"granted\")\n        permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  };\n  const { on: onClick, trigger: clickTrigger } = createEventHook();\n  const { on: onShow, trigger: showTrigger } = createEventHook();\n  const { on: onError, trigger: errorTrigger } = createEventHook();\n  const { on: onClose, trigger: closeTrigger } = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value || !permissionGranted.value)\n      return;\n    const options2 = Object.assign({}, defaultWebNotificationOptions, overrides);\n    notification.value = new Notification(options2.title || \"\", options2);\n    notification.value.onclick = clickTrigger;\n    notification.value.onshow = showTrigger;\n    notification.value.onerror = errorTrigger;\n    notification.value.onclose = closeTrigger;\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  if (_requestForPermissions)\n    tryOnMounted(ensurePermissions);\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    ensurePermissions,\n    permissionGranted,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n}\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = toRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const close = (code = 1e3, reason) => {\n    if (!isClient || !wsRef.value)\n      return;\n    explicitlyClosed = true;\n    resetHeartbeat();\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed || typeof urlRef.value === \"undefined\")\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(\n      () => {\n        send(message, false);\n        if (pongTimeoutWait != null)\n          return;\n        pongTimeoutWait = setTimeout(() => {\n          close();\n          explicitlyClosed = false;\n        }, pongTimeout);\n      },\n      interval,\n      { immediate: false }\n    );\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    if (isClient)\n      useEventListener(\"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    if (!isClient && !isWorker)\n      return;\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = (...args) => {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(...args);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (typeof arg0 === \"string\")\n      worker.value = new Worker(arg0, workerOptions);\n    else if (typeof arg0 === \"function\")\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nfunction jobRunner(userFunc) {\n  return (e) => {\n    const userFuncArgs = e.data[0];\n    return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n      postMessage([\"SUCCESS\", result]);\n    }).catch((error) => {\n      postMessage([\"ERROR\", error]);\n    });\n  };\n}\n\nfunction depsParser(deps) {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n}\n\nfunction createWorkerBlobUrl(fn, deps) {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n}\n\nfunction useWebWorkerFn(fn, options = {}) {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      e.preventDefault();\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(\n        () => workerTerminate(\"TIMEOUT_EXPIRED\"),\n        timeout\n      );\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\n        \"[useWebWorkerFn] You can only run one instance of the worker at a time.\"\n      );\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n}\n\nfunction useWindowFocus(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll(options = {}) {\n  const { window = defaultWindow, behavior = \"auto\" } = options;\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const internalX = ref(window.scrollX);\n  const internalY = ref(window.scrollY);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo({ left: x2, behavior });\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo({ top: y2, behavior });\n    }\n  });\n  useEventListener(\n    window,\n    \"scroll\",\n    () => {\n      internalX.value = window.scrollX;\n      internalY.value = window.scrollY;\n    },\n    {\n      capture: false,\n      passive: true\n    }\n  );\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Number.POSITIVE_INFINITY,\n    initialHeight = Number.POSITIVE_INFINITY,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation) {\n    const matches = useMediaQuery(\"(orientation: portrait)\");\n    watch(matches, () => update());\n  }\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsPrimeFlex, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createReusableTemplate, createTemplatePromise, createUnrefFn, customStorageEventName, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, executeTransition, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAnimate, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useClipboardItems, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, useParentElement, usePerformanceObserver, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, usePrevious, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport type {AlignmentJustifyContent} from '../types'\n\nexport default (align: MaybeRefOrGetter<AlignmentJustifyContent | undefined>) =>\n  computed(() => {\n    const value = toValue(align)\n    return !value ? '' : `justify-content-${value}`\n  })\n","import type {Booleanish} from '../types'\nimport {computed, type ComputedRef, type MaybeRefOrGetter, toValue} from 'vue'\n\nconst isBooleanish = (input: unknown): input is Booleanish =>\n  typeof input === 'boolean' || input === '' || input === 'true' || input === 'false'\n\n/**\n * Resolves a Booleanish type reactively to type boolean\n */\nexport default <T>(el: MaybeRefOrGetter<T>): ComputedRef<T extends Booleanish ? boolean : T> =>\n  computed(() => {\n    const value = toValue(el)\n    return (\n      !isBooleanish(value)\n        ? value\n        : typeof value === 'boolean'\n        ? value\n        : value === '' || value === 'true'\n        ? true\n        : false\n    ) as T extends Booleanish ? boolean : T\n  })\n","import useBooleanish from './useBooleanish'\nimport type {AriaInvalid} from '../types'\nimport {computed, type MaybeRefOrGetter, toRef} from 'vue'\n\nexport default (\n  ariaInvalid: MaybeRefOrGetter<AriaInvalid | undefined>,\n  state: MaybeRefOrGetter<boolean | null | undefined>\n) => {\n  const resolvedAriaInvalid = useBooleanish(ariaInvalid)\n  const resolvedState = toRef(state)\n\n  return computed(() =>\n    resolvedAriaInvalid.value === true\n      ? 'true'\n      : typeof resolvedAriaInvalid.value === 'string'\n      ? resolvedAriaInvalid.value\n      : resolvedState.value === false\n      ? 'true'\n      : resolvedAriaInvalid.value === false\n      ? 'false'\n      : undefined\n  )\n}\n","import {computed, type MaybeRefOrGetter, toRef} from 'vue'\nimport {isLink, pick} from '../utils'\n\nexport default <T extends Record<string, unknown>, const B extends ReadonlyArray<PropertyKey>>(\n  props: MaybeRefOrGetter<T>,\n  pickProps?: MaybeRefOrGetter<B | (keyof T)[]>\n) => {\n  const pickPropsResolved = toRef(pickProps)\n  const resolvedProps = toRef(props)\n\n  const computedLink = toRef(() => isLink(resolvedProps.value))\n  const computedLinkProps = computed(() =>\n    computedLink.value\n      ? pick(\n          resolvedProps.value,\n          pickPropsResolved.value ?? [\n            'active',\n            'activeClass',\n            'append',\n            'href',\n            'rel',\n            'replace',\n            'routerComponentName',\n            'target',\n            'to',\n            'variant',\n            'opacity',\n            'opacityHover',\n            'underlineVariant',\n            'underlineOffset',\n            'underlineOffsetHover',\n            'underlineOpacity',\n            'underlineOpacityHover',\n          ]\n        )\n      : {}\n  )\n\n  return {computedLink, computedLinkProps}\n}\n","import {reactive} from 'vue'\nimport type {BreadcrumbItem} from '../types'\nimport {createGlobalState} from '@vueuse/core'\n\nexport default createGlobalState(() => {\n  const items = reactive<BreadcrumbItem[]>([])\n  const reset = (): void => {\n    items.splice(0, items.length)\n  }\n\n  return {items, reset}\n})\n","import {useColorMode, type UseColorModeOptions} from '@vueuse/core'\n\nexport interface ColorModeOptions extends UseColorModeOptions {\n  /**\n   * When set to true, useColorMode will automatically store itself and persist (default localstorage).\n   * @default false\n   */\n  persist?: boolean\n}\n\nexport default (opts: ColorModeOptions = {}) => {\n  const persist = opts.persist ?? false\n  const attribute = 'data-bs-theme'\n  const selector = 'body'\n  return useColorMode({\n    attribute,\n    selector,\n    storageKey:\n      persist === true\n        ? `bv-color-${opts.attribute ?? attribute}-${opts.selector ?? selector}`\n        : null,\n    ...opts,\n  })\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\nimport type {ColorExtendables} from '../types'\n\nexport default (obj: MaybeRefOrGetter<ColorExtendables>) =>\n  computed(() => {\n    const props = toValue(obj)\n    return {\n      [`text-bg-${props.variant}`]: props.variant !== null,\n      [`text-${props.textVariant}`]: props.textVariant !== null && props.variant === null,\n      [`bg-${props.bgVariant}`]: props.bgVariant !== null && props.variant === null,\n    }\n  })\n","import type {Breakpoint} from '../types'\nimport {computed, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (value: MaybeRefOrGetter<boolean | Breakpoint | 'fluid'>) =>\n  computed(() => {\n    const resolvedValue = toValue(value)\n    return {\n      container: resolvedValue === true,\n      [`container-${resolvedValue}`]: typeof resolvedValue === 'string',\n    }\n  })\n","import {useIntervalFn, type UseIntervalFnOptions} from '@vueuse/core'\nimport {type MaybeRefOrGetter, readonly, ref, type Ref, toRef, watch, watchEffect} from 'vue'\n\ntype VoidFn = () => void\n\ninterface CountdownReturn {\n  isActive: Readonly<Ref<boolean>>\n  isPaused: Readonly<Ref<boolean>>\n  restart: VoidFn\n  stop: VoidFn\n  resume: VoidFn\n  pause: VoidFn\n  value: Readonly<Ref<number>>\n}\n\n/**\n * A simple interval timer that counts down the remaining seconds\n *\n * @param {MaybeRefOrGetter<number>} length the total amount of time to loop through in ms\n * @param {MaybeRefOrGetter<number>} interval how often the interval should refresh. Default 1000\n * @param {UseIntervalFnOptions} intervalOpts opts to pass to the interval fn. Default {}\n * @important ensure that you call `stop()` before unmount in the component\n */\nexport default (\n  length: MaybeRefOrGetter<number>,\n  interval: MaybeRefOrGetter<number> = ref(1000),\n  intervalOpts: UseIntervalFnOptions = {}\n): CountdownReturn => {\n  const resolvedLength = readonly(toRef(length))\n\n  const resolvedInterval = readonly(toRef(interval))\n\n  const isPaused = ref(false)\n\n  const intervalsPassed = ref(0)\n\n  const amountOfIntervals = toRef(() => Math.ceil(resolvedLength.value / resolvedInterval.value))\n\n  const value = toRef(() =>\n    isActive.value || isPaused.value\n      ? Math.round(resolvedLength.value - intervalsPassed.value * resolvedInterval.value)\n      : 0\n  )\n\n  const {pause, resume, isActive} = useIntervalFn(\n    () => {\n      intervalsPassed.value = intervalsPassed.value + 1\n    },\n    interval,\n    intervalOpts\n  )\n\n  const restart = () => {\n    isPaused.value = false\n    intervalsPassed.value = 0\n    resume()\n  }\n\n  const stop = () => {\n    isPaused.value = false\n    intervalsPassed.value = amountOfIntervals.value\n    // pause() // Only here for the sake of demonstrating the flow. It will be called in the watchEffect\n  }\n  watchEffect(() => {\n    if (intervalsPassed.value > amountOfIntervals.value) {\n      intervalsPassed.value = amountOfIntervals.value\n    }\n    if (intervalsPassed.value === amountOfIntervals.value) {\n      pause()\n    }\n  })\n\n  watch([resolvedInterval, resolvedLength], () => {\n    stop()\n    restart()\n  })\n\n  const myPause = () => {\n    if (isActive.value === false) return\n    isPaused.value = true\n    pause()\n  }\n\n  const myResume = () => {\n    if (intervalsPassed.value === amountOfIntervals.value) return\n    isPaused.value = false\n    resume()\n  }\n\n  return {\n    isActive: readonly(isActive),\n    isPaused: readonly(isPaused),\n    restart,\n    stop,\n    pause: myPause,\n    resume: myResume,\n    value,\n  }\n}\n","import {computed, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (value: MaybeRefOrGetter<boolean | null>) =>\n  computed(() => {\n    const resolvedValue = toValue(value)\n\n    return resolvedValue === true ? 'is-valid' : resolvedValue === false ? 'is-invalid' : null\n  })\n","import type {AriaInvalid, ButtonVariant, Size} from '../types'\nimport {computed, type MaybeRefOrGetter, toRef, toValue} from 'vue'\nimport useAriaInvalid from './useAriaInvalid'\nimport useStateClass from './useStateClass'\n\ninterface ClassesItemsInput {\n  plain?: boolean\n  button?: boolean\n  inline?: boolean\n  switch?: boolean\n  size?: Size\n}\n\nconst getClasses = (items: MaybeRefOrGetter<ClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check': resolvedItems.plain === false && resolvedItems.button === false,\n      'form-check-inline': resolvedItems.inline === true,\n      'form-switch': resolvedItems.switch === true,\n      [`form-control-${resolvedItems.size}`]:\n        resolvedItems.size !== undefined &&\n        resolvedItems.size !== 'md' &&\n        resolvedItems.button === false,\n    }\n  })\n\ninterface InputClassesItemsInput {\n  plain?: boolean\n  button?: boolean\n  state?: boolean | null\n}\n\nconst getInputClasses = (items: MaybeRefOrGetter<InputClassesItemsInput>) => {\n  const resolvedItems = toRef(items)\n\n  const stateClass = useStateClass(() => resolvedItems.value.state ?? null)\n\n  return computed(() => [\n    stateClass.value,\n    {\n      'form-check-input':\n        resolvedItems.value.plain === false && resolvedItems.value.button === false,\n      'btn-check': resolvedItems.value.button === true,\n    },\n  ])\n}\n\ninterface LabelClasesItemsInput {\n  plain?: boolean\n  button?: boolean\n  buttonVariant?: ButtonVariant | null\n  size?: Size\n}\n\nconst getLabelClasses = (items: MaybeRefOrGetter<LabelClasesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'form-check-label': resolvedItems.plain === false && resolvedItems.button === false,\n      'btn': resolvedItems.button === true,\n      [`btn-${resolvedItems.buttonVariant}`]:\n        resolvedItems.button === true &&\n        resolvedItems.buttonVariant !== undefined &&\n        resolvedItems.buttonVariant !== null,\n      [`btn-${resolvedItems.size}`]:\n        resolvedItems.button && resolvedItems.size && resolvedItems.size !== 'md',\n    }\n  })\n\ninterface GroupAttrItemsInput {\n  required?: boolean\n  ariaInvalid?: AriaInvalid\n  state?: boolean | null\n}\n\nconst getGroupAttr = (items: MaybeRefOrGetter<GroupAttrItemsInput>) => {\n  const resolvedItems = toRef(items)\n  const computedAriaInvalid = useAriaInvalid(\n    () => resolvedItems.value.ariaInvalid,\n    () => resolvedItems.value.state\n  )\n  return computed(() => ({\n    'aria-invalid': computedAriaInvalid.value as Exclude<AriaInvalid, ''> | undefined,\n    'aria-required': resolvedItems.value.required === true ? true : undefined,\n  }))\n}\n\ninterface GroupClassesItemsInput {\n  validated?: boolean\n  buttons?: boolean\n  stacked?: boolean\n  size?: Size\n}\n\nconst getGroupClasses = (items: MaybeRefOrGetter<GroupClassesItemsInput>) =>\n  computed(() => {\n    const resolvedItems = toValue(items)\n    return {\n      'was-validated': resolvedItems.validated === true,\n      'btn-group': resolvedItems.buttons === true && resolvedItems.stacked === false,\n      'btn-group-vertical': resolvedItems.stacked === true && resolvedItems.buttons === true,\n      [`btn-group-${resolvedItems.size}`]: resolvedItems.size !== undefined,\n    }\n  })\n\nexport {getClasses, getInputClasses, getLabelClasses, getGroupAttr, getGroupClasses}\n","import {getId} from '../utils'\nimport {computed, type ComputedRef, type MaybeRefOrGetter, toValue} from 'vue'\n\nexport default (id?: MaybeRefOrGetter<string | undefined>, suffix?: string): ComputedRef<string> =>\n  computed(() => toValue(id) || getId(suffix))\n","import type {AriaInvalid, Booleanish, Size} from '../types'\nimport {nextTick, onActivated, onMounted, ref} from 'vue'\nimport useAriaInvalid from './useAriaInvalid'\nimport useBooleanish from './useBooleanish'\nimport useId from './useId'\nimport {useDebounceFn, useFocus, useToNumber, useVModel} from '@vueuse/core'\n\nexport interface CommonInputProps {\n  ariaInvalid?: AriaInvalid\n  autocomplete?: string\n  autofocus?: Booleanish\n  disabled?: Booleanish\n  form?: string\n  debounce?: string | number\n  debounceMaxWait?: string | number\n  formatter?: (val: string, evt: Event) => string\n  id?: string\n  lazy?: Booleanish\n  lazyFormatter?: Booleanish\n  list?: string\n  modelValue?: string | number\n  name?: string\n  number?: Booleanish\n  placeholder?: string\n  plaintext?: Booleanish\n  readonly?: Booleanish\n  required?: Booleanish\n  size?: Size\n  state?: Booleanish | null | undefined\n  trim?: Booleanish\n}\n\nexport default (\n  props: Readonly<CommonInputProps>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  emit: ((evt: 'update:modelValue', val: any) => void) &\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ((evt: 'change', val: any) => void) &\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ((evt: 'blur', val: any) => void) &\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ((evt: 'input', val: any) => void)\n) => {\n  const input = ref<HTMLInputElement | null>(null)\n\n  const modelValue = useVModel(props, 'modelValue', emit)\n\n  const computedId = useId(() => props.id, 'input')\n  const autofocusBoolean = useBooleanish(() => props.autofocus)\n  const disabledBoolean = useBooleanish(() => props.disabled)\n  const lazyBoolean = useBooleanish(() => props.lazy)\n  const lazyFormatterBoolean = useBooleanish(() => props.lazyFormatter)\n  const numberBoolean = useBooleanish(() => props.number)\n  const stateBoolean = useBooleanish(() => props.state)\n  const trimBoolean = useBooleanish(() => props.trim)\n  const debounceNumber = useToNumber(() => props.debounce ?? 0)\n  const debounceMaxWaitNumber = useToNumber(() => props.debounceMaxWait ?? NaN)\n\n  const internalUpdateModelValue = useDebounceFn(\n    (value: string | number | undefined) => {\n      modelValue.value = value\n    },\n    () => (lazyBoolean.value === true ? 0 : debounceNumber.value),\n    {maxWait: () => (lazyBoolean.value === true ? NaN : debounceMaxWaitNumber.value)}\n  )\n\n  const updateModelValue = (value: string | number | undefined, force = false) => {\n    if (lazyBoolean.value === true && force === false) return\n    internalUpdateModelValue(value)\n  }\n\n  const {focused} = useFocus(input, {\n    initialValue: autofocusBoolean.value,\n  })\n\n  const _formatValue = (value: string, evt: Event, force = false) => {\n    if (props.formatter !== undefined && (!lazyFormatterBoolean.value || force)) {\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n\n  const _getModelValue = (value: string) => {\n    if (trimBoolean.value) return value.trim()\n    if (numberBoolean.value) return Number.parseFloat(value)\n\n    return value\n  }\n\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = modelValue.value?.toString() ?? ''\n    }\n  })\n\n  onActivated(() => {\n    nextTick(() => {\n      if (autofocusBoolean.value) {\n        focused.value = true\n      }\n    })\n  })\n\n  const computedAriaInvalid = useAriaInvalid(() => props.ariaInvalid, stateBoolean)\n\n  const onInput = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = _getModelValue(formattedValue)\n\n    updateModelValue(nextModel)\n\n    emit('input', formattedValue)\n  }\n\n  const onChange = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    const nextModel = _getModelValue(formattedValue)\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n\n    emit('change', formattedValue)\n  }\n\n  const onBlur = (evt: FocusEvent) => {\n    emit('blur', evt)\n    if (!lazyBoolean.value && !lazyFormatterBoolean.value) return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    const nextModel = _getModelValue(formattedValue)\n    if (modelValue.value !== nextModel) {\n      updateModelValue(formattedValue, true)\n    }\n  }\n\n  const focus = () => {\n    if (!disabledBoolean.value) {\n      focused.value = true\n    }\n  }\n\n  const blur = () => {\n    if (!disabledBoolean.value) {\n      focused.value = false\n    }\n  }\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n  }\n}\n","// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _getNested = (obj: any, path: string): any => {\n  if (!obj) return obj\n  if (path in obj) return obj[path]\n\n  const paths = path.split('.')\n\n  return _getNested(obj[paths[0]], paths.splice(1).join('.'))\n}\n\nconst _normalizeOption = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  option: any,\n  key: string | null = null,\n  componentName: string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  props: any\n) => {\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    const value = _getNested(option, props.valueField)\n    const text = _getNested(option, props.textField)\n    const html = _getNested(option, props.htmlField)\n    const disabled = _getNested(option, props.disabledField)\n\n    const options = option[props.optionsField] || null\n    if (options !== null) {\n      return {\n        label: String(_getNested(option, props.labelField) || text),\n        options: normalizeOptions(options, componentName, props),\n      }\n    }\n\n    return {\n      value: typeof value === 'undefined' ? key || text : value,\n      text: String(typeof text === 'undefined' ? key : text),\n      html,\n      disabled: Boolean(disabled),\n    }\n  }\n  return {\n    value: key || option,\n    text: String(option),\n    disabled: false,\n  }\n}\n\nconst normalizeOptions = (\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  options: any[],\n  componentName: string,\n  props: Record<string, unknown>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any => {\n  if (Array.isArray(options)) {\n    return options.map((option) => _normalizeOption(option, null, componentName, props))\n  } else if (Object.prototype.toString.call(options) === '[object Object]') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `[BootstrapVue warn]: ${componentName} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`\n    )\n\n    return Object.keys(options).map((key: string) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const el: any = options[key]\n      switch (typeof el) {\n        case 'object':\n          return _normalizeOption(el.text, String(el.value), componentName, props)\n        default:\n          return _normalizeOption(el, String(key), componentName, props)\n      }\n    })\n  }\n\n  return []\n}\n\nexport default normalizeOptions\n","import {createSharedComposable, getSSRHandler, tryOnScopeDispose, unrefElement} from '@vueuse/core'\nimport {\n  type ComponentInternalInstance,\n  computed,\n  getCurrentInstance,\n  type Ref,\n  shallowRef,\n  toRef,\n  watch,\n} from 'vue'\n\nconst modalOpenClassName = 'modal-open'\n\nexport const useSharedModalStack = createSharedComposable(() => {\n  /**\n   * A collection of all currently active modals\n   */\n  const stack: Ref<ComponentInternalInstance[]> = shallowRef([])\n\n  const countStack = toRef(() => stack.value.length)\n  const lastStack = toRef(() => stack.value[stack.value.length - 1])\n\n  const pushStack = (modal: ComponentInternalInstance) => {\n    stack.value = [...stack.value, modal]\n  }\n  const removeStack = (modal: ComponentInternalInstance) => {\n    stack.value = stack.value.filter((item) => item.uid !== modal.uid)\n  }\n\n  /**\n   * A collection of all registered modals\n   */\n  const registry: Ref<ComponentInternalInstance[]> = shallowRef([])\n\n  // Utility getters not made, would not be used (count, last)\n\n  const pushRegistry = (modal: ComponentInternalInstance) => {\n    registry.value = [...registry.value, modal]\n  }\n  const removeRegistry = (modal: ComponentInternalInstance) => {\n    registry.value = registry.value.filter((item) => item.uid !== modal.uid)\n  }\n\n  /**\n   * Removes an item from both the stack and registry\n   */\n  const dispose = (modal: ComponentInternalInstance): void => {\n    removeStack(modal)\n    removeRegistry(modal)\n  }\n\n  const updateHTMLAttrs = getSSRHandler('updateHTMLAttrs', (selector, attribute, value) => {\n    const el =\n      typeof selector === 'string'\n        ? window?.document.querySelector(selector)\n        : unrefElement(selector)\n    if (!el) return\n\n    if (attribute === 'class') {\n      el.classList.toggle(modalOpenClassName, value === modalOpenClassName)\n    } else {\n      el.setAttribute(attribute, value)\n    }\n  })\n\n  tryOnScopeDispose(() => {\n    updateHTMLAttrs('body', 'class', '')\n  })\n\n  watch(countStack, (newValue) => {\n    updateHTMLAttrs('body', 'class', newValue > 0 ? modalOpenClassName : '')\n  })\n\n  return {\n    registry,\n    stack,\n    lastStack,\n    countStack,\n    pushStack,\n    removeStack,\n    pushRegistry,\n    removeRegistry,\n    dispose,\n  }\n})\n\nexport default (modalOpen: Ref<boolean>) => {\n  const {pushRegistry, pushStack, removeStack, stack, dispose, countStack} = useSharedModalStack()\n\n  const currentModal = getCurrentInstance()\n\n  if (!currentModal || currentModal.type.__name !== 'BModal') {\n    throw new Error('useModalManager must only use in BModal component')\n  }\n\n  pushRegistry(currentModal)\n\n  tryOnScopeDispose(() => {\n    dispose(currentModal)\n  })\n\n  watch(\n    modalOpen,\n    (newValue, oldValue) => {\n      if (newValue) {\n        pushStack(currentModal)\n      } else if (oldValue && !newValue) {\n        removeStack(currentModal)\n      }\n    },\n    {immediate: true}\n  )\n\n  return {\n    activePosition: computed(() =>\n      stack.value.findIndex((el) => el.exposed?.id === currentModal.exposed?.id)\n    ),\n    activeModalCount: countStack,\n  }\n}\n","import {\n  type ComponentInternalInstance,\n  computed,\n  getCurrentInstance,\n  type MaybeRefOrGetter,\n  toRef,\n  toValue,\n} from 'vue'\nimport {useSharedModalStack} from './useModalManager'\n\nexport default (id: MaybeRefOrGetter<string | undefined> = undefined) => {\n  const {registry} = useSharedModalStack()\n  const instance = getCurrentInstance()\n\n  const modalComponent = computed(() => {\n    const resolvedId = toValue(id)\n    if (resolvedId) {\n      return registry.value.find((modal) => modal.exposed?.id.value === resolvedId) || null\n    }\n\n    if (!instance) {\n      return null\n    }\n\n    return findBModal(instance)\n  })\n\n  const modal = toRef(() => modalComponent.value?.proxy)\n\n  return {\n    show() {\n      modalComponent.value?.exposed?.show()\n    },\n    hide(trigger = '') {\n      modalComponent.value?.exposed?.hide(trigger)\n    },\n    modal,\n  }\n}\n\nconst findBModal = (component: ComponentInternalInstance): ComponentInternalInstance | null => {\n  if (!component.parent) {\n    return null\n  }\n\n  if (component.parent.type.__name === 'BModal') {\n    return component.parent\n  }\n\n  return findBModal(component.parent)\n}\n","import {useSharedModalStack} from './useModalManager'\n\nexport default () => {\n  const {lastStack, stack} = useSharedModalStack()\n\n  const hide = (trigger = '') => {\n    if (lastStack.value) {\n      lastStack.value.exposed?.hide(trigger)\n    }\n  }\n\n  const hideAll = (trigger = '') => {\n    for (const modal of stack.value) {\n      modal.exposed?.hide(trigger)\n    }\n  }\n\n  return {\n    hide,\n    hideAll,\n    // Todo: Supports listening events globally in the future\n  }\n}\n","import {computed, type MaybeRefOrGetter, readonly, toRef} from 'vue'\nimport type {RadiusElement, RadiusElementExtendables} from '../types'\nimport useBooleanish from './useBooleanish'\n\nexport default (obj: MaybeRefOrGetter<RadiusElementExtendables>) => {\n  const resolveRadiusElement = (\n    value: boolean | RadiusElement,\n    str: 'top' | 'bottom' | 'start' | 'end' | null\n  ): string => {\n    const strValue = str === null ? '' : `${str}-`\n\n    return value === 'circle'\n      ? `${strValue}rounded-circle`\n      : value === 'pill'\n      ? `${strValue}rounded-pill`\n      : typeof value === 'number' ||\n        value === '0' ||\n        value === '1' ||\n        value === '2' ||\n        value === '3' ||\n        value === '4' ||\n        value === '5'\n      ? `${strValue}rounded-${value}`\n      : value === 'none'\n      ? `${strValue}rounded-0`\n      : value === 'sm'\n      ? `${strValue}rounded-1`\n      : value === 'lg'\n      ? `${strValue}rounded-5`\n      : `${strValue}rounded` // true is last\n  }\n\n  const props = readonly(toRef(obj))\n  const roundedBoolean = useBooleanish(() => props.value.rounded)\n  const roundedTopBoolean = useBooleanish(() => props.value.roundedTop)\n  const roundedBottomBoolean = useBooleanish(() => props.value.roundedBottom)\n  const roundedStartBoolean = useBooleanish(() => props.value.roundedStart)\n  const roundedEndBoolean = useBooleanish(() => props.value.roundedEnd)\n  return computed(() => ({\n    [`${resolveRadiusElement(roundedBoolean.value as boolean | RadiusElement, null)}`]:\n      !!roundedBoolean.value,\n    [`${resolveRadiusElement(roundedTopBoolean.value as boolean | RadiusElement, 'top')}`]:\n      !!roundedTopBoolean.value,\n    [`${resolveRadiusElement(roundedBottomBoolean.value as boolean | RadiusElement, 'bottom')}`]:\n      !!roundedBottomBoolean.value,\n    [`${resolveRadiusElement(roundedStartBoolean.value as boolean | RadiusElement, 'start')}`]:\n      !!roundedStartBoolean.value,\n    [`${resolveRadiusElement(roundedEndBoolean.value as boolean | RadiusElement, 'end')}`]:\n      !!roundedEndBoolean.value,\n  }))\n}\n","import {type MaybeRefOrGetter, onMounted, readonly, toRef, watch} from 'vue'\nimport {useScrollLock} from '@vueuse/core'\n\nexport default (isOpen: MaybeRefOrGetter<boolean>, bodyScroll: MaybeRefOrGetter<boolean>) => {\n  const resolvedIsOpen = readonly(toRef(isOpen))\n  const resolvedBodyScrolling = readonly(toRef(bodyScroll))\n\n  /**\n   * We use the inverse because bodyScrolling === true means we allow scrolling, while bodyScrolling === false means we disallow\n   */\n  const inverseBodyScrollingValue = toRef(() => !resolvedBodyScrolling.value)\n\n  onMounted(() => {\n    const isLocked = useScrollLock(\n      document.body,\n      resolvedIsOpen.value && inverseBodyScrollingValue.value\n    )\n\n    watch([resolvedIsOpen, inverseBodyScrollingValue], ([modelVal, bodyVal]) => {\n      isLocked.value = modelVal && bodyVal\n    })\n  })\n}\n","import {createGlobalState} from '@vueuse/core'\nimport {ref} from 'vue'\nimport type {Toast} from '../types'\n\nconst posDefault = 'top-right'\n\nexport default createGlobalState(() => {\n  const toasts = ref<(Toast & {self: symbol})[]>([])\n\n  /**\n   * @returns {symbol} A symbol that corresponds to its unique id. You can pass this id to the hide function to force a Toast to hide\n   */\n  const show = (...[el, obj]: [el: string, obj?: Omit<Toast, 'body'>] | [el: Toast]): symbol => {\n    const payload: Toast = {pos: posDefault}\n    if (typeof el === 'string') {\n      Object.assign(payload, obj, {\n        body: el,\n        value: obj?.value || 5000,\n      } satisfies Toast)\n    } else {\n      Object.assign(payload, el, {value: el.value || 5000} satisfies Toast)\n    }\n    const self = Symbol()\n\n    toasts.value.push({...payload, self})\n\n    return self\n  }\n\n  /**\n   * You can get the symbol param from the return value from the show method\n   */\n  const hide = (self: symbol) => {\n    const ind = toasts.value.findIndex((el) => el.self === self)\n    if (ind === -1) return\n    toasts.value.splice(ind, 1)\n  }\n\n  return {toasts, show, hide}\n})\n","<template>\n  <span ref=\"placeholder\" />\n  <slot name=\"target\" :show=\"show\" :hide=\"hide\" :toggle=\"toggle\" :show-state=\"showState\" />\n  <Teleport :to=\"container\" :disabled=\"!container\">\n    <div\n      v-if=\"showStateInternal || persistentBoolean\"\n      :id=\"id\"\n      v-bind=\"$attrs\"\n      ref=\"element\"\n      :class=\"computedClasses\"\n      role=\"tooltip\"\n      tabindex=\"-1\"\n      :style=\"floatingStyles\"\n    >\n      <div\n        ref=\"arrow\"\n        :class=\"`${tooltipBoolean ? 'tooltip' : 'popover'}-arrow`\"\n        :style=\"arrowStyle\"\n        data-popper-arrow\n      />\n      <div class=\"overflow-auto\" :style=\"sizeStyles\">\n        <template v-if=\"title || $slots.title\">\n          <div\n            v-if=\"!isHtml\"\n            class=\"position-sticky top-0\"\n            :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-header'\"\n          >\n            <slot name=\"title\">\n              {{ title }}\n            </slot>\n          </div>\n          <!-- eslint-disable vue/no-v-html -->\n          <div\n            v-else\n            class=\"position-sticky top-0\"\n            :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-header'\"\n            v-html=\"sanitizedTitle\"\n          />\n          <!-- eslint-enable vue/no-v-html -->\n        </template>\n        <template v-if=\"(tooltipBoolean && !$slots.title && !title) || !tooltipBoolean\">\n          <div v-if=\"!isHtml\" :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-body'\">\n            <slot>\n              {{ content }}\n            </slot>\n          </div>\n          <!-- eslint-disable vue/no-v-html -->\n          <div\n            v-else\n            :class=\"tooltipBoolean ? 'tooltip-inner' : 'popover-body'\"\n            v-html=\"sanitizedContent\"\n          />\n          <!-- eslint-enable vue/no-v-html -->\n        </template>\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  type Alignment,\n  arrow as arrowMiddleware,\n  autoPlacement,\n  autoUpdate,\n  type Boundary,\n  flip,\n  hide as hideMiddleware,\n  inline as inlineMiddleware,\n  type Middleware,\n  offset as offsetMiddleware,\n  type Placement as OriginalPlacement,\n  type RootBoundary,\n  shift,\n  size as sizeMiddleware,\n  useFloating,\n} from '@floating-ui/vue'\nimport {\n  BvTriggerableEvent,\n  getTransitionDelay,\n  IS_BROWSER,\n  resolveBootstrapPlacement,\n} from '../utils'\nimport {DefaultAllowlist, sanitizeHtml} from '../utils/sanitizer'\nimport {onClickOutside, useMouseInElement, useToNumber} from '@vueuse/core'\nimport {\n  type ComponentPublicInstance,\n  computed,\n  type CSSProperties,\n  type MaybeRef,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  toRef,\n  unref,\n  watch,\n  watchEffect,\n} from 'vue'\nimport {useBooleanish, useId} from '../composables'\nimport type {BPopoverProps} from '../types'\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(defineProps<BPopoverProps>(), {\n  boundary: 'clippingAncestors',\n  boundaryPadding: undefined,\n  click: false,\n  container: undefined,\n  content: undefined,\n  customClass: '',\n  delay: () => ({show: 100, hide: 300}),\n  floatingMiddleware: undefined,\n  hide: undefined,\n  html: false,\n  id: undefined,\n  inline: false,\n  manual: false,\n  modelValue: false,\n  noAutoClose: false,\n  noFade: false,\n  noFlip: false,\n  noHide: false,\n  noShift: false,\n  noSize: false,\n  noninteractive: false,\n  offset: null,\n  placement: 'top',\n  realtime: false,\n  reference: null,\n  strategy: 'absolute',\n  target: null,\n  title: undefined,\n  tooltip: false,\n  variant: null,\n  persistent: false,\n})\n\nconst emit = defineEmits<{\n  'hidden': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': [value: BvTriggerableEvent]\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  target?: (props: {\n    show: () => void\n    hide: (e: Event) => void\n    toggle: (e: Event) => void\n    showState: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst modelValueBoolean = useBooleanish(() => props.modelValue)\nconst showState = ref(modelValueBoolean.value)\nconst showStateInternal = ref(modelValueBoolean.value)\nwatchEffect(() => {\n  emit('update:modelValue', showState.value)\n})\n\nwatch(modelValueBoolean, () => {\n  if (modelValueBoolean.value === showState.value) return\n  modelValueBoolean.value ? show() : hide(new Event('update:modelValue'))\n})\n\nconst computedId = useId(() => props.id, 'popover')\n\nconst clickBoolean = useBooleanish(() => props.click)\nconst manualBoolean = useBooleanish(() => props.manual)\nconst noShiftBoolean = useBooleanish(() => props.noShift)\nconst noSizeBoolean = useBooleanish(() => props.noSize)\nconst noFlipBoolean = useBooleanish(() => props.noFlip)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst noAutoCloseBoolean = useBooleanish(() => props.noAutoClose)\nconst noHideBoolean = useBooleanish(() => props.noHide)\nconst realtimeBoolean = useBooleanish(() => props.realtime)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst persistentBoolean = useBooleanish(() => props.persistent)\nconst tooltipBoolean = useBooleanish(() => props.tooltip)\nconst noninteractiveBoolean = useBooleanish(() => props.noninteractive)\nconst isHtml = useBooleanish(() => props.html)\n\nconst hidden = ref(false)\n\nconst element = ref<HTMLElement | null>(null)\nconst targetTrigger = ref<HTMLElement | null>(null)\nconst arrow = ref<HTMLElement | null>(null)\nconst trigger = ref<HTMLElement | null>(null)\nconst placeholder = ref<HTMLElement | null>(null)\n\nconst sanitizedTitle = computed(() =>\n  props.title ? sanitizeHtml(props.title, DefaultAllowlist) : ''\n)\n\nconst sanitizedContent = computed(() =>\n  props.content ? sanitizeHtml(props.content, DefaultAllowlist) : ''\n)\nconst isAutoPlacement = toRef(() => props.placement.startsWith('auto'))\nconst offsetNumber = useToNumber(() => props.offset ?? NaN)\n\nconst boundary = computed<Boundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? undefined : props.boundary\n)\nconst rootBoundary = computed<RootBoundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? props.boundary : undefined\n)\n\nconst sizeStyles = ref<CSSProperties>({})\nconst floatingMiddleware = computed<Middleware[]>(() => {\n  if (props.floatingMiddleware !== undefined) {\n    return props.floatingMiddleware\n  }\n  const off = props.offset !== null ? offsetNumber.value : tooltipBoolean.value ? 6 : 8\n  const arr: Middleware[] = [offsetMiddleware(off)]\n  if (noFlipBoolean.value === false && !isAutoPlacement.value) {\n    arr.push(\n      flip({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (isAutoPlacement.value) {\n    arr.push(\n      autoPlacement({\n        alignment: (props.placement.split('-')[1] as Alignment) || undefined,\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (noShiftBoolean.value === false) {\n    arr.push(\n      shift({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (noHideBoolean.value === false) {\n    arr.push(\n      hideMiddleware({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (inlineBoolean.value === true) {\n    arr.push(inlineMiddleware())\n  }\n  arr.push(arrowMiddleware({element: arrow, padding: 10}))\n  if (noSizeBoolean.value === false) {\n    arr.push(\n      sizeMiddleware({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n        apply({availableWidth, availableHeight}) {\n          sizeStyles.value = {\n            maxHeight: availableHeight ? `${availableHeight}px` : undefined,\n            maxWidth: availableWidth ? `${availableWidth}px` : undefined,\n          }\n        },\n      })\n    )\n  }\n  return arr\n})\n\nconst placementRef = toRef(() =>\n  isAutoPlacement.value ? undefined : (props.placement as OriginalPlacement)\n)\n\nconst {floatingStyles, middlewareData, placement, update} = useFloating(targetTrigger, element, {\n  placement: placementRef,\n  middleware: floatingMiddleware,\n  strategy: toRef(() => props.strategy),\n  whileElementsMounted: (...args) => {\n    const cleanup = autoUpdate(...args, {animationFrame: realtimeBoolean.value})\n    // Important! Always return the cleanup function.\n    return cleanup\n  },\n})\n\nconst arrowStyle = ref<CSSProperties>({position: 'absolute'})\n\nwatch(middlewareData, () => {\n  if (noHideBoolean.value === false) {\n    if (middlewareData.value.hide?.referenceHidden) {\n      hidden.value = true\n    } else {\n      hidden.value = false\n    }\n  }\n  if (middlewareData.value.arrow) {\n    const {x, y} = middlewareData.value.arrow\n    arrowStyle.value = {\n      position: 'absolute',\n      top: y ? `${y}px` : '',\n      left: x ? `${x}px` : '',\n    }\n  }\n})\n\nconst computedClasses = computed(() => {\n  const type = tooltipBoolean.value ? 'tooltip' : 'popover'\n  return [\n    type,\n    `b-${type}`,\n    {\n      [`b-${type}-${props.variant}`]: props.variant !== null,\n      show: showState.value && !hidden.value,\n      ['pe-none']: !showState.value,\n      fade: !noFadeBoolean.value,\n      ['d-none']: !showState.value && noFadeBoolean.value,\n      [`${props.customClass}`]: props.customClass !== undefined,\n      [`bs-${type}-${resolveBootstrapPlacement(placement.value)}`]: placement.value !== undefined,\n    },\n  ]\n})\n\nconst {isOutside} = useMouseInElement(element)\nconst {isOutside: triggerIsOutside} = useMouseInElement(trigger)\n\nconst toggle = (e: Event) => {\n  const event = e ?? new Event('click')\n  showState.value ? hide(event) : show()\n}\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nlet showTimeout: ReturnType<typeof setTimeout> | undefined\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('show-prevented')\n    return\n  }\n  showStateInternal.value = true\n  nextTick(() => {\n    update()\n    showTimeout = setTimeout(\n      () => {\n        update()\n        showState.value = true\n        nextTick(() => {\n          emit('shown', buildTriggerableEvent('shown'))\n        })\n      },\n      typeof props.delay === 'number' ? props.delay : props.delay?.show || 0\n    )\n  })\n}\n\nconst hide = (e: Event) => {\n  const event = buildTriggerableEvent('hide', {cancelable: true})\n  emit('hide', event)\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n  if (showTimeout) {\n    clearTimeout(showTimeout)\n    showTimeout = undefined\n  }\n  const delay = typeof props.delay === 'number' ? props.delay : props.delay?.hide || 0\n  setTimeout(() => {\n    if (\n      e?.type === 'click' ||\n      e?.type === 'forceHide' ||\n      (e?.type === 'update:modelValue' && manualBoolean.value) ||\n      (!noninteractiveBoolean.value &&\n        isOutside.value &&\n        triggerIsOutside.value &&\n        !element.value?.contains(document?.activeElement) &&\n        !trigger.value?.contains(document?.activeElement)) ||\n      (noninteractiveBoolean.value && triggerIsOutside.value)\n    ) {\n      showState.value = false\n      nextTick(() => {\n        setTimeout(\n          () => {\n            showStateInternal.value = false\n          },\n          element.value ? getTransitionDelay(element.value) : 150\n        )\n        emit('hidden', buildTriggerableEvent('hidden'))\n      })\n    } else {\n      setTimeout(\n        () => {\n          hide(e)\n        },\n        delay < 50 ? 50 : delay\n      )\n    }\n  }, delay)\n}\n\ndefineExpose({\n  hide,\n  show,\n  toggle,\n})\n\nconst getElement = (\n  target: MaybeRef<\n    string | ComponentPublicInstance<HTMLElement> | HTMLSpanElement | HTMLElement | null\n  >\n): HTMLElement | undefined => {\n  const element = unref(target)\n  if (!element) return undefined\n  if (typeof element === 'string') {\n    const idElement = document.getElementById(element)\n    return idElement ? idElement : undefined\n  }\n  if ((element as ComponentPublicInstance<HTMLElement>).$el) {\n    return (element as ComponentPublicInstance<HTMLElement>).$el as HTMLElement\n  }\n  return element\n}\n\nconst bind = () => {\n  // TODO: is this the best way to bind the events?\n  // we place a span and get the next element sibling fo rthe listeners\n  if (props.target) {\n    const elem = getElement(props.target)\n    if (elem) {\n      trigger.value = elem\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('Target element not found', props.target)\n    }\n  } else {\n    trigger.value = placeholder.value?.nextElementSibling as HTMLElement\n  }\n  if (props.reference) {\n    const elem = getElement(props.reference)\n    if (elem) {\n      targetTrigger.value = elem\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn('Reference element not found', props.reference)\n    }\n  } else {\n    targetTrigger.value = trigger.value\n  }\n  if (!trigger.value || manualBoolean.value) {\n    return\n  }\n  if (!IS_BROWSER) return\n  trigger.value.addEventListener('forceHide', hide)\n  if (clickBoolean.value) {\n    trigger.value.addEventListener('click', toggle)\n    return\n  }\n  trigger.value.addEventListener('pointerenter', show)\n  trigger.value.addEventListener('pointerleave', hide)\n  trigger.value.addEventListener('focus', show)\n  trigger.value.addEventListener('blur', hide)\n}\n\nconst unbind = () => {\n  if (trigger.value) {\n    trigger.value.removeEventListener('forceHide', hide)\n    trigger.value.removeEventListener('click', toggle)\n    trigger.value.removeEventListener('pointerenter', show)\n    trigger.value.removeEventListener('pointerleave', hide)\n    trigger.value.removeEventListener('focus', show)\n    trigger.value.removeEventListener('blur', hide)\n  }\n}\n\nonClickOutside(\n  element,\n  () => {\n    if (showState.value && clickBoolean.value && !noAutoCloseBoolean.value && !manualBoolean.value)\n      hide(new Event('clickOutside'))\n  },\n  {ignore: [trigger]}\n)\n\nwatch([() => props.click, () => props.target, () => props.reference], () => {\n  unbind()\n  bind()\n  // update()\n})\n\nonMounted(bind)\n\nonBeforeUnmount(unbind)\n</script>\n","import type {Placement} from '@floating-ui/vue'\nexport {autoUpdate} from '@floating-ui/vue'\n\nimport {type App, createApp, type DirectiveBinding, h, type Ref} from 'vue'\nimport {DefaultAllowlist, sanitizeHtml} from './sanitizer'\nimport BPopover from '../components/BPopover.vue'\n\n// TODO this function doesn't currently resolve with RTL in mind. Once Bootstrap finalizes their RTL, we should make this change here\n/**\n * Configures Bootstrap-like placement props to floating-ui Placement strings.\n * Top drops up, bottom drops down, end drops right, start drops left, dropend will _align_ the drop to the 'end',\n * dropstart will _align_ the drop to the 'start'. Bottom is default, so it is the last in the order. Bottom should essentially be the opposite of top\n * @param {top: boolean; bottom: boolean; start: boolean; end: boolean; dropstart: boolean; dropend: boolean}\n * @returns {Placement} Placement\n */\nexport const resolveFloatingPlacement = ({\n  top,\n  end,\n  start,\n  alignCenter,\n  alignEnd,\n}: {\n  top: boolean\n  start: boolean\n  end: boolean\n  alignCenter: boolean\n  alignEnd: boolean\n}): Placement => {\n  const direction = top ? 'top' : start ? 'left' : end ? 'right' : 'bottom'\n  const align = alignEnd ? 'end' : alignCenter ? null : 'start'\n  return `${direction}${align ? `-${align}` : ''}` as Placement\n}\n\nexport const resolveBootstrapPlacement = (placement: Placement): string => {\n  const [_placement] = placement.split('-')\n  switch (_placement) {\n    case 'left':\n      return 'start'\n    case 'right':\n      return 'end'\n    default:\n      return _placement\n  }\n}\n\nexport const resolveActiveStatus = (values: DirectiveBinding['value']): boolean =>\n  typeof values !== 'object' || values.active !== false\n\nexport const resolveContent = (\n  values: DirectiveBinding['value'],\n  el: HTMLElement\n): {title?: string; content?: string} => {\n  const isActive = resolveActiveStatus(values)\n  if (!isActive) return {}\n\n  const missingBindingValue =\n    typeof values === 'undefined' ||\n    (typeof values === 'object' && !values.title && !values.content)\n  const title = el.getAttribute('title') || el.getAttribute('data-original-title')\n  if (missingBindingValue) {\n    if (title) {\n      el.removeAttribute('title')\n      el.setAttribute('data-original-title', title)\n\n      return {\n        content: sanitizeHtml(title, DefaultAllowlist),\n      }\n    }\n    return {}\n  }\n  if (typeof values === 'string') {\n    return {\n      content: sanitizeHtml(values, DefaultAllowlist),\n    }\n  }\n  return {\n    title: values?.title ? sanitizeHtml(values?.title, DefaultAllowlist) : undefined,\n    content: values?.content ? sanitizeHtml(values?.content, DefaultAllowlist) : undefined,\n  }\n}\n\nexport const resolveDirectiveProps = (binding: DirectiveBinding, el: HTMLElement) => ({\n  target: el,\n  modelValue: binding.modifiers.show,\n  inline: binding.modifiers.inline,\n  click: binding.modifiers.click,\n  realtime: binding.modifiers.realtime,\n  persistent: binding.modifiers.persistent,\n  placement: binding.modifiers.left\n    ? 'left'\n    : binding.modifiers.right\n    ? 'right'\n    : binding.modifiers.bottom\n    ? 'bottom'\n    : binding.modifiers.top\n    ? 'top'\n    : undefined,\n  html: true,\n  ...(typeof binding.value === 'object' ? binding.value : {}),\n  title: null,\n  content: null,\n})\n\nexport interface ElementWithPopper extends HTMLElement {\n  $__state?: Ref<{title: string; target: HTMLElement}>\n  $__app?: App\n  $__element?: HTMLElement\n}\n\nexport const bind = (el: ElementWithPopper, binding: DirectiveBinding) => {\n  const div = document.createElement('span')\n  if (binding.modifiers.body) document.body.appendChild(div)\n  else if (binding.modifiers.child) el.appendChild(div)\n  else el.parentNode?.insertBefore(div, el.nextSibling)\n  el.$__app = createApp({render: () => h(BPopover, {...el.$__state?.value})})\n  el.$__app.mount(div)\n  el.$__element = div\n}\n\nexport const unbind = (el: ElementWithPopper) => {\n  const div = el.$__element\n  el.$__app?.unmount()\n  delete el.$__app\n  delete el.$__state\n  setTimeout(() => {\n    div?.remove()\n  }, 0)\n  delete el.$__element\n}\n","type PropDefinition = {\n  type: unknown[]\n  default: unknown\n}\n\nexport interface ComponentProps {\n  [key: string]: PropDefinition\n}\n\n/**\n * @deprecated\n */\nexport default (\n  prefix: string,\n  breakpoints: string[],\n  definition: PropDefinition\n): ComponentProps =>\n  breakpoints.concat(['sm', 'md', 'lg', 'xl', 'xxl']).reduce((props, breakpoint) => {\n    props[\n      !prefix ? breakpoint : `${prefix}${breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)}`\n    ] = definition\n    return props\n  }, Object.create(null))\n","import type {ComponentProps} from './getBreakpointProps'\n\n/**\n * @deprecated\n */\nexport default (\n  props: Record<PropertyKey, unknown>,\n  els: ComponentProps,\n  propPrefix: string,\n  classPrefix = propPrefix\n): string[] =>\n  Object.keys(els).reduce((arr: string[], prop) => {\n    if (!props[prop]) return arr\n\n    arr.push(\n      [classPrefix, prop.replace(propPrefix, ''), props[prop]]\n        .filter((e) => e && typeof e !== 'boolean')\n        .join('-')\n        .toLowerCase()\n    )\n\n    return arr\n  }, [])\n","import {titleCase} from './stringUtils'\nimport type {TableField} from '../types'\n\nexport default (field: TableField) =>\n  typeof field === 'string'\n    ? titleCase(field)\n    : field.label !== undefined\n    ? field.label\n    : typeof field.key === 'string'\n    ? titleCase(field.key)\n    : field.key\n","export default (suffix = ''): string =>\n  `__BVID__${Math.random().toString().slice(2, 8)}___BV_${suffix}__`\n","import type {Slot, VNode} from 'vue'\n\nexport default (slot: Slot | undefined, filterBy: string): VNode[] =>\n  (slot?.() ?? [])\n    .reduce((arr: VNode[], slot: VNode) => {\n      if (typeof slot.type === 'symbol') {\n        arr = arr.concat(slot.children as unknown as VNode)\n      } else {\n        arr.push(slot)\n      }\n      return arr\n    }, [])\n    .filter((child) => (child.type as {__name: string} | undefined)?.__name === filterBy)\n","/**\n * @deprecated\n */\nexport const isObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  obj !== null && typeof obj === 'object'\n\n/**\n * @deprecated\n */\nexport const isNumeric = (value: unknown): boolean => /^[0-9]*\\.?[0-9]+$/.test(String(value))\n","import type {RouteLocationRaw} from 'vue-router'\n\nexport default (props: {href?: string; to?: RouteLocationRaw}): boolean =>\n  !!(props.href || props.to)\n","import type {InjectionKey, Ref} from 'vue'\nimport type {\n  ButtonVariant,\n  CheckboxValue,\n  ClassValue,\n  ColorVariant,\n  RadioValue,\n  RadiusElement,\n  Size,\n  TabType,\n  TextColorVariant,\n} from '../types'\n\n// BCarousel\nexport const carouselInjectionKey: InjectionKey<{\n  background: Readonly<Ref<string | undefined>>\n  width: Readonly<Ref<string | undefined>>\n  height: Readonly<Ref<string | undefined>>\n}> = Symbol('carousel')\n\n// BTabs\nexport const tabsInjectionKey: InjectionKey<{\n  lazy: Readonly<Ref<boolean>>\n  card: Readonly<Ref<boolean>>\n  noFade: Readonly<Ref<boolean>>\n  registerTab: (tab: Readonly<Ref<TabType>>) => void\n  unregisterTab: (id: string) => void\n  activateTab: (id: string | undefined) => void\n  activeTabClass: Readonly<Ref<ClassValue>>\n  activeId: Readonly<Ref<string | undefined>>\n}> = Symbol('tabs')\n\n// BProgress\nexport const progressInjectionKey: InjectionKey<{\n  animated: Readonly<Ref<boolean | undefined>>\n  max: Readonly<Ref<number | string>>\n  showProgress: Readonly<Ref<boolean | undefined>>\n  showValue: Readonly<Ref<boolean | undefined>>\n  striped: Readonly<Ref<boolean | undefined>>\n}> = Symbol('progress')\n\n// BListGroup\nexport const listGroupInjectionKey: InjectionKey<{\n  numbered: Readonly<Ref<boolean>>\n}> = Symbol('listGroup')\n\n// BAvatarGroup\nexport const avatarGroupInjectionKey: InjectionKey<{\n  overlapScale: Readonly<Ref<number>>\n  size: Readonly<Ref<Size | string | undefined>>\n  square: Readonly<Ref<boolean>>\n  rounded: Readonly<Ref<RadiusElement | boolean>>\n  roundedTop: Readonly<Ref<RadiusElement | boolean | undefined>>\n  roundedBottom: Readonly<Ref<RadiusElement | boolean | undefined>>\n  roundedStart: Readonly<Ref<RadiusElement | boolean | undefined>>\n  roundedEnd: Readonly<Ref<RadiusElement | boolean | undefined>>\n  variant: Readonly<Ref<ColorVariant | null>>\n  bgVariant: Readonly<Ref<ColorVariant | null>>\n  textVariant: Readonly<Ref<TextColorVariant | null>>\n}> = Symbol('avatarGroup')\n\n// BAccordion\nexport const accordionInjectionKey: InjectionKey<{\n  openItem: Readonly<Ref<string | undefined>>\n  free: Readonly<Ref<boolean>>\n  setOpenItem: (id: string) => void\n}> = Symbol('accordion')\n\n// BFormCheckboxGroup\nexport const checkboxGroupKey: InjectionKey<{\n  modelValue: Ref<CheckboxValue[]>\n  switch: Readonly<Ref<boolean>>\n  buttonVariant: Readonly<Ref<ButtonVariant | null>>\n  form: Readonly<Ref<string | undefined>>\n  name: Readonly<Ref<string>>\n  state: Readonly<Ref<boolean | undefined | null>>\n  plain: Readonly<Ref<boolean>>\n  size: Readonly<Ref<Size>>\n  inline: Readonly<Ref<boolean>>\n  required: Readonly<Ref<boolean>>\n  buttons: Readonly<Ref<boolean>>\n  disabled: Readonly<Ref<boolean>>\n}> = Symbol('checkboxGroup')\n\nexport const radioGroupKey: InjectionKey<{\n  modelValue: Ref<RadioValue>\n  buttonVariant: Readonly<Ref<ButtonVariant | null>>\n  form: Readonly<Ref<string | undefined>>\n  name: Readonly<Ref<string>>\n  buttons: Readonly<Ref<boolean>>\n  state: Readonly<Ref<boolean | undefined | null>>\n  plain: Readonly<Ref<boolean>>\n  size: Readonly<Ref<Size>>\n  inline: Readonly<Ref<boolean>>\n  required: Readonly<Ref<boolean>>\n  disabled: Readonly<Ref<boolean>>\n}> = Symbol('radioGroup')\n\n// Collapse\nexport const collapseInjectionKey: InjectionKey<{\n  id?: Readonly<Ref<string>>\n  readonly close?: () => void\n  readonly open?: () => void\n  readonly toggle?: () => void\n  visible?: Readonly<Ref<boolean>>\n  isNav?: Readonly<Ref<boolean>>\n}> = Symbol('collapse')\n\nexport const dropdownInjectionKey: InjectionKey<{\n  id?: Readonly<Ref<string>>\n  readonly close?: () => void\n  readonly open?: () => void\n  readonly toggle?: () => void\n  visible?: Readonly<Ref<boolean>>\n  isNav?: Readonly<Ref<boolean>>\n}> = Symbol('collapse')\n\nexport const navbarInjectionKey: InjectionKey<{\n  tag?: Readonly<Ref<string>>\n  autoClose?: Readonly<Ref<boolean>>\n}> = Symbol('navbar')\n","import type {Slots, VNode} from 'vue'\n\nexport default (name: string, scope = {}, $slots: Slots = {}): VNode => {\n  // Ensure names is an array\n  const names = [name]\n  let slot\n  for (let i = 0; i < names.length && !slot; i++) {\n    const name = names[i]\n    slot = $slots[name]\n  }\n  // Note: in Vue 3.x, slots have been unified. No more scoped slots and all slots are exposed as functions\n  return (slot && typeof slot === 'function' ? slot(scope) : slot) as unknown as VNode\n}\n","/**\n * Validates a number is an integer. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n * @deprecated\n */\nexport const toInteger = (value: number, defaultValue = NaN): number =>\n  Number.isInteger(value) ? value : defaultValue\n\n/**\n * @param value\n * @param defaultValue\n * @returns\n * @deprecated\n */\nexport const stringToInteger = (value: string, defaultValue = NaN): number => {\n  const integer = Number.parseInt(value, 10)\n  return Number.isNaN(integer) ? defaultValue : integer\n}\n\n/**\n * Validates a number is a float. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n * @deprecated\n */\nexport const toFloat = (value: number | string, defaultValue = NaN): number => {\n  const float = Number.parseFloat(value.toString())\n  return Number.isNaN(float) ? defaultValue : float\n}\n","/**\n * Removes properties from an object, based on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Omit<>\n */\nexport const omit = <\n  A extends Record<PropertyKey, unknown>,\n  const B extends ReadonlyArray<PropertyKey>,\n>(\n  objToPluck: A,\n  keysToPluck: B | (keyof A)[]\n): Omit<A, B[number]> =>\n  Object.keys(objToPluck)\n    .filter((key) => !keysToPluck.map((el) => el.toString()).includes(key))\n    .reduce((result, key) => ({...result, [key]: objToPluck[key]}), {} as Omit<A, B[number]>)\n\n/**\n * Picks properties from an object, base on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Pick<>\n */\nexport const pick = <\n  A extends Record<PropertyKey, unknown>,\n  const B extends ReadonlyArray<PropertyKey>,\n>(\n  objToPluck: A,\n  keysToPluck: B | (keyof A)[]\n): Pick<A, B[number]> =>\n  [...keysToPluck].reduce(\n    (memo, prop) => {\n      memo[prop] = objToPluck[prop]\n      return memo\n    },\n    {} as Record<PropertyKey, unknown>\n  ) as Pick<A, B[number]>\n\n/**\n * Dynamically get a nested value from an array or\n * object with a string.\n *\n * @example get(person, 'friends[0].name')\n * @link https://github.com/rayepps/radash/blob/master/src/object.ts#L214\n */\nexport const get = <TDefault = unknown>(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: any,\n  path: string,\n  defaultValue?: TDefault\n): TDefault => {\n  const segments = path.split(/[.[\\]]/g)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let current: any = value\n  for (const key of segments) {\n    if (current === null) return defaultValue as TDefault\n    if (current === undefined) return defaultValue as TDefault\n    if (key.trim() === '') continue\n    current = current[key]\n  }\n  if (current === undefined) return defaultValue as TDefault\n  return current\n}\n","import type {ConfigurationOption} from '../types'\n\nexport default <Type extends string, Base extends ConfigurationOption<Type>>(\n  options: Base,\n  values: Type[]\n): Type[] => {\n  const {all, ...others} = options\n  const valuesCopy: Partial<Record<keyof Base, boolean>> = {}\n  if (all) {\n    values.forEach((el) => {\n      valuesCopy[el] = all\n    })\n  }\n  const merge: Record<string, boolean> = {...valuesCopy, ...others}\n  return (\n    Object.entries(merge)\n      // filtering possible invalid keys\n      .filter(([name, value]) => !!value && values.includes(name as Type))\n      .map(([name]) => name as Type)\n  )\n}\n","// Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n\nimport {upperFirst} from './stringUtils'\n\n/**\n * Use data last parameters to allow for currying\n *\n * @param suffix\n * @param value\n * @returns\n */\nexport const suffixPropName = (suffix: string, value: string): string =>\n  value + (suffix ? upperFirst(suffix) : '')\n","<template>\n  <div :id=\"computedId\" class=\"accordion\" :class=\"computedClasses\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed, provide, readonly} from 'vue'\nimport {accordionInjectionKey} from '../../utils'\nimport {useBooleanish, useId} from '../../composables'\nimport {useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    flush?: Booleanish\n    free?: Booleanish\n    id?: string\n    modelValue?: string\n  }>(),\n  {\n    flush: false,\n    free: false,\n    id: undefined,\n    modelValue: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: string]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst computedId = useId(() => props.id, 'accordion')\n\nconst flushBoolean = useBooleanish(() => props.flush)\nconst freeBoolean = useBooleanish(() => props.free)\n\nconst computedClasses = computed(() => ({\n  'accordion-flush': flushBoolean.value,\n}))\n\nprovide(accordionInjectionKey, {\n  openItem: readonly(modelValue),\n  free: freeBoolean,\n  setOpenItem: (id: string) => {\n    modelValue.value = id\n  },\n})\n</script>\n","<template>\n  <slot\n    :id=\"computedId\"\n    name=\"header\"\n    :visible=\"modelValueBoolean\"\n    :toggle=\"toggleFn\"\n    :open=\"open\"\n    :close=\"close\"\n  />\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    ref=\"element\"\n    class=\"collapse\"\n    :class=\"computedClasses\"\n    :is-nav=\"isNavBoolean\"\n    v-bind=\"$attrs\"\n  >\n    <slot :visible=\"modelValueBoolean\" :toggle=\"toggleFn\" :open=\"open\" :close=\"close\" />\n  </component>\n  <slot\n    :id=\"computedId\"\n    name=\"footer\"\n    :visible=\"modelValueBoolean\"\n    :toggle=\"toggleFn\"\n    :open=\"open\"\n    :close=\"close\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, onMounted, provide, readonly, ref, watch} from 'vue'\nimport {useBooleanish, useId} from '../composables'\nimport {useEventListener, useVModel} from '@vueuse/core'\nimport type {Booleanish} from '../types'\nimport {BvTriggerableEvent, collapseInjectionKey, getTransitionDelay} from '../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    // appear?: Booleanish\n    horizontal?: Booleanish\n    id?: string\n    isNav?: Booleanish\n    modelValue?: Booleanish\n    skipAnimation?: Booleanish\n    tag?: string\n    toggle?: Booleanish\n    visible?: Booleanish\n  }>(),\n  {\n    horizontal: false,\n    id: undefined,\n    isNav: false,\n    modelValue: false,\n    skipAnimation: false,\n    tag: 'div',\n    toggle: false,\n    visible: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  default?: (props: {\n    close: () => void\n    open: () => void\n    toggle: () => void\n    visible: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  footer?: (props: {\n    close: () => void\n    id: string\n    open: () => void\n    toggle: () => void\n    visible: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  header?: (props: {\n    close: () => void\n    id: string\n    open: () => void\n    toggle: () => void\n    visible: boolean\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\nconst toggleBoolean = useBooleanish(() => props.toggle)\nconst horizontalBoolean = useBooleanish(() => props.horizontal)\nconst isNavBoolean = useBooleanish(() => props.isNav)\nconst visibleBoolean = useBooleanish(() => props.visible)\nconst skipAnimationBoolean = useBooleanish(() => props.skipAnimation)\n\nconst computedId = useId(() => props.id, 'collapse')\n\nconst element = ref<HTMLElement | null>(null)\nconst isCollapsing = ref(false)\nconst show = ref(modelValueBoolean.value)\n\nconst computedClasses = computed(() => ({\n  'show': show.value,\n  'navbar-collapse': isNavBoolean.value,\n  'collapsing': isCollapsing.value,\n  'closing': show.value && !modelValueBoolean.value,\n  'collapse-horizontal': horizontalBoolean.value,\n}))\n\nconst close = () => {\n  modelValue.value = false\n}\nconst open = () => {\n  modelValue.value = true\n}\nconst toggleFn = () => {\n  modelValue.value = !modelValueBoolean.value\n}\n\nlet revealTimeout: ReturnType<typeof setTimeout> | undefined\nlet hideTimeout: ReturnType<typeof setTimeout> | undefined\nlet _skipAnimation = skipAnimationBoolean.value\n\nconst reveal = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('show-prevented')\n    return\n  }\n  clearTimeout(hideTimeout)\n  clearTimeout(revealTimeout)\n  show.value = true\n  if (_skipAnimation) return\n  isCollapsing.value = true\n  nextTick(() => {\n    if (element.value === null) return\n    if (horizontalBoolean.value) {\n      element.value.style.width = `${element.value.scrollWidth}px`\n    } else {\n      element.value.style.height = `${element.value.scrollHeight}px`\n    }\n    revealTimeout = setTimeout(() => {\n      isCollapsing.value = false\n      emit('shown')\n      if (element.value === null) return\n      element.value.style.height = ''\n      element.value.style.width = ''\n    }, getTransitionDelay(element.value))\n  })\n}\n\nconst hide = () => {\n  const event = buildTriggerableEvent('hide', {cancelable: true})\n  emit('hide', event)\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n  clearTimeout(revealTimeout)\n  clearTimeout(hideTimeout)\n  if (element.value === null) return\n  if (_skipAnimation) {\n    show.value = false\n    return\n  }\n  if (isCollapsing.value) {\n    element.value.style.height = ``\n    element.value.style.width = ``\n    // return\n  } else {\n    if (horizontalBoolean.value) {\n      element.value.style.width = `${element.value.scrollWidth}px`\n    } else {\n      element.value.style.height = `${element.value.scrollHeight}px`\n    }\n  }\n  // element.value.style.height = `${element.value.scrollHeight}px`\n  element.value.offsetHeight // force reflow\n  isCollapsing.value = true\n  nextTick(() => {\n    if (element.value === null) return\n    element.value.style.height = ``\n    element.value.style.width = ``\n    hideTimeout = setTimeout(() => {\n      show.value = false\n      isCollapsing.value = false\n      emit('hidden')\n    }, getTransitionDelay(element.value))\n  })\n}\n\nwatch(modelValue, () => {\n  modelValueBoolean.value ? reveal() : hide()\n})\n\nonMounted(() => {\n  if (element.value === null) return\n  if (!modelValueBoolean.value && toggleBoolean.value) {\n    nextTick(() => {\n      modelValue.value = true\n    })\n  }\n})\n\nwatch(skipAnimationBoolean, (newval) => {\n  _skipAnimation = newval\n})\n\nif (visibleBoolean.value) {\n  _skipAnimation = true\n  modelValue.value = true\n  nextTick(() => {\n    _skipAnimation = skipAnimationBoolean.value\n  })\n}\n\nwatch(visibleBoolean, (newval) => {\n  _skipAnimation = true\n  newval ? open() : close()\n  nextTick(() => {\n    _skipAnimation = skipAnimationBoolean.value\n  })\n})\n\nuseEventListener(element, 'bv-toggle', () => {\n  modelValue.value = !modelValueBoolean.value\n})\n\ndefineExpose({\n  close,\n  isNav: isNavBoolean,\n  open,\n  toggle: toggleFn,\n  visible: readonly(show),\n})\n\nprovide(collapseInjectionKey, {\n  id: computedId,\n  close,\n  open,\n  toggle: toggleFn,\n  visible: readonly(show),\n  isNav: isNavBoolean,\n})\n</script>\n","<template>\n  <div class=\"accordion-item\" v-bind=\"wrapperAttrs\" :class=\"wrapperClass\">\n    <BCollapse\n      :id=\"computedId\"\n      v-model=\"modelValue\"\n      class=\"accordion-collapse\"\n      :class=\"collapseClass\"\n      :aria-labelledby=\"`${computedId}-heading`\"\n      v-bind=\"collapseAttrs\"\n      :tag=\"tag\"\n      :toggle=\"toggle\"\n      :horizontal=\"horizontal\"\n      :visible=\"visible\"\n      :is-nav=\"isNav\"\n      @show=\"emit('show', $event)\"\n      @shown=\"emit('shown')\"\n      @hide=\"emit('hide', $event)\"\n      @hidden=\"emit('hidden')\"\n      @hide-prevented=\"emit('hide-prevented')\"\n      @show-prevented=\"emit('show-prevented')\"\n    >\n      <template #header=\"{visible: toggleVisible, toggle: slotToggle}\">\n        <component\n          :is=\"headerTag\"\n          :id=\"`${computedId}-heading`\"\n          class=\"accordion-header\"\n          :class=\"headerClass\"\n          v-bind=\"headerAttrs\"\n        >\n          <button\n            class=\"accordion-button\"\n            v-bind=\"buttonAttrs\"\n            :class=\"[{collapsed: !toggleVisible}, buttonClass]\"\n            type=\"button\"\n            :aria-expanded=\"toggleVisible ? 'true' : 'false'\"\n            :aria-controls=\"computedId\"\n            @click=\"slotToggle\"\n          >\n            <slot name=\"title\"> {{ title }} </slot>\n          </button>\n        </component>\n      </template>\n      <div class=\"accordion-body\" v-bind=\"bodyAttrs\" :class=\"bodyClass\">\n        <slot />\n      </div>\n    </BCollapse>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {inject, onMounted, useAttrs, watch} from 'vue'\nimport {useVModel} from '@vueuse/core'\nimport BCollapse from '../BCollapse.vue'\nimport {accordionInjectionKey, BvTriggerableEvent} from '../../utils'\nimport {useId} from '../../composables'\nimport type {AttrsValue, Booleanish, ClassValue} from '../../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\nconst {class: wrapperClass, ...collapseAttrs} = useAttrs()\n\nconst props = withDefaults(\n  defineProps<{\n    bodyAttrs?: AttrsValue\n    bodyClass?: ClassValue\n    buttonAttrs?: AttrsValue\n    buttonClass?: ClassValue\n    collapseClass?: ClassValue\n    headerAttrs?: AttrsValue\n    headerClass?: ClassValue\n    headerTag?: string\n    horizontal?: Booleanish\n    id?: string\n    isNav?: Booleanish\n    modelValue?: boolean\n    tag?: string\n    title?: string\n    toggle?: Booleanish\n    visible?: Booleanish\n    wrapperAttrs?: AttrsValue\n  }>(),\n  {\n    bodyAttrs: undefined,\n    bodyClass: undefined,\n    buttonAttrs: undefined,\n    buttonClass: undefined,\n    collapseClass: undefined,\n    headerAttrs: undefined,\n    headerClass: undefined,\n    headerTag: 'h2',\n    horizontal: undefined,\n    id: undefined,\n    isNav: undefined,\n    modelValue: false,\n    tag: undefined,\n    title: undefined,\n    toggle: undefined,\n    visible: false,\n    wrapperAttrs: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst parentData = inject(accordionInjectionKey, null)\n\nconst computedId = useId(() => props.id, 'accordion_item')\n\nonMounted(() => {\n  if (modelValue.value && !parentData?.free.value) {\n    parentData?.setOpenItem(computedId.value)\n  }\n  if (!modelValue.value && parentData?.openItem.value === computedId.value) {\n    modelValue.value = true\n  }\n})\n\nwatch(\n  () => parentData?.openItem.value,\n  () =>\n    (modelValue.value = parentData?.openItem.value === computedId.value && !parentData?.free.value)\n)\nwatch(modelValue, () => {\n  if (modelValue.value && !parentData?.free.value) parentData?.setOpenItem(computedId.value)\n})\n</script>\n","<template>\n  <Transition v-bind=\"computedAttrs\">\n    <slot />\n  </Transition>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, TransitionMode} from '../../types'\nimport {computed, type TransitionProps} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    appear?: Booleanish\n    mode?: TransitionMode\n    noFade?: Booleanish\n    transProps?: TransitionProps\n  }>(),\n  {\n    appear: false,\n    mode: undefined,\n    noFade: false,\n    transProps: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst appearBoolean = useBooleanish(() => props.appear)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\n\nconst fadeProperties = computed(() => {\n  const NO_FADE_PROPS = {\n    name: '',\n    enterActiveClass: '',\n    enterToClass: '',\n    leaveActiveClass: '',\n    leaveToClass: 'showing',\n    enterFromClass: 'showing',\n    leaveFromClass: '',\n  }\n  const FADE_PROPS = {\n    ...NO_FADE_PROPS,\n    enterActiveClass: 'fade showing',\n    leaveActiveClass: 'fade showing',\n  }\n  return noFadeBoolean.value ? NO_FADE_PROPS : FADE_PROPS\n})\n\nconst baseProperties = computed(() => ({mode: props.mode, css: true, ...fadeProperties.value}))\n\nconst computedAttrs = computed(() =>\n  props.transProps !== undefined\n    ? {\n        // Order matters here since the props.transProps would get overwritten if it came first\n        // But the goal of props.transProps is to overwrite base properties\n        ...baseProperties.value,\n        ...props.transProps,\n      }\n    : appearBoolean.value\n    ? {\n        ...baseProperties.value,\n        appear: true,\n        appearActiveClass: fadeProperties.value.enterActiveClass,\n        appearToClass: fadeProperties.value.enterToClass,\n      }\n    : baseProperties.value\n)\n</script>\n\n<style lang=\"scss\">\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.25s linear;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n</style>\n","<template>\n  <button\n    :type=\"type\"\n    class=\"btn-close\"\n    :disabled=\"disabledBoolean\"\n    :aria-label=\"ariaLabel\"\n    @click=\"emit('click', $event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ButtonType} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    disabled?: Booleanish\n    type?: ButtonType\n  }>(),\n  {\n    ariaLabel: 'Close',\n    disabled: false,\n    type: 'button',\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :class=\"computedClasses\"\n    :role=\"label || hasLabelSlot ? role : null\"\n    :aria-hidden=\"label || hasLabelSlot ? null : true\"\n  >\n    <span v-if=\"label || hasLabelSlot\" class=\"visually-hidden\">\n      <slot name=\"label\">{{ label }}</slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../types'\nimport {useBooleanish} from '../composables'\nimport {isEmptySlot} from '../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    label?: string\n    role?: string\n    small?: Booleanish\n    tag?: string\n    type?: SpinnerType\n    variant?: ColorVariant | null\n  }>(),\n  {\n    label: undefined,\n    role: 'status',\n    small: false,\n    tag: 'span',\n    type: 'border',\n    variant: null,\n  }\n)\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  label?: (props: Record<string, never>) => any\n}>()\n\nconst smallBoolean = useBooleanish(() => props.small)\n\nconst computedClasses = computed(() => [\n  `spinner-${props.type}`,\n  {\n    [`spinner-${props.type}-sm`]: smallBoolean.value,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst hasLabelSlot = toRef(() => !isEmptySlot(slots.label))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    v-if=\"tag === 'router-link'\"\n    v-slot=\"//@ts-ignore \n    {href: localHref, navigate, isActive, isExactActive}\"\n    v-bind=\"routerAttr\"\n    custom\n  >\n    <component\n      :is=\"routerTag\"\n      :href=\"localHref\"\n      :class=\"{\n        [defaultActiveClass]: activeBoolean,\n        [activeClass]: isActive,\n        [exactActiveClass]: isExactActive,\n      }\"\n      v-bind=\"$attrs\"\n      @click=\";[navigate($event), clicked($event)]\"\n    >\n      <slot />\n    </component>\n  </component>\n  <component :is=\"tag\" v-else :class=\"computedLinkClasses\" v-bind=\"routerAttr\" @click=\"clicked\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BLinkProps} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {collapseInjectionKey, navbarInjectionKey} from '../../utils'\nimport {computed, getCurrentInstance, inject, useAttrs} from 'vue'\n\n// TODO this component will likely have an issue with inheritAttrs\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(defineProps<BLinkProps>(), {\n  active: undefined,\n  activeClass: 'router-link-active',\n  append: false,\n  disabled: false,\n  event: 'click',\n  exactActiveClass: 'router-link-exact-active',\n  href: undefined,\n  icon: false,\n  opacity: undefined,\n  opacityHover: undefined,\n  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n  rel: undefined,\n  replace: false,\n  routerComponentName: 'router-link',\n  routerTag: 'a',\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: null,\n  variant: null,\n})\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst attrs = useAttrs()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst iconBoolean = useBooleanish(() => props.icon)\n// TODO\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst appendBoolean = useBooleanish(() => props.append)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n// TODO\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst replaceBoolean = useBooleanish(() => props.replace)\nconst collapseData = inject(collapseInjectionKey, null)\nconst navbarData = inject(navbarInjectionKey, null)\n\nconst instance = getCurrentInstance()\n\nconst defaultActiveClass = 'active' as const\n\nconst tag = computed(() => {\n  const routerName = props.routerComponentName\n    .split('-')\n    .map((e) => e.charAt(0).toUpperCase() + e.slice(1))\n    .join('')\n  const hasRouter = instance?.appContext.app.component(routerName) !== undefined\n  if (!hasRouter || disabledBoolean.value || !props.to) {\n    return 'a'\n  }\n  return props.routerComponentName\n})\n\nconst computedHref = computed(() => {\n  const toFallback = '#'\n  if (props.href) return props.href\n\n  if (typeof props.to === 'string') return props.to || toFallback\n\n  const {to} = props\n\n  if (to !== undefined && 'path' in to) {\n    const path = to.path || ''\n    const query = to.query\n      ? `?${Object.keys(to.query)\n          .map((e) => `${e}=${to.query?.[e]}`)\n          .join('=')}`\n      : ''\n    const hash = !to.hash || to.hash.charAt(0) === '#' ? to.hash || '' : `#${to.hash}`\n    return `${path}${query}${hash}` || toFallback\n  }\n  // There is no resolver for `RouteLocationNamedRaw`. Which, I'm not sure there can be one in this context.\n\n  return toFallback\n})\n\nconst computedClasses = computed(() => ({\n  [`link-${props.variant}`]: props.variant !== null,\n  [`link-opacity-${props.opacity}`]: props.opacity !== undefined,\n  [`link-opacity-${props.opacityHover}-hover`]: props.opacityHover !== undefined,\n  [`link-underline-${props.underlineVariant}`]: props.underlineVariant !== null,\n  [`link-offset-${props.underlineOffset}`]: props.underlineOffset !== undefined,\n  [`link-offset-${props.underlineOffsetHover}-hover`]: props.underlineOffsetHover !== undefined,\n  [`link-underline-opacity-${props.underlineOpacity}`]: props.underlineOpacity !== undefined,\n  [`link-underline-opacity-${props.underlineOpacityHover}-hover`]:\n    props.underlineOpacityHover !== undefined,\n  'icon-link': iconBoolean.value === true,\n}))\n\nconst routerAttr = computed(() => ({\n  'class': computedClasses.value,\n  'to': props.to,\n  'href': computedHref.value,\n  'target': props.target,\n  'rel': props.target === '_blank' ? props.rel ?? 'noopener' : undefined,\n  'tabindex': disabledBoolean.value\n    ? '-1'\n    : typeof attrs.tabindex === 'undefined'\n    ? null\n    : attrs.tabindex,\n  'aria-disabled': disabledBoolean.value ? true : null,\n}))\n\nconst computedLinkClasses = computed(() => ({\n  [defaultActiveClass]: activeBoolean.value,\n  disabled: disabledBoolean.value,\n}))\n\nconst clicked = (e: MouseEvent): void => {\n  if (disabledBoolean.value) {\n    e.preventDefault()\n    e.stopImmediatePropagation()\n    return\n  }\n\n  if (\n    (collapseData?.isNav?.value === true && navbarData === null) ||\n    (navbarData !== null && navbarData.autoClose?.value === true)\n  ) {\n    collapseData?.close?.()\n  }\n\n  emit('click', e)\n}\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"btn\"\n    v-bind=\"linkProps\"\n    :class=\"computedClasses\"\n    :aria-disabled=\"nonStandardTag ? disabledBoolean : null\"\n    :aria-pressed=\"isToggle ? pressedBoolean : null\"\n    :autocomplete=\"isToggle ? 'off' : null\"\n    :disabled=\"isButton ? disabledBoolean : null\"\n    :href=\"href\"\n    :rel=\"computedLink ? rel : null\"\n    :role=\"nonStandardTag || computedLink ? 'button' : null\"\n    :target=\"computedLink ? target : null\"\n    :type=\"isButton ? type : null\"\n    :to=\"!isButton ? to : null\"\n    :append=\"computedLink ? append : null\"\n    @click=\"clicked\"\n  >\n    <template v-if=\"loadingBoolean\">\n      <slot name=\"loading\">\n        <template v-if=\"!loadingFillBoolean\">\n          {{ loadingText }}\n        </template>\n        <slot name=\"loading-spinner\">\n          <BSpinner :small=\"size !== 'lg'\" :label=\"loadingFillBoolean ? loadingText : undefined\" />\n        </slot>\n      </slot>\n    </template>\n    <template v-else>\n      <slot />\n    </template>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport BSpinner from '../BSpinner.vue'\nimport {useBLinkHelper, useBooleanish} from '../../composables'\nimport type {BLinkProps, Booleanish, ButtonType, ButtonVariant, Size} from '../../types'\nimport BLink from '../BLink/BLink.vue'\nimport {useVModel} from '@vueuse/core'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'loading'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'loading-spinner'?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      loading?: Booleanish\n      loadingFill?: Booleanish\n      loadingText?: string\n      pill?: Booleanish\n      pressed?: Booleanish\n      size?: Size\n      squared?: Booleanish\n      tag?: string\n      type?: ButtonType\n      variant?: ButtonVariant | null\n    } & Omit<BLinkProps, 'variant'>\n  >(),\n  {\n    loading: false,\n    loadingFill: false,\n    loadingText: 'Loading...',\n    pill: false,\n    pressed: undefined,\n    size: 'md',\n    squared: false,\n    tag: 'button',\n    type: 'button',\n    // Link props\n    active: false, // Why is this active: false?\n    variant: 'secondary',\n    // All others use defaults\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    event: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    routerTag: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    // End link props\n  }\n)\n\nconst emit = defineEmits<{\n  'click': [value: MouseEvent]\n  'update:pressed': [value: boolean]\n}>()\n\nconst pressedValue = useVModel(props, 'pressed', emit)\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst pillBoolean = useBooleanish(() => props.pill)\nconst pressedBoolean = useBooleanish(() => props.pressed)\nconst squaredBoolean = useBooleanish(() => props.squared)\nconst loadingBoolean = useBooleanish(() => props.loading)\nconst loadingFillBoolean = useBooleanish(() => props.loadingFill)\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props, [\n  'active-class',\n  'exact-active-class',\n  'event',\n  'replace',\n  'router-component-name',\n  'router-tag',\n])\n\nconst isToggle = toRef(() => typeof pressedBoolean.value === 'boolean')\nconst isButton = toRef(\n  () => props.tag === 'button' && props.href === undefined && props.to === undefined\n)\nconst isBLink = toRef(() => props.to !== undefined)\nconst nonStandardTag = toRef(() => (props.href !== undefined ? false : !isButton.value))\n\nconst linkProps = computed(() => (isBLink.value ? computedLinkProps.value : []))\n\nconst computedClasses = computed(() => [\n  [`btn-${props.size}`],\n  {\n    [`btn-${props.variant}`]: props.variant !== null,\n    'active': activeBoolean.value || pressedBoolean.value,\n    'rounded-pill': pillBoolean.value,\n    'rounded-0': squaredBoolean.value,\n    'disabled': disabledBoolean.value,\n  },\n])\n\nconst computedTag = toRef(() => (isBLink.value ? BLink : props.href ? 'a' : props.tag))\n\nconst clicked = (e: MouseEvent): void => {\n  if (disabledBoolean.value) {\n    e.preventDefault()\n    e.stopPropagation()\n    return\n  }\n  emit('click', e)\n  if (isToggle.value) {\n    pressedValue.value = !pressedBoolean.value\n  }\n}\n</script>\n","<template>\n  <BTransition :no-fade=\"!fadeBoolean\" :trans-props=\"{enterToClass: 'show'}\">\n    <div\n      v-if=\"isAlertVisible\"\n      ref=\"element\"\n      class=\"alert\"\n      role=\"alert\"\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      :class=\"computedClasses\"\n    >\n      <slot />\n      <template v-if=\"dismissibleBoolean\">\n        <BButton v-if=\"hasCloseSlot || closeContent\" v-bind=\"closeAttrs\" @click=\"hide\">\n          <slot name=\"close\">\n            {{ closeContent }}\n          </slot>\n        </BButton>\n        <BCloseButton v-else :aria-label=\"closeLabel\" v-bind=\"closeAttrs\" @click=\"hide\" />\n      </template>\n    </div>\n  </BTransition>\n</template>\n\n<script setup lang=\"ts\">\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {Booleanish, ButtonVariant, ClassValue, ColorVariant} from '../../types'\nimport {computed, onBeforeUnmount, ref, toRef, watch, watchEffect} from 'vue'\nimport {useBooleanish, useCountdown} from '../../composables'\nimport {isEmptySlot} from '../../utils'\nimport {useElementHover, useToNumber, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    closeClass?: ClassValue\n    closeContent?: string\n    closeLabel?: string\n    closeVariant?: ButtonVariant | null\n    dismissible?: Booleanish\n    fade?: Booleanish\n    immediate?: Booleanish\n    interval?: number | string\n    modelValue?: boolean | number\n    noHoverPause?: Booleanish\n    showOnPause?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    closeClass: undefined,\n    closeContent: undefined,\n    closeLabel: 'Close',\n    closeVariant: 'secondary',\n    dismissible: false,\n    fade: false,\n    immediate: true,\n    interval: 1000,\n    modelValue: false,\n    noHoverPause: false,\n    showOnPause: true,\n    variant: 'info',\n  }\n)\n\nconst emit = defineEmits<{\n  'close': []\n  'close-countdown': [value: number]\n  'closed': []\n  'update:modelValue': [value: boolean | number]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  close?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst element = ref<HTMLElement | null>(null)\n\nconst modelValue = useVModel(props, 'modelValue', emit)\nconst isHovering = useElementHover(element)\n\nconst dismissibleBoolean = useBooleanish(() => props.dismissible)\nconst fadeBoolean = useBooleanish(() => props.fade)\nconst immediateBoolean = useBooleanish(() => props.immediate)\nconst showOnPauseBoolean = useBooleanish(() => props.showOnPause)\nconst noHoverPauseBoolean = useBooleanish(() => props.noHoverPause)\nconst intervalNumber = useToNumber(() => props.interval)\n\nconst hasCloseSlot = toRef(() => !isEmptySlot(slots.close))\n\nconst countdownLength = toRef(() => (typeof modelValue.value === 'boolean' ? 0 : modelValue.value))\n\nconst computedClasses = computed(() => ({\n  [`alert-${props.variant}`]: props.variant !== null,\n  'alert-dismissible': dismissibleBoolean.value,\n}))\n\nconst closeClasses = computed(() => [props.closeClass, {'btn-close-custom': hasCloseSlot.value}])\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(countdownLength, intervalNumber, {\n  immediate: typeof modelValue.value === 'number' && immediateBoolean.value,\n})\n\nconst isAlertVisible = toRef(() =>\n  typeof modelValue.value === 'boolean'\n    ? modelValue.value\n    : isActive.value || (showOnPauseBoolean.value && isPaused.value)\n)\n\nconst closeAttrs = computed(() => ({\n  variant: hasCloseSlot.value ? props.closeVariant : undefined,\n  class: closeClasses.value,\n}))\n\nwatchEffect(() => {\n  emit('close-countdown', remainingMs.value)\n})\n\nconst hide = () => {\n  emit('close')\n\n  if (typeof modelValue.value === 'boolean') {\n    modelValue.value = false\n  } else {\n    modelValue.value = 0\n    stop()\n  }\n\n  emit('closed')\n}\n\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\n\nwatch(isHovering, (newValue) => {\n  if (newValue) {\n    onMouseEnter()\n    return\n  }\n  resume()\n})\n\nonBeforeUnmount(stop)\n\ndefineExpose({\n  pause,\n  restart,\n  resume,\n  stop,\n})\n</script>\n\n<style lang=\"scss\" scoped>\n.btn-close-custom {\n  position: absolute;\n  top: 0;\n  right: 0;\n  z-index: 2;\n  margin: var(--bs-alert-padding-y) var(--bs-alert-padding-x);\n}\n</style>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"b-avatar\"\n    :class=\"computedClasses\"\n    :style=\"computedStyle\"\n    v-bind=\"computedLinkProps\"\n    :type=\"buttonBoolean && !computedLink ? props.buttonType : undefined\"\n    :disabled=\"disabledBoolean || null\"\n    @click=\"clicked\"\n  >\n    <span v-if=\"hasDefaultSlot\" class=\"b-avatar-custom\">\n      <slot />\n    </span>\n    <span v-else-if=\"!!src\" class=\"b-avatar-img\">\n      <img :src=\"src\" :alt=\"alt\" @error=\"onImgError\" />\n    </span>\n    <span v-else-if=\"!!text\" class=\"b-avatar-text\" :style=\"textFontStyle\">\n      {{ text }}\n    </span>\n    <span v-if=\"showBadge\" class=\"b-avatar-badge\" :class=\"badgeClasses\" :style=\"badgeStyle\">\n      <slot name=\"badge\">\n        {{ badgeText }}\n      </slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {avatarGroupInjectionKey, isEmptySlot, isNumeric, toFloat} from '../../utils'\nimport {computed, type CSSProperties, inject, type StyleValue, toRef} from 'vue'\nimport type {\n  BLinkProps,\n  Booleanish,\n  ButtonType,\n  ColorExtendables,\n  ColorVariant,\n  RadiusElementExtendables,\n  Size,\n  TextColorVariant,\n} from '../../types'\nimport {\n  useBLinkHelper,\n  useBooleanish,\n  useColorVariantClasses,\n  useRadiusElementClasses,\n} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      alt?: string\n      badge?: boolean | string // Can't make this Booleanish. string is valid text\n      badgeBgVariant?: ColorVariant | null\n      badgeOffset?: string\n      badgeStart?: Booleanish\n      badgeTextVariant?: TextColorVariant | null\n      badgeTop?: Booleanish\n      badgeVariant?: ColorVariant | null\n      button?: Booleanish\n      buttonType?: ButtonType\n      icon?: string\n      size?: Size | string // TODO number --> compat\n      square?: Booleanish\n      src?: string\n      text?: string\n    } & Omit<BLinkProps, 'event' | 'routerTag'> &\n      ColorExtendables &\n      RadiusElementExtendables\n  >(),\n  {\n    alt: 'avatar',\n    badge: false,\n    badgeBgVariant: null,\n    badgeOffset: undefined,\n    badgeStart: false,\n    badgeTextVariant: null,\n    badgeTop: false,\n    badgeVariant: 'primary',\n    button: false,\n    buttonType: 'button',\n    size: undefined,\n    square: false,\n    src: undefined,\n    text: undefined,\n    // Link props\n    variant: 'secondary',\n    // All others use defaults\n    active: undefined,\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    // End link props\n    // ColorExtendables props\n    // Variant is here as well\n    bgVariant: null,\n    textVariant: null,\n    // End ColorExtendables props\n    // RadiusElementExtendables props\n    rounded: false,\n    roundedBottom: undefined,\n    roundedEnd: undefined,\n    roundedStart: undefined,\n    roundedTop: undefined,\n    // End RadiusElementExtendables props\n  }\n)\n\nconst emit = defineEmits<{\n  'click': [value: MouseEvent]\n  'img-error': [value: Event]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  badge?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props)\n\nconst parentData = inject(avatarGroupInjectionKey, null)\n\nconst SIZES = ['sm', null, 'lg']\nconst FONT_SIZE_SCALE = 0.4\nconst BADGE_FONT_SIZE_SCALE = FONT_SIZE_SCALE * 0.7\n\nconst badgeStartBoolean = useBooleanish(() => props.badgeStart)\nconst badgeTopBoolean = useBooleanish(() => props.badgeTop)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst squareBoolean = useBooleanish(() => props.square)\nconst roundedBoolean = useBooleanish(() => props.rounded)\nconst roundedTopBoolean = useBooleanish(() => props.roundedTop)\nconst roundedBottomBoolean = useBooleanish(() => props.roundedBottom)\nconst roundedStartBoolean = useBooleanish(() => props.roundedStart)\nconst roundedEndBoolean = useBooleanish(() => props.roundedEnd)\n\nconst hasDefaultSlot = toRef(() => !isEmptySlot(slots.default))\nconst hasBadgeSlot = toRef(() => !isEmptySlot(slots.badge))\n\nconst showBadge = toRef(() => !!props.badge || props.badge === '' || hasBadgeSlot.value)\nconst computedSquare = toRef(() => parentData?.size.value ?? squareBoolean.value)\nconst computedSize = toRef(() => parentData?.size.value ?? computeSize(props.size))\nconst computedVariant = toRef(() => parentData?.variant.value ?? props.variant)\nconst computedRounded = toRef(() => parentData?.rounded.value ?? roundedBoolean.value)\nconst computedRoundedTop = toRef(() => parentData?.roundedTop.value ?? roundedTopBoolean.value)\nconst computedRoundedBottom = toRef(\n  () => parentData?.roundedBottom.value ?? roundedBottomBoolean.value\n)\nconst computedRoundedStart = toRef(\n  () => parentData?.roundedStart.value ?? roundedStartBoolean.value\n)\nconst computedRoundedEnd = toRef(() => parentData?.roundedEnd.value ?? roundedEndBoolean.value)\n\nconst radiusElementClasses = useRadiusElementClasses(() => ({\n  rounded: computedRounded.value,\n  roundedTop: computedRoundedTop.value,\n  roundedBottom: computedRoundedBottom.value,\n  roundedStart: computedRoundedStart.value,\n  roundedEnd: computedRoundedEnd.value,\n}))\nconst badgeClasses = useColorVariantClasses(() => ({\n  variant: props.badgeVariant,\n  bgVariant: props.badgeBgVariant,\n  textVariant: props.badgeTextVariant,\n}))\n\nconst badgeText = toRef(() => (props.badge === true ? '' : props.badge))\n\nconst computedTextVariant = toRef(() => parentData?.textVariant.value ?? props.textVariant)\nconst computedBgVariant = toRef(() => parentData?.bgVariant.value ?? props.bgVariant)\n\nconst resolvedBackgroundClasses = useColorVariantClasses(() => ({\n  bgVariant: computedBgVariant.value,\n  textVariant: computedTextVariant.value,\n  variant: computedVariant.value,\n}))\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  // Square overwrites all else\n  computedSquare.value === true ? undefined : radiusElementClasses.value,\n  {\n    [`b-avatar-${props.size}`]: !!props.size && SIZES.indexOf(computeSize(props.size)) !== -1,\n    [`btn-${computedVariant.value}`]: buttonBoolean.value ? computedVariant.value !== null : false,\n    'badge': !buttonBoolean.value && computedVariant.value !== null && hasDefaultSlot.value,\n    'btn': buttonBoolean.value,\n    // Square is the same as rounded-0 class\n    'rounded-0': computedSquare.value === true,\n  },\n])\n\nconst badgeStyle = computed<StyleValue>(() => {\n  const offset = props.badgeOffset || '0px'\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${BADGE_FONT_SIZE_SCALE})`\n      : ''\n  return {\n    fontSize: fontSize || '',\n    top: badgeTopBoolean.value ? offset : '',\n    bottom: badgeTopBoolean.value ? '' : offset,\n    left: badgeStartBoolean.value ? offset : '',\n    right: badgeStartBoolean.value ? '' : offset,\n  }\n})\n\nconst textFontStyle = computed<StyleValue>(() => {\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${FONT_SIZE_SCALE})`\n      : null\n  return fontSize ? {fontSize} : {}\n})\n\nconst marginStyle = computed(() => {\n  const overlapScale = parentData?.overlapScale?.value || 0\n\n  const value =\n    computedSize.value && overlapScale ? `calc(${computedSize.value} * -${overlapScale})` : null\n  return value ? {marginLeft: value, marginRight: value} : {}\n})\n\nconst computedTag = toRef(() =>\n  computedLink.value ? BLink : buttonBoolean.value ? 'button' : 'span'\n)\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  ...marginStyle.value,\n  width: computedSize.value ?? undefined,\n  height: computedSize.value ?? undefined,\n}))\n\nconst clicked = (e: MouseEvent): void => {\n  if (!disabledBoolean.value && (computedLink.value || buttonBoolean.value)) emit('click', e)\n}\n\nconst onImgError = (e: Event) => {\n  emit('img-error', e)\n}\n</script>\n\n<script lang=\"ts\">\nexport const computeSize = (value: string | undefined): string | null => {\n  const calcValue = typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value\n  return typeof calcValue === 'number' ? `${calcValue}px` : calcValue || null\n}\n</script>\n","<template>\n  <component :is=\"tag\" class=\"b-avatar-group\" role=\"group\">\n    <div class=\"b-avatar-group-inner\" :style=\"paddingStyle\">\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, type StyleValue, toRef} from 'vue'\nimport type {Booleanish, ColorExtendables, RadiusElementExtendables, Size} from '../../types'\nimport {avatarGroupInjectionKey} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computeSize} from './BAvatar.vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      overlap?: number | string\n      size?: Size | string\n      square?: Booleanish\n      tag?: string\n    } & ColorExtendables &\n      RadiusElementExtendables\n  >(),\n  {\n    overlap: 0.3,\n    size: undefined,\n    square: false,\n    tag: 'div',\n    // RadiusElementExtendables props\n    rounded: false,\n    roundedBottom: undefined,\n    roundedEnd: undefined,\n    roundedStart: undefined,\n    roundedTop: undefined,\n    // End RadiusElementExtendables props\n    // ColorExtendables props\n    bgVariant: null,\n    textVariant: null,\n    variant: null,\n    // End ColorExtendables props\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst squareBoolean = useBooleanish(() => props.square)\nconst roundedBoolean = useBooleanish(() => props.rounded)\nconst roundedTopBoolean = useBooleanish(() => props.roundedTop)\nconst roundedBottomBoolean = useBooleanish(() => props.roundedBottom)\nconst roundedStartBoolean = useBooleanish(() => props.roundedStart)\nconst roundedEndBoolean = useBooleanish(() => props.roundedEnd)\nconst overlapNumber = useToNumber(() => props.overlap)\n\nconst computedSize = computed(() => computeSize(props.size))\nconst overlapScale = toRef(() => Math.min(Math.max(overlapNumber.value, 0), 1) / 2)\n\nconst paddingStyle = computed<StyleValue>(() => {\n  const value = computedSize.value ? `calc(${computedSize.value} * ${overlapScale.value})` : null\n  return value ? {paddingLeft: value, paddingRight: value} : {}\n})\n\nprovide(avatarGroupInjectionKey, {\n  overlapScale,\n  size: toRef(() => props.size),\n  square: squareBoolean,\n  rounded: roundedBoolean,\n  roundedTop: roundedTopBoolean,\n  roundedBottom: roundedBottomBoolean,\n  roundedStart: roundedStartBoolean,\n  roundedEnd: roundedEndBoolean,\n  variant: toRef(() => props.variant),\n  bgVariant: toRef(() => props.bgVariant),\n  textVariant: toRef(() => props.textVariant),\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"badge\" :class=\"computedClasses\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {useBLinkHelper, useBooleanish, useColorVariantClasses} from '../../composables'\nimport {computed, toRef} from 'vue'\nimport type {BLinkProps, Booleanish, ColorExtendables} from '../../types'\nimport BLink from '../BLink/BLink.vue'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      dotIndicator?: Booleanish\n      pill?: Booleanish\n      tag?: string\n      textIndicator?: Booleanish\n    } & Omit<BLinkProps, 'event' | 'routerTag'> &\n      ColorExtendables\n  >(),\n  {\n    dotIndicator: false,\n    pill: false,\n    tag: 'span',\n    textIndicator: false,\n    // Link props\n    variant: 'secondary',\n    // All others use defaults\n    active: undefined,\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    // End link props\n    // ColorExtendables props\n    // Variant is here as well\n    textVariant: null,\n    bgVariant: null,\n    // End ColorExtendables props\n  }\n)\n\nconst pillBoolean = useBooleanish(() => props.pill)\nconst textIndicatorBoolean = useBooleanish(() => props.textIndicator)\nconst dotIndicatorBoolean = useBooleanish(() => props.dotIndicator)\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props, [\n  'active',\n  'activeClass',\n  'append',\n  'disabled',\n  'href',\n  'rel',\n  'replace',\n  'routerComponentName',\n  'target',\n  'to',\n  'opacity',\n  'opacityHover',\n  'underlineVariant',\n  'underlineOffset',\n  'underlineOffsetHover',\n  'underlineOpacity',\n  'underlineOpacityHover',\n  'icon',\n])\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.tag))\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    'active': activeBoolean.value,\n    'disabled': disabledBoolean.value,\n    'rounded-pill': pillBoolean.value,\n    'position-absolute top-0 start-100 translate-middle':\n      textIndicatorBoolean.value || dotIndicatorBoolean.value,\n    'p-2 border border-light rounded-circle': dotIndicatorBoolean.value,\n    'text-decoration-none': computedLink.value,\n  },\n])\n</script>\n","<template>\n  <li class=\"breadcrumb-item\" :class=\"computedClasses\">\n    <component\n      :is=\"computedTag\"\n      :aria-current=\"computedAriaCurrent\"\n      v-bind=\"computedLinkProps\"\n      @click=\"clicked\"\n    >\n      <slot>\n        {{ text }}\n      </slot>\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {pick} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BLinkProps} from '../../types'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      ariaCurrent?: string\n      text?: string\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    ariaCurrent: 'location',\n    text: undefined,\n    // Link props\n    active: false, // Why is this active: false?\n    // All others use defaults\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    event: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    routerTag: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    variant: undefined,\n    // End link props\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst computedClasses = computed(() => ({\n  active: activeBoolean.value,\n}))\n\nconst computedTag = toRef(() => (activeBoolean.value ? 'span' : BLink))\n\nconst computedAriaCurrent = toRef(() => (activeBoolean.value ? props.ariaCurrent : undefined))\n\nconst computedLinkProps = computed(() =>\n  computedTag.value !== 'span'\n    ? pick(props, [\n        'active',\n        'activeClass',\n        'append',\n        'disabled',\n        'href',\n        'rel',\n        'replace',\n        'routerComponentName',\n        'target',\n        'to',\n        'variant',\n        'opacity',\n        'opacityHover',\n        'underlineVariant',\n        'underlineOffset',\n        'underlineOffsetHover',\n        'underlineOpacity',\n        'underlineOpacityHover',\n        'icon',\n      ])\n    : {}\n)\n\nconst clicked = (e: MouseEvent): void => {\n  if (disabledBoolean.value || activeBoolean.value) {\n    e.preventDefault()\n    e.stopImmediatePropagation()\n    return\n  }\n  if (!disabledBoolean.value) emit('click', e)\n}\n</script>\n","<template>\n  <nav aria-label=\"breadcrumb\">\n    <ol class=\"breadcrumb\">\n      <slot name=\"prepend\" />\n      <BBreadcrumbItem v-for=\"(item, i) in breadcrumbItemObjects\" :key=\"i\" v-bind=\"item\">\n        {{ item.text }}\n      </BBreadcrumbItem>\n      <slot />\n      <slot name=\"append\" />\n    </ol>\n  </nav>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport {useBreadcrumb} from '../../composables'\nimport type {BreadcrumbItem, BreadcrumbItemObject} from '../../types'\nimport BBreadcrumbItem from './BBreadcrumbItem.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    items?: BreadcrumbItem[]\n  }>(),\n  {items: undefined}\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  append?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  prepend?: (props: Record<string, never>) => any\n}>()\n\nconst breadcrumb = useBreadcrumb()\n\nconst breadcrumbItemObjects = computed<BreadcrumbItemObject[]>(() => {\n  const localItems = props.items || breadcrumb?.items || []\n  let activeDefined = false\n  const items = localItems.map((item, idx) => {\n    if (typeof item === 'string') {\n      item = {text: item}\n      if (idx < localItems.length - 1) item.href = '#'\n    }\n    if (item.active) activeDefined = true\n\n    // Auto-detect active by position in list\n    if (!item.active && !activeDefined) {\n      item.active = idx + 1 === localItems.length\n    }\n    return item\n  })\n  return items\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" role=\"group\" :aria-label=\"ariaLabel\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, Size} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    size?: Size\n    tag?: string\n    vertical?: Booleanish\n  }>(),\n  {\n    ariaLabel: 'Group',\n    size: 'md',\n    tag: 'div',\n    vertical: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst verticalBoolean = useBooleanish(() => props.vertical)\n\nconst computedClasses = computed(() => ({\n  'btn-group': !verticalBoolean.value,\n  [`btn-group-${props.size}`]: props.size !== 'md',\n  'btn-group-vertical': verticalBoolean.value,\n}))\n</script>\n","<template>\n  <div :class=\"computedClasses\" class=\"btn-toolbar\" :role=\"role\" :aria-label=\"ariaLabel\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    // keyNav?: Booleanish\n    justify?: Booleanish\n    role?: string\n  }>(),\n  {\n    ariaLabel: 'Group',\n    justify: false,\n    role: 'toolbar',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst justifyBoolean = useBooleanish(() => props.justify)\n\nconst computedClasses = computed(() => ({\n  'justify-content-between': justifyBoolean.value,\n}))\n</script>\n","<template>\n  <img\n    :class=\"computedClasses\"\n    :src=\"!blankBoolean ? src : computedBlankImgSrc\"\n    :width=\"computedDimentions.width || undefined\"\n    :height=\"computedDimentions.height || undefined\"\n    :srcset=\"!blankBoolean ? computedSrcset : undefined\"\n    :sizes=\"!blankBoolean ? computedSizes : undefined\"\n    :loading=\"lazyBoolean ? 'lazy' : 'eager'\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {BImgProps} from '../types'\nimport {useBooleanish, useRadiusElementClasses} from '../composables'\nimport {computed, toRef} from 'vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BImgProps>(), {\n  blank: false,\n  blankColor: 'transparent',\n  block: false,\n  center: false,\n  end: false,\n  fluid: false,\n  fluidGrow: false,\n  height: undefined,\n  lazy: false,\n  sizes: undefined,\n  src: undefined,\n  srcset: undefined,\n  start: false,\n  thumbnail: false,\n  width: undefined,\n  // RadiusElementExtendables props\n  rounded: false,\n  roundedBottom: undefined,\n  roundedEnd: undefined,\n  roundedStart: undefined,\n  roundedTop: undefined,\n  // End RadiusElementExtendables props\n})\n\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst blankBoolean = useBooleanish(() => props.blank)\nconst blockBoolean = useBooleanish(() => props.block)\nconst centerBoolean = useBooleanish(() => props.center)\nconst fluidBoolean = useBooleanish(() => props.fluid)\nconst fluidGrowBoolean = useBooleanish(() => props.fluidGrow)\nconst startBoolean = useBooleanish(() => props.start)\nconst endBoolean = useBooleanish(() => props.end)\nconst thumbnailBoolean = useBooleanish(() => props.thumbnail)\nconst heightNumber = useToNumber(() => props.height ?? NaN)\nconst widthNumber = useToNumber(() => props.width ?? NaN)\nconst roundedBoolean = useBooleanish(() => props.rounded)\nconst roundedTopBoolean = useBooleanish(() => props.roundedTop)\nconst roundedBottomBoolean = useBooleanish(() => props.roundedBottom)\nconst roundedStartBoolean = useBooleanish(() => props.roundedStart)\nconst roundedEndBoolean = useBooleanish(() => props.roundedEnd)\n\nconst radiusElementClasses = useRadiusElementClasses(() => ({\n  rounded: roundedBoolean.value,\n  roundedTop: roundedTopBoolean.value,\n  roundedBottom: roundedBottomBoolean.value,\n  roundedStart: roundedStartBoolean.value,\n  roundedEnd: roundedEndBoolean.value,\n}))\n\nconst computedSrcset = computed(() =>\n  typeof props.srcset === 'string'\n    ? props.srcset\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.srcset)\n    ? props.srcset.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedSizes = computed(() =>\n  typeof props.sizes === 'string'\n    ? props.sizes\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.sizes)\n    ? props.sizes.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedDimentions = computed<{height: number | undefined; width: number | undefined}>(() => {\n  const width = Number.isNaN(widthNumber.value) ? undefined : widthNumber.value\n  const height = Number.isNaN(heightNumber.value) ? undefined : heightNumber.value\n  if (blankBoolean.value) {\n    if (width !== undefined && height === undefined) {\n      return {height: width, width}\n    }\n    if (width === undefined && height !== undefined) {\n      return {height, width: height}\n    }\n    return {height: 1, width: 1}\n  }\n  return {\n    width,\n    height,\n  }\n})\n\nconst computedBlankImgSrc = toRef(() =>\n  makeBlankImgSrc(computedDimentions.value.width, computedDimentions.value.height, props.blankColor)\n)\n\nconst alignment = toRef(() =>\n  startBoolean.value\n    ? 'float-start'\n    : endBoolean.value\n    ? 'float-end'\n    : centerBoolean.value\n    ? 'mx-auto'\n    : undefined\n)\n\nconst computedClasses = computed(() => [\n  radiusElementClasses.value,\n  {\n    'img-thumbnail': thumbnailBoolean.value,\n    'img-fluid': fluidBoolean.value || fluidGrowBoolean.value,\n    'w-100': fluidGrowBoolean.value,\n    [`${alignment.value}`]: alignment.value !== undefined,\n    'd-block': blockBoolean.value || centerBoolean.value,\n  },\n])\n\nconst makeBlankImgSrc = (width: number | undefined, height: number | undefined, color: string) =>\n  `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(`<svg width=\"${width}\" height=\"${height}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">\n    <rect width=\"100%\" height=\"100%\" style=\"fill:${color};\"></rect>\n    </svg>`)}`\n</script>\n","<template>\n  <BImg v-bind=\"computedImgProps\" :class=\"baseClass\" />\n</template>\n\n<script setup lang=\"ts\">\nimport BImg from '../BImg.vue'\nimport type {BImgProps, Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {omit} from '../../utils'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      bottom?: Booleanish\n      top?: Booleanish\n    } & BImgProps\n  >(),\n  {\n    bottom: false,\n    top: false,\n    // BImg props\n    blank: undefined,\n    blankColor: undefined,\n    block: undefined,\n    center: undefined,\n    end: undefined,\n    fluid: undefined,\n    fluidGrow: undefined,\n    height: undefined,\n    lazy: undefined,\n    rounded: undefined,\n    roundedBottom: undefined,\n    roundedEnd: undefined,\n    roundedStart: undefined,\n    roundedTop: undefined,\n    sizes: undefined,\n    src: undefined,\n    srcset: undefined,\n    start: undefined,\n    thumbnail: undefined,\n    width: undefined,\n    // End BImg props\n  }\n)\n\nconst bottomBoolean = useBooleanish(() => props.bottom)\nconst endBoolean = useBooleanish(() => props.end)\nconst startBoolean = useBooleanish(() => props.start)\nconst topBoolean = useBooleanish(() => props.top)\n\nconst baseClass = toRef(() =>\n  topBoolean.value\n    ? 'card-img-top'\n    : endBoolean.value\n    ? 'card-img-right'\n    : bottomBoolean.value\n    ? 'card-img-bottom'\n    : startBoolean.value\n    ? 'card-img-left'\n    : 'card-img'\n)\n\nconst computedImgProps = computed(() => omit(props, ['bottom', 'top', 'end', 'start']))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <!-- eslint-disable-next-line vue/no-v-html -->\n    <div v-if=\"!!html\" v-html=\"html\" />\n    <slot v-else>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {BCardHeadFootProps} from '../../types'\nimport {useColorVariantClasses} from '../../composables'\n\nconst props = withDefaults(defineProps<BCardHeadFootProps>(), {\n  borderVariant: null,\n  html: undefined,\n  tag: 'div',\n  text: undefined,\n  // ColorExtendables props\n  bgVariant: null,\n  textVariant: null,\n  variant: null,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n  },\n])\n</script>\n","<template>\n  <BCardHeadFoot class=\"card-header\" v-bind=\"props\">\n    <slot />\n  </BCardHeadFoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardHeadFootProps} from '../../types'\nimport BCardHeadFoot from './BCardHeadFoot.vue'\n\nconst props = withDefaults(defineProps<BCardHeadFootProps>(), {\n  borderVariant: undefined,\n  html: undefined,\n  tag: 'div',\n  text: undefined,\n  // ColorExtendables props\n  bgVariant: undefined,\n  textVariant: undefined,\n  variant: undefined,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-subtitle mb-2\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {TextColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    text?: string\n    tag?: string\n    textVariant?: TextColorVariant | null\n  }>(),\n  {\n    tag: 'h6',\n    text: undefined,\n    textVariant: 'body-secondary',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-body\" :class=\"computedClasses\">\n    <BCardTitle v-if=\"!!title || hasTitleSlot\" :tag=\"titleTag\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </BCardTitle>\n\n    <BCardSubtitle\n      v-if=\"!!subtitle || hasSubtitleSlot\"\n      :tag=\"subtitleTag\"\n      :text-variant=\"subtitleTextVariant\"\n    >\n      <slot name=\"subtitle\">\n        {{ subtitle }}\n      </slot>\n    </BCardSubtitle>\n\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport BCardTitle from './BCardTitle.vue'\nimport {isEmptySlot} from '../../utils'\nimport BCardSubtitle from './BCardSubtitle.vue'\nimport type {Booleanish, ColorExtendables, TextColorVariant} from '../../types'\nimport {useBooleanish, useColorVariantClasses} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      overlay?: Booleanish\n      subtitle?: string\n      subtitleTag?: string\n      subtitleTextVariant?: TextColorVariant | null\n      tag?: string\n      text?: string\n      title?: string\n      titleTag?: string\n    } & ColorExtendables\n  >(),\n  {\n    overlay: false,\n    subtitle: undefined,\n    subtitleTag: 'h4',\n    subtitleTextVariant: undefined,\n    tag: 'div',\n    text: undefined,\n    title: undefined,\n    titleTag: 'h4',\n    // ColorExtendables props\n    bgVariant: null,\n    textVariant: null,\n    variant: null,\n    // End ColorExtendables props\n  }\n)\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subtitle?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst overlayBoolean = useBooleanish(() => props.overlay)\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst hasTitleSlot = toRef(() => !isEmptySlot(slots.title))\nconst hasSubtitleSlot = toRef(() => !isEmptySlot(slots.subtitle))\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    'card-img-overlay': overlayBoolean.value,\n  },\n])\n</script>\n","<template>\n  <BCardHeadFoot class=\"card-footer\" v-bind=\"props\">\n    <slot>\n      {{ text }}\n    </slot>\n  </BCardHeadFoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BCardHeadFootProps} from '../../types'\nimport BCardHeadFoot from './BCardHeadFoot.vue'\n\nconst props = withDefaults(defineProps<BCardHeadFootProps>(), {\n  borderVariant: undefined,\n  html: undefined,\n  tag: 'div',\n  text: undefined,\n  // ColorExtendables props\n  bgVariant: undefined,\n  textVariant: undefined,\n  variant: undefined,\n  // End ColorExtendables props\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card\" :class=\"computedClasses\">\n    <slot v-if=\"!imgBottomBoolean\" name=\"img\">\n      <BCardImg v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n    <BCardHeader\n      v-if=\"header || hasHeaderSlot || headerHtml\"\n      :bg-variant=\"headerBgVariant\"\n      :variant=\"headerVariant\"\n      :border-variant=\"headerBorderVariant\"\n      :html=\"headerHtml\"\n      :tag=\"headerTag\"\n      :text-variant=\"headerTextVariant\"\n      :class=\"headerClass\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </BCardHeader>\n    <BCardBody\n      v-if=\"!noBodyBoolean\"\n      :overlay=\"overlay\"\n      :bg-variant=\"bodyBgVariant\"\n      :tag=\"bodyTag\"\n      :text-variant=\"bodyTextVariant\"\n      :subtitle=\"subtitle\"\n      :subtitle-tag=\"subtitleTag\"\n      :subtitle-text-variant=\"subtitleTextVariant\"\n      :title=\"title\"\n      :title-tag=\"titleTag\"\n      :class=\"bodyClass\"\n    >\n      <slot>\n        {{ bodyText }}\n      </slot>\n    </BCardBody>\n    <slot v-else>\n      {{ bodyText }}\n    </slot>\n    <BCardFooter\n      v-if=\"footer || hasFooterSlot || footerHtml\"\n      :bg-variant=\"footerBgVariant\"\n      :border-variant=\"footerBorderVariant\"\n      :variant=\"footerVariant\"\n      :html=\"footerHtml\"\n      :tag=\"footerTag\"\n      :text-variant=\"footerTextVariant\"\n      :class=\"footerClass\"\n    >\n      <slot name=\"footer\">\n        {{ footer }}\n      </slot>\n    </BCardFooter>\n    <slot v-if=\"imgBottomBoolean\" name=\"img\">\n      <BCardImg v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {\n  AlignmentTextHorizontal,\n  Booleanish,\n  ClassValue,\n  ColorExtendables,\n  ColorVariant,\n  TextColorVariant,\n} from '../../types'\nimport {isEmptySlot} from '../../utils'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish, useColorVariantClasses} from '../../composables'\nimport BCardImg from './BCardImg.vue'\nimport BCardHeader from './BCardHeader.vue'\nimport BCardBody from './BCardBody.vue'\nimport BCardFooter from './BCardFooter.vue'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      align?: AlignmentTextHorizontal\n      bodyBgVariant?: ColorVariant | null\n      bodyClass?: ClassValue\n      bodyTag?: string\n      bodyText?: string\n      bodyTextVariant?: TextColorVariant | null\n      borderVariant?: ColorVariant | null\n      footer?: string\n      footerBgVariant?: ColorVariant | null\n      footerBorderVariant?: ColorVariant | null\n      footerClass?: ClassValue\n      footerHtml?: string\n      footerTag?: string\n      footerTextVariant?: TextColorVariant | null\n      footerVariant?: ColorVariant | null\n      header?: string\n      headerBgVariant?: ColorVariant | null\n      headerBorderVariant?: ColorVariant | null\n      headerClass?: ClassValue\n      headerHtml?: string\n      headerTag?: string\n      headerTextVariant?: TextColorVariant | null\n      headerVariant?: ColorVariant | null\n      imgAlt?: string\n      imgBottom?: Booleanish\n      imgEnd?: Booleanish\n      imgHeight?: string | number\n      imgSrc?: string\n      imgStart?: Booleanish\n      imgTop?: Booleanish\n      imgWidth?: string | number\n      noBody?: Booleanish\n      overlay?: Booleanish\n      subtitle?: string\n      subtitleTag?: string\n      subtitleTextVariant?: TextColorVariant | null\n      tag?: string\n      title?: string\n      titleTag?: string\n    } & ColorExtendables\n  >(),\n  {\n    align: undefined,\n    bodyBgVariant: undefined,\n    bodyClass: undefined,\n    bodyTag: 'div',\n    bodyText: '',\n    bodyTextVariant: undefined,\n    borderVariant: null,\n    footer: undefined,\n    footerBgVariant: undefined,\n    footerBorderVariant: undefined,\n    footerClass: undefined,\n    footerHtml: '',\n    footerTag: 'div',\n    footerTextVariant: undefined,\n    footerVariant: null,\n    header: undefined,\n    headerBgVariant: undefined,\n    headerBorderVariant: undefined,\n    headerClass: undefined,\n    headerHtml: '',\n    headerTag: 'div',\n    headerTextVariant: undefined,\n    headerVariant: null,\n    imgAlt: undefined,\n    imgBottom: false,\n    imgEnd: false,\n    imgHeight: undefined,\n    imgSrc: undefined,\n    imgStart: false,\n    imgTop: false,\n    imgWidth: undefined,\n    noBody: false,\n    overlay: false,\n    subtitle: undefined,\n    subtitleTag: 'h6',\n    subtitleTextVariant: 'body-secondary',\n    tag: 'div',\n    title: undefined,\n    titleTag: 'h4',\n    // ColorExtendables props\n    bgVariant: null,\n    textVariant: null,\n    variant: null,\n    // End ColorExtendables props\n  }\n)\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n}>()\n\nconst imgBottomBoolean = useBooleanish(() => props.imgBottom)\nconst imgEndBoolean = useBooleanish(() => props.imgEnd)\nconst imgStartBoolean = useBooleanish(() => props.imgStart)\nconst noBodyBoolean = useBooleanish(() => props.noBody)\n\nconst hasHeaderSlot = toRef(() => !isEmptySlot(slots.header))\nconst hasFooterSlot = toRef(() => !isEmptySlot(slots.footer))\n\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    [`text-${props.align}`]: props.align !== undefined,\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n    'flex-row': imgStartBoolean.value,\n    'flex-row-reverse': imgEndBoolean.value,\n  },\n])\n\nconst imgAttr = computed(() => ({\n  src: props.imgSrc,\n  alt: props.imgAlt,\n  height: props.imgHeight,\n  width: props.imgWidth,\n  bottom: props.imgBottom,\n  end: props.imgEnd,\n  start: props.imgStart,\n  top: props.imgTop,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"cardTypeClass\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    columns?: Booleanish\n    deck?: Booleanish\n    tag?: string\n  }>(),\n  {\n    columns: false,\n    deck: false,\n    tag: 'div',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst columnsBoolean = useBooleanish(() => props.columns)\nconst deckBoolean = useBooleanish(() => props.deck)\n\nconst cardTypeClass = toRef(() =>\n  deckBoolean.value ? 'card-deck' : columnsBoolean.value ? 'card-columns' : 'card-group'\n)\n</script>\n","<template>\n  <div :id=\"computedId\" ref=\"element\" class=\"carousel slide pointer-event\" :class=\"computedClasses\">\n    <div v-if=\"indicatorsBoolean\" class=\"carousel-indicators\">\n      <!-- :data-bs-target=\"`#${computedId}`\" is required since the classes target elems with that attr -->\n      <button\n        v-for=\"(_, i) in slides.length\"\n        :key=\"i\"\n        type=\"button\"\n        data-bs-target=\"\"\n        :class=\"i === modelValue ? 'active' : ''\"\n        :aria-current=\"i === modelValue ? true : undefined\"\n        :aria-label=\"`${indicatorsButtonLabel} ${i}`\"\n        @click=\"goToValue(i)\"\n      />\n    </div>\n\n    <div ref=\"relatedTarget\" class=\"carousel-inner\">\n      <TransitionGroup\n        :enter-from-class=\"enterClasses\"\n        :enter-active-class=\"enterClasses\"\n        :enter-to-class=\"enterClasses\"\n        :leave-from-class=\"leaveClasses\"\n        :leave-active-class=\"leaveClasses\"\n        :leave-to-class=\"leaveClasses\"\n        @before-leave=\"onBeforeLeave\"\n        @after-leave=\"onAfterLeave\"\n        @after-enter=\"onAfterEnter\"\n      >\n        <component\n          :is=\"slide\"\n          v-for=\"(slide, i) in slides\"\n          v-show=\"i === modelValue\"\n          :key=\"i\"\n          :class=\"{active: i === modelValue && isTransitioning === false}\"\n        />\n      </TransitionGroup>\n    </div>\n\n    <template v-if=\"controlsBoolean\">\n      <button class=\"carousel-control-prev\" type=\"button\" @click=\"prev\">\n        <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsPrevText }}</span>\n      </button>\n      <button class=\"carousel-control-next\" type=\"button\" @click=\"next\">\n        <span class=\"carousel-control-next-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsNextText }}</span>\n      </button>\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {BvCarouselEvent, carouselInjectionKey, getSlotElements} from '../../utils'\nimport {computed, provide, ref, toRef, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish} from '../../types'\nimport {\n  onKeyStroke,\n  useElementHover,\n  useIntervalFn,\n  useSwipe,\n  useToNumber,\n  useVModel,\n} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    background?: string\n    controls?: Booleanish\n    controlsNextText?: string\n    controlsPrevText?: string\n    fade?: Booleanish\n    id?: string\n    imgHeight?: string\n    imgWidth?: string\n    indicators?: Booleanish\n    indicatorsButtonLabel?: string\n    interval?: number | string\n    keyboard?: Booleanish\n    modelValue?: number\n    noHoverPause?: Booleanish\n    noTouch?: Booleanish\n    noWrap?: Booleanish\n    ride?: Booleanish | 'carousel'\n    rideReverse?: Booleanish\n    touchThreshold?: number | string\n  }>(),\n  {\n    background: undefined,\n    controls: false,\n    controlsNextText: 'Next',\n    controlsPrevText: 'Previous',\n    fade: false,\n    id: undefined,\n    imgHeight: undefined,\n    imgWidth: undefined,\n    indicators: false,\n    indicatorsButtonLabel: 'Slide',\n    interval: 5000,\n    keyboard: true,\n    modelValue: 0,\n    noHoverPause: false,\n    noTouch: false,\n    noWrap: false,\n    // eslint-disable-next-line vue/require-valid-default-prop\n    ride: false,\n    rideReverse: false,\n    touchThreshold: 50,\n  }\n)\n\nconst emit = defineEmits<{\n  'slide': [value: BvCarouselEvent]\n  'slid': [value: BvCarouselEvent]\n  'update:modelValue': [value: number]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id, 'carousel')\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst keyboardBoolean = useBooleanish(() => props.keyboard)\nconst rideReverseBoolean = useBooleanish(() => props.rideReverse)\nconst noHoverPauseBoolean = useBooleanish(() => props.noHoverPause)\nconst fadeBoolean = useBooleanish(() => props.fade)\nconst controlsBoolean = useBooleanish(() => props.controls)\nconst indicatorsBoolean = useBooleanish(() => props.indicators)\nconst noTouchBoolean = useBooleanish(() => props.noTouch)\nconst noWrapBoolean = useBooleanish(() => props.noWrap)\nconst touchThresholdNumber = useToNumber(() => props.touchThreshold)\nconst intervalNumber = useToNumber(() => props.interval)\nconst rideResolved = useBooleanish(() => props.ride)\n\nconst isTransitioning = ref(false)\nconst rideStarted = ref(false)\nconst direction = ref(true)\nconst relatedTarget = ref<HTMLElement | null>(null)\nconst element = ref<HTMLElement | null>(null)\nconst previousModelValue = ref(modelValue.value)\n\nconst isHovering = useElementHover(element)\n\n// Class carousel-item is a static property\n// If you make it static, the direction can be reversed -- properly (atm it does the carousel-item-${} logic backwards for entering, a weird hack)\n// So all that would be great. However, when you do this, it will break the transition flow. Something about it breaks and I'm not sure why!\n// Try it by removing carousel-item from below and making `!direction.value` => `direction.value` for enter\n// Then reviewing the behavior\nconst enterClasses = toRef(\n  () =>\n    `carousel-item carousel-item-${!direction.value ? 'next' : 'prev'} carousel-item-${\n      !direction.value ? 'start' : 'end'\n    }`\n)\nconst leaveClasses = toRef(\n  () => `carousel-item active carousel-item-${direction.value ? 'start' : 'end'}`\n)\n\nconst {pause, resume} = useIntervalFn(\n  () => {\n    rideReverseBoolean.value ? prev() : next()\n  },\n  intervalNumber,\n  {immediate: rideResolved.value === 'carousel'}\n)\n\nconst isRiding = toRef(\n  () =>\n    (rideResolved.value === true && rideStarted.value === true) || rideResolved.value === 'carousel'\n)\nconst slides = computed(() => getSlotElements(slots.default, 'BCarouselSlide'))\nconst computedClasses = computed(() => ({'carousel-fade': fadeBoolean.value}))\n// TODO a general idea of showing only slides that are in bounds\n// const localValue = computed(() =>\n//   props.modelValue >= slides.value.length\n//     ? slides.value.length - 1\n//     : props.modelValue < 0\n//     ? 0\n//     : props.modelValue\n// )\n\nconst buildBvCarouselEvent = (event: 'slid' | 'slide') =>\n  new BvCarouselEvent(event, {\n    componentId: computedId.value,\n    cancelable: false,\n    target: element.value,\n    direction: direction.value ? 'right' : 'left',\n    from: previousModelValue.value,\n    to: modelValue.value,\n    relatedTarget: relatedTarget.value?.children[modelValue.value] ?? null,\n  })\n\nconst goToValue = (value: number): void => {\n  if (isTransitioning.value === true) return\n\n  if (rideResolved.value === true) {\n    rideStarted.value = true\n  }\n  if (isRiding.value === true) {\n    resume()\n  }\n  direction.value = value < modelValue.value ? false : true\n  if (value >= slides.value.length) {\n    if (noWrapBoolean.value) return\n    modelValue.value = 0\n    return\n  }\n  if (value < 0) {\n    if (noWrapBoolean.value) return\n    modelValue.value = slides.value.length - 1\n    return\n  }\n  previousModelValue.value = modelValue.value\n  modelValue.value = value\n}\n\nconst prev = (): void => {\n  goToValue(modelValue.value - 1)\n}\nconst next = (): void => {\n  goToValue(modelValue.value + 1)\n}\n\nconst onKeydown = (fn: () => void) => {\n  if (keyboardBoolean.value === false) return\n  fn()\n}\n\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\nconst onMouseLeave = () => {\n  if (!isRiding.value) return\n  resume()\n}\n\nconst {lengthX} = useSwipe(element, {\n  passive: true,\n  onSwipeStart() {\n    if (noTouchBoolean.value === true) return\n    pause()\n  },\n  onSwipeEnd() {\n    if (noTouchBoolean.value === true) return\n    const resumeRiding = () => {\n      if (isRiding.value === false) return\n      resume()\n    }\n    if (lengthX.value >= touchThresholdNumber.value) {\n      next()\n      resumeRiding()\n      return\n    }\n    if (lengthX.value <= -touchThresholdNumber.value) {\n      prev()\n      resumeRiding()\n    }\n  },\n})\n\nconst onBeforeLeave = () => {\n  emit('slide', buildBvCarouselEvent('slide'))\n  isTransitioning.value = true\n}\nconst onAfterLeave = () => {\n  emit('slid', buildBvCarouselEvent('slid'))\n  isTransitioning.value = false\n}\n// carousel-item class is removed from the slide during the transition,\n// as is included within enter classes.\n// The first slide recovers carousel-item class,\nconst onAfterEnter = (el: Element) => {\n  if (modelValue.value !== 0) {\n    el.classList.add('carousel-item')\n  }\n}\n\nonKeyStroke(\n  'ArrowLeft',\n  () => {\n    onKeydown(prev)\n  },\n  {target: element}\n)\nonKeyStroke(\n  'ArrowRight',\n  () => {\n    onKeydown(next)\n  },\n  {target: element}\n)\n\nwatch(rideResolved, () => {\n  rideStarted.value = false\n})\n\nwatch(isHovering, (newValue) => {\n  if (newValue) {\n    onMouseEnter()\n    return\n  }\n  onMouseLeave()\n})\n\ndefineExpose({\n  next,\n  pause,\n  prev,\n  resume,\n})\n\nprovide(carouselInjectionKey, {\n  background: toRef(() => props.background),\n  width: toRef(() => props.imgWidth),\n  height: toRef(() => props.imgHeight),\n})\n</script>\n","<template>\n  <div class=\"carousel-item\" :style=\"computedStyle\">\n    <slot name=\"img\">\n      <BImg\n        class=\"d-block w-100\"\n        :alt=\"imgAlt\"\n        :srcset=\"imgSrcset\"\n        :src=\"imgSrc\"\n        :width=\"imgWidth || parentData?.width.value\"\n        :height=\"imgHeight || parentData?.height.value\"\n        :blank=\"imgBlank\"\n        :blank-color=\"imgBlankColor\"\n      />\n    </slot>\n    <component\n      :is=\"contentTag\"\n      v-if=\"hasContent\"\n      class=\"carousel-caption\"\n      :class=\"computedContentClasses\"\n    >\n      <component :is=\"captionTag\" v-if=\"hasCaption\">\n        <slot name=\"caption\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"captionHtml\" v-html=\"captionHtml\" />\n          <span v-else>{{ caption }}</span>\n        </slot>\n      </component>\n      <component :is=\"textTag\" v-if=\"hasText\">\n        <slot name=\"text\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"textHtml\" v-html=\"textHtml\" />\n          <span v-else>{{ text }}</span>\n        </slot>\n      </component>\n      <slot />\n    </component>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties, inject, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {carouselInjectionKey, isEmptySlot} from '../../utils'\nimport BImg from '../BImg.vue'\n\n// TODO interval is unused\n// Need to add https://getbootstrap.com/docs/5.3/components/carousel/#individual-carousel-item-interval\n// Perhaps a provide/inject with next/prev values where the component can call those would work.\n\nconst props = withDefaults(\n  defineProps<{\n    background?: string\n    caption?: string\n    captionHtml?: string\n    captionTag?: string\n    contentTag?: string\n    contentVisibleUp?: string\n    id?: string\n    imgAlt?: string\n    imgBlank?: Booleanish\n    imgBlankColor?: string\n    imgHeight?: string | number\n    imgSrc?: string\n    imgSrcset?: string | string[]\n    imgWidth?: string | number\n    interval?: string | number\n    text?: string\n    textHtml?: string\n    textTag?: string\n  }>(),\n  {\n    background: undefined,\n    caption: undefined,\n    captionHtml: undefined,\n    captionTag: 'h3',\n    contentTag: 'div',\n    contentVisibleUp: undefined,\n    id: undefined,\n    imgAlt: undefined,\n    imgBlank: false,\n    imgBlankColor: 'transparent',\n    imgHeight: undefined,\n    imgSrc: undefined,\n    imgSrcset: undefined,\n    imgWidth: undefined,\n    interval: undefined,\n    text: undefined,\n    textHtml: undefined,\n    textTag: 'p',\n  }\n)\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  caption?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  text?: (props: Record<string, never>) => any\n}>()\n\nconst parentData = inject(carouselInjectionKey, null)\n\nconst hasText = toRef(() => props.text || props.textHtml || !isEmptySlot(slots.text))\nconst hasCaption = toRef(() => props.caption || props.captionHtml || !isEmptySlot(slots.caption))\nconst hasContent = toRef(() => hasText.value || hasCaption.value || !isEmptySlot(slots.default))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  background: `${\n    props.background || parentData?.background.value || 'rgb(171, 171, 171)'\n  } none repeat scroll 0% 0%`,\n}))\n\nconst computedContentClasses = computed(() => ({\n  'd-none': props.contentVisibleUp !== undefined,\n  [`d-${props.contentVisibleUp}-block`]: props.contentVisibleUp !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, type SlotsType} from 'vue'\nimport type {AlignmentVertical, Booleanish} from '../types'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport {useBooleanish} from '../composables'\n\nconst breakpointCol = getBreakpointProps('', [], {type: [Boolean, String, Number], default: false})\nconst breakpointOffset = getBreakpointProps('offset', [''], {type: [String, Number], default: null})\nconst breakpointOrder = getBreakpointProps('order', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BCol',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    col: {type: [Boolean, String] as PropType<Booleanish>, default: false}, // Generic flexbox .col (xs)\n    cols: {type: [String, Number], default: null}, // .col-[1-12]|auto (xs)\n    ...breakpointCol,\n    offset: {type: [String, Number], default: null},\n    ...breakpointOffset,\n    order: {type: [String, Number], default: null},\n    ...breakpointOrder,\n    alignSelf: {type: String as PropType<AlignmentVertical | 'auto'>, default: null},\n    tag: {type: String, default: 'div'},\n  },\n  setup(props) {\n    const properties = [\n      {content: breakpointCol, propPrefix: 'cols', classPrefix: 'col'},\n      {content: breakpointOffset, propPrefix: 'offset'},\n      {content: breakpointOrder, propPrefix: 'order'},\n    ]\n\n    const colBoolean = useBooleanish(() => props.col)\n\n    const classList = computed(() =>\n      properties.flatMap((el) => getClasses(props, el.content, el.propPrefix, el.classPrefix))\n    )\n\n    const computedClasses = computed(() => [\n      classList.value,\n      {\n        col: colBoolean.value || (!classList.value.some((e) => /^col-/.test(e)) && !props.cols),\n        [`col-${props.cols}`]: !!props.cols,\n        [`offset-${props.offset}`]: !!props.offset,\n        [`order-${props.order}`]: !!props.order,\n        [`align-self-${props.alignSelf}`]: !!props.alignSelf,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, Breakpoint} from '../types'\nimport {computed} from 'vue'\nimport {useToNumber} from '@vueuse/core'\nimport {useBooleanish} from '..//composables'\n\nconst props = withDefaults(\n  defineProps<{\n    fluid?: Booleanish | Breakpoint\n    gutterX?: string | number\n    gutterY?: string | number\n    tag?: string\n  }>(),\n  {\n    fluid: false,\n    gutterX: undefined,\n    gutterY: undefined,\n    tag: 'div',\n  }\n)\n\nconst gutterXToNumber = useToNumber(() => props.gutterX ?? NaN, {method: 'parseInt'})\nconst gutterYToNumber = useToNumber(() => props.gutterY ?? NaN, {method: 'parseInt'})\nconst resolvedFluid = useBooleanish(() => props.fluid)\n\nconst computedClasses = computed(() => ({\n  container: resolvedFluid.value === false,\n  [`container-fluid`]: resolvedFluid.value === true,\n  [`container-${resolvedFluid.value}`]: typeof resolvedFluid.value === 'string',\n  [`gx-${gutterXToNumber.value}`]: !Number.isNaN(gutterXToNumber.value),\n  [`gy-${gutterYToNumber.value}`]: !Number.isNaN(gutterYToNumber.value),\n}))\n</script>\n","<template>\n  <div ref=\"wrapper\" :class=\"computedClasses\" class=\"btn-group\">\n    <BButton\n      :id=\"computedId\"\n      ref=\"splitButton\"\n      :variant=\"splitVariant || variant\"\n      :size=\"size\"\n      :class=\"buttonClasses\"\n      :disabled=\"splitDisabledBoolean || disabled\"\n      :type=\"splitButtonType\"\n      :aria-label=\"ariaLabel\"\n      :aria-expanded=\"splitBoolean ? undefined : modelValueBoolean\"\n      :aria-haspopup=\"splitBoolean ? undefined : 'menu'\"\n      :href=\"splitBoolean ? splitHref : undefined\"\n      :to=\"splitBoolean && splitTo ? splitTo : undefined\"\n      @click=\"onSplitClick\"\n    >\n      <slot name=\"button-content\">\n        {{ text }}\n      </slot>\n    </BButton>\n    <BButton\n      v-if=\"splitBoolean\"\n      ref=\"button\"\n      :variant=\"variant\"\n      :size=\"size\"\n      :disabled=\"disabled\"\n      :class=\"[toggleClass, ...[modelValueBoolean ? 'show' : undefined]]\"\n      class=\"dropdown-toggle-split dropdown-toggle\"\n      :aria-expanded=\"modelValueBoolean\"\n      aria-haspopup=\"menu\"\n      @click=\"onButtonClick\"\n    >\n      <span class=\"visually-hidden\">\n        <slot name=\"toggle-text\">\n          {{ toggleText }}\n        </slot>\n      </span>\n    </BButton>\n    <Teleport :to=\"container\" :disabled=\"!container\">\n      <ul\n        v-if=\"!lazyBoolean || modelValueBoolean\"\n        v-show=\"lazyBoolean || modelValueBoolean\"\n        ref=\"floating\"\n        :style=\"[floatingStyles, sizeStyles]\"\n        class=\"dropdown-menu show overflow-auto\"\n        :class=\"menuClass\"\n        :aria-labelledby=\"computedId\"\n        :role=\"role\"\n        @click=\"onClickInside\"\n      >\n        <slot :hide=\"close\" :show=\"open\" />\n      </ul>\n    </Teleport>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  autoUpdate,\n  type Boundary,\n  flip,\n  type Middleware,\n  offset as offsetMiddleware,\n  type RootBoundary,\n  shift,\n  size as sizeMiddleware,\n  useFloating,\n} from '@floating-ui/vue'\nimport {onClickOutside, onKeyStroke, useToNumber, useVModel} from '@vueuse/core'\nimport {computed, type CSSProperties, nextTick, provide, ref, toRef, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {BDropdownProps} from '../../types'\nimport {BvTriggerableEvent, dropdownInjectionKey, resolveFloatingPlacement} from '../../utils'\nimport BButton from '../BButton/BButton.vue'\n\n// TODO add navigation through keyboard events\n// TODO standardize keydown vs keyup events globally\n\nconst props = withDefaults(defineProps<BDropdownProps>(), {\n  ariaLabel: undefined,\n  autoClose: true,\n  boundary: 'clippingAncestors',\n  boundaryPadding: undefined,\n  center: false,\n  container: undefined,\n  disabled: false,\n  dropend: false,\n  dropstart: false,\n  dropup: false,\n  end: false,\n  floatingMiddleware: undefined,\n  id: undefined,\n  isNav: false,\n  lazy: false,\n  menuClass: undefined,\n  modelValue: false,\n  noCaret: false,\n  noFlip: false,\n  noShift: false,\n  noSize: false,\n  offset: 0,\n  role: 'menu',\n  size: 'md',\n  split: false,\n  splitButtonType: 'button',\n  splitClass: undefined,\n  splitDisabled: undefined,\n  splitHref: undefined,\n  splitTo: undefined,\n  splitVariant: undefined,\n  strategy: 'absolute',\n  text: undefined,\n  toggleClass: undefined,\n  toggleText: 'Toggle dropdown',\n  variant: 'secondary',\n})\n\nconst emit = defineEmits<{\n  'click': [event: MouseEvent]\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n  'toggle': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'button-content'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: {hide: () => void; show: () => void}) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'toggle-text'?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id, 'dropdown')\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\nconst dropupBoolean = useBooleanish(() => props.dropup)\nconst dropendBoolean = useBooleanish(() => props.dropend)\nconst isNavBoolean = useBooleanish(() => props.isNav)\nconst dropstartBoolean = useBooleanish(() => props.dropstart)\nconst centerBoolean = useBooleanish(() => props.center)\nconst endBoolean = useBooleanish(() => props.end)\nconst splitBoolean = useBooleanish(() => props.split)\nconst noCaretBoolean = useBooleanish(() => props.noCaret)\nconst noFlipBoolean = useBooleanish(() => props.noFlip)\nconst noShiftBoolean = useBooleanish(() => props.noShift)\nconst noSizeBoolean = useBooleanish(() => props.noSize)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst splitDisabledBoolean = useBooleanish(() => props.splitDisabled)\n\nconst computedOffset = toRef(() =>\n  typeof props.offset === 'string' || typeof props.offset === 'number' ? props.offset : NaN\n)\nconst offsetToNumber = useToNumber(computedOffset)\n\nconst floating = ref<HTMLElement | null>(null)\nconst button = ref<HTMLElement | null>(null)\nconst splitButton = ref<HTMLElement | null>(null)\nconst wrapper = ref<HTMLElement | null>(null)\n\nconst boundary = computed<Boundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? undefined : props.boundary\n)\nconst rootBoundary = computed<RootBoundary | undefined>(() =>\n  props.boundary === 'document' || props.boundary === 'viewport' ? props.boundary : undefined\n)\n\nconst referencePlacement = toRef(() => (!splitBoolean.value ? splitButton.value : button.value))\n\nonKeyStroke(\n  'Escape',\n  () => {\n    modelValue.value = !modelValueBoolean\n  },\n  {target: referencePlacement}\n)\nonKeyStroke(\n  'Escape',\n  () => {\n    modelValue.value = !modelValueBoolean\n  },\n  {target: floating}\n)\n\nconst keynav = (e: Event, v: number) => {\n  e.preventDefault()\n  if (!modelValueBoolean.value) {\n    open()\n    nextTick(() => keynav(e, v))\n    return\n  }\n  const list = floating.value?.querySelectorAll('.dropdown-item:not(.disabled):not(:disabled)')\n  if (!list) return\n  if (floating.value?.contains(document.activeElement)) {\n    const active = floating.value.querySelector('.dropdown-item:focus')\n    const index = Array.prototype.indexOf.call(list, active) + v\n    if (index >= 0 && index < list?.length) (list[index] as HTMLElement)?.focus()\n  } else {\n    ;(list[v === -1 ? list.length - 1 : 0] as HTMLElement)?.focus()\n  }\n}\n\nonKeyStroke('ArrowUp', (e) => keynav(e, -1), {target: referencePlacement})\nonKeyStroke('ArrowDown', (e) => keynav(e, 1), {target: referencePlacement})\nonKeyStroke('ArrowUp', (e) => keynav(e, -1), {target: floating})\nonKeyStroke('ArrowDown', (e) => keynav(e, 1), {target: floating})\n\nconst floatingPlacement = computed(() =>\n  resolveFloatingPlacement({\n    top: dropupBoolean.value,\n    start: dropstartBoolean.value,\n    end: dropendBoolean.value,\n    alignCenter: centerBoolean.value,\n    alignEnd: endBoolean.value,\n  })\n)\nconst sizeStyles = ref<CSSProperties>({})\nconst floatingMiddleware = computed<Middleware[]>(() => {\n  if (props.floatingMiddleware !== undefined) {\n    return props.floatingMiddleware\n  }\n  const localOffset =\n    typeof props.offset === 'string' || typeof props.offset === 'number'\n      ? offsetToNumber.value\n      : props.offset\n  const arr: Middleware[] = [offsetMiddleware(localOffset)]\n  if (noFlipBoolean.value === false) {\n    arr.push(\n      flip({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (noShiftBoolean.value === false) {\n    arr.push(\n      shift({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n      })\n    )\n  }\n  if (noSizeBoolean.value === false) {\n    arr.push(\n      sizeMiddleware({\n        boundary: boundary.value,\n        rootBoundary: rootBoundary.value,\n        padding: props.boundaryPadding,\n        apply({availableWidth, availableHeight}) {\n          sizeStyles.value = {\n            maxHeight: availableHeight ? `${availableHeight}px` : undefined,\n            maxWidth: availableWidth ? `${availableWidth}px` : undefined,\n          }\n        },\n      })\n    )\n  }\n  return arr\n})\nconst {update, floatingStyles} = useFloating(referencePlacement, floating, {\n  placement: floatingPlacement,\n  middleware: floatingMiddleware,\n  strategy: toRef(() => props.strategy),\n  whileElementsMounted: autoUpdate,\n})\n\nconst computedClasses = computed(() => ({\n  'dropup': dropupBoolean.value,\n  'dropend': dropendBoolean.value,\n  'dropstart': dropstartBoolean.value,\n  'position-static': props.boundary !== 'clippingAncestors' && !isNavBoolean.value,\n}))\n\nconst buttonClasses = computed(() => [\n  splitBoolean.value ? props.splitClass : props.toggleClass,\n  {\n    'nav-link': isNavBoolean.value,\n    'dropdown-toggle': !splitBoolean.value,\n    'dropdown-toggle-no-caret': noCaretBoolean.value && !splitBoolean.value,\n    'show': splitBoolean.value ? undefined : modelValueBoolean.value,\n  },\n])\n\nconst onButtonClick = () => {\n  toggle()\n}\n\nconst onSplitClick = (event: MouseEvent) => {\n  splitBoolean.value ? emit('click', event) : onButtonClick()\n}\n\nonClickOutside(\n  floating,\n  () => {\n    if (modelValueBoolean.value && (props.autoClose === true || props.autoClose === 'outside')) {\n      toggle()\n    }\n  },\n  {ignore: [button, splitButton]}\n)\nconst onClickInside = () => {\n  if (modelValueBoolean.value && (props.autoClose === true || props.autoClose === 'inside')) {\n    toggle()\n  }\n}\n\nconst close = () => {\n  modelValue.value && toggle()\n}\nconst open = () => {\n  modelValue.value || toggle()\n}\nconst toggle = () => {\n  emit('toggle')\n  const currentModelValue = modelValueBoolean.value\n  const e = new BvTriggerableEvent(currentModelValue ? 'hide' : 'show')\n  currentModelValue ? emit('hide', e) : emit('show', e)\n  if (e.defaultPrevented) {\n    currentModelValue ? emit('hide-prevented') : emit('show-prevented')\n    return\n  }\n  modelValue.value = !currentModelValue\n  currentModelValue ? emit('hidden') : emit('shown')\n  wrapper.value?.dispatchEvent(new Event('forceHide'))\n}\n\nwatch(modelValueBoolean, () => {\n  update()\n})\n\ndefineExpose({\n  close,\n  open,\n  toggle,\n})\n\nprovide(dropdownInjectionKey, {\n  id: computedId,\n  open,\n  close,\n  toggle,\n  visible: modelValueBoolean,\n  isNav: isNavBoolean,\n})\n</script>\n","<template>\n  <li role=\"presentation\">\n    <component\n      :is=\"headerTag\"\n      :id=\"headerId\"\n      class=\"dropdown-header\"\n      :class=\"computedClasses\"\n      :role=\"headerRole\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </component>\n    <ul\n      :id=\"id\"\n      role=\"group\"\n      class=\"list-unstyled\"\n      v-bind=\"$attrs\"\n      :aria-describedby=\"ariaDescribedby || headerId\"\n    >\n      <slot />\n    </ul>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ClassValue, ColorVariant} from '../../types'\nimport {computed, toRef} from 'vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    ariaDescribedby?: string\n    header?: string\n    headerClass?: ClassValue\n    headerTag?: string\n    headerVariant?: ColorVariant | null\n    id?: string\n  }>(),\n  {\n    ariaDescribedby: undefined,\n    header: undefined,\n    headerClass: undefined,\n    headerTag: 'header',\n    headerVariant: null,\n    id: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n}>()\n\nconst headerId = toRef(() => (props.id ? `${props.id}_group_dd_header` : undefined))\nconst headerRole = toRef(() => (props.headerTag === 'header' ? undefined : 'heading'))\n\nconst computedClasses = computed(() => [\n  props.headerClass,\n  {\n    [`text-${props.headerVariant}`]: props.headerVariant !== null,\n  },\n])\n</script>\n","<template>\n  <li role=\"presentation\" :class=\"wrapperClass\" v-bind=\"wrapperAttrs\">\n    <component\n      :is=\"computedTag\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"disabledBoolean\"\n      :aria-disabled=\"disabledBoolean ? true : null\"\n      :aria-current=\"activeBoolean ? true : null\"\n      :href=\"computedTag === 'a' ? href : null\"\n      :rel=\"rel\"\n      role=\"menuitem\"\n      :type=\"computedTag === 'button' ? 'button' : null\"\n      :target=\"target\"\n      v-bind=\"{...computedLinkProps, ...attrs}\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport BLink from '../BLink/BLink.vue'\nimport {computed, inject, toRef, useAttrs} from 'vue'\nimport type {AttrsValue, BLinkProps, ClassValue} from '../../types'\nimport {useBLinkHelper, useBooleanish} from '../../composables'\nimport {collapseInjectionKey, dropdownInjectionKey, navbarInjectionKey} from '../../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<\n    {\n      linkClass?: ClassValue\n      wrapperAttrs?: AttrsValue\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    wrapperAttrs: undefined,\n    // Link props\n    linkClass: undefined,\n    variant: 'secondary',\n    // All others use defaults\n    active: undefined,\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    // End link props\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst {class: wrapperClass, ...attrs} = useAttrs()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props)\n\nconst computedClasses = computed(() => [\n  props.linkClass,\n  {\n    active: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.href ? 'a' : 'button'))\n\nconst collapseData = inject(collapseInjectionKey, null)\nconst dropdownData = inject(dropdownInjectionKey, null)\nconst navbarData = inject(navbarInjectionKey, null)\n\n// Pretty sure this emits if computedTag is not button and is disabled\nconst clicked = (e: MouseEvent): void => {\n  emit('click', e)\n  if (navbarData !== null && navbarData?.autoClose?.value === true) {\n    collapseData?.close?.()\n  }\n  dropdownData?.close?.()\n}\n</script>\n","<template>\n  <li role=\"presentation\">\n    <button\n      role=\"menu\"\n      type=\"button\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"disabledBoolean\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </button>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ClassValue, ColorVariant} from '../../types'\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    active?: Booleanish\n    activeClass?: ClassValue\n    buttonClass?: ClassValue\n    disabled?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    active: false,\n    activeClass: 'active',\n    buttonClass: undefined,\n    disabled: false,\n    variant: null,\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => [\n  props.buttonClass,\n  {\n    [props.activeClass]: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== null,\n  },\n])\n\nconst clicked = (e: MouseEvent) => {\n  emit('click', e)\n}\n</script>\n","<template>\n  <form\n    :id=\"id\"\n    ref=\"element\"\n    :novalidate=\"novalidateBoolean\"\n    :class=\"computedClasses\"\n    @submit.prevent=\"submitted\"\n  >\n    <slot />\n  </form>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormProps} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, ref} from 'vue'\n\nconst props = withDefaults(defineProps<BFormProps>(), {\n  floating: false,\n  id: undefined,\n  novalidate: false,\n  validated: false,\n})\n\nconst emit = defineEmits<{\n  submit: [value: Event]\n}>()\n\nconst element = ref<HTMLFormElement | null>(null)\n\nconst floatingBoolean = useBooleanish(() => props.floating)\nconst novalidateBoolean = useBooleanish(() => props.novalidate)\nconst validatedBoolean = useBooleanish(() => props.validated)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  'form-floating': floatingBoolean.value,\n  'was-validated': validatedBoolean.value,\n}))\n\nconst submitted = (e: Event) => {\n  emit('submit', e)\n}\n\ndefineExpose({\n  element,\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"ariaLive ? true : undefined\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {BFormFeedbackSharedProps} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(defineProps<BFormFeedbackSharedProps>(), {\n  ariaLive: undefined,\n  forceShow: false,\n  id: undefined,\n  role: undefined,\n  state: null,\n  tag: 'div',\n  text: undefined,\n  tooltip: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst forceShowBoolean = useBooleanish(() => props.forceShow)\nconst stateBoolean = useBooleanish(() => props.state)\nconst tooltipBoolean = useBooleanish(() => props.tooltip)\n\nconst computedShow = toRef(() => forceShowBoolean.value === true || stateBoolean.value === false)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'invalid-feedback': !tooltipBoolean.value,\n  'invalid-tooltip': tooltipBoolean.value,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    id?: string\n    inline?: Booleanish\n    tag?: string\n    text?: string\n    textVariant?: TextColorVariant | null\n  }>(),\n  {\n    id: undefined,\n    inline: false,\n    tag: 'small',\n    text: undefined,\n    textVariant: 'body-secondary',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst inlineBoolean = useBooleanish(() => props.inline)\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== null,\n  'form-text': !inlineBoolean.value,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"ariaLive ? true : undefined\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {BFormFeedbackSharedProps} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(defineProps<BFormFeedbackSharedProps>(), {\n  ariaLive: undefined,\n  forceShow: false,\n  id: undefined,\n  role: undefined,\n  state: null,\n  tag: 'div',\n  text: undefined,\n  tooltip: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst forceShowBoolean = useBooleanish(() => props.forceShow)\nconst stateBoolean = useBooleanish(() => props.state)\nconst tooltipBoolean = useBooleanish(() => props.tooltip)\n\nconst computedShow = toRef(() => forceShowBoolean.value === true || stateBoolean.value === true)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'valid-feedback': !tooltipBoolean.value,\n  'valid-tooltip': tooltipBoolean.value,\n}))\n</script>\n","<script lang=\"ts\">\nimport {\n  defineComponent,\n  h,\n  type PropType,\n  type RendererElement,\n  type SlotsType,\n  Teleport,\n} from 'vue'\n\nexport default defineComponent({\n  name: 'ComponentOrEmpty',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    tag: {\n      type: String,\n      default: 'div',\n    },\n    to: {\n      type: [String, Object] as PropType<string | RendererElement | null | undefined>,\n      default: null,\n    },\n    skip: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, {slots, attrs}) {\n    return () =>\n      props.skip\n        ? slots.default?.()\n        : props.tag === 'Teleport'\n        ? h(Teleport, {to: props.to}, [slots.default?.()])\n        : h(props.tag, {...attrs}, [slots.default?.()])\n  },\n})\n</script>\n","<template>\n  <RenderComponentOrSkip :skip=\"isButtonGroup\" :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"checkbox\"\n      :disabled=\"disabledBoolean || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"name || parentData?.name.value\"\n      :form=\"form || parentData?.form.value\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledBy\"\n      :aria-required=\"computedRequired || undefined\"\n      :value=\"value\"\n      :true-value=\"value\"\n      :false-value=\"uncheckedValue\"\n      :indeterminate=\"indeterminateBoolean\"\n      @change=\"modelValue !== undefined && emit('change', modelValue)\"\n      @input=\"modelValue !== undefined && emit('input', modelValue)\"\n    />\n    <label v-if=\"hasDefaultSlot || plainBoolean === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus, useVModel} from '@vueuse/core'\nimport {computed, inject, ref, toRef} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonVariant, CheckboxValue, Size} from '../../types'\nimport {checkboxGroupKey, isEmptySlot} from '../../utils'\nimport RenderComponentOrSkip from '../RenderComponentOrSkip.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    ariaLabelledBy?: string\n    autofocus?: Booleanish\n    button?: Booleanish\n    buttonGroup?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    disabled?: Booleanish\n    form?: string\n    id?: string\n    indeterminate?: Booleanish\n    inline?: Booleanish\n    modelValue?: CheckboxValue | CheckboxValue[]\n    name?: string\n    plain?: Booleanish\n    required?: Booleanish\n    size?: Size\n    state?: Booleanish | null\n    switch?: Booleanish\n    uncheckedValue?: CheckboxValue\n    value?: CheckboxValue\n  }>(),\n  {\n    ariaLabel: undefined,\n    ariaLabelledBy: undefined,\n    autofocus: false,\n    button: false,\n    buttonGroup: false,\n    buttonVariant: null,\n    disabled: false,\n    form: undefined,\n    id: undefined,\n    indeterminate: undefined,\n    inline: false,\n    modelValue: undefined,\n    name: undefined,\n    plain: false,\n    required: undefined,\n    size: undefined,\n    state: null,\n    switch: false,\n    uncheckedValue: false,\n    value: true,\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: CheckboxValue | CheckboxValue[]]\n  'input': [value: CheckboxValue | CheckboxValue[]]\n  'update:modelValue': [value: CheckboxValue | CheckboxValue[]]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst indeterminateBoolean = useBooleanish(() => props.indeterminate)\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst buttonGroupBoolean = useBooleanish(() => props.buttonGroup)\nconst switchBoolean = useBooleanish(() => props.switch)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst parentData = inject(checkboxGroupKey, null)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst hasDefaultSlot = toRef(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () => parentData?.modelValue.value ?? modelValue.value,\n  set: (newVal) => {\n    if (newVal === undefined) return\n    if (parentData !== null && Array.isArray(newVal)) {\n      // The type cast isn't perfect. Array.isArray detects CheckboxValue.unknown[],\n      // but since it's parentData, it should always be CheckboxValue[]\n      // It doesn't quite work when props.value is an [], but this is more of a Vue issue\n      parentData.modelValue.value = newVal as CheckboxValue[]\n      return\n    }\n    modelValue.value = newVal as CheckboxValue\n  },\n})\n\nconst computedRequired = toRef(\n  () =>\n    !!(props.name ?? parentData?.name.value) &&\n    (requiredBoolean.value || parentData?.required.value)\n)\n\nconst isButtonGroup = toRef(() => buttonGroupBoolean.value || (parentData?.buttons.value ?? false))\n\nconst classesObject = computed(() => ({\n  plain: plainBoolean.value || (parentData?.plain.value ?? false),\n  button: buttonBoolean.value || (parentData?.buttons.value ?? false),\n  inline: inlineBoolean.value || (parentData?.inline.value ?? false),\n  switch: switchBoolean.value || (parentData?.switch.value ?? false),\n  state: stateBoolean.value || parentData?.state.value,\n  size: props.size ?? parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant: props.buttonVariant ?? parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n}))\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"group\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormCheckbox v-for=\"item in normalizeOptions\" :key=\"item.self\" v-bind=\"item.props\">\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </BFormCheckbox>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, provide, ref, toRef, watch} from 'vue'\nimport BFormCheckbox from './BFormCheckbox.vue'\nimport type {AriaInvalid, Booleanish, ButtonVariant, CheckboxValue, Size} from '../../types'\nimport {getGroupAttr, getGroupClasses, useBooleanish, useId} from '../../composables'\nimport {checkboxGroupKey} from '../../utils'\nimport {useFocus, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaInvalid?: AriaInvalid\n    autofocus?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    buttons?: Booleanish\n    disabled?: Booleanish\n    disabledField?: string\n    form?: string\n    htmlField?: string\n    id?: string\n    modelValue?: CheckboxValue[]\n    name?: string\n    options?: (string | number | Record<string, unknown>)[]\n    plain?: Booleanish\n    required?: Booleanish\n    size?: Size\n    stacked?: Booleanish\n    state?: Booleanish | null\n    switches?: Booleanish\n    textField?: string\n    validated?: Booleanish\n    valueField?: string\n  }>(),\n  {\n    ariaInvalid: undefined,\n    autofocus: false,\n    buttonVariant: 'secondary',\n    buttons: false,\n    disabled: false,\n    disabledField: 'disabled',\n    form: undefined,\n    htmlField: 'html',\n    id: undefined,\n    modelValue: () => [],\n    name: undefined,\n    options: () => [],\n    plain: false,\n    required: false,\n    size: 'md',\n    stacked: false,\n    state: null,\n    switches: false,\n    textField: 'text',\n    validated: false,\n    valueField: 'value',\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: CheckboxValue[]]\n  'input': [value: CheckboxValue[]]\n  'update:modelValue': [value: CheckboxValue[]]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId(() => props.id, 'checkbox')\nconst computedName = useId(() => props.name, 'checkbox')\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst buttonsBoolean = useBooleanish(() => props.buttons)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stackedBoolean = useBooleanish(() => props.stacked)\nconst stateBoolean = useBooleanish(() => props.state)\nconst switchesBoolean = useBooleanish(() => props.switches)\nconst validatedBoolean = useBooleanish(() => props.validated)\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: autofocusBoolean.value,\n})\n\nprovide(checkboxGroupKey, {\n  modelValue,\n  switch: switchesBoolean,\n  buttonVariant: toRef(() => props.buttonVariant),\n  form: toRef(() => props.form),\n  name: computedName,\n  state: stateBoolean,\n  plain: plainBoolean,\n  size: toRef(() => props.size),\n  inline: toRef(() => !stackedBoolean.value),\n  required: requiredBoolean,\n  buttons: buttonsBoolean,\n  disabled: disabledBoolean,\n})\n\nwatch(modelValue, (newValue) => {\n  emit('input', newValue)\n  nextTick(() => {\n    emit('change', newValue)\n  })\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el, ind) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          props: {\n            value: el,\n            disabled: disabledBoolean.value,\n          },\n          text: el.toString(),\n          html: undefined,\n          self: Symbol(`checkboxGroupOptionItem${ind}`),\n        }\n      : {\n          props: {\n            value: el[props.valueField] as string | number | undefined,\n            disabled: el[props.disabledField] as boolean | undefined,\n            ...(el.props ? el.props : {}),\n          },\n          text: el[props.textField] as string | undefined,\n          html: el[props.htmlField] as string | undefined,\n          self: Symbol(`checkboxGroupOptionItem${ind}`),\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: requiredBoolean.value,\n  ariaInvalid: props.ariaInvalid,\n  state: stateBoolean.value,\n  validated: validatedBoolean.value,\n  buttons: buttonsBoolean.value,\n  stacked: stackedBoolean.value,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <label v-if=\"hasLabelSlot || label\" :for=\"computedId\" class=\"form-label\" :class=\"labelClass\">\n    <slot name=\"label\">\n      {{ label }}\n    </slot>\n  </label>\n  <input\n    :id=\"computedId\"\n    v-bind=\"$attrs\"\n    ref=\"input\"\n    type=\"file\"\n    class=\"form-control\"\n    :class=\"computedClasses\"\n    :form=\"form\"\n    :name=\"name\"\n    :multiple=\"multipleBoolean\"\n    :disabled=\"disabledBoolean\"\n    :capture=\"computedCapture\"\n    :accept=\"computedAccept || undefined\"\n    :required=\"requiredBoolean || undefined\"\n    :aria-required=\"requiredBoolean || undefined\"\n    :directory=\"directoryBoolean\"\n    :webkitdirectory=\"directoryBoolean\"\n    @change=\"onChange\"\n    @drop=\"onDrop\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, toRef, watch} from 'vue'\nimport {useFocus, useVModel} from '@vueuse/core'\nimport type {Booleanish, ClassValue, Size} from '../../types'\nimport {useBooleanish, useId, useStateClass} from '../../composables'\nimport {isEmptySlot} from '../../utils'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  label?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<{\n    accept?: string | string[]\n    autofocus?: Booleanish\n    capture?: Booleanish | 'user' | 'environment'\n    directory?: Booleanish\n    disabled?: Booleanish\n    form?: string\n    id?: string\n    label?: string\n    labelClass?: ClassValue\n    modelValue?: File[] | File | null\n    multiple?: Booleanish\n    name?: string\n    noDrop?: Booleanish\n    noTraverse?: Booleanish\n    required?: Booleanish\n    size?: Size\n    state?: Booleanish | null\n  }>(),\n  {\n    accept: '',\n    autofocus: false,\n    // eslint-disable-next-line vue/require-valid-default-prop\n    capture: false,\n    directory: false,\n    disabled: false,\n    form: undefined,\n    id: undefined,\n    label: '',\n    labelClass: undefined,\n    modelValue: null,\n    multiple: false,\n    name: undefined,\n    noDrop: false,\n    noTraverse: false,\n    required: false,\n    size: undefined,\n    state: null,\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: Event]\n  'update:modelValue': [value: File | File[] | null]\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\nconst computedId = useId(() => props.id)\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst directoryBoolean = useBooleanish(() => props.directory)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst multipleBoolean = useBooleanish(() => props.multiple)\nconst noDropBoolean = useBooleanish(() => props.noDrop)\n// TODO not implemented yet\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst noTraverseBoolean = useBooleanish(() => props.noTraverse)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\nconst computedCapture = useBooleanish(() => props.capture)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst input = ref<HTMLInputElement | null>(null)\n\nconst {focused} = useFocus(input, {initialValue: autofocusBoolean.value})\n\nconst hasLabelSlot = toRef(() => !isEmptySlot(slots['label']))\nconst computedAccept = toRef(() =>\n  typeof props.accept === 'string' ? props.accept : props.accept.join(',')\n)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    [`form-control-${props.size}`]: props.size !== undefined,\n  },\n])\n\nconst onChange = (e: Event) => {\n  const value =\n    input.value?.files === null || input.value?.files === undefined ? null : [...input.value.files]\n  modelValue.value = value === null ? null : multipleBoolean.value === true ? value : value[0]\n  emit('change', e)\n}\n\nconst onDrop = (e: Event) => {\n  if (noDropBoolean.value === true) {\n    e.preventDefault()\n  }\n}\n\n/**\n * Reset the form input\n */\nconst reset = () => {\n  modelValue.value = null\n}\n\nwatch(modelValue, (newValue) => {\n  if (newValue === null && input.value !== null) {\n    input.value.value = ''\n  }\n})\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n  reset,\n})\n</script>\n","<script lang=\"ts\">\nimport {useAriaInvalid, useBooleanish, useId, useStateClass} from '../../composables'\nimport {RX_SPACE_SPLIT} from '../../constants/regex'\nimport {\n  attemptFocus,\n  cssEscape,\n  getAttr,\n  getId,\n  IS_BROWSER,\n  isVisible,\n  normalizeSlot,\n  removeAttr,\n  select,\n  selectAll,\n  setAttr,\n  stringToInteger,\n  suffixPropName,\n} from '../../utils'\nimport {computed, defineComponent, h, nextTick, onMounted, type PropType, ref, watch} from 'vue'\nimport BCol from '../BCol.vue'\nimport BFormInvalidFeedback from '../BForm/BFormInvalidFeedback.vue'\nimport BFormRow from '../BForm/BFormRow.vue'\nimport BFormText from '../BForm/BFormText.vue'\nimport BFormValidFeedback from '../BForm/BFormValidFeedback.vue'\nimport type {AriaInvalid, Booleanish} from '../../types'\n\nconst INPUTS = ['input', 'select', 'textarea']\n// Selector for finding first input in the form group\nconst INPUT_SELECTOR = INPUTS.map((v) => `${v}:not([disabled])`).join()\n\n// A list of interactive elements (tag names) inside `<BFormGroup>`'s legend\nconst LEGEND_INTERACTIVE_ELEMENTS = [...INPUTS, 'a', 'button', 'label']\n\nexport const SLOT_NAME_LABEL = 'label'\nexport const SLOT_NAME_INVALID_FEEDBACK = 'invalid-feedback'\nexport const SLOT_NAME_VALID_FEEDBACK = 'valid-feedback'\nexport const SLOT_NAME_DESCRIPTION = 'description'\nexport const SLOT_NAME_DEFAULT = 'default'\n\nexport default defineComponent({\n  components: {BCol, BFormInvalidFeedback, BFormRow, BFormText, BFormValidFeedback},\n  props: {\n    ariaInvalid: {type: [Boolean, String] as PropType<AriaInvalid>, default: undefined},\n    contentCols: {type: [Boolean, String, Number], default: undefined},\n    contentColsLg: {type: [Boolean, String, Number], default: undefined},\n    contentColsMd: {type: [Boolean, String, Number], default: undefined},\n    contentColsSm: {type: [Boolean, String, Number], default: undefined},\n    contentColsXl: {type: [Boolean, String, Number], default: undefined},\n    description: {type: [String], default: undefined},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    feedbackAriaLive: {type: String, default: 'assertive'},\n    id: {type: String, default: undefined},\n    invalidFeedback: {type: String, default: undefined},\n    label: {type: String, default: undefined},\n    labelAlign: {type: [Boolean, String, Number], default: undefined},\n    labelAlignLg: {type: [Boolean, String, Number], default: undefined},\n    labelAlignMd: {type: [Boolean, String, Number], default: undefined},\n    labelAlignSm: {type: [Boolean, String, Number], default: undefined},\n    labelAlignXl: {type: [Boolean, String, Number], default: undefined},\n    labelClass: {type: [Array, Object, String], default: undefined},\n    labelCols: {type: [Boolean, String, Number], default: undefined},\n    labelColsLg: {type: [Boolean, String, Number], default: undefined},\n    labelColsMd: {type: [Boolean, String, Number], default: undefined},\n    labelColsSm: {type: [Boolean, String, Number], default: undefined},\n    labelColsXl: {type: [Boolean, String, Number], default: undefined},\n    labelFor: {type: String, default: undefined},\n    labelSize: {type: String, default: undefined},\n    labelSrOnly: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish | null>, default: null},\n    tooltip: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    validFeedback: {type: String, default: undefined},\n    validated: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    floating: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  },\n  setup(props) {\n    const disabledBoolean = useBooleanish(() => props.disabled)\n    const labelSrOnlyBoolean = useBooleanish(() => props.labelSrOnly)\n    const stateBoolean = useBooleanish(() => props.state)\n    const tooltipBoolean = useBooleanish(() => props.tooltip)\n    const validatedBoolean = useBooleanish(() => props.validated)\n    const floatingBoolean = useBooleanish(() => props.floating)\n\n    const ariaDescribedby: string | null = null as string | null\n    const breakPoints = ['xs', 'sm', 'md', 'lg', 'xl']\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const getAlignClasses = (props: any, prefix: string) =>\n      breakPoints.reduce((result: string[], breakpoint) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Align`)\n        const propValue: string = props[suffix] || null\n        if (propValue) {\n          breakpoint === 'xs'\n            ? result.push(`text-${propValue}`)\n            : result.push(`text-${breakpoint}-${propValue}`)\n        }\n\n        return result\n      }, [])\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const getColProps = (props: any, prefix: string) =>\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      breakPoints.reduce((result: any, breakpoint: string) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Cols`)\n        let propValue = props[suffix]\n        // Handle case where the prop's value is an empty string,\n        // which represents `true`\n        propValue = propValue === '' ? true : propValue || false\n\n        if (!(typeof propValue === 'boolean') && propValue !== 'auto') {\n          // Convert to column size to number\n          propValue = stringToInteger(propValue, 0)\n          // Ensure column size is greater than `0`\n          propValue = propValue > 0 ? propValue : false\n        }\n\n        // Add the prop to the list of props to give to `</BCol>`\n        // If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n        // the 'col' prop to make equal width at 'xs'\n        if (propValue) {\n          // Extra care is required for xs since it does not have a BCol breakpoint prop\n          // Xs breakpoint is simply 'cols'\n          if (breakpoint === 'xs') {\n            result[typeof propValue === 'boolean' ? 'col' : 'cols'] = propValue\n          } else {\n            result[breakpoint || (typeof propValue === 'boolean' ? 'col' : 'cols')] = propValue\n          }\n        }\n        return result\n      }, {})\n\n    const content = ref<HTMLElement | null>(null)\n\n    // Sets the `aria-describedby` attribute on the input if `labelFor` is set\n    // Optionally accepts a string of Ids to remove as the second parameter\n    // Preserves any `aria-describedby` value(s) user may have on input\n    const updateAriaDescribedby = (newValue: string | null, oldValue: string | null = null) => {\n      if (IS_BROWSER && props.labelFor && content.value !== null) {\n        // We need to escape `labelFor` since it can be user-provided\n        const $input = select(`#${cssEscape(props.labelFor)}`, content.value)\n        if ($input) {\n          const attr = 'aria-describedby'\n          const newIds = (newValue || '').split(RX_SPACE_SPLIT)\n          const oldIds = (oldValue || '').split(RX_SPACE_SPLIT)\n\n          // Update Id list, preserving any original Ids\n          // and ensuring the Id's are unique\n          const ids = (getAttr($input, attr) || '')\n            .split(RX_SPACE_SPLIT)\n            .filter((id) => !oldIds.includes(id))\n            .concat(newIds)\n            .filter((id, index, ids) => ids.indexOf(id) === index)\n            .filter((x) => x)\n            .join(' ')\n            .trim()\n\n          if (ids) {\n            setAttr($input, attr, ids)\n          } else {\n            removeAttr($input, attr)\n          }\n        }\n      }\n    }\n\n    const contentColProps = computed(() => getColProps(props, 'content'))\n    const labelAlignClasses = computed(() => getAlignClasses(props, 'label'))\n    const labelColProps = computed(() => getColProps(props, 'label'))\n    const isHorizontal = computed(\n      () =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(contentColProps.value).length > 0 || Object.keys(labelColProps.value).length > 0\n    )\n\n    const stateClass = useStateClass(stateBoolean)\n\n    const computedAriaInvalid = useAriaInvalid(() => props.ariaInvalid, stateBoolean)\n\n    watch(\n      () => ariaDescribedby,\n      (newValue: string | null, oldValue: string | null) => {\n        if (newValue !== oldValue) {\n          updateAriaDescribedby(newValue, oldValue)\n        }\n      }\n    )\n\n    onMounted(() => {\n      nextTick(() => {\n        // Set `aria-describedby` on the input specified by `labelFor`\n        // We do this in a `$nextTick()` to ensure the children have finished rendering\n        updateAriaDescribedby(ariaDescribedby)\n      })\n    })\n\n    const onLegendClick = (event: MouseEvent) => {\n      // Don't do anything if `labelFor` is set\n      if (props.labelFor || content.value === null) return\n\n      const {target} = event\n      const tagName = target ? (target as HTMLElement).tagName : ''\n\n      // If clicked an interactive element inside legend,\n      // we just let the default happen\n      if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) return\n\n      // If only a single input, focus it, emulating label behaviour\n      const inputs = selectAll(INPUT_SELECTOR, content.value).filter(isVisible)\n      if (inputs.length === 1) {\n        attemptFocus(inputs[0])\n      }\n    }\n\n    return {\n      disabledBoolean,\n      labelSrOnlyBoolean,\n      stateBoolean,\n      tooltipBoolean,\n      validatedBoolean,\n      floatingBoolean,\n      ariaDescribedby,\n      computedAriaInvalid,\n      contentColProps,\n      isHorizontal,\n      labelAlignClasses,\n      labelColProps,\n      onLegendClick,\n      stateClass,\n    }\n  },\n  render() {\n    const props = this.$props\n    const slots = this.$slots\n\n    const id = useId()\n    const isFieldset = !props.labelFor\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let $label: any = null\n    const labelContent = normalizeSlot(SLOT_NAME_LABEL, {}, slots) || props.label\n    const labelId = labelContent ? getId('_BV_label_') : null\n\n    if (labelContent || this.isHorizontal) {\n      const labelTag: 'legend' | 'label' = isFieldset ? 'legend' : 'label'\n      if (this.labelSrOnlyBoolean) {\n        if (labelContent) {\n          $label = h(\n            labelTag,\n            {\n              class: 'visually-hidden',\n              id: labelId,\n              for: props.labelFor || null,\n            },\n            labelContent\n          )\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, this.labelColProps, {default: () => $label})\n        } else {\n          $label = h('div', {}, [$label])\n        }\n      } else {\n        const renderProps = {\n          onClick: isFieldset ? this.onLegendClick : null,\n          ...(this.isHorizontal ? this.labelColProps : {}),\n          tag: this.isHorizontal ? labelTag : null,\n          id: labelId,\n          for: props.labelFor || null,\n          tabIndex: isFieldset ? '-1' : null,\n          class: [\n            this.isHorizontal ? 'col-form-label' : 'form-label',\n            {\n              'bv-no-focus-ring': isFieldset,\n              'col-form-label': this.isHorizontal || isFieldset,\n              'pt-0': !this.isHorizontal && isFieldset,\n              'd-block': !this.isHorizontal && !isFieldset,\n              [`col-form-label-${props.labelSize}`]: !!props.labelSize,\n            },\n            this.labelAlignClasses,\n            props.labelClass,\n          ],\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, renderProps, {default: () => labelContent})\n        } else {\n          $label = h(labelTag, renderProps, labelContent)\n        }\n      }\n    }\n\n    let $invalidFeedback = null\n    const invalidFeedbackContent =\n      normalizeSlot(SLOT_NAME_INVALID_FEEDBACK, {}, slots) || this.invalidFeedback\n    const invalidFeedbackId = invalidFeedbackContent ? getId('_BV_feedback_invalid_') : undefined\n\n    if (invalidFeedbackContent) {\n      $invalidFeedback = h(\n        BFormInvalidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: invalidFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => invalidFeedbackContent}\n      )\n    }\n\n    let $validFeedback = null\n    const validFeedbackContent =\n      normalizeSlot(SLOT_NAME_VALID_FEEDBACK, {}, slots) || this.validFeedback\n    const validFeedbackId = validFeedbackContent ? getId('_BV_feedback_valid_') : undefined\n\n    if (validFeedbackContent) {\n      $validFeedback = h(\n        BFormValidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: validFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => validFeedbackContent}\n        // validFeedbackContent\n      )\n    }\n\n    let $description = null\n    const descriptionContent = normalizeSlot(SLOT_NAME_DESCRIPTION, {}, slots) || this.description\n    const descriptionId = descriptionContent ? getId('_BV_description_') : undefined\n    if (descriptionContent) {\n      $description = h(\n        BFormText,\n        {\n          id: descriptionId,\n        },\n        {default: () => descriptionContent}\n      )\n    }\n\n    // Update `ariaDescribedby`\n    // Screen readers will read out any content linked to by `aria-describedby`\n    // even if the content is hidden with `display: none;`, hence we only include\n    // feedback Ids if the form group's state is explicitly valid or invalid\n    const ariaDescribedby = (this.ariaDescribedby =\n      [\n        descriptionId,\n        this.stateBoolean === false ? invalidFeedbackId : null,\n        this.stateBoolean === true ? validFeedbackId : null,\n      ]\n        .filter((x) => x)\n        .join(' ') || null)\n\n    const contentBlocks = [\n      normalizeSlot(SLOT_NAME_DEFAULT, {ariaDescribedby, descriptionId, id, labelId}, slots) || '',\n      $invalidFeedback,\n      $validFeedback,\n      $description,\n    ]\n    if (!this.isHorizontal && this.floatingBoolean) contentBlocks.push($label)\n\n    let $content = h(\n      'div',\n      {\n        ref: 'content',\n        class: [\n          {\n            'form-floating': !this.isHorizontal && this.floatingBoolean,\n          },\n        ],\n      },\n      contentBlocks\n    )\n    if (this.isHorizontal) {\n      $content = h(BCol, {ref: 'content', ...this.contentColProps}, {default: () => contentBlocks})\n    }\n\n    // Return it wrapped in a form group\n    // Note: Fieldsets do not support adding `row` or `form-row` directly\n    // to them due to browser specific render issues, so we move the `form-row`\n    // to an inner wrapper div when horizontal and using a fieldset\n    const rowProps = {\n      'class': [\n        this.stateClass,\n        {\n          'was-validated': this.validatedBoolean,\n        },\n      ],\n      'id': useId(() => props.id).value,\n      'disabled': isFieldset ? this.disabledBoolean : null,\n      'role': isFieldset ? null : 'group',\n      'aria-invalid': this.computedAriaInvalid,\n      // Only apply `aria-labelledby` if we are a horizontal fieldset\n      // as the legend is no longer a direct child of fieldset\n      'aria-labelledby': isFieldset && this.isHorizontal ? labelId : null,\n    }\n\n    if (this.isHorizontal && !isFieldset) {\n      return h(BFormRow, rowProps, {default: () => [$label, $content]})\n    }\n\n    return h(\n      isFieldset ? 'fieldset' : 'div',\n      rowProps,\n      this.isHorizontal && isFieldset\n        ? [h(BFormRow, null, {default: () => [$label, $content]})]\n        : this.isHorizontal || !this.floatingBoolean\n        ? [$label, $content]\n        : [$content]\n    )\n  },\n})\n</script>\n","<template>\n  <input\n    :id=\"computedId\"\n    ref=\"input\"\n    :value=\"modelValue\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :type=\"type\"\n    :disabled=\"disabledBoolean\"\n    :placeholder=\"placeholder\"\n    :required=\"requiredBoolean || undefined\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonlyBoolean || plaintextBoolean\"\n    :min=\"min\"\n    :max=\"max\"\n    :step=\"step\"\n    :list=\"type !== 'password' ? list : undefined\"\n    :aria-required=\"requiredBoolean || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\nimport {useBooleanish, useFormInput, useStateClass} from '../../composables'\nimport type {CommonInputProps} from '../../composables/useFormInput'\nimport type {InputType} from '../../types'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      max?: string | number\n      min?: string | number\n      // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet\n      step?: string | number\n      type?: InputType\n    } & CommonInputProps\n  >(),\n  {\n    max: undefined,\n    min: undefined,\n    step: undefined,\n    type: 'text',\n    // CommonInputProps\n    ariaInvalid: undefined,\n    autocomplete: undefined,\n    autofocus: false,\n    debounce: 0,\n    debounceMaxWait: NaN,\n    disabled: false,\n    form: undefined,\n    formatter: undefined,\n    id: undefined,\n    lazy: false,\n    lazyFormatter: false,\n    list: undefined,\n    modelValue: '',\n    name: undefined,\n    number: false,\n    placeholder: undefined,\n    plaintext: false,\n    readonly: false,\n    required: false,\n    size: undefined,\n    state: null,\n    trim: false,\n    // End CommonInputProps\n  }\n)\n\nconst emit = defineEmits<{\n  'blur': [val: FocusEvent]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'change': [val: any]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'input': [val: any]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'update:modelValue': [val: any]\n}>()\n\nconst {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n  useFormInput(props, emit)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst readonlyBoolean = useBooleanish(() => props.readonly)\nconst plaintextBoolean = useBooleanish(() => props.plaintext)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst isHighlighted = ref(false)\n\nconst computedClasses = computed(() => {\n  const isRange = props.type === 'range'\n  const isColor = props.type === 'color'\n  return [\n    stateClass.value,\n    {\n      'form-control-highlighted': isHighlighted.value,\n      'form-range': isRange,\n      'form-control': isColor || (!props.plaintext && !isRange),\n      'form-control-color': isColor,\n      'form-control-plaintext': props.plaintext && !isRange && !isColor,\n      [`form-control-${props.size}`]: !!props.size,\n    },\n  ]\n})\n\ndefineExpose({\n  blur,\n  element: input,\n  focus,\n})\n\n// const highlight = () => {\n//   if (isHighlighted.value === true) return\n//   isHighlighted.value = true\n//   setTimeout(() => {\n//     isHighlighted.value = false\n//   }, 2000)\n// }\n</script>\n","<template>\n  <RenderComponentOrSkip :skip=\"isButtonGroup\" :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"radio\"\n      :disabled=\"disabledBoolean || parentData?.disabled.value\"\n      :required=\"computedRequired || undefined\"\n      :name=\"name || parentData?.name.value\"\n      :form=\"form || parentData?.form.value\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :value=\"value\"\n      :aria-required=\"computedRequired || undefined\"\n      @change=\"modelValue !== undefined && emit('change', modelValue)\"\n      @input=\"modelValue !== undefined && emit('input', modelValue)\"\n    />\n    <label v-if=\"hasDefaultSlot || plainBoolean === false\" :for=\"computedId\" :class=\"labelClasses\">\n      <slot />\n    </label>\n  </RenderComponentOrSkip>\n</template>\n\n<script setup lang=\"ts\">\nimport {useFocus, useVModel} from '@vueuse/core'\nimport {computed, inject, ref, toRef} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonVariant, RadioValue, Size} from '../../types'\nimport {isEmptySlot, radioGroupKey} from '../../utils'\nimport RenderComponentOrSkip from '../RenderComponentOrSkip.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    ariaLabel?: string\n    ariaLabelledby?: string\n    autofocus?: Booleanish\n    button?: Booleanish\n    buttonGroup?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    disabled?: Booleanish\n    form?: string\n    id?: string\n    inline?: Booleanish\n    modelValue?: RadioValue\n    name?: string\n    plain?: Booleanish\n    required?: Booleanish\n    size?: Size\n    state?: Booleanish | null\n    value?: RadioValue\n  }>(),\n  {\n    ariaLabel: undefined,\n    ariaLabelledby: undefined,\n    autofocus: false,\n    button: false,\n    buttonGroup: false,\n    buttonVariant: null,\n    disabled: false,\n    form: undefined,\n    id: undefined,\n    inline: false,\n    modelValue: undefined,\n    name: undefined,\n    plain: false,\n    required: false,\n    size: undefined,\n    state: null,\n    value: true,\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: RadioValue]\n  'input': [value: RadioValue]\n  'update:modelValue': [value: RadioValue]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst computedId = useId(() => props.id, 'form-check')\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst buttonGroupBoolean = useBooleanish(() => props.buttonGroup)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst parentData = inject(radioGroupKey, null)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst hasDefaultSlot = toRef(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: () => parentData?.modelValue.value ?? modelValue.value,\n  set: (newValue) => {\n    if (newValue === undefined) return\n    if (parentData !== null) {\n      parentData.modelValue.value = newValue as RadioValue\n      return\n    }\n    modelValue.value = newValue as RadioValue\n  },\n})\n\nconst computedRequired = toRef(\n  () =>\n    !!(props.name ?? parentData?.name.value) &&\n    (requiredBoolean.value || parentData?.required.value)\n)\n\nconst isButtonGroup = toRef(() => buttonGroupBoolean.value || (parentData?.buttons.value ?? false))\n\nconst classesObject = computed(() => ({\n  plain: plainBoolean.value || (parentData?.plain.value ?? false),\n  button: buttonBoolean.value || (parentData?.buttons.value ?? false),\n  inline: inlineBoolean.value || (parentData?.inline.value ?? false),\n  state: stateBoolean.value || parentData?.state.value,\n  size: props.size ?? parentData?.size.value ?? 'md', // This is where the true default is made\n  buttonVariant: props.buttonVariant ?? parentData?.buttonVariant.value ?? 'secondary', // This is where the true default is made\n}))\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    ref=\"element\"\n    role=\"radiogroup\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <slot name=\"first\" />\n    <BFormRadio v-for=\"item in normalizeOptions\" :key=\"item.self\" v-bind=\"item.props\">\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </BFormRadio>\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AriaInvalid, Booleanish, ButtonVariant, RadioValue, Size} from '../../types'\nimport {computed, nextTick, provide, ref, toRef, watch} from 'vue'\nimport {radioGroupKey} from '../../utils'\nimport BFormRadio from './BFormRadio.vue'\nimport {getGroupAttr, getGroupClasses, useBooleanish, useId} from '../../composables'\nimport {useFocus, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaInvalid?: AriaInvalid\n    autofocus?: Booleanish\n    buttonVariant?: ButtonVariant | null\n    buttons?: Booleanish\n    disabled?: Booleanish\n    disabledField?: string\n    form?: string\n    htmlField?: string\n    id?: string\n    modelValue?: RadioValue\n    name?: string\n    options?: (string | number | Record<string, unknown>)[]\n    plain?: Booleanish\n    required?: Booleanish\n    size?: Size\n    stacked?: Booleanish\n    state?: Booleanish | null\n    textField?: string\n    validated?: Booleanish\n    valueField?: string\n  }>(),\n  {\n    ariaInvalid: undefined,\n    autofocus: false,\n    buttonVariant: 'secondary',\n    buttons: false,\n    disabled: false,\n    disabledField: 'disabled',\n    form: undefined,\n    htmlField: 'html',\n    id: undefined,\n    modelValue: null,\n    name: undefined,\n    options: () => [],\n    plain: false,\n    required: false,\n    size: 'md',\n    stacked: false,\n    state: null,\n    textField: 'text',\n    validated: false,\n    valueField: 'value',\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: RadioValue]\n  'input': [value: RadioValue]\n  'update:modelValue': [value: RadioValue]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId(() => props.id, 'radio')\nconst computedName = useId(() => props.name, 'checkbox')\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst buttonsBoolean = useBooleanish(() => props.buttons)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stackedBoolean = useBooleanish(() => props.stacked)\nconst stateBoolean = useBooleanish(() => props.state)\nconst validatedBoolean = useBooleanish(() => props.validated)\n\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element, {\n  initialValue: autofocusBoolean.value,\n})\n\nprovide(radioGroupKey, {\n  modelValue,\n  buttonVariant: toRef(() => props.buttonVariant),\n  form: toRef(() => props.form),\n  name: computedName,\n  buttons: buttonsBoolean,\n  state: stateBoolean,\n  plain: plainBoolean,\n  size: toRef(() => props.size),\n  inline: toRef(() => !stackedBoolean.value),\n  required: requiredBoolean,\n  disabled: disabledBoolean,\n})\n\nwatch(modelValue, (newValue) => {\n  emit('input', newValue)\n  nextTick(() => {\n    emit('change', newValue)\n  })\n})\n\nconst normalizeOptions = computed(() =>\n  props.options.map((el, ind) =>\n    typeof el === 'string' || typeof el === 'number'\n      ? {\n          props: {\n            value: el,\n            disabled: disabledBoolean.value,\n          },\n          text: el.toString(),\n          html: undefined,\n          self: Symbol(`radioGroupOptionItem${ind}`),\n        }\n      : {\n          props: {\n            value: el[props.valueField] as string | undefined,\n            disabled: el[props.disabledField] as boolean | undefined,\n            ...(el.props ? el.props : {}),\n          },\n          text: el[props.textField] as string | undefined,\n          html: el[props.htmlField] as string | undefined,\n          self: Symbol(`radioGroupOptionItem${ind}`),\n        }\n  )\n)\n\nconst classesObject = computed(() => ({\n  required: requiredBoolean.value,\n  ariaInvalid: props.ariaInvalid,\n  state: stateBoolean.value,\n  validated: validatedBoolean.value,\n  buttons: buttonsBoolean.value,\n  stacked: stackedBoolean.value,\n  size: props.size,\n}))\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <option :value=\"value\" :disabled=\"disabledBoolean\">\n    <slot />\n  </option>\n</template>\n\n<script setup lang=\"ts\">\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\n\nconst props = withDefaults(\n  defineProps<{\n    disabled?: Booleanish\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    value?: any\n  }>(),\n  {\n    disabled: false,\n    value: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n</script>\n","<template>\n  <optgroup :label=\"label\">\n    <slot name=\"first\" />\n    <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n    <!-- eslint-disable vue/no-v-html -->\n    <!-- TODO these options don't seem right for the component -->\n    <BFormSelectOption\n      v-for=\"(option, index) in formOptions\"\n      :key=\"index\"\n      :value=\"(option as any).value\"\n      :disabled=\"(option as any).disabled\"\n      v-bind=\"$attrs\"\n      v-html=\"(option as any).html || (option as any).text\"\n    />\n    <!--eslint-enable-->\n    <slot />\n  </optgroup>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport {normalizeOptions} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    disabledField?: string\n    htmlField?: string\n    label?: string\n    options?: unknown[] | Record<string, unknown>\n    textField?: string\n    valueField?: string\n  }>(),\n  {\n    disabledField: 'disabled',\n    htmlField: 'html',\n    label: undefined,\n    options: () => [],\n    textField: 'text',\n    valueField: 'value',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\n// TODO this needs to be redone to fit the structure of BFormCheckboxGroup\nconst formOptions = computed(() =>\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  normalizeOptions(props.options as any[], 'BFormSelectOptionGroup', props)\n)\n</script>\n","<template>\n  <select\n    :id=\"computedId\"\n    ref=\"input\"\n    v-model=\"localValue\"\n    :class=\"computedClasses\"\n    :name=\"name\"\n    :form=\"form || undefined\"\n    :multiple=\"multipleBoolean || undefined\"\n    :size=\"computedSelectSize\"\n    :disabled=\"disabledBoolean\"\n    :required=\"requiredBoolean || undefined\"\n    :aria-required=\"requiredBoolean || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n  >\n    <slot name=\"first\" />\n    <template v-for=\"(option, index) in formOptions\" :key=\"index\">\n      <BFormSelectOptionGroup\n        v-if=\"Array.isArray((option as any).options)\"\n        :label=\"(option as any).label\"\n        :options=\"(option as any).options\"\n      />\n      <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n      <!-- eslint-disable vue/no-v-html -->\n      <BFormSelectOption\n        v-else\n        :value=\"(option as any).value\"\n        :disabled=\"(option as any).disabled\"\n        v-html=\"(option as any).html || (option as any).text\"\n      />\n      <!--eslint-enable-->\n    </template>\n    <slot />\n  </select>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AriaInvalid, Booleanish, Size} from '../../types'\nimport {computed, nextTick, ref, toRef} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport BFormSelectOptionGroup from './BFormSelectOptionGroup.vue'\nimport {\n  normalizeOptions,\n  useAriaInvalid,\n  useBooleanish,\n  useId,\n  useStateClass,\n} from '../../composables'\nimport {useFocus, useToNumber, useVModel} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    ariaInvalid?: AriaInvalid\n    autofocus?: Booleanish\n    disabled?: Booleanish\n    disabledField?: string\n    form?: string\n    htmlField?: string\n    id?: string\n    labelField?: string\n    modelValue?: string | unknown[] | Record<string, unknown> | number | null\n    multiple?: Booleanish\n    name?: string\n    options?: unknown[] | Record<string, unknown> // TODO It was declared deprecated in useFormSelect to use a Record. https://bootstrap-vue.org/docs/components/form-select#options-as-an-object\n    optionsField?: string\n    plain?: Booleanish\n    required?: Booleanish\n    selectSize?: number | string\n    size?: Size\n    state?: Booleanish | null\n    textField?: string\n    valueField?: string\n  }>(),\n  {\n    ariaInvalid: undefined,\n    autofocus: false,\n    disabled: false,\n    disabledField: 'disabled',\n    form: undefined,\n    htmlField: 'html',\n    id: undefined,\n    labelField: 'label',\n    modelValue: '',\n    multiple: false,\n    name: undefined,\n    options: () => [],\n    optionsField: 'options',\n    plain: false,\n    required: false,\n    selectSize: 0,\n    size: 'md',\n    state: null,\n    textField: 'text',\n    valueField: 'value',\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: unknown]\n  'input': [value: unknown]\n  'update:modelValue': [value: unknown]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  first?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId(() => props.id, 'input')\n\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst multipleBoolean = useBooleanish(() => props.multiple)\nconst plainBoolean = useBooleanish(() => props.plain)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\nconst selectSizeNumber = useToNumber(() => props.selectSize)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst input = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    'form-control': plainBoolean.value,\n    [`form-control-${props.size}`]: props.size !== 'md' && plainBoolean.value,\n    'form-select': !plainBoolean.value,\n    [`form-select-${props.size}`]: props.size !== 'md' && !plainBoolean.value,\n  },\n])\n\nconst computedSelectSize = toRef(() =>\n  selectSizeNumber.value || plainBoolean.value ? selectSizeNumber.value : undefined\n)\n\nconst computedAriaInvalid = useAriaInvalid(() => props.ariaInvalid, stateBoolean)\n\n// TODO this needs to be redone to fit the structure of BFormCheckboxGroup\n// It also doesn't work for array syntaxes. Review second example from https://bootstrap-vue.org/docs/components/form-select\n// For more info on how it should behave\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst formOptions = computed(() => normalizeOptions(props.options as any[], 'BFormSelect', props))\nconst localValue = computed({\n  get: () => modelValue.value,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  set: (newValue: any) => {\n    emit('input', newValue)\n    modelValue.value = newValue\n    nextTick(() => {\n      emit('change', newValue)\n    })\n  },\n})\n\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","import {RX_STRIP_LOCALE_MODS} from '../constants/regex'\nimport {toString} from './stringUtils'\n\n// Languages that are RTL\nconst RTL_LANGS = [\n  'ar',\n  'az',\n  'ckb',\n  'fa',\n  'he',\n  'ks',\n  'lrc',\n  'mzn',\n  'ps',\n  'sd',\n  'te',\n  'ug',\n  'ur',\n  'yi',\n].map((locale) => locale.toLowerCase())\n\n// Returns true if the locale is RTL\n/**\n * @deprecated -- there's probably a better way to do this, but I also don't know what its for\n */\nexport const isLocaleRTL = (locale: string) => {\n  // Determines if the locale is RTL (only single locale supported)\n  const parts = toString(locale).toLowerCase().replace(RX_STRIP_LOCALE_MODS, '').split('-')\n  const locale1 = parts.slice(0, 2).join('-')\n  const [locale2] = parts\n  return RTL_LANGS.includes(locale1) || RTL_LANGS.includes(locale2)\n}\n","import {HAS_PASSIVE_EVENT_SUPPORT} from './env'\nimport {isObject} from './inspect'\n\n// Normalize event options based on support of passive option\n// Exported only for testing purposes\n/**\n * @deprecated\n */\nexport const parseEventOptions = (\n  options: boolean | EventListenerOptions | undefined\n): boolean | EventListenerOptions | undefined => {\n  if (HAS_PASSIVE_EVENT_SUPPORT) {\n    return isObject(options) ? options : {capture: !!options || false}\n  }\n  // Need to translate to actual Boolean value\n  return !!(isObject(options) ? options.capture : options)\n}\n\n// Attach an event listener to an element\n/**\n * @deprecated\n */\nexport const eventOn = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.addEventListener) {\n    el.addEventListener(eventName, handler, parseEventOptions(options))\n  }\n}\n\n// Remove an event listener from an element\n/**\n * @deprecated\n */\nexport const eventOff = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.removeEventListener) {\n    el.removeEventListener(eventName, handler, options)\n  }\n}\n\n// Utility method to add/remove a event listener based on first argument (boolean)\n// It passes all other arguments to the `eventOn()` or `eventOff` method\n/**\n * @deprecated\n */\nexport const eventOnOff = (on: boolean, eventParams: Parameters<typeof eventOff>) => {\n  const method = on ? eventOn : eventOff\n  method(...eventParams)\n}\n\n// Utility method to prevent the default event handling and propagation\n/**\n * @deprecated\n */\nexport const stopEvent = (\n  event: Event,\n  {preventDefault = true, propagation = true, immediatePropagation = false} = {}\n) => {\n  if (preventDefault) {\n    event.preventDefault()\n  }\n  if (propagation) {\n    event.stopPropagation()\n  }\n  if (immediatePropagation) {\n    event.stopImmediatePropagation()\n  }\n}\n","export const CODE_BACKSPACE = 'Backspace'\nexport const CODE_BREAK = 19\nexport const CODE_DELETE = 46\nexport const CODE_DOWN = 'ArrowDown'\nexport const CODE_END = 'End'\nexport const CODE_ENTER = 13\nexport const CODE_ESC = 27\nexport const CODE_HOME = 'Home'\nexport const CODE_LEFT = 37\nexport const CODE_PAGEDOWN = 'PageDown'\nexport const CODE_PAGEUP = 'PageUp'\nexport const CODE_RIGHT = 39\nexport const CODE_SPACE = 32\nexport const CODE_UP = 'ArrowUp'\n","<template>\n  <div\n    ref=\"element\"\n    class=\"b-form-spinbutton form-control\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    :lang=\"computedLocale\"\n    :tabindex=\"disabledBoolean ? undefined : '-1'\"\n    :title=\"ariaLabel\"\n    @click=\"focused = true\"\n  >\n    <!-- eslint-disable-next-line prettier/prettier -->\n    <slot :name=\"(buttons.top.slot.name as 'increment' | 'decrement')\" :has-focus=\"focused\">\n      <button\n        v-bind=\"buttons.top.button\"\n        @mousedown=\"buttons.top.handler\"\n        @touchstart=\"buttons.top.handler\"\n      >\n        <svg v-bind=\"buttons.top.svg\">\n          <path v-bind=\"buttons.top.path\" />\n        </svg>\n      </button>\n    </slot>\n    <input\n      v-if=\"name && !disabledBoolean\"\n      key=\"hidden\"\n      type=\"hidden\"\n      :name=\"name\"\n      :form=\"form\"\n      :value=\"valueAsFixed\"\n    />\n    <output\n      :id=\"computedId\"\n      key=\"output\"\n      class=\"flex-grow-1\"\n      :class=\"computedSpinClasses\"\n      :dir=\"computedRTL ? 'rtl' : 'ltr'\"\n      :tabindex=\"disabledBoolean ? undefined : '0'\"\n      role=\"spinbutton\"\n      aria-live=\"off\"\n      :aria-label=\"ariaLabel || undefined\"\n      :aria-invalid=\"\n        stateBoolean === false || (!modelValue !== null && requiredBoolean) ? true : undefined\n      \"\n      :aria-required=\"requiredBoolean ? true : undefined\"\n      :aria-valuemin=\"computedMin\"\n      :aria-valuemax=\"computedMax\"\n      :aria-valuenow=\"modelValue !== null ? modelValue : undefined\"\n      :aria-valuetext=\"modelValue !== null ? computedFormatter(modelValue) : undefined\"\n    >\n      <bdi>\n        {{ (modelValue !== null ? computedFormatter(modelValue) : placeholder) || '' }}\n      </bdi>\n    </output>\n    <!-- eslint-disable-next-line prettier/prettier -->\n    <slot :name=\"(buttons.bottom.slot.name as 'increment' | 'decrement')\" :has-focus=\"focused\">\n      <button\n        v-bind=\"buttons.bottom.button\"\n        @mousedown=\"buttons.bottom.handler\"\n        @touchstart=\"buttons.bottom.handler\"\n      >\n        <svg v-bind=\"buttons.bottom.svg\">\n          <path v-bind=\"buttons.bottom.path\" />\n        </svg>\n      </button>\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, toRef} from 'vue'\nimport type {Booleanish, ButtonType, Size} from '../../types'\nimport {isLocaleRTL} from '../../utils/locale'\nimport {eventOnOff, stopEvent} from '../../utils/event'\nimport {\n  CODE_DOWN,\n  CODE_END,\n  CODE_HOME,\n  CODE_PAGEDOWN,\n  CODE_PAGEUP,\n  CODE_UP,\n} from '../../constants/codes'\nimport {onKeyStroke, useFocus, useToNumber, useVModel} from '@vueuse/core'\nimport {useBooleanish, useId} from '../../composables'\n\nconst KEY_CODES = [CODE_UP, CODE_DOWN, CODE_HOME, CODE_END, CODE_PAGEUP, CODE_PAGEDOWN]\n\nconst props = withDefaults(\n  defineProps<{\n    ariaControls?: string\n    ariaLabel?: string\n    disabled?: Booleanish\n    form?: string\n    formatterFn?: (value: number) => string\n    id?: string\n    inline?: Booleanish\n    labelDecrement?: string\n    labelIncrement?: string\n    locale?: string\n    max?: string | number\n    min?: string | number\n    modelValue?: number | null\n    name?: string\n    placeholder?: string\n    readonly?: Booleanish\n    repeatDelay?: string | number\n    repeatInterval?: string | number\n    repeatStepMultiplier?: string | number\n    repeatThreshold?: string | number\n    required?: Booleanish\n    size?: Size\n    state?: Booleanish | null\n    step?: string | number\n    vertical?: Booleanish\n    wrap?: Booleanish\n  }>(),\n  {\n    ariaControls: undefined,\n    ariaLabel: undefined,\n    disabled: false,\n    form: undefined,\n    formatterFn: undefined,\n    id: undefined,\n    inline: false,\n    labelDecrement: 'Decrement',\n    labelIncrement: 'Increment',\n    locale: 'locale',\n    max: defaultValues.max,\n    min: defaultValues.min,\n    modelValue: null,\n    name: undefined,\n    placeholder: undefined,\n    readonly: false,\n    repeatDelay: defaultValues.repeatDelay,\n    repeatInterval: defaultValues.repeatInterval,\n    repeatStepMultiplier: defaultValues.repeatMultiplier,\n    repeatThreshold: defaultValues.repeatThreshold,\n    required: false,\n    size: undefined,\n    state: null,\n    step: defaultValues.step,\n    vertical: false,\n    wrap: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'change': [value: number | null]\n  'update:modelValue': [value: number | null]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  decrement?: (props: {hasFocus: boolean}) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  increment?: (props: {hasFocus: boolean}) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\n// TODO focus system\nconst element = ref<HTMLElement | null>(null)\n\nconst {focused} = useFocus(element)\n\nconst computedId = useId(() => props.id, 'spinbutton')\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst inlineBoolean = useBooleanish(() => props.inline)\nconst readonlyBoolean = useBooleanish(() => props.readonly)\nconst verticalBoolean = useBooleanish(() => props.vertical)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst wrapBoolean = useBooleanish(() => props.wrap)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst computedClasses = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'readonly': readonlyBoolean.value,\n  'focus': focused.value,\n  'd-inline-flex': inlineBoolean.value || verticalBoolean.value,\n  'd-flex': !inlineBoolean.value && !verticalBoolean.value,\n  'align-items-stretch': !verticalBoolean.value,\n  'flex-column': verticalBoolean.value,\n  [`form-control-${props.size}`]: props.size !== undefined,\n}))\n\nconst computedSpinClasses = computed(() => ({\n  'd-flex': verticalBoolean.value,\n  'align-self-center': !verticalBoolean.value,\n  'align-items-center': verticalBoolean.value,\n  'border-top': verticalBoolean.value,\n  'border-bottom': verticalBoolean.value,\n  'border-start': !verticalBoolean.value,\n  'border-end': !verticalBoolean.value,\n}))\n\n//non reactive properties\nlet $_autoDelayTimer: ReturnType<typeof setTimeout> | undefined\nlet $_autoRepeatTimer: ReturnType<typeof setTimeout> | undefined\nlet $_keyIsDown = false\n\n// const computedInline = computed(() => props.inline && !props.vertical)\n\n// const computedReadonly = computed(() => props.readonly && !props.disabled)\n\nconst stepNumber = useToNumber(() => props.step)\nconst computedStep = toRef(() =>\n  Number.isNaN(stepNumber.value) ? defaultValues.step : stepNumber.value\n)\n\nconst minNumber = useToNumber(() => props.min)\nconst computedMin = toRef(() =>\n  Number.isNaN(minNumber.value) ? defaultValues.min : minNumber.value\n)\n\nconst maxNumber = useToNumber(() => props.max)\nconst computedMax = toRef(() => {\n  const step = computedStep.value\n  const min = computedMin.value\n  return Math.floor((maxNumber.value - min) / step) * step + min\n})\n\nconst repeatDelayNumber = useToNumber(() => props.repeatDelay, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedDelay = toRef(() =>\n  repeatDelayNumber.value > 0 ? repeatDelayNumber.value : defaultValues.repeatDelay\n)\n\nconst repeatIntervalNumber = useToNumber(() => props.repeatInterval, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedInterval = toRef(() =>\n  repeatIntervalNumber.value > 0 ? repeatIntervalNumber.value : defaultValues.repeatInterval\n)\n\nconst repeatThresholdNumber = useToNumber(() => props.repeatThreshold, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedThreshold = toRef(() =>\n  Math.max(\n    Number.isNaN(repeatThresholdNumber.value)\n      ? defaultValues.repeatThreshold\n      : repeatThresholdNumber.value,\n    1\n  )\n)\n\nconst repeatStepMultiplierNumber = useToNumber(() => props.repeatStepMultiplier, {\n  nanToZero: true,\n  method: 'parseInt',\n})\nconst computedStepMultiplier = toRef(() =>\n  Math.max(\n    Number.isNaN(repeatStepMultiplierNumber.value)\n      ? defaultValues.repeatMultiplier\n      : repeatStepMultiplierNumber.value,\n    1\n  )\n)\n\nconst computedPrecision = toRef(() => {\n  const step = computedStep.value\n  return Math.floor(step) === step ? 0 : (step.toString().split('.')[1] || '').length\n})\n\nconst computedMultiplier = toRef(() => Math.pow(10, computedPrecision.value || 0))\n\nconst valueAsFixed = toRef(() =>\n  modelValue.value === null ? '' : modelValue.value.toFixed(computedPrecision.value)\n)\n\nconst computedLocale = computed(() => {\n  // TODO\n  const locales = [props.locale]\n  const nf = new Intl.NumberFormat(locales)\n  return nf.resolvedOptions().locale\n})\n\nconst computedRTL = computed(() =>\n  // TODO\n  isLocaleRTL(computedLocale.value)\n)\n\nconst defaultFormatter = () =>\n  new Intl.NumberFormat(computedLocale.value, {\n    style: 'decimal',\n    useGrouping: false,\n    minimumIntegerDigits: 1,\n    minimumFractionDigits: computedPrecision.value,\n    maximumFractionDigits: computedPrecision.value,\n    notation: 'standard',\n  }).format\n\nconst computedFormatter = toRef(() => props.formatterFn ?? defaultFormatter())\n\nconst stepValue = (direction: number) => {\n  // Sets a new incremented or decremented value, supporting optional wrapping\n  // Direction is either +1 or -1 (or a multiple thereof)\n  let {value} = modelValue\n  if (!disabledBoolean.value && value !== null) {\n    const step = computedStep.value * direction\n    const min = computedMin.value\n    const max = computedMax.value\n    const multiplier = computedMultiplier.value\n    const {wrap} = props\n    // We ensure that the value steps like a native input\n    value = Math.round((value - min) / step) * step + min + step\n    // We ensure that precision is maintained (decimals)\n    value = Math.round(value * multiplier) / multiplier\n    // Handle if wrapping is enabled\n    modelValue.value = value > max ? (wrap ? min : max) : value < min ? (wrap ? max : min) : value\n  }\n}\n\nconst stepUp = (multiplier = 1) => {\n  if (modelValue.value === null) {\n    modelValue.value = computedMin.value\n    return\n  }\n  stepValue(+1 * multiplier)\n}\n\nconst stepDown = (multiplier = 1) => {\n  if (modelValue.value === null) {\n    modelValue.value = wrapBoolean.value ? computedMax.value : computedMin.value\n    return\n  }\n  stepValue(-1 * multiplier)\n}\n\nonKeyStroke(\n  KEY_CODES,\n  (event) => {\n    const {code, altKey, ctrlKey, metaKey} = event\n\n    if (disabledBoolean.value || readonlyBoolean.value || altKey || ctrlKey || metaKey) return\n\n    // https://w3c.github.io/aria-practices/#spinbutton\n    stopEvent(event, {propagation: false})\n    if ($_keyIsDown) {\n      // Keypress is already in progress\n      return\n    }\n\n    resetTimers()\n    if ([CODE_UP, CODE_DOWN].includes(code)) {\n      // The following use the custom auto-repeat handling\n\n      $_keyIsDown = true\n      if (code === CODE_UP) {\n        handleStepRepeat(event, stepUp)\n        return\n      }\n      if (code === CODE_DOWN) {\n        handleStepRepeat(event, stepDown)\n      }\n      return\n    }\n    // These use native OS key repeating\n    if (code === CODE_PAGEUP) {\n      stepUp(computedStepMultiplier.value)\n      return\n    }\n    if (code === CODE_PAGEDOWN) {\n      stepDown(computedStepMultiplier.value)\n      return\n    }\n    if (code === CODE_HOME) {\n      modelValue.value = computedMin.value\n      return\n    }\n    if (code === CODE_END) {\n      modelValue.value = computedMax.value\n    }\n  },\n  {target: element, eventName: 'keydown'}\n)\n\nonKeyStroke(\n  KEY_CODES,\n  (event: KeyboardEvent) => {\n    // Emit a change event when the keyup happens\n\n    const {altKey, ctrlKey, metaKey} = event\n\n    if (disabledBoolean.value || readonlyBoolean.value || altKey || ctrlKey || metaKey) return\n\n    stopEvent(event, {propagation: false})\n    resetTimers()\n    $_keyIsDown = false\n    emit('change', modelValue.value)\n  },\n  {target: element, eventName: 'keyup'}\n)\n\n// takes in a mount or Keyboard Event\nconst handleStepRepeat = (event: Event, stepper: (step: number) => void) => {\n  const {type} = event || {}\n\n  if (!disabledBoolean.value && !readonlyBoolean.value) {\n    if (isMouseEvent(event)) {\n      // We only respond to left (main === 0) button clicks\n      if (type === 'mousedown' && event.button) return\n    }\n    resetTimers()\n    // Step the counter initially\n    stepper(1)\n    const threshold = computedThreshold.value\n    const multiplier = computedStepMultiplier.value\n    const delay = computedDelay.value\n    const interval = computedInterval.value\n\n    // Initiate the delay/repeat interval\n    $_autoDelayTimer = setTimeout(() => {\n      let count = 0\n      $_autoRepeatTimer = setInterval(() => {\n        // After N initial repeats, we increase the incrementing step amount\n        // We do this to minimize screen reader announcements of the value\n        // (values are announced every change, which can be chatty for SR users)\n        // And to make it easer to select a value when the range is large\n        stepper(count < threshold ? 1 : multiplier)\n        count++\n      }, interval)\n    }, delay)\n  }\n}\n\nconst isMouseEvent = (evt: Event): evt is MouseEvent =>\n  evt.type === 'mouseup' || evt.type === 'mousedown'\n\nconst onMouseup: EventListener = (event: Event) => {\n  // `<body>` listener, only enabled when mousedown starts\n\n  if (isMouseEvent(event)) {\n    if (event.type === 'mouseup' && event.button) {\n      // Ignore non left button (main === 0) mouse button click\n      return\n    }\n  }\n\n  stopEvent(event, {propagation: false})\n  resetTimers()\n  setMouseup(false)\n  // Trigger the change event\n  emit('change', modelValue.value)\n}\n\nconst setMouseup = (on: boolean) => {\n  // Enable or disabled the body mouseup/touchend handlers\n  // Use try/catch to handle case when called server side\n  try {\n    eventOnOff(on, [document.body, 'mouseup', onMouseup, false])\n    eventOnOff(on, [document.body, 'touchend', onMouseup, false])\n  } catch {\n    /* empty */\n  }\n}\nconst resetTimers = () => {\n  clearTimeout($_autoDelayTimer)\n  clearInterval($_autoRepeatTimer)\n  $_autoDelayTimer = undefined\n  $_autoRepeatTimer = undefined\n}\n\nconst buttons = computed(() => {\n  const incrementSvgAttrs = {\n    svg: {\n      xmlns: 'http://www.w3.org/2000/svg',\n      width: '16',\n      height: '16',\n      fill: 'currentColor',\n      class: 'bi bi-plus',\n      viewBox: '0 0 16 16',\n    },\n    path: {\n      d: 'M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z',\n    },\n  } as const\n\n  const decrementSvgAttrs = {\n    svg: {\n      xmlns: 'http://www.w3.org/2000/svg',\n      width: '16',\n      height: '16',\n      fill: 'currentColor',\n      class: 'bi bi-dash',\n      viewBox: '0 0 16 16',\n    },\n    path: {d: 'M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z'},\n  } as const\n\n  const sharedButtonAttrs = {\n    'class': [{'py-0': !verticalBoolean.value}, 'btn', 'btn-sm', 'border-0', 'rounded-0'],\n    'tabindex': '-1',\n    'type': 'button' as ButtonType,\n    'disabled': disabledBoolean.value || readonlyBoolean.value,\n    'aria-disabled': disabledBoolean.value || readonlyBoolean.value ? true : undefined,\n    'aria-controls': computedId.value,\n  }\n\n  const sharedSvgAttrs = {\n    'aria-hidden': true,\n    'scale': focused.value ? 1.5 : 1.25,\n  }\n\n  const handler = (event: Event, stepper: (multiplier?: number) => void) => {\n    if (!disabledBoolean.value && !readonlyBoolean.value) {\n      stopEvent(event, {propagation: false})\n      setMouseup(true)\n      // Since we `preventDefault()`, we must manually focus the button\n      // Though it's likely captured from the element click focus\n      focused.value = true\n      handleStepRepeat(event, stepper)\n    }\n  }\n\n  const incrementAttrs = {\n    button: {\n      ...sharedButtonAttrs,\n      'aria-label': props.labelIncrement || undefined,\n      'aria-keyshortcuts': 'ArrowUp',\n    },\n    svg: {\n      ...sharedSvgAttrs,\n      ...incrementSvgAttrs.svg,\n    },\n    path: {\n      ...incrementSvgAttrs.path,\n    },\n    slot: {\n      name: 'increment',\n    },\n    handler: (e: Event) => handler(e, stepUp),\n  }\n\n  const decrementAttrs = {\n    button: {\n      ...sharedButtonAttrs,\n      'aria-label': props.labelDecrement || undefined,\n      'aria-keyshortcuts': 'ArrowDown',\n    },\n    svg: {\n      ...sharedSvgAttrs,\n      ...decrementSvgAttrs.svg,\n    },\n    path: {\n      ...decrementSvgAttrs.path,\n    },\n    slot: {\n      name: 'decrement',\n    },\n    handler: (e: Event) => handler(e, stepDown),\n  }\n\n  return {\n    top: {\n      ...(verticalBoolean.value ? incrementAttrs : decrementAttrs),\n    },\n    bottom: {\n      ...(!verticalBoolean.value ? incrementAttrs : decrementAttrs),\n    },\n  }\n})\n</script>\n\n<script lang=\"ts\">\nconst defaultValues = {\n  min: 1,\n  max: 100,\n  step: 1,\n  repeatDelay: 500,\n  repeatInterval: 100,\n  repeatThreshold: 10,\n  repeatMultiplier: 4,\n} as const\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    :title=\"tagText\"\n    class=\"badge b-form-tag d-inline-flex align-items-center mw-100\"\n    :class=\"computedClasses\"\n    :aria-labelledby=\"taglabelId\"\n  >\n    <span :id=\"taglabelId\" class=\"b-form-tag-content flex-grow-1 text-truncate\">\n      <slot>{{ tagText }}</slot>\n    </span>\n    <BCloseButton\n      v-if=\"!disabledBoolean && !noRemoveBoolean\"\n      aria-keyshortcuts=\"Delete\"\n      :aria-label=\"removeLabel\"\n      class=\"b-form-tag-remove\"\n      :aria-describedby=\"taglabelId\"\n      :aria-controls=\"id\"\n      @click=\"emit('remove', tagText)\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BCloseButton from '../BButton/BCloseButton.vue'\n\nconst props = withDefaults(\n  defineProps<{\n    disabled?: Booleanish\n    id?: string\n    noRemove?: Booleanish\n    pill?: Booleanish\n    removeLabel?: string\n    tag?: string\n    title?: string\n    variant?: ColorVariant | null\n  }>(),\n  {\n    disabled: false,\n    id: undefined,\n    noRemove: false,\n    pill: false,\n    removeLabel: 'Remove tag',\n    tag: 'span',\n    title: undefined,\n    variant: 'secondary',\n  }\n)\n\nconst emit = defineEmits<{\n  remove: [value: string]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedId = useId(() => props.id)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst noRemoveBoolean = useBooleanish(() => props.noRemove)\nconst pillBoolean = useBooleanish(() => props.pill)\n\nconst tagText = computed(\n  () => ((slots.default?.({})[0].children ?? '').toString() || props.title) ?? ''\n)\nconst taglabelId = toRef(() => `${computedId.value}taglabel__`)\n\nconst computedClasses = computed(() => ({\n  [`text-bg-${props.variant}`]: props.variant !== null,\n  'rounded-pill': pillBoolean.value,\n  'disabled': disabledBoolean.value,\n}))\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    class=\"b-form-tags form-control h-auto\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    tabindex=\"-1\"\n    @focusin=\"onFocusin\"\n    @focusout=\"emit('focusout', $event)\"\n  >\n    <output\n      :id=\"`${computedId}selected_tags__`\"\n      class=\"visually-hidden\"\n      :for=\"_inputId\"\n      :aria-live=\"focused ? 'polite' : 'off'\"\n      aria-atomic=\"true\"\n      aria-relevant=\"additions text\"\n      >{{ tags.join(', ') }}</output\n    >\n    <div\n      :id=\"`${computedId}removed_tags__`\"\n      role=\"status\"\n      :aria-live=\"focused ? 'assertive' : 'off'\"\n      aria-atomic=\"true\"\n      class=\"visually-hidden\"\n    >\n      ({{ tagRemovedLabel }}) {{ lastRemovedTag }}\n    </div>\n\n    <slot v-bind=\"slotAttrs\">\n      <ul\n        :id=\"`${computedId}tag_list__`\"\n        class=\"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      >\n        <template v-for=\"(tag, index) in tags\" :key=\"index\">\n          <slot\n            name=\"tag\"\n            :tag=\"tag\"\n            :tag-class=\"tagClass\"\n            :tag-variant=\"tagVariant\"\n            :tag-pills=\"tagPillsBoolean\"\n            :remove-tag=\"removeTag\"\n          >\n            <BFormTag\n              :key=\"tag\"\n              :class=\"tagClass\"\n              tag=\"li\"\n              :variant=\"tagVariant\"\n              :pill=\"tagPills\"\n              @remove=\"removeTag\"\n              >{{ tag }}</BFormTag\n            >\n          </slot>\n        </template>\n        <li\n          role=\"none\"\n          aria-live=\"off\"\n          class=\"b-from-tags-field flex-grow-1\"\n          :aria-controls=\"`${computedId}tag_list__`\"\n        >\n          <div role=\"group\" class=\"d-flex\">\n            <input\n              :id=\"_inputId\"\n              ref=\"input\"\n              :disabled=\"disabledBoolean\"\n              :value=\"inputValue\"\n              :type=\"inputType\"\n              :placeholder=\"placeholder\"\n              class=\"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\"\n              style=\"outline: currentcolor none 0px; min-width: 5rem\"\n              v-bind=\"inputAttrs\"\n              :form=\"form\"\n              :required=\"requiredBoolean || undefined\"\n              :aria-required=\"requiredBoolean || undefined\"\n              @input=\"onInput\"\n              @change=\"onChange\"\n              @focus=\"onFocus\"\n              @blur=\"onBlur\"\n            />\n            <button\n              v-if=\"disableAddButton\"\n              type=\"button\"\n              class=\"btn b-form-tags-button py-0\"\n              :class=\"[\n                inputClass,\n                {\n                  [`btn-${addButtonVariant}`]: addButtonVariant !== null,\n                  'disabled invisible': inputValue.length === 0,\n                },\n              ]\"\n              style=\"font-size: 90%\"\n              :disabled=\"disabledBoolean || inputValue.length === 0 || isLimitReached\"\n              @click=\"addTag(inputValue)\"\n            >\n              <slot name=\"add-button-text\">{{ addButtonText }}</slot>\n            </button>\n          </div>\n        </li>\n      </ul>\n      <div aria-live=\"polite\" aria-atomic=\"true\">\n        <div v-if=\"isInvalid\" class=\"d-block invalid-feedback\">\n          {{ invalidTagText }}: {{ inputValue }}\n        </div>\n        <small v-if=\"isDuplicate\" class=\"form-text text-body-secondary\"\n          >{{ duplicateTagText }}: {{ inputValue }}</small\n        >\n        <small v-if=\"tags.length === limit\" class=\"form-text text-body-secondary\"\n          >Tag limit reached</small\n        >\n      </div>\n    </slot>\n    <template v-if=\"name\">\n      <input v-for=\"(tag, index) in tags\" :key=\"index\" type=\"hidden\" :name=\"name\" :value=\"tag\" />\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref, toRef, watch} from 'vue'\nimport BFormTag from './BFormTag.vue'\nimport {useBooleanish, useId, useStateClass} from '../../composables'\nimport type {\n  Booleanish,\n  ButtonVariant,\n  ClassValue,\n  ColorVariant,\n  InputType,\n  Size,\n} from '../../types'\nimport {onKeyStroke, useFocus, useToNumber, useVModel} from '@vueuse/core'\nimport {escapeRegExpChars} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    addButtonText?: string\n    addButtonVariant?: ButtonVariant | null\n    addOnChange?: Booleanish\n    autofocus?: Booleanish\n    disabled?: Booleanish\n    duplicateTagText?: string\n    form?: string\n    inputAttrs?: Record<string, unknown>\n    inputClass?: ClassValue\n    inputId?: string\n    inputType?: InputType\n    invalidTagText?: string\n    limit?: number | string\n    limitTagsText?: string\n    modelValue?: string[]\n    name?: string\n    noAddOnEnter?: Booleanish\n    noOuterFocus?: Booleanish\n    noTagRemove?: Booleanish\n    placeholder?: string\n    removeOnDelete?: Booleanish\n    required?: Booleanish\n    separator?: string | string[]\n    size?: Size\n    state?: Booleanish | null\n    tagClass?: ClassValue\n    tagPills?: Booleanish\n    tagRemoveLabel?: string\n    tagRemovedLabel?: string\n    tagValidator?: (t: string) => boolean\n    tagVariant?: ColorVariant | null\n  }>(),\n  {\n    addButtonText: 'Add',\n    addButtonVariant: 'outline-secondary',\n    addOnChange: false,\n    autofocus: false,\n    disabled: false,\n    duplicateTagText: 'Duplicate tag(s)',\n    form: undefined,\n    inputAttrs: undefined,\n    inputClass: undefined,\n    inputId: undefined,\n    inputType: 'text',\n    invalidTagText: 'Invalid tag(s)',\n    limit: undefined,\n    limitTagsText: 'Tag limit reached',\n    modelValue: () => [],\n    name: undefined,\n    noAddOnEnter: false,\n    noOuterFocus: false,\n    noTagRemove: false,\n    placeholder: 'Add tag...',\n    removeOnDelete: false,\n    required: false,\n    separator: undefined,\n    size: 'md',\n    state: null,\n    tagClass: undefined,\n    tagPills: false,\n    tagRemoveLabel: undefined,\n    tagRemovedLabel: 'Tag removed',\n    tagValidator: () => true,\n    tagVariant: 'secondary',\n  }\n)\n\nconst emit = defineEmits<{\n  'blur': [value: FocusEvent]\n  'focus': [value: FocusEvent]\n  'focusin': [value: FocusEvent]\n  'focusout': [value: FocusEvent]\n  'input': [value: string[]]\n  'tag-state': [...args: string[][]]\n  'update:modelValue': [value: string[]]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'add-button-text'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: typeof slotAttrs.value) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tag'?: (props: {\n    tag: string\n    tagClass: ClassValue\n    tagVariant: ColorVariant | null\n    tagPills: boolean\n    removeTag: (tag?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst computedId = useId()\n\nconst addOnChangeBoolean = useBooleanish(() => props.addOnChange)\nconst autofocusBoolean = useBooleanish(() => props.autofocus)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst noAddOnEnterBoolean = useBooleanish(() => props.noAddOnEnter)\nconst noOuterFocusBoolean = useBooleanish(() => props.noOuterFocus)\nconst noTagRemoveBoolean = useBooleanish(() => props.noTagRemove)\nconst removeOnDeleteBoolean = useBooleanish(() => props.removeOnDelete)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst stateBoolean = useBooleanish(() => props.state)\nconst tagPillsBoolean = useBooleanish(() => props.tagPills)\nconst limitNumber = useToNumber(() => props.limit ?? NaN)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst input = ref<HTMLInputElement | null>(null)\n\nconst {focused} = useFocus(input, {\n  initialValue: autofocusBoolean.value,\n})\n\nconst _inputId = toRef(() => props.inputId || `${computedId.value}input__`)\nconst tags = ref<string[]>(modelValue.value)\nconst inputValue = ref<string>('')\nconst shouldRemoveOnDelete = ref<boolean>(modelValue.value.length > 0)\nconst lastRemovedTag = ref<string>('')\nconst validTags = ref<string[]>([])\nconst invalidTags = ref<string[]>([])\nconst duplicateTags = ref<string[]>([])\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    [`form-control-${props.size}`]: props.size !== 'md',\n    disabled: disabledBoolean.value,\n    focus: focused.value,\n  },\n])\n\nconst isDuplicate = computed(() => tags.value.includes(inputValue.value))\nconst isInvalid = computed(() =>\n  inputValue.value === '' ? false : !props.tagValidator(inputValue.value)\n)\nconst isLimitReached = toRef(() => tags.value.length === limitNumber.value)\nconst disableAddButton = toRef(() => !isInvalid.value && !isDuplicate.value)\n\nconst slotAttrs = computed(() => ({\n  addButtonText: props.addButtonText,\n  addButtonVariant: props.addButtonVariant,\n  addTag,\n  disableAddButton: disableAddButton.value,\n  disabled: disabledBoolean.value,\n  duplicateTagText: props.duplicateTagText,\n  duplicateTags: duplicateTags.value,\n  form: props.form,\n  inputAttrs: {\n    ...props.inputAttrs,\n    disabled: disabledBoolean.value,\n    form: props.form,\n    id: _inputId,\n    value: inputValue,\n  },\n  inputHandlers: {\n    input: onInput,\n    keydown: onKeydown,\n    change: onChange,\n  },\n  inputId: _inputId,\n  inputType: props.inputType,\n  invalidTagText: props.invalidTagText,\n  invalidTags: invalidTags.value,\n  isDuplicate: isDuplicate.value,\n  isInvalid: isInvalid.value,\n  isLimitReached: isLimitReached.value,\n  limitTagsText: props.limitTagsText,\n  limit: limitNumber.value,\n  noTagRemove: noTagRemoveBoolean.value,\n  placeholder: props.placeholder,\n  removeTag,\n  required: requiredBoolean.value,\n  separator: props.separator,\n  size: props.size,\n  state: stateBoolean.value,\n  tagClass: props.tagClass,\n  tagPills: tagPillsBoolean.value,\n  tagRemoveLabel: props.tagRemoveLabel,\n  tagVariant: props.tagVariant,\n  tags: tags.value,\n}))\n\nwatch(modelValue, (newVal) => {\n  tags.value = newVal\n})\n\nconst onFocusin = (e: FocusEvent): void => {\n  if (disabledBoolean.value) {\n    const target = e.target as HTMLDivElement\n    target.blur()\n    return\n  }\n\n  emit('focusin', e)\n}\n\nconst onFocus = (e: FocusEvent): void => {\n  if (disabledBoolean.value || noOuterFocusBoolean.value) {\n    return\n  }\n\n  focused.value = true\n  emit('focus', e)\n}\n\nconst onBlur = (e: FocusEvent): void => {\n  focused.value = false\n  emit('blur', e)\n}\n\nconst onInput = (e: Event | string): void => {\n  const value = typeof e === 'string' ? e : (e.target as HTMLInputElement).value\n\n  shouldRemoveOnDelete.value = false\n\n  if (props.separator?.includes(value.charAt(0)) && value.length > 0) {\n    if (input.value) {\n      input.value.value = ''\n    }\n    return\n  }\n\n  inputValue.value = value\n\n  if (props.separator?.includes(value.charAt(value.length - 1))) {\n    addTag(value.slice(0, value.length - 1))\n    return\n  }\n\n  validTags.value = props.tagValidator(value) && !isDuplicate.value ? [value] : []\n  invalidTags.value = props.tagValidator(value) ? [] : [value]\n  duplicateTags.value = isDuplicate.value ? [value] : []\n\n  emit('tag-state', validTags.value, invalidTags.value, duplicateTags.value)\n}\n\nconst onChange = (e: Event): void => {\n  if (addOnChangeBoolean.value) {\n    onInput(e)\n\n    if (!isDuplicate.value) {\n      addTag(inputValue.value)\n    }\n  }\n}\n\nconst onKeydown = (e: KeyboardEvent): void => {\n  if (e.key === 'Enter' && !noAddOnEnterBoolean.value) {\n    addTag(inputValue.value)\n    return\n  }\n\n  if (\n    (e.key === 'Backspace' || e.key === 'Delete') &&\n    removeOnDeleteBoolean.value &&\n    inputValue.value === '' &&\n    shouldRemoveOnDelete.value &&\n    tags.value.length > 0\n  ) {\n    removeTag(tags.value[tags.value.length - 1])\n  } else {\n    shouldRemoveOnDelete.value = true\n  }\n}\n\nonKeyStroke(onKeydown, {target: input})\n\nconst separator = computed(() => {\n  if (!props.separator) {\n    return\n  }\n\n  return typeof props.separator === 'string' ? props.separator : props.separator.join('')\n})\n\nconst separatorRegExp = computed(() => {\n  if (!separator.value) {\n    return\n  }\n\n  return new RegExp(`[${escapeRegExpChars(separator.value)}]+`)\n})\n\nconst addTag = (tag?: string): void => {\n  tag = (tag ?? inputValue.value).trim()\n\n  const newTags = separatorRegExp.value\n    ? tag.split(separatorRegExp.value).map((t) => t.trim())\n    : [tag]\n  const validTags: string[] = []\n\n  for (const newTag of newTags) {\n    if (newTag === '' || isDuplicate.value || !props.tagValidator(newTag)) {\n      continue\n    }\n\n    if (limitNumber.value && isLimitReached.value) {\n      break\n    }\n\n    validTags.push(newTag)\n  }\n\n  const newValue = [...modelValue.value, ...validTags]\n  inputValue.value = ''\n  shouldRemoveOnDelete.value = true\n  modelValue.value = newValue\n  emit('input', newValue)\n  focused.value = true\n}\n\nconst removeTag = (tag?: string): void => {\n  const tagIndex = tags.value.indexOf(tag?.toString() ?? '')\n  lastRemovedTag.value = tags.value.splice(tagIndex, 1).toString()\n  modelValue.value = tags.value\n}\n\n// TODO these focus/blur events aren't quite in line with use useFormInput implementation. Perhaps we should bring them together?\ndefineExpose({\n  blur: () => {\n    focused.value = false\n  },\n  element: input,\n  focus: () => {\n    focused.value = true\n  },\n})\n</script>\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :value=\"modelValue\"\n    :disabled=\"disabledBoolean\"\n    :placeholder=\"placeholder\"\n    :required=\"requiredBoolean || undefined\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonlyBoolean || plaintextBoolean\"\n    :aria-required=\"required || undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"rows\"\n    :style=\"computedStyles\"\n    :wrap=\"wrap || undefined\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed, type CSSProperties} from 'vue'\nimport {useBooleanish, useFormInput, useStateClass} from '../../composables'\nimport type {CommonInputProps} from '../../composables/useFormInput'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      noResize?: Booleanish\n      rows?: string | number\n      wrap?: string\n    } & CommonInputProps\n  >(),\n  {\n    // CommonInputProps\n    ariaInvalid: undefined,\n    autocomplete: undefined,\n    autofocus: false,\n    debounce: 0,\n    debounceMaxWait: NaN,\n    disabled: false,\n    form: undefined,\n    formatter: undefined,\n    id: undefined,\n    lazy: false,\n    lazyFormatter: false,\n    list: undefined,\n    modelValue: '',\n    name: undefined,\n    number: false,\n    placeholder: undefined,\n    plaintext: false,\n    readonly: false,\n    required: false,\n    size: undefined,\n    state: null,\n    trim: false,\n    // End CommonInputProps\n    noResize: false,\n    rows: 2,\n    wrap: 'soft',\n  }\n)\n\nconst emit = defineEmits<{\n  'blur': [val: FocusEvent]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'change': [val: any]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'input': [val: any]\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'update:modelValue': [val: any]\n}>()\n\nconst {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n  useFormInput(props, emit)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst requiredBoolean = useBooleanish(() => props.required)\nconst readonlyBoolean = useBooleanish(() => props.readonly)\nconst plaintextBoolean = useBooleanish(() => props.plaintext)\nconst noResizeBoolean = useBooleanish(() => props.noResize)\nconst stateBoolean = useBooleanish(() => props.state)\n\nconst stateClass = useStateClass(stateBoolean)\n\nconst computedClasses = computed(() => [\n  stateClass.value,\n  {\n    'form-control': !props.plaintext,\n    'form-control-plaintext': props.plaintext,\n    [`form-control-${props.size}`]: !!props.size,\n  },\n])\n\nconst computedStyles = computed<CSSProperties>(() => ({\n  resize: noResizeBoolean.value ? 'none' : undefined,\n}))\n\ndefineExpose({\n  blur,\n  element: input,\n  focus,\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"input-group\" :class=\"computedClasses\" role=\"group\">\n    <slot name=\"prepend\">\n      <span v-if=\"hasPrepend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!prependHtml\" v-html=\"prependHtml\" />\n        <span v-else>{{ prepend }}</span>\n      </span>\n    </slot>\n    <slot />\n    <slot name=\"append\">\n      <span v-if=\"hasAppend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!appendHtml\" v-html=\"appendHtml\" />\n        <span v-else>{{ append }}</span>\n      </span>\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Size} from '../../types'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    append?: string\n    appendHtml?: string\n    id?: string\n    prepend?: string\n    prependHtml?: string\n    size?: Size\n    tag?: string\n  }>(),\n  {\n    append: undefined,\n    appendHtml: undefined,\n    id: undefined,\n    prepend: undefined,\n    prependHtml: undefined,\n    size: 'md',\n    tag: 'div',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  append?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  prepend?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`input-group-${props.size}`]: props.size !== 'md',\n}))\nconst hasAppend = toRef(() => !!props.append || !!props.appendHtml)\nconst hasPrepend = toRef(() => !!props.prepend || !!props.prependHtml)\n</script>\n","<template>\n  <BInputGroupText v-if=\"isTextBoolean\">\n    <slot />\n  </BInputGroupText>\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport {useBooleanish} from '../../composables'\nimport type {BInputGroupAddonProps} from '../../types'\nimport BInputGroupText from './BInputGroupText.vue'\n\nconst props = withDefaults(defineProps<BInputGroupAddonProps>(), {\n  isText: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst isTextBoolean = useBooleanish(() => props.isText)\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"list-group\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, toRef} from 'vue'\nimport {listGroupInjectionKey} from '../../utils'\nimport type {Booleanish, Breakpoint} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    flush?: Booleanish\n    horizontal?: Booleanish | Breakpoint\n    numbered?: Booleanish\n    tag?: string\n  }>(),\n  {\n    flush: false,\n    horizontal: false,\n    numbered: false,\n    tag: 'div',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst flushBoolean = useBooleanish(() => props.flush)\nconst numberedBoolean = useBooleanish(() => props.numbered)\nconst computedHorizontal = useBooleanish(() => props.horizontal)\n\nconst computedClasses = computed(() => {\n  const horizontal = flushBoolean.value ? false : computedHorizontal.value\n  return {\n    'list-group-flush': flushBoolean.value,\n    'list-group-horizontal': horizontal === true,\n    [`list-group-horizontal-${horizontal}`]: typeof horizontal === 'string',\n    'list-group-numbered': numberedBoolean.value,\n  }\n})\nconst computedTag = toRef(() => (numberedBoolean.value === true ? 'ol' : props.tag))\n\nprovide(listGroupInjectionKey, {\n  numbered: numberedBoolean,\n})\n</script>\n","<template>\n  <component\n    :is=\"tagComputed\"\n    class=\"list-group-item\"\n    :class=\"computedClasses\"\n    :aria-current=\"activeBoolean ? true : undefined\"\n    :aria-disabled=\"disabledBoolean ? true : undefined\"\n    :target=\"isLink ? target : undefined\"\n    :href=\"!buttonBoolean ? href : undefined\"\n    :to=\"!buttonBoolean ? to : undefined\"\n    v-bind=\"computedAttrs\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, inject, toRef, useAttrs} from 'vue'\nimport type {BLinkProps, Booleanish} from '../../types'\nimport {useBLinkHelper, useBooleanish} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\nimport {listGroupInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      action?: Booleanish\n      button?: Booleanish\n      tag?: string\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    action: false,\n    button: false,\n    tag: 'div',\n    // Link props\n    active: false, // Why is this active: false?\n    // All others use defaults\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    variant: undefined,\n    // End link props\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst attrs = useAttrs()\n\nconst parentData = inject(listGroupInjectionKey, null)\n\nconst actionBoolean = useBooleanish(() => props.action)\nconst activeBoolean = useBooleanish(() => props.active)\nconst buttonBoolean = useBooleanish(() => props.button)\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst {computedLink} = useBLinkHelper(props)\n\nconst isLink = toRef(() => !buttonBoolean.value && computedLink.value)\nconst tagComputed = toRef(() =>\n  parentData?.numbered.value\n    ? 'li'\n    : buttonBoolean.value\n    ? 'button'\n    : !isLink.value\n    ? props.tag\n    : BLink\n)\n\nconst isAction = computed(\n  () =>\n    actionBoolean.value ||\n    isLink.value ||\n    buttonBoolean.value ||\n    ['a', 'router-link', 'button', 'b-link'].includes(props.tag)\n)\n\nconst computedClasses = computed(() => ({\n  [`list-group-item-${props.variant}`]: props.variant !== null && props.variant !== undefined,\n  'list-group-item-action': isAction.value,\n  'active': activeBoolean.value,\n  'disabled': disabledBoolean.value,\n}))\n\nconst computedAttrs = computed(() => {\n  const localAttrs = {} as {type?: string; disabled?: boolean}\n  if (buttonBoolean.value) {\n    if (!attrs || !attrs.type) {\n      // Add a type for button is one not provided in passed attributes\n      localAttrs.type = 'button'\n    }\n    if (disabledBoolean.value) {\n      // Set disabled attribute if button and disabled\n      localAttrs.disabled = true\n    }\n  }\n  return localAttrs\n})\n</script>\n","<template>\n  <component :is=\"wrapTag\" class=\"b-overlay-wrap position-relative\" :aria-busy=\"computedAriaBusy\">\n    <slot />\n    <BTransition\n      :no-fade=\"noFade\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      name=\"fade\"\n      @on-after-enter=\"emit('shown')\"\n      @on-after-leave=\"emit('hidden')\"\n    >\n      <component\n        :is=\"overlayTag\"\n        v-if=\"showBoolean\"\n        class=\"b-overlay\"\n        :class=\"overlayClasses\"\n        :style=\"overlayStyles\"\n        @click=\"emit('click', $event)\"\n      >\n        <div class=\"position-absolute\" :class=\"blurClasses\" :style=\"blurStyles\" />\n\n        <div class=\"position-absolute\" :style=\"spinWrapperStyles\">\n          <slot name=\"overlay\" v-bind=\"spinnerAttrs\">\n            <BSpinner v-if=\"!noSpinnerBoolean\" v-bind=\"spinnerAttrs\" />\n          </slot>\n        </div>\n      </component>\n    </BTransition>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, RadiusElementExtendables, SpinnerType} from '../../types'\nimport {useBooleanish, useRadiusElementClasses} from '../../composables'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BSpinner from '../BSpinner.vue'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      bgColor?: string\n      blur?: string | null\n      fixed?: Booleanish\n      noCenter?: Booleanish\n      noFade?: Booleanish\n      noSpinner?: Booleanish\n      noWrap?: Booleanish\n      opacity?: number | string\n      overlayTag?: string\n      show?: Booleanish\n      spinnerSmall?: Booleanish\n      spinnerType?: SpinnerType\n      spinnerVariant?: ColorVariant | null\n      variant?: ColorVariant | 'white' | 'transparent' | null\n      wrapTag?: string\n      zIndex?: number | string\n    } & RadiusElementExtendables\n  >(),\n  {\n    blur: '2px',\n    bgColor: undefined,\n    fixed: false,\n    noCenter: false,\n    noFade: false,\n    noSpinner: false,\n    noWrap: false,\n    opacity: 0.85,\n    overlayTag: 'div',\n    show: false,\n    spinnerSmall: false,\n    spinnerType: 'border',\n    spinnerVariant: undefined,\n    variant: 'light',\n    wrapTag: 'div',\n    zIndex: 10,\n    // RadiusElementExtendables props\n    rounded: false,\n    roundedBottom: undefined,\n    roundedEnd: undefined,\n    roundedStart: undefined,\n    roundedTop: undefined,\n    // End RadiusElementExtendables props\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n  hidden: []\n  shown: []\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  overlay?: (props: typeof spinnerAttrs.value) => any\n}>()\n\nconst positionStyles = {top: 0, left: 0, bottom: 0, right: 0} as const\n\nconst fixedBoolean = useBooleanish(() => props.fixed)\nconst noSpinnerBoolean = useBooleanish(() => props.noSpinner)\nconst noCenterBoolean = useBooleanish(() => props.noCenter)\nconst noWrapBoolean = useBooleanish(() => props.noWrap)\nconst showBoolean = useBooleanish(() => props.show)\nconst spinnerSmallBoolean = useBooleanish(() => props.spinnerSmall)\nconst roundedBoolean = useBooleanish(() => props.rounded)\nconst roundedTopBoolean = useBooleanish(() => props.roundedTop)\nconst roundedBottomBoolean = useBooleanish(() => props.roundedBottom)\nconst roundedStartBoolean = useBooleanish(() => props.roundedStart)\nconst roundedEndBoolean = useBooleanish(() => props.roundedEnd)\n\nconst radiusElementClasses = useRadiusElementClasses(() => ({\n  rounded: roundedBoolean.value,\n  roundedTop: roundedTopBoolean.value,\n  roundedBottom: roundedBottomBoolean.value,\n  roundedStart: roundedStartBoolean.value,\n  roundedEnd: roundedEndBoolean.value,\n}))\n\nconst computedVariant = toRef(() =>\n  props.variant !== null && !props.bgColor ? `bg-${props.variant}` : ''\n)\n\nconst computedAriaBusy = toRef(() => (showBoolean.value ? true : null))\n\nconst spinnerAttrs = computed(() => ({\n  type: props.spinnerType,\n  variant: props.spinnerVariant,\n  small: spinnerSmallBoolean.value,\n}))\n\nconst overlayStyles = computed(() => ({\n  ...positionStyles,\n  zIndex: props.zIndex || 10,\n}))\n\nconst overlayClasses = computed(() => ({\n  'position-absolute': !noWrapBoolean.value || !fixedBoolean.value,\n  'position-fixed': noWrapBoolean.value && fixedBoolean.value,\n}))\n\nconst blurClasses = computed(() => [computedVariant.value, radiusElementClasses.value])\n\nconst blurStyles = computed(() => ({\n  ...positionStyles,\n  opacity: props.opacity,\n  backgroundColor: props.bgColor || undefined,\n  backdropFilter: props.blur ? `blur(${props.blur})` : undefined,\n}))\n\nconst spinWrapperStyles = computed(() =>\n  noCenterBoolean.value\n    ? positionStyles\n    : {\n        top: '50%',\n        left: '50%',\n        transform: 'translateX(-50%) translateY(-50%)',\n      }\n)\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"teleportDisabledBoolean\">\n    <BTransition\n      :no-fade=\"true\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      @before-enter=\"onBeforeEnter\"\n      @after-enter=\"onAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"onAfterLeave\"\n    >\n      <div\n        v-show=\"modelValueBoolean\"\n        :id=\"computedId\"\n        ref=\"element\"\n        class=\"modal\"\n        :class=\"modalClasses\"\n        role=\"dialog\"\n        :aria-labelledby=\"!hideHeaderBoolean ? `${computedId}-label` : undefined\"\n        :aria-describedby=\"`${computedId}-body`\"\n        tabindex=\"-1\"\n        v-bind=\"$attrs\"\n        :style=\"computedZIndex\"\n      >\n        <div class=\"modal-dialog\" :class=\"modalDialogClasses\">\n          <div v-if=\"lazyShowing\" class=\"modal-content\" :class=\"contentClass\">\n            <div v-if=\"!hideHeaderBoolean\" class=\"modal-header\" :class=\"headerClasses\">\n              <slot name=\"header\" v-bind=\"sharedSlots\">\n                <component\n                  :is=\"titleTag\"\n                  :id=\"`${computedId}-label`\"\n                  class=\"modal-title\"\n                  :class=\"titleClasses\"\n                >\n                  <slot name=\"title\" v-bind=\"sharedSlots\">\n                    {{ title }}\n                  </slot>\n                </component>\n                <template v-if=\"!hideHeaderCloseBoolean\">\n                  <BButton\n                    v-if=\"hasHeaderCloseSlot\"\n                    v-bind=\"headerCloseAttrs\"\n                    @click=\"hide('close')\"\n                  >\n                    <slot name=\"header-close\" />\n                  </BButton>\n                  <BCloseButton\n                    v-else\n                    :aria-label=\"headerCloseLabel\"\n                    v-bind=\"headerCloseAttrs\"\n                    @click=\"hide('close')\"\n                  />\n                </template>\n              </slot>\n            </div>\n            <div :id=\"`${computedId}-body`\" class=\"modal-body\" :class=\"bodyClasses\">\n              <slot v-bind=\"sharedSlots\" />\n            </div>\n            <div v-if=\"!hideFooterBoolean\" class=\"modal-footer\" :class=\"footerClasses\">\n              <slot name=\"footer\" v-bind=\"sharedSlots\">\n                <slot name=\"cancel\" v-bind=\"sharedSlots\">\n                  <BButton\n                    v-if=\"!okOnlyBoolean\"\n                    ref=\"cancelButton\"\n                    :disabled=\"disableCancel\"\n                    :size=\"buttonSize\"\n                    :variant=\"cancelVariant\"\n                    @click=\"hide('cancel')\"\n                  >\n                    {{ cancelTitle }}\n                  </BButton>\n                </slot>\n                <slot name=\"ok\" v-bind=\"sharedSlots\">\n                  <BButton\n                    ref=\"okButton\"\n                    :disabled=\"disableOk\"\n                    :size=\"buttonSize\"\n                    :variant=\"okVariant\"\n                    @click=\"hide('ok')\"\n                  >\n                    {{ okTitle }}\n                  </BButton>\n                </slot>\n              </slot>\n            </div>\n          </div>\n        </div>\n        <slot name=\"backdrop\">\n          <BOverlay\n            :variant=\"computedBackdropVariant\"\n            :show=\"modelValueBoolean\"\n            no-spinner\n            fixed\n            no-wrap\n            :blur=\"null\"\n            @click=\"hide('backdrop')\"\n          />\n        </slot>\n      </div>\n    </BTransition>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties, reactive, ref, type RendererElement, toRef, watch} from 'vue'\nimport {\n  useBooleanish,\n  useColorVariantClasses,\n  useId,\n  useModalManager,\n  useSafeScrollLock,\n} from '../composables'\nimport {onKeyStroke, useEventListener, useFocus, useVModel} from '@vueuse/core'\nimport type {\n  Booleanish,\n  Breakpoint,\n  ButtonVariant,\n  ClassValue,\n  ColorVariant,\n  Size,\n  TextColorVariant,\n} from '../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../utils'\nimport BButton from './BButton/BButton.vue'\nimport BCloseButton from './BButton/BCloseButton.vue'\nimport BTransition from './BTransition/BTransition.vue'\nimport BOverlay from './BOverlay/BOverlay.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\n// aria\n// autofocus\n// close on escape when autofocus\n\n// Note, attempt to return focus to item that openned the modal after close\n// Implement auto focus props like autoFocusButton\n\nconst props = withDefaults(\n  defineProps<{\n    autoFocus?: Booleanish\n    autoFocusButton?: 'ok' | 'cancel' | 'close'\n    backdropVariant?: ColorVariant | null\n    bodyBgVariant?: ColorVariant | null\n    bodyClass?: ClassValue\n    bodyScrolling?: Booleanish\n    bodyTextVariant?: TextColorVariant | null\n    bodyVariant?: ColorVariant | null\n    busy?: Booleanish\n    buttonSize?: Size\n    cancelDisabled?: Booleanish\n    cancelTitle?: string\n    cancelVariant?: ButtonVariant | null\n    centered?: Booleanish\n    contentClass?: ClassValue\n    dialogClass?: ClassValue\n    footerBgVariant?: ColorVariant | null\n    footerBorderVariant?: ColorVariant | null\n    footerClass?: ClassValue\n    footerTextVariant?: TextColorVariant | null\n    footerVariant?: ColorVariant | null\n    fullscreen?: Booleanish | Breakpoint\n    headerBgVariant?: ColorVariant | null\n    headerBorderVariant?: ColorVariant | null\n    headerClass?: ClassValue\n    headerCloseClass?: ClassValue\n    headerCloseLabel?: string\n    headerCloseVariant?: ButtonVariant | null\n    headerTextVariant?: TextColorVariant | null\n    headerVariant?: ColorVariant | null\n    hideBackdrop?: Booleanish\n    hideFooter?: Booleanish\n    hideHeader?: Booleanish\n    hideHeaderClose?: Booleanish\n    id?: string\n    lazy?: Booleanish\n    modalClass?: ClassValue\n    modelValue?: Booleanish\n    noCloseOnBackdrop?: Booleanish\n    noCloseOnEsc?: Booleanish\n    noFade?: Booleanish\n    okDisabled?: Booleanish\n    okOnly?: Booleanish\n    okTitle?: string\n    okVariant?: ButtonVariant | null\n    scrollable?: Booleanish\n    size?: Size | 'xl'\n    teleportDisabled?: Booleanish\n    teleportTo?: string | RendererElement | null | undefined\n    title?: string\n    titleClass?: ClassValue\n    titleSrOnly?: Booleanish\n    titleTag?: string\n  }>(),\n  {\n    autoFocus: true,\n    autoFocusButton: undefined,\n    backdropVariant: undefined,\n    bodyBgVariant: null,\n    bodyClass: undefined,\n    bodyScrolling: false,\n    bodyTextVariant: null,\n    bodyVariant: null,\n    busy: false,\n    buttonSize: 'md',\n    cancelDisabled: false,\n    cancelTitle: 'Cancel',\n    cancelVariant: 'secondary',\n    centered: false,\n    contentClass: undefined,\n    dialogClass: undefined,\n    footerBgVariant: null,\n    footerBorderVariant: null,\n    footerClass: undefined,\n    footerTextVariant: null,\n    footerVariant: null,\n    fullscreen: false,\n    headerBgVariant: null,\n    headerBorderVariant: null,\n    headerClass: undefined,\n    headerCloseClass: undefined,\n    headerCloseLabel: 'Close',\n    headerCloseVariant: 'secondary',\n    headerTextVariant: null,\n    headerVariant: null,\n    hideBackdrop: false,\n    hideFooter: false,\n    hideHeader: false,\n    hideHeaderClose: false,\n    id: undefined,\n    lazy: false,\n    modalClass: undefined,\n    modelValue: false,\n    noCloseOnBackdrop: false,\n    noCloseOnEsc: false,\n    noFade: false,\n    okDisabled: false,\n    okOnly: false,\n    okTitle: 'Ok',\n    okVariant: 'primary',\n    scrollable: false,\n    size: 'md',\n    teleportDisabled: false,\n    teleportTo: 'body',\n    title: undefined,\n    titleClass: undefined,\n    titleSrOnly: false,\n    titleTag: 'h5',\n  }\n)\n\nconst emit = defineEmits<{\n  'cancel': [value: BvTriggerableEvent]\n  'close': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'ok': [value: BvTriggerableEvent]\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': [value: BvTriggerableEvent]\n  'update:modelValue': [value: boolean]\n}>()\n\ntype SharedSlotsData = {\n  cancel: () => void\n  close: () => void\n  hide: (trigger?: string) => void\n  ok: () => void\n  visible: boolean\n}\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'backdrop'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'cancel'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'footer'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header-close'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'ok'?: (props: SharedSlotsData) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'title'?: (props: SharedSlotsData) => any\n}>()\n\nconst computedId = useId(() => props.id, 'modal')\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst busyBoolean = useBooleanish(() => props.busy)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst cancelDisabledBoolean = useBooleanish(() => props.cancelDisabled)\nconst centeredBoolean = useBooleanish(() => props.centered)\nconst hideBackdropBoolean = useBooleanish(() => props.hideBackdrop)\nconst hideFooterBoolean = useBooleanish(() => props.hideFooter)\nconst hideHeaderBoolean = useBooleanish(() => props.hideHeader)\nconst hideHeaderCloseBoolean = useBooleanish(() => props.hideHeaderClose)\nconst modelValueBoolean = useBooleanish(modelValue)\nconst noCloseOnBackdropBoolean = useBooleanish(() => props.noCloseOnBackdrop)\nconst noCloseOnEscBoolean = useBooleanish(() => props.noCloseOnEsc)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst autoFocusBoolean = useBooleanish(() => props.autoFocus)\nconst okDisabledBoolean = useBooleanish(() => props.okDisabled)\nconst okOnlyBoolean = useBooleanish(() => props.okOnly)\nconst scrollableBoolean = useBooleanish(() => props.scrollable)\nconst titleSrOnlyBoolean = useBooleanish(() => props.titleSrOnly)\nconst teleportDisabledBoolean = useBooleanish(() => props.teleportDisabled)\nconst bodyScrollingBoolean = useBooleanish(() => props.bodyScrolling)\nconst computedFullScreen = useBooleanish(() => props.fullscreen)\n\nconst element = ref<HTMLElement | null>(null)\nconst okButton = ref<HTMLElement | null>(null)\nconst cancelButton = ref<HTMLElement | null>(null)\nconst closeButton = ref<HTMLElement | null>(null)\nconst isActive = ref(modelValueBoolean.value)\nconst lazyLoadCompleted = ref(false)\n\nonKeyStroke(\n  'Escape',\n  () => {\n    hide('esc')\n  },\n  {target: element}\n)\nuseSafeScrollLock(modelValueBoolean, bodyScrollingBoolean)\nconst {focused: modalFocus} = useFocus(element, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === undefined,\n})\nconst {focused: okButtonFocus} = useFocus(okButton, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === 'ok',\n})\nconst {focused: cancelButtonFocus} = useFocus(cancelButton, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === 'cancel',\n})\nconst {focused: closeButtonFocus} = useFocus(closeButton, {\n  initialValue: modelValueBoolean.value && props.autoFocusButton === 'close',\n})\n\nconst modalClasses = computed(() => [\n  props.modalClass,\n  {\n    fade: !noFadeBoolean.value,\n    show: isActive.value,\n  },\n])\n\nconst lazyShowing = toRef(\n  () =>\n    lazyBoolean.value === false ||\n    (lazyBoolean.value === true && lazyLoadCompleted.value === true) ||\n    (lazyBoolean.value === true && modelValueBoolean.value === true)\n)\n\nconst computedBackdropVariant = toRef(() =>\n  props.backdropVariant !== undefined\n    ? props.backdropVariant\n    : hideBackdropBoolean.value\n    ? 'transparent'\n    : 'dark'\n)\n\nconst hasHeaderCloseSlot = toRef(() => !isEmptySlot(slots['header-close']))\n\nconst modalDialogClasses = computed(() => [\n  props.dialogClass,\n  {\n    'modal-fullscreen': computedFullScreen.value === true,\n    [`modal-fullscreen-${computedFullScreen.value}-down`]:\n      typeof computedFullScreen.value === 'string',\n    [`modal-${props.size}`]: props.size !== 'md',\n    'modal-dialog-centered': centeredBoolean.value,\n    'modal-dialog-scrollable': scrollableBoolean.value,\n  },\n])\n\nconst resolvedBodyBgClasses = useColorVariantClasses(() => ({\n  bgVariant: props.bodyBgVariant,\n  textVariant: props.bodyTextVariant,\n  variant: props.bodyVariant,\n}))\n\nconst bodyClasses = computed(() => [props.bodyClass, resolvedBodyBgClasses.value])\n\nconst resolvedHeaderBgClasses = useColorVariantClasses(() => ({\n  bgVariant: props.headerBgVariant,\n  textVariant: props.headerTextVariant,\n  variant: props.headerVariant,\n}))\n\nconst headerClasses = computed(() => [\n  props.headerClass,\n  resolvedHeaderBgClasses.value,\n  {\n    [`border-${props.headerBorderVariant}`]: props.headerBorderVariant !== null,\n  },\n])\n\nconst headerCloseAttrs = computed(() => ({\n  variant: hasHeaderCloseSlot.value ? props.headerCloseVariant : undefined,\n  class: props.headerCloseClass,\n}))\n\nconst resolvedFooterBgClasses = useColorVariantClasses(() => ({\n  bgVariant: props.footerBgVariant,\n  textVariant: props.footerTextVariant,\n  variant: props.footerVariant,\n}))\n\nconst footerClasses = computed(() => [\n  props.footerClass,\n  resolvedFooterBgClasses.value,\n  {\n    [`border-${props.footerBorderVariant}`]: props.footerBorderVariant !== null,\n  },\n])\n\nconst titleClasses = computed(() => [\n  props.titleClass,\n  {\n    ['visually-hidden']: titleSrOnlyBoolean.value,\n  },\n])\nconst disableCancel = toRef(() => cancelDisabledBoolean.value || busyBoolean.value)\nconst disableOk = toRef(() => okDisabledBoolean.value || busyBoolean.value)\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nwatch(modelValueBoolean, (newValue, oldValue) => {\n  if (newValue === oldValue) return\n  if (newValue === true) {\n    showFn()\n  } else {\n    hide()\n  }\n})\n\nconst hide = (trigger = '') => {\n  if (\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('hide-prevented')\n    return\n  }\n\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'ok') {\n    emit(trigger, event)\n  }\n  if (trigger === 'cancel') {\n    emit(trigger, event)\n  }\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    if (!modelValue.value) modelValue.value = true\n    return\n  }\n  if (modelValue.value) modelValue.value = false\n}\n\n// TODO: If a show is prevented, it will briefly show the animation. This is a bug\n// I'm not sure how to wait for the event to be determined. Before showing\nconst showFn = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    if (modelValue.value) modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  if (!modelValue.value) modelValue.value = true\n}\n\nconst pickFocusItem = () => {\n  if (autoFocusBoolean.value === false) return\n  props.autoFocusButton === 'ok'\n    ? (okButtonFocus.value = true)\n    : props.autoFocusButton === 'close'\n    ? (closeButtonFocus.value = true)\n    : props.autoFocusButton === 'cancel'\n    ? (cancelButtonFocus.value = true)\n    : (modalFocus.value = true)\n}\n\nconst onBeforeEnter = () => showFn()\nconst onAfterEnter = () => {\n  isActive.value = true\n  pickFocusItem()\n  emit('shown', buildTriggerableEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst onAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\n\nconst {activePosition, activeModalCount} = useModalManager(isActive)\nconst defaultModalDialogZIndex = 1056\nconst computedZIndex = computed<CSSProperties>(() => ({\n  // Make sure that newly opened modals have a higher z-index than currently active ones.\n  // All active modals have a z-index of ('defaultZIndex' - 'stackSize' - 'positionInStack').\n  //\n  // This means inactive modals will already be higher than active ones when opened.\n  'z-index': isActive.value\n    ? defaultModalDialogZIndex - (activeModalCount.value - activePosition.value)\n    : defaultModalDialogZIndex,\n}))\n\nuseEventListener(element, 'bv-toggle', () => {\n  modelValueBoolean.value ? hide() : showFn()\n})\n\nconst sharedSlots: SharedSlotsData = reactive({\n  cancel: () => {\n    hide('cancel')\n  },\n  close: () => {\n    hide('close')\n  },\n  hide,\n  ok: () => {\n    hide('ok')\n  },\n  visible: modelValueBoolean,\n})\n\ndefineExpose({\n  hide,\n  id: computedId,\n  show: showFn,\n})\n</script>\n\n<style lang=\"scss\" scoped>\n.modal {\n  display: block;\n}\n\n.modal-dialog {\n  z-index: 1051;\n}\n</style>\n","<template>\n  <component :is=\"tag\" class=\"nav\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AlignmentJustifyContent, Booleanish} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    align?: AlignmentJustifyContent\n    cardHeader?: Booleanish\n    fill?: Booleanish\n    justified?: Booleanish\n    pills?: Booleanish\n    small?: Booleanish\n    tabs?: Booleanish\n    tag?: string\n    underline?: Booleanish\n    vertical?: Booleanish\n  }>(),\n  {\n    align: undefined,\n    cardHeader: false,\n    fill: false,\n    justified: false,\n    pills: false,\n    small: false,\n    tabs: false,\n    tag: 'ul',\n    underline: false,\n    vertical: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst cardHeaderBoolean = useBooleanish(() => props.cardHeader)\nconst fillBoolean = useBooleanish(() => props.fill)\nconst justifiedBoolean = useBooleanish(() => props.justified)\nconst pillsBoolean = useBooleanish(() => props.pills)\nconst smallBoolean = useBooleanish(() => props.small)\nconst tabsBoolean = useBooleanish(() => props.tabs)\nconst verticalBoolean = useBooleanish(() => props.vertical)\nconst alignment = useAlignment(() => props.align)\nconst underlineBoolean = useBooleanish(() => props.underline)\n\nconst computedClasses = computed(() => ({\n  'nav-tabs': tabsBoolean.value,\n  'nav-pills': pillsBoolean.value && !tabsBoolean.value,\n  'card-header-tabs': !verticalBoolean.value && cardHeaderBoolean.value && tabsBoolean.value,\n  'card-header-pills':\n    !verticalBoolean.value && cardHeaderBoolean.value && pillsBoolean.value && !tabsBoolean.value,\n  'flex-column': verticalBoolean.value,\n  'nav-fill': !verticalBoolean.value && fillBoolean.value,\n  'nav-justified': !verticalBoolean.value && justifiedBoolean.value,\n  [alignment.value]: !verticalBoolean.value && props.align !== undefined,\n  'small': smallBoolean.value,\n  'nav-underline': underlineBoolean.value,\n}))\n</script>\n","<template>\n  <li class=\"d-flex flex-row align-items-center flex-wrap\">\n    <BForm\n      v-bind=\"$attrs\"\n      :id=\"id\"\n      :floating=\"floating\"\n      :role=\"role\"\n      :novalidate=\"novalidate\"\n      :validated=\"validated\"\n      class=\"d-flex\"\n      @submit.prevent=\"submitted\"\n    >\n      <slot />\n    </BForm>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BFormProps} from '../../types'\nimport BForm from '../BForm/BForm.vue'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nwithDefaults(\n  defineProps<\n    {\n      role?: string\n    } & BFormProps\n  >(),\n  {\n    role: undefined,\n    // BForm props\n    floating: undefined,\n    id: undefined,\n    novalidate: undefined,\n    validated: undefined,\n    // End BForm props\n  }\n)\n\nconst emit = defineEmits<{\n  submit: [value: Event]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst submitted = (e: Event) => {\n  emit('submit', e)\n}\n</script>\n","<template>\n  <li class=\"nav-item\">\n    <BLink\n      class=\"nav-link\"\n      :class=\"linkClass\"\n      :tabindex=\"disabledBoolean ? -1 : undefined\"\n      :aria-disabled=\"disabledBoolean ? true : undefined\"\n      v-bind=\"{...computedLinkProps, ...linkAttrs}\"\n      @click=\"emit('click', $event)\"\n    >\n      <slot />\n    </BLink>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport {useBooleanish} from '../../composables'\nimport type {BLinkProps, ClassValue} from '../../types'\nimport {pick} from '../../utils'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      linkAttrs?: Record<string, unknown>\n      linkClass?: ClassValue\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    // Link props\n    active: undefined,\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    linkAttrs: undefined,\n    linkClass: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    variant: undefined,\n    // End link props\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst computedLinkProps = computed(() =>\n  pick(props, [\n    'active',\n    'activeClass',\n    'append',\n    'disabled',\n    'href',\n    'icon',\n    'opacity',\n    'opacityHover',\n    'rel',\n    'replace',\n    'routerComponentName',\n    'target',\n    'to',\n    'underlineOffset',\n    'underlineOffsetHover',\n    'underlineOpacity',\n    'underlineOpacityHover',\n    'underlineVariant',\n    'variant',\n  ])\n)\ncomputedLinkProps.value.activeClass\n</script>\n","<template>\n  <li class=\"nav-item dropdown\">\n    <BDropdown\n      ref=\"dropdown\"\n      v-bind=\"props\"\n      is-nav\n      @show=\"emit('show', $event)\"\n      @shown=\"emit('shown')\"\n      @hide=\"emit('hide', $event)\"\n      @hidden=\"emit('hidden')\"\n      @hide-prevented=\"emit('hide-prevented')\"\n      @show-prevented=\"emit('show-prevented')\"\n      @click=\"emit('click', $event)\"\n      @toggle=\"emit('toggle')\"\n      @update:model-value=\"emit('update:modelValue', $event)\"\n    >\n      <template #button-content>\n        <slot name=\"button-content\" />\n      </template>\n      <template #toggle-text>\n        <slot name=\"toggle-text\" />\n      </template>\n      <template #default>\n        <slot :hide=\"close\" :show=\"open\" />\n      </template>\n    </BDropdown>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref} from 'vue'\nimport {BvTriggerableEvent} from '../../utils'\nimport BDropdown from '../BDropdown/BDropdown.vue'\nimport type {BDropdownProps} from '../../types'\n\nconst props = withDefaults(defineProps<BDropdownProps>(), {\n  ariaLabel: undefined,\n  autoClose: true,\n  block: false,\n  boundary: 'clippingAncestors',\n  boundaryPadding: undefined,\n  center: false,\n  container: undefined,\n  disabled: false,\n  dropend: false,\n  dropstart: false,\n  dropup: false,\n  end: false,\n  floatingMiddleware: undefined,\n  id: undefined,\n  isNav: true,\n  lazy: false,\n  menuClass: undefined,\n  modelValue: false,\n  noCaret: false,\n  noFlip: false,\n  noShift: false,\n  noSize: false,\n  offset: 0,\n  role: 'menu',\n  size: 'md',\n  split: false,\n  splitButtonType: 'button',\n  splitClass: undefined,\n  splitDisabled: undefined,\n  splitHref: undefined,\n  splitTo: undefined,\n  splitVariant: undefined,\n  strategy: 'absolute',\n  text: undefined,\n  toggleClass: undefined,\n  toggleText: 'Toggle dropdown',\n  variant: 'link',\n})\n\nconst emit = defineEmits<{\n  'click': [event: MouseEvent]\n  'hidden': []\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': []\n  'toggle': []\n  'update:modelValue': [value: boolean]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'button-content'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: {hide: () => void; show: () => void}) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'toggle-text'?: (props: Record<string, never>) => any\n}>()\nconst dropdown = ref<InstanceType<typeof BDropdown> | null>(null)\n\nconst close = () => {\n  dropdown.value?.close()\n}\nconst open = () => {\n  dropdown.value?.open()\n}\nconst toggle = () => {\n  dropdown.value?.toggle()\n}\n\ndefineExpose({\n  close,\n  open,\n  toggle,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"navbar\" :class=\"computedClasses\" :role=\"computedRole\">\n    <div v-if=\"container !== false\" :class=\"containerClass\">\n      <slot />\n    </div>\n    <slot v-else />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, provide, toRef} from 'vue'\nimport type {Booleanish, Breakpoint, ColorVariant} from '../../types'\nimport {useBooleanish, useContainerClasses} from '../../composables'\nimport {navbarInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    autoClose?: Booleanish\n    container?: 'fluid' | Booleanish | Breakpoint\n    fixed?: 'top' | 'bottom'\n    print?: Booleanish\n    sticky?: 'top' | 'bottom'\n    tag?: string\n    toggleable?: Booleanish | Breakpoint\n    variant?: ColorVariant | null\n  }>(),\n  {\n    autoClose: true,\n    container: 'fluid',\n    fixed: undefined,\n    print: false,\n    sticky: undefined,\n    tag: 'nav',\n    toggleable: false,\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst containerBoolean = useBooleanish(() => props.container)\nconst autoCloseBoolean = useBooleanish(() => props.autoClose)\nconst printBoolean = useBooleanish(() => props.print)\nconst computedNavbarExpand = useBooleanish(() => props.toggleable)\n\nconst computedRole = toRef(() => (props.tag === 'nav' ? undefined : 'navigation'))\n\nconst containerClass = useContainerClasses(containerBoolean)\n\nconst computedClasses = computed(() => ({\n  'd-print': printBoolean.value,\n  [`sticky-${props.sticky}`]: props.sticky !== undefined,\n  [`bg-${props.variant}`]: props.variant !== null,\n  [`fixed-${props.fixed}`]: props.fixed !== undefined,\n  'navbar-expand': computedNavbarExpand.value === false,\n  [`navbar-expand-${computedNavbarExpand.value}`]: typeof computedNavbarExpand.value === 'string',\n}))\n\nprovide(navbarInjectionKey, {\n  tag: toRef(() => props.tag),\n  autoClose: autoCloseBoolean,\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"navbar-brand\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {toRef} from 'vue'\nimport BLink from '../BLink/BLink.vue'\nimport type {BLinkProps} from '../../types'\nimport {useBLinkHelper} from '../../composables'\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst props = withDefaults(\n  defineProps<\n    {\n      tag?: string\n    } & Omit<BLinkProps, 'event' | 'routerTag'>\n  >(),\n  {\n    tag: 'div',\n    // Link props\n    active: undefined,\n    activeClass: undefined,\n    append: undefined,\n    disabled: undefined,\n    exactActiveClass: undefined,\n    href: undefined,\n    icon: undefined,\n    opacity: undefined,\n    opacityHover: undefined,\n    rel: undefined,\n    replace: undefined,\n    routerComponentName: undefined,\n    target: undefined,\n    to: undefined,\n    underlineOffset: undefined,\n    underlineOffsetHover: undefined,\n    underlineOpacity: undefined,\n    underlineOpacityHover: undefined,\n    underlineVariant: undefined,\n    variant: undefined,\n    // End link props\n  }\n)\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props, [\n  'active',\n  'activeClass',\n  'append',\n  'disabled',\n  'href',\n  'rel',\n  'replace',\n  'routerComponentName',\n  'target',\n  'to',\n  'variant',\n  'opacity',\n  'opacityHover',\n  'underlineVariant',\n  'underlineOffset',\n  'underlineOffsetHover',\n  'underlineOpacity',\n  'underlineOpacityHover',\n  'icon',\n])\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : props.tag))\n</script>\n","<template>\n  <ul class=\"navbar-nav\" :class=\"computedClasses\">\n    <slot />\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport type {AlignmentJustifyContent, Booleanish} from '../../types'\nimport {computed} from 'vue'\nimport {useAlignment, useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    align?: AlignmentJustifyContent\n    fill?: Booleanish\n    justified?: Booleanish\n    small?: Booleanish\n    tag?: string\n  }>(),\n  {\n    align: undefined,\n    fill: false,\n    justified: false,\n    small: false,\n    tag: 'ul',\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst fillBoolean = useBooleanish(() => props.fill)\nconst justifiedBoolean = useBooleanish(() => props.justified)\nconst smallBoolean = useBooleanish(() => props.small)\nconst alignment = useAlignment(() => props.align)\n\nconst computedClasses = computed(() => ({\n  'nav-fill': fillBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'small': smallBoolean.value,\n}))\n</script>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst setTheme = (el: HTMLElement, value: string): void => el.setAttribute('data-bs-theme', value)\nexport default {\n  mounted(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n  updated(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n} satisfies Directive<HTMLElement>\n","import {RX_HASH, RX_HASH_ID, RX_SPACE_SPLIT} from '../constants/regex'\nimport {getAttr, isTag} from '../utils'\nimport type {Directive, DirectiveBinding} from 'vue'\n\nconst getTargets = (binding: DirectiveBinding<string | string[]>, el: HTMLElement) => {\n  const {modifiers, arg, value} = binding\n  // Any modifiers are considered target Ids\n  const targets = Object.keys(modifiers || {})\n\n  // If value is a string, split out individual targets (if space delimited)\n  const localValue = typeof value === 'string' ? value.split(RX_SPACE_SPLIT) : value\n\n  // Support target Id as link href (`href=\"#id\"`)\n  if (isTag(el.tagName, 'a')) {\n    const href = getAttr(el, 'href') || ''\n    if (RX_HASH_ID.test(href)) {\n      targets.push(href.replace(RX_HASH, ''))\n    }\n  }\n\n  // Add Id from `arg` (if provided), and support value\n  // as a single string Id or an array of string Ids\n  // If `value` is not an array or string, then it gets filtered out\n  Array.prototype.concat\n    .apply([], [arg, localValue])\n    .forEach((t) => typeof t === 'string' && targets.push(t))\n\n  // Return only unique and truthy target Ids\n  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index)\n}\n\nconst toggle = (targetIds: string[], el: HTMLElement) => {\n  targetIds.forEach((targetId) => {\n    const target = document.getElementById(targetId)\n\n    if (target !== null) {\n      target.dispatchEvent(new Event('bv-toggle'))\n    }\n  })\n  setTimeout(() => checkVisibility(targetIds, el), 50)\n}\n\nconst checkVisibility = (targetIds: string[], el: HTMLElement) => {\n  let visible = false\n  targetIds.forEach((targetId) => {\n    const target = document.getElementById(targetId)\n\n    if (target?.classList.contains('show')) {\n      visible = true\n    }\n    if (target?.classList.contains('closing')) {\n      visible = false\n    }\n  })\n  el.setAttribute('aria-expanded', visible ? 'true' : 'false')\n  el.classList.remove(visible ? 'collapsed' : 'not-collapsed')\n  el.classList.add(visible ? 'not-collapsed' : 'collapsed')\n}\n\nconst handleUpdate = (el: WithToggle, binding: DirectiveBinding<string | string[] | undefined>) => {\n  // Determine targets\n  if (binding.value === undefined && Object.keys(binding.modifiers || {}).length === 0) return\n  const targets = getTargets(binding as DirectiveBinding<string | string[]>, el)\n\n  // Set up click handler\n  if (el.__toggle) {\n    el.removeEventListener('click', el.__toggle)\n  }\n  el.__toggle = () => toggle(targets, el)\n  el.addEventListener('click', el.__toggle)\n\n  // Update attributes\n  el.setAttribute('aria-controls', targets.join(' '))\n  checkVisibility(targets, el)\n}\n\nexport interface WithToggle extends HTMLElement {\n  __toggle: () => void\n}\n\nexport default {\n  mounted: handleUpdate,\n  updated: handleUpdate,\n  unmounted(el: WithToggle): void {\n    el.removeEventListener('click', el.__toggle)\n    el.removeAttribute('aria-controls')\n    el.removeAttribute('aria-expanded')\n  },\n} satisfies Directive<WithToggle>\n","import {type Directive, ref} from 'vue'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\n\nexport default {\n  mounted(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    el.$__state = ref({\n      ...resolveDirectiveProps(binding, el),\n      ...text,\n    })\n    bind(el, binding)\n  },\n  updated(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    if (!el.$__state) {\n      // Same binding as above\n      // This happens when mounting occurs, but binding does not happen ie (if (!text.content && !text.title) return)\n      // So mounting occurs without a title or content set\n      el.$__state = ref({\n        ...resolveDirectiveProps(binding, el),\n        ...text,\n      })\n      bind(el, binding)\n      return\n    }\n    el.$__state.value = {\n      ...resolveDirectiveProps(binding, el),\n      ...text,\n    }\n  },\n  beforeUnmount(el) {\n    unbind(el)\n  },\n} satisfies Directive<ElementWithPopper>\n","import {type Directive, ref} from 'vue'\nimport {\n  bind,\n  type ElementWithPopper,\n  resolveActiveStatus,\n  resolveContent,\n  resolveDirectiveProps,\n  unbind,\n} from '../utils/floatingUi'\n\nexport default {\n  mounted(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    el.$__state = ref({\n      noninteractive: true,\n      ...resolveDirectiveProps(binding, el),\n      title: text.title ?? text.content ?? '',\n      tooltip: isActive,\n    })\n    bind(el, binding)\n  },\n  updated(el, binding) {\n    const isActive = resolveActiveStatus(binding.value)\n    if (!isActive) return\n\n    const text = resolveContent(binding.value, el)\n\n    if (!text.content && !text.title) return\n\n    if (!el.$__state) {\n      // Same binding as above\n      // This happens when mounting occurs, but binding does not happen ie (if (!text.content && !text.title) return)\n      // So mounting occurs without a title or content set\n      el.$__state = ref({\n        noninteractive: true,\n        ...resolveDirectiveProps(binding, el),\n        title: text.title ?? text.content ?? '',\n        tooltip: isActive,\n      })\n      bind(el, binding)\n      return\n    }\n    el.$__state.value = {\n      noninteractive: true,\n      ...resolveDirectiveProps(binding, el),\n      title: text.title ?? text.content ?? '',\n      tooltip: isActive,\n    }\n  },\n  beforeUnmount(el) {\n    unbind(el)\n  },\n} satisfies Directive<ElementWithPopper>\n","<template>\n  <button\n    v-b-toggle=\"!disabledBoolean ? target : undefined\"\n    class=\"navbar-toggler\"\n    type=\"button\"\n    :class=\"computedClasses\"\n    :disabled=\"disabledBoolean\"\n    :aria-label=\"label\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <span class=\"navbar-toggler-icon\" />\n    </slot>\n  </button>\n</template>\n\n<script setup lang=\"ts\">\nimport {vBToggle} from '../../directives'\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    disabled?: Booleanish\n    label?: string\n    target?: string | string[]\n  }>(),\n  {\n    label: 'Toggle navigation',\n    disabled: false,\n    target: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  click: [value: MouseEvent]\n}>()\n\ndefineSlots<{\n  // TODO this scoped slot is {expanded: boolean}\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\n\nconst computedClasses = computed(() => ({\n  disabled: disabledBoolean.value,\n}))\n\nconst onClick = (e: MouseEvent): void => {\n  if (!disabledBoolean.value) {\n    emit('click', e)\n  }\n}\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"teleportDisabledBoolean\">\n    <BTransition\n      :no-fade=\"true\"\n      :trans-props=\"{\n        enterToClass: 'showing',\n        enterFromClass: '',\n        leaveToClass: 'hiding show',\n        leaveFromClass: 'show',\n      }\"\n      @before-enter=\"OnBeforeEnter\"\n      @after-enter=\"OnAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"OnAfterLeave\"\n    >\n      <div\n        v-show=\"modelValue\"\n        :id=\"computedId\"\n        ref=\"element\"\n        aria-modal=\"true\"\n        role=\"dialog\"\n        :class=\"computedClasses\"\n        tabindex=\"-1\"\n        :aria-labelledby=\"`${computedId}-offcanvas-label`\"\n        data-bs-backdrop=\"false\"\n        v-bind=\"$attrs\"\n      >\n        <template v-if=\"lazyShowing\">\n          <div v-if=\"!noHeaderBoolean\" class=\"offcanvas-header\" :class=\"headerClass\">\n            <slot name=\"header\" :visible=\"modelValueBoolean\" :placement=\"placement\" :hide=\"hide\">\n              <h5 :id=\"`${computedId}-offcanvas-label`\" class=\"offcanvas-title\">\n                <slot name=\"title\" :visible=\"modelValueBoolean\" :placement=\"placement\" :hide=\"hide\">\n                  {{ title }}\n                </slot>\n              </h5>\n              <template v-if=\"!noHeaderCloseBoolean\">\n                <BButton v-if=\"hasHeaderCloseSlot\" v-bind=\"headerCloseAttrs\" @click=\"hide('close')\">\n                  <slot name=\"header-close\" />\n                </BButton>\n                <BCloseButton\n                  v-else\n                  :aria-label=\"headerCloseLabel\"\n                  v-bind=\"headerCloseAttrs\"\n                  @click=\"hide('close')\"\n                />\n              </template>\n            </slot>\n          </div>\n          <div class=\"offcanvas-body\" :class=\"bodyClass\">\n            <slot :visible=\"modelValueBoolean\" :placement=\"placement\" :hide=\"hide\" />\n          </div>\n          <div v-if=\"hasFooterSlot\" :class=\"footerClass\">\n            <slot name=\"footer\" :visible=\"modelValueBoolean\" :placement=\"placement\" :hide=\"hide\" />\n          </div>\n        </template>\n      </div>\n    </BTransition>\n    <slot name=\"backdrop\">\n      <BOverlay\n        :variant=\"backdropVariant\"\n        :show=\"showBackdrop\"\n        fixed\n        no-wrap\n        no-spinner\n        @click=\"hide('backdrop')\"\n      />\n    </slot>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, ref, type RendererElement, toRef} from 'vue'\nimport {onKeyStroke, useEventListener, useFocus, useVModel} from '@vueuse/core'\nimport {useBooleanish, useId, useSafeScrollLock} from '../../composables'\nimport type {Booleanish, ButtonVariant, ClassValue, ColorVariant} from '../../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../../utils'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BButton from '../BButton/BButton.vue'\n\n// TODO once the responsive stuff may be implemented correctly,\n// What needs to occur is a fixing of the \"body scrolling\".\n// If the offcanvas is on the screen on a large screen, body scrolling is not disabled\n// Even though the modelValue is true\n// When it's a small screen and close, it works, as normal,\n// But then when it opens up on a small screen, it must disable again\n// This is implemented on Layout.vue, but is not officially supported.\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    backdrop?: Booleanish\n    backdropVariant?: ColorVariant | null\n    bodyClass?: string\n    bodyScrolling?: Booleanish\n    footerClass?: string\n    headerClass?: string\n    headerCloseClass?: ClassValue\n    headerCloseLabel?: string\n    headerCloseVariant?: ButtonVariant | null\n    id?: string\n    lazy?: Booleanish\n    modelValue?: Booleanish\n    noCloseOnBackdrop?: Booleanish\n    noCloseOnEsc?: Booleanish\n    noFocus?: Booleanish\n    noHeader?: Booleanish\n    noHeaderClose?: Booleanish\n    // TODO standardize this. Create a dedicated type\n    // Then in components that use individual props (BImg)\n    // Make them just use prop placement\n    placement?: 'top' | 'bottom' | 'start' | 'end'\n    teleportDisabled?: Booleanish\n    teleportTo?: string | RendererElement | null | undefined\n    title?: string\n    // responsive?: Breakpoint\n    // TODO responsive doesn't work\n  }>(),\n  {\n    backdrop: true,\n    backdropVariant: 'dark',\n    bodyClass: undefined,\n    bodyScrolling: false,\n    footerClass: undefined,\n    headerClass: undefined,\n    headerCloseClass: undefined,\n    headerCloseLabel: 'Close',\n    headerCloseVariant: 'secondary',\n    id: undefined,\n    lazy: false,\n    modelValue: false,\n    noCloseOnBackdrop: false,\n    noCloseOnEsc: false,\n    noFocus: false,\n    noHeader: false,\n    noHeaderClose: false,\n    placement: 'start',\n    teleportDisabled: false,\n    teleportTo: 'body',\n    title: undefined,\n  }\n)\n\nconst emit = defineEmits<{\n  'close': [value: BvTriggerableEvent]\n  'esc': [value: BvTriggerableEvent]\n  'hidden': [value: BvTriggerableEvent]\n  'hide': [value: BvTriggerableEvent]\n  'hide-prevented': []\n  'show': [value: BvTriggerableEvent]\n  'show-prevented': []\n  'shown': [value: BvTriggerableEvent]\n  'update:modelValue': [value: boolean]\n}>()\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'backdrop'?: (props: Record<string, never>) => any\n  'default'?: (props: {\n    visible: boolean\n    placement: 'top' | 'bottom' | 'start' | 'end'\n    hide: (trigger?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  'footer'?: (props: {\n    visible: boolean\n    placement: 'top' | 'bottom' | 'start' | 'end'\n    hide: (trigger?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  'header'?: (props: {\n    visible: boolean\n    placement: 'top' | 'bottom' | 'start' | 'end'\n    hide: (trigger?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'header-close'?: (props: Record<string, never>) => any\n  'title'?: (props: {\n    visible: boolean\n    placement: 'top' | 'bottom' | 'start' | 'end'\n    hide: (trigger?: string) => void\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  }) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\n\nconst modelValueBoolean = useBooleanish(modelValue)\nconst bodyScrollingBoolean = useBooleanish(() => props.bodyScrolling)\nconst backdropBoolean = useBooleanish(() => props.backdrop)\nconst noHeaderCloseBoolean = useBooleanish(() => props.noHeaderClose)\nconst noHeaderBoolean = useBooleanish(() => props.noHeader)\nconst noFocusBoolean = useBooleanish(() => props.noFocus)\nconst noCloseOnBackdropBoolean = useBooleanish(() => props.noCloseOnBackdrop)\nconst noCloseOnEscBoolean = useBooleanish(() => props.noCloseOnEsc)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst teleportDisabledBoolean = useBooleanish(() => props.teleportDisabled)\n\nconst computedId = useId(() => props.id, 'offcanvas')\nuseSafeScrollLock(modelValueBoolean, bodyScrollingBoolean)\n\nconst element = ref<HTMLElement | null>(null)\n\nonKeyStroke(\n  'Escape',\n  () => {\n    hide('esc')\n  },\n  {target: element}\n)\n\nconst {focused} = useFocus(element, {\n  initialValue: modelValueBoolean.value && noFocusBoolean.value === false,\n})\n\nconst isActive = ref(modelValueBoolean.value)\nconst lazyLoadCompleted = ref(false)\n\nconst showBackdrop = toRef(() => backdropBoolean.value === true && modelValueBoolean.value === true)\n\nconst lazyShowing = toRef(\n  () =>\n    lazyBoolean.value === false ||\n    (lazyBoolean.value === true && lazyLoadCompleted.value === true) ||\n    (lazyBoolean.value === true && modelValueBoolean.value === true)\n)\n\nconst hasHeaderCloseSlot = toRef(() => !isEmptySlot(slots['header-close']))\nconst headerCloseClasses = computed(() => [\n  {'text-reset': !hasHeaderCloseSlot.value},\n  props.headerCloseClass,\n])\nconst headerCloseAttrs = computed(() => ({\n  variant: hasHeaderCloseSlot.value ? props.headerCloseVariant : undefined,\n  class: headerCloseClasses.value,\n}))\n\nconst hasFooterSlot = toRef(() => !isEmptySlot(slots.footer))\nconst computedClasses = computed(() => [\n  // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n  'offcanvas', // Remove when above check is fixed\n  `offcanvas-${props.placement}`,\n  {\n    show: modelValueBoolean.value && isActive.value === true,\n  },\n])\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  if (\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('hide-prevented')\n    return\n  }\n\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  if (trigger === 'esc') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (event.defaultPrevented) {\n    emit('hide-prevented')\n    return\n  }\n\n  modelValue.value = false\n}\n\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    modelValue.value = false\n    emit('show-prevented')\n    return\n  }\n  modelValue.value = true\n}\n\nconst focus = () => {\n  nextTick(() => {\n    if (noFocusBoolean.value === false) {\n      focused.value = true\n    }\n  })\n}\n\nconst OnBeforeEnter = () => show()\nconst OnAfterEnter = () => {\n  isActive.value = true\n  focus()\n  emit('shown', buildTriggerableEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => {\n  isActive.value = false\n}\nconst OnAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\nuseEventListener(element, 'bv-toggle', () => {\n  modelValueBoolean.value ? hide() : show()\n})\n\ndefineExpose({\n  hide,\n  show,\n})\n</script>\n","<template>\n  <ul\n    class=\"pagination\"\n    :class=\"computedWrapperClasses\"\n    role=\"menubar\"\n    :aria-disabled=\"disabledBoolean\"\n    :aria-label=\"ariaLabel || undefined\"\n  >\n    <!-- First -->\n    <li v-if=\"!hideGotoEndButtonsBoolean && !firstNumberBoolean\" v-bind=\"firstButtonProps.li\">\n      <component\n        v-bind=\"firstButtonProps.button\"\n        :is=\"firstButtonProps.button.is\"\n        @click=\"pageClick($event, 1)\"\n      >\n        <slot name=\"first-text\">\n          {{ firstText }}\n        </slot>\n      </component>\n    </li>\n    <!-- Prev -->\n    <li v-bind=\"prevButtonProps.li\">\n      <component\n        v-bind=\"prevButtonProps.button\"\n        :is=\"prevButtonProps.button.is\"\n        @click=\"pageClick($event, modelValueNumber - 1)\"\n      >\n        <slot name=\"prev-text\">\n          {{ prevText }}\n        </slot>\n      </component>\n    </li>\n    <!-- Ellipsis start -->\n    <li v-if=\"showFirstDots\" v-bind=\"ellipsisProps.li\">\n      <span v-bind=\"ellipsisProps.span\">\n        <slot name=\"ellipsis-text\">\n          {{ ellipsisText || '...' }}\n        </slot>\n      </span>\n    </li>\n    <!-- Main -->\n    <li\n      v-for=\"page in pages\"\n      :key=\"`page-${page.number}`\"\n      :class=\"[\n        'page-item',\n        {\n          'disabled': disabledBoolean,\n          'active': isActivePage(page.number),\n          'flex-fill': computedFill,\n          'd-flex': computedFill && !disabledBoolean,\n        },\n        pageClass,\n      ]\"\n      role=\"presentation\"\n      :aria-hidden=\"disabledBoolean || undefined\"\n    >\n      <component\n        :is=\"disabledBoolean ? 'span' : 'button'\"\n        :key=\"`page-${page.number}`\"\n        :class=\"['page-link', {'flex-grow-1': !disabledBoolean && computedFill}]\"\n        :aria-controls=\"ariaControls || undefined\"\n        :aria-disabled=\"disabledBoolean ? true : undefined\"\n        :aria-label=\"labelPage ? `${labelPage} ${page.number}` : undefined\"\n        :aria-posinset=\"page.number\"\n        :aria-checked=\"isActivePage(page.number)\"\n        :aria-setsize=\"numberOfPages\"\n        role=\"menuitemradio\"\n        :type=\"disabledBoolean ? undefined : 'button'\"\n        :tabindex=\"getTabIndex(page.number)\"\n        @click=\"pageClick($event, page.number)\"\n      >\n        <slot\n          name=\"page\"\n          :active=\"isActivePage(page.number)\"\n          :disabled=\"disabledBoolean\"\n          :page=\"page.number\"\n          :index=\"page.number - 1\"\n          :content=\"page.number\"\n        >\n          {{ page.number }}\n        </slot>\n      </component>\n    </li>\n\n    <!-- Ellipsis end -->\n    <li v-if=\"showLastDots\" v-bind=\"ellipsisProps.li\">\n      <span v-bind=\"ellipsisProps.span\">\n        <slot name=\"ellipsis-text\">\n          {{ ellipsisText || '...' }}\n        </slot>\n      </span>\n    </li>\n    <!-- Next -->\n    <li v-bind=\"nextButtonProps.li\">\n      <component\n        v-bind=\"nextButtonProps.button\"\n        :is=\"nextButtonProps.button.is\"\n        @click=\"pageClick($event, modelValueNumber + 1)\"\n      >\n        <slot name=\"next-text\">\n          {{ nextText }}\n        </slot>\n      </component>\n    </li>\n    <!-- Last -->\n    <li v-if=\"!lastNumberBoolean && !hideGotoEndButtonsBoolean\" v-bind=\"lastEndButtonProps.li\">\n      <component\n        v-bind=\"lastEndButtonProps.button\"\n        :is=\"lastEndButtonProps.button.is\"\n        @click=\"pageClick($event, numberOfPages)\"\n      >\n        <slot name=\"last-text\">\n          {{ lastText }}\n        </slot>\n      </component>\n    </li>\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport {BvEvent} from '../../utils'\nimport {computed, toRef, watch} from 'vue'\nimport type {AlignmentJustifyContent, Booleanish, ClassValue, Size} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport {useToNumber, useVModel} from '@vueuse/core'\n\n// Threshold of limit size when we start/stop showing ellipsis\nconst ELLIPSIS_THRESHOLD = 3\n\nconst props = withDefaults(\n  defineProps<{\n    align?: AlignmentJustifyContent | 'fill'\n    ariaControls?: string\n    ariaLabel?: string\n    disabled?: Booleanish\n    ellipsisClass?: ClassValue\n    ellipsisText?: string\n    firstClass?: ClassValue\n    firstNumber?: Booleanish\n    firstText?: string\n    hideEllipsis?: Booleanish\n    hideGotoEndButtons?: Booleanish\n    labelFirstPage?: string\n    labelLastPage?: string\n    labelNextPage?: string\n    labelPage?: string\n    labelPrevPage?: string\n    lastClass?: ClassValue\n    lastNumber?: Booleanish\n    lastText?: string\n    limit?: number\n    modelValue?: string | number\n    nextClass?: ClassValue\n    nextText?: string\n    pageClass?: ClassValue\n    perPage?: string | number\n    pills?: Booleanish\n    prevClass?: ClassValue\n    prevText?: string\n    size?: Size\n    totalRows?: string | number\n  }>(),\n  {\n    align: 'start',\n    ariaControls: undefined,\n    ariaLabel: 'Pagination',\n    disabled: false,\n    ellipsisClass: undefined,\n    ellipsisText: '\\u2026',\n    firstClass: undefined,\n    firstNumber: false,\n    firstText: '\\u00AB',\n    hideEllipsis: false,\n    hideGotoEndButtons: false,\n    labelFirstPage: 'Go to first page',\n    labelLastPage: 'Go to last page',\n    labelNextPage: 'Go to next page',\n    labelPage: 'Go to page',\n    labelPrevPage: 'Go to previous page',\n    lastClass: undefined,\n    lastNumber: false,\n    lastText: '\\u00BB',\n    limit: 5,\n    modelValue: 1,\n    nextClass: undefined,\n    nextText: '\\u203A',\n    pageClass: undefined,\n    perPage: DEFAULT_PER_PAGE,\n    pills: false,\n    prevClass: undefined,\n    prevText: '\\u2039',\n    size: undefined,\n    totalRows: DEFAULT_TOTAL_ROWS,\n  }\n)\n\nconst emit = defineEmits<{\n  'update:modelValue': [value: number]\n  'page-click': [event: BvEvent, pageNumber: number]\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst firstNumberBoolean = useBooleanish(() => props.firstNumber)\nconst hideEllipsisBoolean = useBooleanish(() => props.hideEllipsis)\nconst hideGotoEndButtonsBoolean = useBooleanish(() => props.hideGotoEndButtons)\nconst lastNumberBoolean = useBooleanish(() => props.lastNumber)\nconst pillsBoolean = useBooleanish(() => props.pills)\n\nconst perPageNumber = useToNumber(() => props.perPage, {nanToZero: true, method: 'parseInt'})\nconst totalRowsNumber = useToNumber(() => props.totalRows, {nanToZero: true, method: 'parseInt'})\nconst modelValueNumber = useToNumber(modelValue, {nanToZero: true, method: 'parseInt'})\n\nconst perPageSanitized = toRef(() => Math.max(perPageNumber.value || DEFAULT_PER_PAGE, 1))\nconst totalRowsSanitized = toRef(() => Math.max(totalRowsNumber.value || DEFAULT_TOTAL_ROWS, 0))\n// Use Active to on page-item to denote active tab\nconst numberOfPages = toRef(() => Math.ceil(totalRowsSanitized.value / perPageSanitized.value))\nconst computedFill = toRef(() => props.align === 'fill')\n// This doesn't use the computedFill util because TS cannot infer that it would never be 'fill'\nconst justifyAlign = toRef(() => (props.align === 'fill' ? 'start' : props.align))\n\nconst alignment = useAlignment(justifyAlign)\n\nconst isActivePage = (pageNumber: number) => pageNumber === modelValueNumber.value\nconst getTabIndex = (num: number) => (disabledBoolean.value ? null : isActivePage(num) ? '0' : '-1')\n\nconst checkDisabled = (num: number) =>\n  disabledBoolean.value ||\n  isActivePage(num) ||\n  modelValueNumber.value < 1 ||\n  // Check if the number is out of bounds\n  num < 1 ||\n  num > numberOfPages.value\n\nconst firstDisabled = computed(() => checkDisabled(1))\nconst prevDisabled = computed(() => checkDisabled(modelValueNumber.value - 1))\nconst lastDisabled = computed(() => checkDisabled(numberOfPages.value))\nconst nextDisabled = computed(() => checkDisabled(modelValueNumber.value + 1))\n\nconst getEndButtonProps = (dis: boolean, classVal: ClassValue) => ({\n  li: {\n    class: [\n      'page-item',\n      {\n        'disabled': dis,\n        'flex-fill': computedFill.value,\n        'd-flex': computedFill.value && !dis,\n      },\n      classVal,\n    ],\n  },\n  button: {\n    'is': dis ? 'span' : 'button',\n    'class': ['page-link', {'flex-grow-1': !dis && computedFill.value}],\n    'aria-label': props.labelFirstPage,\n    'aria-controls': props.ariaControls || undefined,\n    'aria-disabled': dis ? true : undefined,\n    'role': 'menuitem',\n    'type': dis ? undefined : 'button',\n    'tabindex': dis ? undefined : '-1',\n  },\n})\n\nconst firstButtonProps = computed(() => getEndButtonProps(firstDisabled.value, props.firstClass))\nconst prevButtonProps = computed(() => getEndButtonProps(prevDisabled.value, props.prevClass))\nconst nextButtonProps = computed(() => getEndButtonProps(nextDisabled.value, props.nextClass))\nconst lastEndButtonProps = computed(() => getEndButtonProps(lastDisabled.value, props.lastClass))\n\nconst ellipsisProps = computed(() => ({\n  li: {\n    class: [\n      'page-item',\n      'disabled',\n      'bv-d-xs-down-none',\n      computedFill.value ? 'flex-fill' : '',\n      props.ellipsisClass,\n    ],\n    role: 'separator',\n  },\n  span: {\n    class: ['page-link'],\n  },\n}))\n\nconst computedWrapperClasses = computed(() => [\n  alignment.value,\n  {\n    [`pagination-${props.size}`]: props.size !== undefined,\n    'b-pagination-pills': pillsBoolean.value,\n  },\n])\n\nconst startNumber = computed(() => {\n  let lStartNumber: number\n  const pagesLeft: number = numberOfPages.value - modelValueNumber.value\n\n  if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n    lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n  } else {\n    // Middle and beginning calculation.\n    lStartNumber = modelValueNumber.value - Math.floor(numberOfLinks.value / 2)\n  }\n  // Negative due at times\n  if (lStartNumber < 1) {\n    lStartNumber = 1\n  } else if (lStartNumber > numberOfPages.value - numberOfLinks.value) {\n    lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n  }\n  //why check for this?\n  // if (showFirstDots.value && cfirstNumber && lStartNumber < 4) {\n  //   lStartNumber = 1\n  // }\n\n  // Special handling for lower limits (where ellipsis are never shown)\n  if (props.limit <= ELLIPSIS_THRESHOLD) {\n    if (lastNumberBoolean.value && numberOfPages.value === lStartNumber + numberOfLinks.value - 1) {\n      lStartNumber = Math.max(lStartNumber - 1, 1)\n    }\n  }\n  return lStartNumber\n})\n\nconst showFirstDots = computed(() => {\n  const pagesLeft = numberOfPages.value - modelValueNumber.value\n  let rShowDots = false\n\n  if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n    if (props.limit > ELLIPSIS_THRESHOLD) {\n      rShowDots = true\n    }\n  } else {\n    if (props.limit > ELLIPSIS_THRESHOLD) {\n      rShowDots = !!(!hideEllipsisBoolean.value || firstNumberBoolean.value)\n    }\n  }\n  if (startNumber.value <= 1) {\n    rShowDots = false\n  }\n\n  if (rShowDots && firstNumberBoolean.value && startNumber.value < 4) {\n    rShowDots = false\n  }\n\n  return rShowDots\n})\n\n//Calculate the number of links considering limit\nconst numberOfLinks = computed(() => {\n  let n: number = props.limit\n\n  if (numberOfPages.value <= props.limit) {\n    n = numberOfPages.value\n  } else if (modelValueNumber.value < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n    if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n      n = props.limit - (firstNumberBoolean.value ? 0 : 1)\n    }\n    n = Math.min(n, props.limit)\n  } else if (\n    numberOfPages.value - modelValueNumber.value + 2 < props.limit &&\n    props.limit > ELLIPSIS_THRESHOLD\n  ) {\n    if (!hideEllipsisBoolean.value || firstNumberBoolean.value) {\n      n = props.limit - (lastNumberBoolean.value ? 0 : 1)\n    }\n  } else {\n    // We consider ellipsis tabs as their own page links\n    if (props.limit > ELLIPSIS_THRESHOLD) {\n      n = props.limit - (hideEllipsisBoolean.value ? 0 : 2)\n    }\n  }\n\n  return n\n})\n\nconst showLastDots = computed(() => {\n  const paginationWindowEnd = numberOfPages.value - numberOfLinks.value // The start of the last window of page links\n\n  let rShowDots = false\n\n  if (modelValueNumber.value < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n    if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n      rShowDots = true\n    }\n  } else {\n    if (props.limit > ELLIPSIS_THRESHOLD) {\n      rShowDots = !!(!hideEllipsisBoolean.value || lastNumberBoolean.value)\n    }\n  }\n  if (startNumber.value > paginationWindowEnd) {\n    rShowDots = false\n  }\n  const lastPageNumber = startNumber.value + numberOfLinks.value - 1\n\n  if (rShowDots && lastNumberBoolean.value && lastPageNumber > numberOfPages.value - 3) {\n    rShowDots = false\n  }\n\n  return rShowDots\n})\n\nconst pagination = computed(() => ({\n  pageSize: perPageSanitized.value,\n  totalRows: totalRowsNumber.value,\n  numberOfPages: numberOfPages.value,\n}))\n\nconst pageClick = (event: MouseEvent, pageNumber: number) => {\n  if (pageNumber === modelValueNumber.value) return\n\n  const clickEvent = new BvEvent('page-click', {\n    cancelable: true,\n    target: event.target,\n  })\n  emit('page-click', clickEvent, pageNumber)\n\n  if (clickEvent.defaultPrevented) return\n\n  modelValue.value = pageNumber\n\n  //    nextTick(() => {\n  //  if (isVisible(target) && un_element.contains(target)) {\n  //  attemptFocus(target)\n  //} else {\n  //this.focusCurrent()\n  //}\n  // })\n}\n\nwatch(modelValueNumber, (newValue) => {\n  const sanitizeCurrentPage = (value: number, numberOfPages: number) => {\n    const page = value || 1\n    return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page\n  }\n  const calculatedValue = sanitizeCurrentPage(newValue, numberOfPages.value)\n  if (calculatedValue === modelValue.value) return\n  modelValue.value = calculatedValue\n})\n\nwatch(pagination, (oldValue, newValue) => {\n  if (newValue.pageSize !== oldValue.pageSize && newValue.totalRows === oldValue.totalRows) {\n    // If the page size changes, reset to page 1\n    modelValue.value = 1\n  } else if (\n    newValue.numberOfPages !== oldValue.numberOfPages &&\n    modelValueNumber.value > newValue.numberOfPages\n  ) {\n    // If `numberOfPages` changes and is less than\n    // the `currentPage` number, reset to page 1\n    modelValue.value = 1\n  }\n})\n\nconst pages = computed(() =>\n  Array.from({length: numberOfLinks.value}, (_, index) => ({\n    number: startNumber.value + index,\n  }))\n)\n</script>\n\n<script lang=\"ts\">\nconst DEFAULT_PER_PAGE = 20\nconst DEFAULT_TOTAL_ROWS = 0\n</script>\n","<template>\n  <component :is=\"wrapperTag\" :class=\"wrapperClasses\">\n    <component\n      v-bind=\"$attrs\"\n      :is=\"tag\"\n      class=\"placeholder\"\n      :class=\"computedClasses\"\n      :style=\"computedStyle\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type CSSProperties, toRef} from 'vue'\nimport type {ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst props = withDefaults(\n  defineProps<{\n    animation?: PlaceholderAnimation\n    cols?: string | number\n    size?: PlaceholderSize\n    tag?: string\n    variant?: ColorVariant | null\n    width?: string | number\n    wrapperTag?: string\n  }>(),\n  {\n    animation: undefined,\n    cols: 12,\n    size: 'md',\n    tag: 'span',\n    variant: null,\n    width: undefined,\n    wrapperTag: 'span',\n  }\n)\n\nconst widthString = toRef(() =>\n  props.width === undefined\n    ? undefined\n    : typeof props.width === 'number'\n    ? props.width.toString()\n    : props.width.replace('%', '')\n)\n\nconst colsString = toRef(() =>\n  props.cols === undefined\n    ? undefined\n    : typeof props.cols === 'number'\n    ? props.cols.toString()\n    : props.cols\n)\n\nconst computedClasses = computed(() => ({\n  [`col-${colsString.value}`]: colsString.value !== undefined && widthString.value === undefined,\n  [`bg-${props.variant}`]: props.variant !== null,\n  [`placeholder-${props.size}`]: props.size !== 'md',\n}))\n\nconst wrapperClasses = computed(() => ({\n  [`placeholder-${props.animation}`]: props.animation !== undefined,\n}))\n\nconst computedStyle = computed<CSSProperties>(() => ({\n  width: widthString.value === undefined ? undefined : `${widthString.value}%`,\n}))\n</script>\n","<template>\n  <BPlaceholder\n    class=\"btn disabled\"\n    :class=\"computedClasses\"\n    :animation=\"animation\"\n    :width=\"width\"\n    :cols=\"cols\"\n    :tag=\"tag\"\n    :style=\"{'cursor': 'wait', 'pointer-events': 'auto'}\"\n  />\n</template>\n\n<script setup lang=\"ts\">\nimport BPlaceholder from './BPlaceholder.vue'\nimport type {ColorVariant, PlaceholderAnimation} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    animation?: PlaceholderAnimation\n    cols?: string | number\n    tag?: string\n    variant?: ColorVariant | null\n    width?: string | number\n  }>(),\n  {\n    animation: undefined,\n    cols: undefined,\n    tag: 'div',\n    variant: 'primary',\n    width: undefined,\n  }\n)\n\nconst computedClasses = computed(() => ({\n  [`btn-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <BCard :img-bottom=\"imgBottom\">\n    <template v-if=\"!noImgBoolean\" #img>\n      <slot name=\"img\">\n        <BCardImg\n          :blank=\"!imgSrc ? true : false\"\n          :blank-color=\"imgBlankColor\"\n          :height=\"!imgSrc ? imgHeight : undefined\"\n          :src=\"imgSrc\"\n          :top=\"!imgBottom\"\n          :bottom=\"imgBottom\"\n          :style=\"{cursor: 'wait'}\"\n        />\n      </slot>\n    </template>\n\n    <template v-if=\"!noHeaderBoolean\" #header>\n      <slot name=\"header\">\n        <BPlaceholder\n          :width=\"headerWidth\"\n          :variant=\"headerVariant\"\n          :animation=\"headerAnimation\"\n          :size=\"headerSize\"\n        />\n      </slot>\n    </template>\n    <slot>\n      <BPlaceholder cols=\"7\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"4\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"4\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"6\" v-bind=\"defaultAttrs\" />\n      <BPlaceholder cols=\"8\" v-bind=\"defaultAttrs\" />\n    </slot>\n    <template v-if=\"!noFooterBoolean\" #footer>\n      <slot name=\"footer\">\n        <component\n          :is=\"footerComponent\"\n          :width=\"footerWidth\"\n          :animation=\"footerAnimation\"\n          :size=\"noButtonBoolean ? footerSize : undefined\"\n          :variant=\"footerVariant\"\n        />\n      </slot>\n    </template>\n  </BCard>\n</template>\n\n<script setup lang=\"ts\">\nimport BCard from '../BCard/BCard.vue'\nimport BCardImg from '../BCard/BCardImg.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport BPlaceholderButton from './BPlaceholderButton.vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    animation?: PlaceholderAnimation\n    footerAnimation?: PlaceholderAnimation\n    footerSize?: PlaceholderSize\n    footerVariant?: ColorVariant | null\n    footerWidth?: string | number\n    headerAnimation?: PlaceholderAnimation\n    headerSize?: PlaceholderSize\n    headerVariant?: ColorVariant | null\n    headerWidth?: string | number\n    imgBlankColor?: string\n    imgBottom?: Booleanish\n    imgHeight?: string | number\n    imgSrc?: string\n    noButton?: Booleanish\n    noFooter?: Booleanish\n    noHeader?: Booleanish\n    noImg?: Booleanish\n    size?: PlaceholderSize\n    variant?: ColorVariant | null\n  }>(),\n  {\n    animation: undefined,\n    footerAnimation: undefined,\n    footerSize: 'md',\n    footerVariant: undefined,\n    footerWidth: 100,\n    headerAnimation: undefined,\n    headerSize: 'md',\n    headerVariant: undefined,\n    headerWidth: 100,\n    imgBlankColor: '#868e96',\n    imgBottom: false,\n    imgHeight: 100,\n    imgSrc: undefined,\n    noButton: false,\n    noFooter: false,\n    noHeader: false,\n    noImg: false,\n    size: 'md',\n    variant: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  footer?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  header?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  img?: (props: Record<string, never>) => any\n}>()\n\nconst noButtonBoolean = useBooleanish(() => props.noButton)\nconst noHeaderBoolean = useBooleanish(() => props.noHeader)\nconst noFooterBoolean = useBooleanish(() => props.noFooter)\nconst noImgBoolean = useBooleanish(() => props.noImg)\n\nconst defaultAttrs = computed(() => ({\n  animation: props.animation,\n  size: props.size,\n  variant: props.variant,\n}))\n\nconst footerComponent = toRef(() => (!noButtonBoolean.value ? BPlaceholderButton : BPlaceholder))\n</script>\n","<template>\n  <table v-if=\"!responsive\" :class=\"computedClasses\">\n    <slot />\n  </table>\n  <div v-else :class=\"responsiveClasses\">\n    <table :class=\"computedClasses\">\n      <slot />\n    </table>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {BTableSimpleProps} from '../../types'\n\n// TODO alphabetize the lists for tables\n// TODO all table things do not declare their props\n// TODO some props are not used. ex id, fixed, etc\n// TODO Attrs fallthrough will attach to either responsive or table, but you can't assign attrs to table if it is responsive. So we will need an attrs & class\nconst props = withDefaults(defineProps<BTableSimpleProps>(), {\n  borderVariant: null,\n  tableClass: undefined,\n  variant: null,\n  bordered: false,\n  borderless: false,\n  captionTop: false,\n  dark: false,\n  hover: false,\n  id: undefined,\n  noBorderCollapse: false,\n  outlined: false,\n  fixed: false,\n  responsive: false,\n  stacked: false,\n  striped: false,\n  stripedColumns: false,\n  small: false,\n  stickyHeader: false,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst captionTopBoolean = useBooleanish(() => props.captionTop)\nconst borderlessBoolean = useBooleanish(() => props.borderless)\nconst borderedBoolean = useBooleanish(() => props.bordered)\nconst darkBoolean = useBooleanish(() => props.dark)\nconst hoverBoolean = useBooleanish(() => props.hover)\nconst smallBoolean = useBooleanish(() => props.small)\nconst stripedBoolean = useBooleanish(() => props.striped)\nconst stickyHeaderBoolean = useBooleanish(() => props.stickyHeader)\nconst stripedColumnsBoolean = useBooleanish(() => props.stripedColumns)\nconst resolvedResponsive = useBooleanish(() => props.responsive)\nconst resolvedStacked = useBooleanish(() => props.stacked)\n\nconst computedClasses = computed(() => [\n  props.tableClass,\n  'table',\n  'b-table',\n  {\n    'table-bordered': borderedBoolean.value,\n    'table-borderless': borderlessBoolean.value,\n    [`border-${props.borderVariant}`]: props.borderVariant !== null,\n    'caption-top': captionTopBoolean.value,\n    'table-dark': darkBoolean.value,\n    'table-hover': hoverBoolean.value,\n    'b-table-stacked': resolvedStacked.value === true,\n    [`b-table-stacked-${resolvedStacked.value}`]: typeof resolvedStacked.value === 'string',\n    'table-striped': stripedBoolean.value,\n    'table-sm': smallBoolean.value,\n    [`table-${props.variant}`]: props.variant !== null,\n    'table-striped-columns': stripedColumnsBoolean.value,\n  },\n])\n\nconst responsiveClasses = computed(() => ({\n  'table-responsive': resolvedResponsive.value === true,\n  [`table-responsive-${resolvedResponsive.value}`]: typeof resolvedResponsive.value === 'string',\n  'b-table-sticky-header': stickyHeaderBoolean.value,\n}))\n</script>\n","<template>\n  <BTableSimple>\n    <slot v-if=\"!hideHeaderBoolean\" name=\"thead\">\n      <thead>\n        <tr>\n          <th v-for=\"(_, i) in computedHeaderColumnsLength\" :key=\"i\">\n            <BPlaceholder\n              :size=\"headerSize\"\n              :variant=\"headerVariant\"\n              :animation=\"headerAnimation\"\n              :width=\"headerCellWidth\"\n            />\n          </th>\n        </tr>\n      </thead>\n    </slot>\n    <slot>\n      <tbody>\n        <tr v-for=\"(_, j) in rowsNumber\" :key=\"j\">\n          <td v-for=\"(__, k) in columnsNumber\" :key=\"k\">\n            <BPlaceholder\n              :size=\"size\"\n              :variant=\"variant\"\n              :animation=\"animation\"\n              :width=\"cellWidth\"\n            />\n          </td>\n        </tr>\n      </tbody>\n    </slot>\n    <slot v-if=\"showFooterBoolean\" name=\"tfoot\">\n      <tfoot>\n        <tr>\n          <th v-for=\"(_, l) in computedFooterColumnsLength\" :key=\"l\">\n            <BPlaceholder\n              :size=\"footerSize\"\n              :variant=\"footerVariant\"\n              :animation=\"footerAnimation\"\n              :width=\"footerCellWidth\"\n            />\n          </th>\n        </tr>\n      </tfoot>\n    </slot>\n  </BTableSimple>\n</template>\n\n<script setup lang=\"ts\">\nimport {toRef} from 'vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(\n  defineProps<{\n    animation?: PlaceholderAnimation\n    cellWidth?: string | number\n    columns?: string | number\n    footerAnimation?: PlaceholderAnimation\n    footerCellWidth?: string | number\n    footerColumns?: string | number\n    footerSize?: PlaceholderSize\n    footerVariant?: ColorVariant | null\n    headerAnimation?: PlaceholderAnimation\n    headerCellWidth?: string | number\n    headerColumns?: string | number\n    headerSize?: PlaceholderSize\n    headerVariant?: ColorVariant | null\n    hideHeader?: Booleanish\n    rows?: string | number\n    showFooter?: Booleanish\n    size?: PlaceholderSize\n    variant?: ColorVariant | null\n  }>(),\n  {\n    animation: undefined,\n    cellWidth: 100,\n    columns: 5,\n    footerAnimation: undefined,\n    footerCellWidth: 100,\n    footerColumns: undefined,\n    footerSize: 'md',\n    footerVariant: undefined,\n    headerAnimation: undefined,\n    headerCellWidth: 100,\n    headerColumns: undefined,\n    headerSize: 'md',\n    headerVariant: undefined,\n    hideHeader: false,\n    rows: 3,\n    showFooter: false,\n    size: 'md',\n    variant: undefined,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tfoot?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  thead?: (props: Record<string, never>) => any\n}>()\n\nconst columnsToNumber = useToNumber(() => props.columns)\nconst rowsToNumber = useToNumber(() => props.rows)\nconst computedHeaderColumns = toRef(() => props.headerColumns ?? NaN)\nconst computedFooterColumns = toRef(() => props.footerColumns ?? NaN)\nconst headerColumnsNumber = useToNumber(computedHeaderColumns)\nconst footerColumnsNumber = useToNumber(computedFooterColumns)\n\nconst columnsNumber = toRef(() => columnsToNumber.value || 5)\nconst rowsNumber = toRef(() => rowsToNumber.value || 3)\n\nconst computedHeaderColumnsLength = toRef(() =>\n  props.headerColumns === undefined ? columnsNumber.value : headerColumnsNumber.value\n)\nconst computedFooterColumnsLength = toRef(() =>\n  props.footerColumns === undefined ? columnsNumber.value : footerColumnsNumber.value\n)\n\nconst hideHeaderBoolean = useBooleanish(() => props.hideHeader)\nconst showFooterBoolean = useBooleanish(() => props.showFooter)\n</script>\n","<template>\n  <slot v-if=\"loadingBoolean\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\nconst props = withDefaults(\n  defineProps<{\n    loading?: Booleanish\n  }>(),\n  {\n    loading: false,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  loading?: (props: Record<string, never>) => any\n}>()\n\nconst loadingBoolean = useBooleanish(() => props.loading)\n</script>\n","<template>\n  <div\n    class=\"progress-bar\"\n    :class=\"computedClasses\"\n    role=\"progressbar\"\n    :aria-valuenow=\"value\"\n    aria-valuemin=\"0\"\n    :aria-valuemax=\"max\"\n    :style=\"{width: computedWidth}\"\n  >\n    <slot>\n      {{ computedLabel }}\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {BProgressBarProps} from '../../types'\nimport {useBooleanish, useColorVariantClasses} from '../../composables'\nimport {computed, inject} from 'vue'\nimport {progressInjectionKey} from '../../utils'\nimport {useToNumber} from '@vueuse/core'\n\nconst props = withDefaults(defineProps<BProgressBarProps>(), {\n  animated: false,\n  bgVariant: null,\n  label: undefined,\n  labelHtml: undefined,\n  max: undefined,\n  precision: 0,\n  showProgress: false,\n  showValue: false,\n  striped: false,\n  textVariant: null,\n  value: 0,\n  variant: null,\n})\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst parentData = inject(progressInjectionKey, null)\n\nconst animatedBoolean = useBooleanish(() => props.animated)\nconst showProgressBoolean = useBooleanish(() => props.showProgress)\nconst showValueBoolean = useBooleanish(() => props.showValue)\nconst stripedBoolean = useBooleanish(() => props.striped)\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    'progress-bar-animated': animatedBoolean.value || parentData?.animated.value,\n    'progress-bar-striped':\n      stripedBoolean.value ||\n      parentData?.striped.value ||\n      animatedBoolean.value ||\n      parentData?.animated.value,\n  },\n])\n\nconst numberPrecision = useToNumber(() => props.precision)\nconst numberValue = useToNumber(() => props.value)\nconst numberMax = useToNumber(() => props.max ?? NaN)\nconst parentMaxNumber = useToNumber(() => parentData?.max.value ?? NaN)\n\nconst computedLabel = computed(() =>\n  props.labelHtml !== undefined\n    ? props.labelHtml\n    : showValueBoolean.value || parentData?.showValue.value\n    ? numberValue.value.toFixed(numberPrecision.value)\n    : showProgressBoolean.value || parentData?.showProgress.value\n    ? ((numberValue.value * 100) / (numberMax.value || 100)).toFixed(numberPrecision.value)\n    : props.label !== undefined\n    ? props.label\n    : ''\n)\n\nconst computedWidth = computed(() =>\n  parentMaxNumber.value\n    ? `${(numberValue.value * 100) / parentMaxNumber.value}%`\n    : numberMax.value\n    ? `${(numberValue.value * 100) / numberMax.value}%`\n    : typeof props.value === 'string'\n    ? props.value\n    : `${props.value}%`\n)\n</script>\n","<template>\n  <div class=\"progress\" :style=\"{height}\">\n    <slot>\n      <BProgressBar\n        :animated=\"animated\"\n        :max=\"max\"\n        :precision=\"precision\"\n        :show-progress=\"showProgress\"\n        :show-value=\"showValue\"\n        :striped=\"striped\"\n        :value=\"value\"\n        :variant=\"variant\"\n        :text-variant=\"textVariant\"\n        :bg-variant=\"bgVariant\"\n      />\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport BProgressBar from './BProgressBar.vue'\nimport type {BProgressBarProps} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {provide, toRef} from 'vue'\nimport {progressInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<\n    {\n      height?: string\n    } & Omit<BProgressBarProps, 'label' | 'labelHtml'>\n  >(),\n  {\n    height: undefined,\n    // BProgressBar props\n    animated: undefined,\n    bgVariant: undefined,\n    max: 100,\n    precision: undefined,\n    showProgress: undefined,\n    showValue: undefined,\n    striped: undefined,\n    textVariant: undefined,\n    value: undefined,\n    variant: undefined,\n    // End BProgressBar props\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst animatedBoolean = useBooleanish(() => props.animated)\nconst showProgressBoolean = useBooleanish(() => props.showProgress)\nconst showValueBoolean = useBooleanish(() => props.showValue)\nconst stripedBoolean = useBooleanish(() => props.striped)\n\nprovide(progressInjectionKey, {\n  animated: animatedBoolean,\n  max: toRef(() => props.max),\n  showProgress: showProgressBoolean,\n  showValue: showValueBoolean,\n  striped: stripedBoolean,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"row\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, type SlotsType} from 'vue'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport type {\n  AlignmentContent,\n  AlignmentJustifyContent,\n  AlignmentVertical,\n  Booleanish,\n} from '../types'\nimport {useAlignment, useBooleanish} from '../composables'\n\nconst rowColsProps = getBreakpointProps('cols', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BRow',\n  slots: Object as SlotsType<{\n    default?: Record<string, never>\n  }>,\n  props: {\n    tag: {type: String, default: 'div'},\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    noGutters: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    alignV: {type: String as PropType<AlignmentVertical>, default: null},\n    alignH: {type: String as PropType<AlignmentJustifyContent>, default: null},\n    alignContent: {type: String as PropType<AlignmentContent>, default: null},\n    ...rowColsProps,\n  },\n  setup(props) {\n    const noGuttersBoolean = useBooleanish(() => props.noGutters)\n    const alignment = useAlignment(() => props.alignH)\n\n    const rowColsClasses = computed(() => getClasses(props, rowColsProps, 'cols', 'row-cols'))\n\n    const computedClasses = computed(() => [\n      rowColsClasses.value,\n      {\n        [`gx-${props.gutterX}`]: props.gutterX !== null,\n        [`gy-${props.gutterY}`]: props.gutterY !== null,\n        'g-0': noGuttersBoolean.value,\n        [`align-items-${props.alignV}`]: props.alignV !== null,\n        [alignment.value]: props.alignH !== null,\n        [`align-content-${props.alignContent}`]: props.alignContent !== null,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <tbody :class=\"computedClasses\">\n    <slot />\n  </tbody>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`thead-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <td\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading\">\n      <slot />\n    </div>\n    <slot v-else />\n  </td>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    colspan?: string | number\n    rowspan?: string | number\n    stackedHeading?: string\n    stickyColumn?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    colspan: undefined,\n    rowspan: undefined,\n    stackedHeading: undefined,\n    stickyColumn: false,\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst stickyColumnBoolean = useBooleanish(() => props.stickyColumn)\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === null,\n}))\n\nconst scope = toRef(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <tfoot :class=\"computedClasses\">\n    <slot />\n  </tfoot>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <th\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading !== undefined\">\n      <slot />\n    </div>\n    <slot v-else />\n  </th>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    colspan?: string | number\n    rowspan?: string | number\n    stackedHeading?: string\n    stickyColumn?: Booleanish\n    variant?: ColorVariant | null\n  }>(),\n  {\n    colspan: undefined,\n    rowspan: undefined,\n    stackedHeading: undefined,\n    stickyColumn: false,\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst stickyColumnBoolean = useBooleanish(() => props.stickyColumn)\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === null,\n}))\n\nconst scope = toRef(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <thead :class=\"computedClasses\">\n    <slot />\n  </thead>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <tr :class=\"computedClasses\">\n    <slot />\n  </tr>\n</template>\n\n<script setup lang=\"ts\">\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\nconst props = withDefaults(\n  defineProps<{\n    variant?: ColorVariant | null\n  }>(),\n  {\n    variant: null,\n  }\n)\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n}>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== null,\n}))\n</script>\n","<template>\n  <BTableSimple\n    :id=\"id\"\n    :bordered=\"bordered\"\n    :borderless=\"borderless\"\n    :border-variant=\"borderVariant\"\n    :caption-top=\"captionTop\"\n    :dark=\"dark\"\n    :fixed=\"fixed\"\n    :hover=\"hover\"\n    :no-border-collapse=\"noBorderCollapse\"\n    :outlined=\"outlined\"\n    :responsive=\"responsive\"\n    :small=\"small\"\n    :stacked=\"computedStacked\"\n    :sticky-header=\"stickyHeader\"\n    :striped=\"striped\"\n    :table-class=\"computedTableClasses\"\n    :variant=\"variant\"\n    :striped-columns=\"stripedColumns\"\n  >\n    <BThead :variant=\"headVariant\" :class=\"theadClass\">\n      <slot v-if=\"$slots['thead-top']\" name=\"thead-top\" />\n      <BTr :variant=\"headRowVariant\" :class=\"theadTrClass\">\n        <BTh\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :variant=\"field.variant\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event)\"\n        >\n          <slot\n            :name=\"$slots[`head(${field.key})`] ? `head(${field.key})` : 'head()'\"\n            :label=\"field.label\"\n            :column=\"field.key\"\n            :field=\"field\"\n            :is-foot=\"false\"\n          >\n            {{ getTableFieldHeadLabel(field) }}\n          </slot>\n        </BTh>\n      </BTr>\n      <BTr v-if=\"$slots['thead-sub']\">\n        <BTd\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :variant=\"field.variant\"\n          :class=\"[field.class, field.thClass]\"\n        >\n          <slot name=\"thead-sub\" :items=\"computedFields\" v-bind=\"field\">\n            {{ field.label }}\n          </slot>\n        </BTd>\n      </BTr>\n    </BThead>\n    <BTbody :class=\"tbodyClass\">\n      <slot\n        name=\"custom-body\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields.length\"\n      >\n        <BTr v-if=\"!computedStacked && $slots['top-row']\">\n          <slot name=\"top-row\" />\n        </BTr>\n\n        <template v-for=\"(item, itemIndex) in items\" :key=\"itemIndex\">\n          <BTr\n            :class=\"getRowClasses(item, 'row')\"\n            :variant=\"item._rowVariant\"\n            @click=\"!filterEvent($event) && emit('row-clicked', item, itemIndex, $event)\"\n            @dblclick=\"!filterEvent($event) && emit('row-dbl-clicked', item, itemIndex, $event)\"\n            @mouseenter=\"!filterEvent($event) && emit('row-hovered', item, itemIndex, $event)\"\n            @mouseleave=\"!filterEvent($event) && emit('row-unhovered', item, itemIndex, $event)\"\n          >\n            <BTd\n              v-for=\"field in computedFields\"\n              :key=\"field.key\"\n              :variant=\"item._cellVariants?.[field.key] ? null : field.variant\"\n              :class=\"getFieldRowClasses(field, item)\"\n              v-bind=\"field.tdAttr\"\n            >\n              <label v-if=\"computedStacked && labelStackedBoolean\" class=\"b-table-stacked-label\">\n                {{ getTableFieldHeadLabel(field) }}\n              </label>\n              <slot\n                :name=\"$slots[`cell(${field.key})`] ? `cell(${field.key})` : 'cell()'\"\n                :value=\"get(item, field.key)\"\n                :index=\"itemIndex\"\n                :item=\"item\"\n                :field=\"field\"\n                :items=\"items\"\n                :toggle-details=\"\n                  () => {\n                    toggleRowDetails(item)\n                  }\n                \"\n                :details-showing=\"item._showDetails ?? false\"\n              >\n                {{ formatItem(item, field.key, field.formatter) }}\n              </slot>\n            </BTd>\n          </BTr>\n\n          <BTr\n            v-if=\"item._showDetails === true && $slots['row-details']\"\n            :class=\"getRowClasses(item, 'row-details')\"\n            :variant=\"item._rowVariant\"\n          >\n            <BTd :colspan=\"computedFieldsTotal\">\n              <slot\n                name=\"row-details\"\n                :item=\"item\"\n                :toggle-details=\"\n                  () => {\n                    toggleRowDetails(item)\n                  }\n                \"\n                :fields=\"fields\"\n                :index=\"itemIndex\"\n              />\n            </BTd>\n          </BTr>\n        </template>\n        <BTr v-if=\"showEmptyBoolean && items.length === 0\" class=\"b-table-empty-slot\">\n          <BTd :colspan=\"computedFieldsTotal\">\n            <slot name=\"empty\" :items=\"items\">\n              {{ emptyText }}\n            </slot>\n          </BTd>\n        </BTr>\n        <BTr v-if=\"!computedStacked && $slots['bottom-row']\">\n          <slot name=\"bottom-row\" />\n        </BTr>\n      </slot>\n    </BTbody>\n    <BTfoot v-if=\"footCloneBoolean\" :variant=\"footVariant\" :class=\"tfootClass\">\n      <BTr :variant=\"footRowVariant\" :class=\"tfootTrClass\">\n        <BTh\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          :variant=\"field.variant\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event, true)\"\n        >\n          <div class=\"d-inline-flex flex-nowrap align-items-center gap-1\">\n            <div>\n              <slot\n                :name=\"$slots[`foot(${field.key})`] ? `foot(${field.key})` : 'foot()'\"\n                :label=\"field.label\"\n                :column=\"field.key\"\n                :field=\"field\"\n                :is-foot=\"true\"\n              >\n                {{ getTableFieldHeadLabel(field) }}\n              </slot>\n            </div>\n          </div>\n        </BTh>\n      </BTr>\n    </BTfoot>\n    <BTfoot v-else-if=\"$slots['custom-foot']\">\n      <slot\n        name=\"custom-foot\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields.length\"\n      />\n    </BTfoot>\n    <caption v-if=\"$slots['table-caption'] || caption\">\n      <slot name=\"table-caption\">\n        {{ caption }}\n      </slot>\n    </caption>\n  </BTableSimple>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {BTableLiteProps, TableField, TableFieldObject, TableItem} from '../../types'\nimport type {TableFieldObjectFormatter} from '../../types/TableFieldObject'\nimport {filterEvent, get, getTableFieldHeadLabel, startCase} from '../../utils'\nimport BTableSimple from './BTableSimple.vue'\nimport BTbody from './BTbody.vue'\nimport BTd from './BTd.vue'\nimport BTfoot from './BTfoot.vue'\nimport BTh from './BTh.vue'\nimport BThead from './BThead.vue'\nimport BTr from './BTr.vue'\n\nconst props = withDefaults(defineProps<BTableLiteProps>(), {\n  caption: undefined,\n  align: undefined,\n  fields: () => [],\n  footClone: false,\n  items: () => [],\n  labelStacked: false,\n  showEmpty: false,\n  emptyText: 'There are no records to show',\n  emptyFilteredText: 'There are no records matching your request', // TODO not implemented\n  fieldColumnClass: undefined,\n  tbodyTrClass: undefined,\n  captionHtml: undefined,\n  detailsTdClass: undefined,\n  headVariant: undefined,\n  headRowVariant: undefined,\n  footRowVariant: undefined,\n  footVariant: undefined,\n  modelValue: undefined,\n  primaryKey: undefined,\n  tbodyClass: undefined,\n  tbodyTrAttr: undefined,\n  tfootClass: undefined,\n  tfootTrClass: undefined,\n  theadClass: undefined,\n  theadTrClass: undefined,\n  // BTableSimpleProps props\n  borderVariant: undefined,\n  tableClass: undefined,\n  variant: undefined,\n  bordered: undefined,\n  borderless: undefined,\n  captionTop: undefined,\n  dark: undefined,\n  hover: undefined,\n  id: undefined,\n  noBorderCollapse: undefined,\n  outlined: undefined,\n  fixed: undefined,\n  responsive: undefined,\n  stacked: undefined,\n  striped: undefined,\n  stripedColumns: undefined,\n  small: undefined,\n  stickyHeader: undefined,\n  // End BTableSimpleProps props\n})\n\nconst emit = defineEmits<{\n  'head-clicked': [\n    key: TableFieldObject['key'],\n    field: TableField,\n    event: MouseEvent,\n    isFooter: boolean,\n  ]\n  'row-clicked': [item: TableItem, index: number, event: MouseEvent]\n  'row-dbl-clicked': [item: TableItem, index: number, event: MouseEvent]\n  'row-hovered': [item: TableItem, index: number, event: MouseEvent]\n  'row-unhovered': [item: TableItem, index: number, event: MouseEvent]\n}>()\n\nconst footCloneBoolean = useBooleanish(() => props.footClone)\nconst labelStackedBoolean = useBooleanish(() => props.labelStacked)\nconst showEmptyBoolean = useBooleanish(() => props.showEmpty)\nconst computedStacked = useBooleanish(() => props.stacked)\n\nconst computedTableClasses = computed(() => [\n  props.tableClass,\n  {\n    [`align-${props.align}`]: props.align !== undefined,\n  },\n])\n\nconst computedFields = computed<TableFieldObject[]>(() => {\n  if (!props.fields.length && props.items.length) {\n    return Object.keys(props.items[0]).map((k) => {\n      const label = startCase(k)\n      return {\n        key: k,\n        label,\n        tdAttr: computedStacked.value === true ? {'data-label': label} : undefined,\n      }\n    })\n  }\n\n  return props.fields.map((f) => {\n    if (typeof f === 'string') {\n      const label = startCase(f)\n      return {\n        key: f,\n        label,\n        tdAttr: computedStacked.value === true ? {'data-label': label} : undefined,\n      }\n    }\n    return {\n      ...f,\n      tdAttr:\n        computedStacked.value === true ? {'data-label': startCase(f.key), ...f.tdAttr} : f.tdAttr,\n    }\n    // TODO handle Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n  })\n})\nconst computedFieldsTotal = toRef(() => computedFields.value.length)\n\nconst formatItem = (\n  item: TableItem,\n  fieldKey: string,\n  formatter?: TableFieldObjectFormatter<typeof item>\n) => {\n  const val = get(item, fieldKey)\n  return formatter && typeof formatter === 'function' ? formatter(val, fieldKey, item) : val\n}\n\nconst headerClicked = (field: TableField, event: MouseEvent, isFooter = false) => {\n  const fieldKey = typeof field === 'string' ? field : field.key\n  emit('head-clicked', fieldKey, field, event, isFooter)\n}\n\nconst toggleRowDetails = (tr: TableItem) => {\n  tr._showDetails = !tr._showDetails\n}\n\nconst getFieldColumnClasses = (field: TableFieldObject) => [\n  field.class,\n  field.thClass,\n  {\n    'b-table-sticky-column': field.stickyColumn,\n  },\n  props.fieldColumnClass\n    ? typeof props.fieldColumnClass === 'function'\n      ? props.fieldColumnClass(field)\n      : props.fieldColumnClass\n    : null,\n]\n\nconst getFieldRowClasses = (field: TableFieldObject, tr: TableItem) => [\n  field.class,\n  field.tdClass,\n  tr._cellVariants?.[field.key] ? `table-${tr._cellVariants[field.key]}` : null,\n  {\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getRowClasses = (item: TableItem, type: 'row-details' | 'row') =>\n  props.tbodyTrClass\n    ? typeof props.tbodyTrClass === 'function'\n      ? props.tbodyTrClass(item, type)\n      : props.tbodyTrClass\n    : null\n</script>\n","<template>\n  <BTableLite\n    v-bind=\"props\"\n    :aria-busy=\"busyBoolean\"\n    :items=\"computedDisplayItems\"\n    :fields=\"computedFields\"\n    :table-class=\"tableClasses\"\n    :tbody-tr-class=\"getRowClasses\"\n    :field-column-class=\"getFieldColumnClasses\"\n    @head-clicked=\"onFieldHeadClick\"\n    @row-clicked=\"onRowClick\"\n  >\n    <template v-for=\"(_, name) in $slots\" #[name]=\"slotData\">\n      <slot :name=\"name\" v-bind=\"slotData\" />\n    </template>\n    <template #head()=\"scope\">\n      {{ getTableFieldHeadLabel(scope.field) }}\n      <template v-if=\"isSortable && scope.field.sortable && noSortableIconBoolean === false\">\n        <slot v-if=\"!sortDescBoolean\" v-bind=\"{...scope}\" name=\"sortAsc\">\n          <svg\n            :style=\"getIconStyle(scope.field)\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"16\"\n            height=\"16\"\n            fill=\"currentColor\"\n            class=\"bi bi-arrow-up-short\"\n            viewBox=\"0 0 16 16\"\n            aria-hidden\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z\"\n            />\n          </svg>\n        </slot>\n        <slot v-else v-bind=\"{...scope}\" name=\"sortDesc\">\n          <svg\n            :style=\"getIconStyle(scope.field)\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n            width=\"16\"\n            height=\"16\"\n            fill=\"currentColor\"\n            class=\"bi bi-arrow-down-short\"\n            viewBox=\"0 0 16 16\"\n            aria-hidden\n          >\n            <path\n              fill-rule=\"evenodd\"\n              d=\"M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z\"\n            />\n          </svg>\n        </slot>\n      </template>\n    </template>\n    <template #custom-body=\"scope\">\n      <BTr v-if=\"busyBoolean\" class=\"b-table-busy-slot\" :class=\"getBusyRowClasses\">\n        <BTd :colspan=\"scope.fields.length\">\n          <slot name=\"table-busy\">\n            <BOverlay show>\n              <template #overlay>\n                <div class=\"d-flex align-items-center gap-2 mt-5\">\n                  <BSpinner />\n                  <strong>{{ busyLoadingText }}</strong>\n                </div>\n              </template>\n            </BOverlay>\n          </slot>\n        </BTd>\n      </BTr>\n    </template>\n  </BTableLite>\n</template>\n\n<script setup lang=\"ts\">\nimport {useToNumber, useVModel} from '@vueuse/core'\nimport {computed, onMounted, ref, type StyleValue, toRef, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {\n  Booleanish,\n  BTableLiteProps,\n  BTableProvider,\n  BTableSortCompare,\n  ColorVariant,\n  LiteralUnion,\n  TableField,\n  TableFieldObject,\n  TableItem,\n} from '../../types'\nimport BSpinner from '../BSpinner.vue'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BTableLite from './BTableLite.vue'\nimport BTd from './BTd.vue'\nimport BTr from './BTr.vue'\nimport {getTableFieldHeadLabel} from '../../utils'\n\ntype NoProviderTypes = 'paging' | 'sorting' | 'filtering'\n\n// TODO sort props list alphabetically when everything is done\nconst props = withDefaults(\n  defineProps<\n    {\n      provider?: BTableProvider\n      sortCompare?: BTableSortCompare\n      noProvider?: NoProviderTypes[]\n      noProviderPaging?: Booleanish\n      noProviderSorting?: Booleanish\n      noProviderFiltering?: Booleanish\n      sortBy?: string\n      sortDesc?: Booleanish\n      selectable?: Booleanish\n      stickySelect?: Booleanish\n      selectHead?: boolean | string\n      selectMode?: 'multi' | 'single' | 'range'\n      selectionVariant?: ColorVariant | null\n      busy?: Booleanish\n      busyLoadingText?: string\n      perPage?: number | string\n      currentPage?: number | string\n      filter?: string\n      filterable?: string[]\n      // TODO\n      // apiUrl?: string\n      // filterFunction?: () => any\n      // filterIgnoredFields?: any[]\n      // filterIncludedFields?: any[]\n      // headRowVariant?: ColorVariant | null\n      // headVariant?: ColorVariant | null\n      // labelSortAsc?: string\n      // labelSortClear?: string\n      // labelSortDesc?: string\n      // noFooterSorting?: Booleanish\n      // noLocalSorting?: Booleanish\n      // noSelectOnClick?: Booleanish\n      // noSortReset?: Booleanish\n      // selectedVariant?: ColorVariant | null\n      // showEmpty?: Booleanish\n      // sortCompareLocale?: () => any\n      // sortCompareOptions?: Record<string, any> // TODO make this explicit\n      // sortDirection?: 'asc' | 'desc' | 'last'\n      // sortIconLeft?: Booleanish\n      // sortNullLast?: Booleanish\n      selectedItems?: TableItem[]\n      noSortableIcon?: Booleanish\n    } & Omit<BTableLiteProps, 'tableClass'>\n  >(),\n  {\n    noSortableIcon: false,\n    perPage: Infinity,\n    sortBy: undefined,\n    filter: undefined,\n    filterable: undefined,\n    provider: undefined,\n    sortCompare: undefined,\n    noProvider: undefined,\n    noProviderPaging: false,\n    noProviderSorting: false,\n    noProviderFiltering: false,\n    sortDesc: false,\n    selectable: false,\n    stickySelect: false,\n    selectHead: true,\n    selectMode: 'multi',\n    selectionVariant: 'primary',\n    busy: false,\n    busyLoadingText: 'Loading...',\n    currentPage: 1,\n    selectedItems: () => [],\n    // BTableLite props\n    items: () => [],\n    fields: () => [],\n    // All others use defaults\n    caption: undefined,\n    align: undefined,\n    footClone: undefined,\n    labelStacked: undefined,\n    showEmpty: undefined,\n    emptyText: undefined,\n    emptyFilteredText: undefined,\n    fieldColumnClass: undefined,\n    tbodyTrClass: undefined,\n    captionHtml: undefined,\n    detailsTdClass: undefined,\n    headVariant: undefined,\n    headRowVariant: undefined,\n    footRowVariant: undefined,\n    footVariant: undefined,\n    modelValue: undefined,\n    primaryKey: undefined,\n    tbodyClass: undefined,\n    tbodyTrAttr: undefined,\n    tfootClass: undefined,\n    tfootTrClass: undefined,\n    theadClass: undefined,\n    theadTrClass: undefined,\n    // End BTableLite props\n    // BTableSimple props\n    borderVariant: undefined,\n    variant: undefined,\n    bordered: undefined,\n    borderless: undefined,\n    captionTop: undefined,\n    dark: undefined,\n    hover: undefined,\n    id: undefined,\n    noBorderCollapse: undefined,\n    outlined: undefined,\n    fixed: undefined,\n    responsive: undefined,\n    stacked: undefined,\n    striped: undefined,\n    stripedColumns: undefined,\n    small: undefined,\n    stickyHeader: undefined,\n    // End BTableSimple props\n  }\n)\n\nconst emit = defineEmits<{\n  'filtered': [value: TableItem[]]\n  'head-clicked': [\n    key: TableFieldObject['key'],\n    field: TableField,\n    event: MouseEvent,\n    isFooter: boolean,\n  ]\n  'row-clicked': [item: TableItem, index: number, event: MouseEvent]\n  'row-dbl-clicked': [item: TableItem, index: number, event: MouseEvent]\n  'row-hovered': [item: TableItem, index: number, event: MouseEvent]\n  'row-selected': [value: TableItem]\n  'row-unhovered': [item: TableItem, index: number, event: MouseEvent]\n  'row-unselected': [value: TableItem]\n  'selection': [value: TableItem[]]\n  'sorted': [sortBy: string, isDesc: boolean]\n  'update:busy': [value: boolean]\n  'update:selectedItems': [value: TableItem[]]\n  'update:sortDesc': [value: boolean]\n  'update:sortBy': [value: string]\n}>()\n\nconst sortByModel = useVModel(props, 'sortBy', emit, {passive: true})\nconst busyModel = useVModel(props, 'busy', emit, {passive: true})\nconst sortDescModel = useVModel(props, 'sortDesc', emit, {passive: true})\nconst selectedItemsModel = useVModel(props, 'selectedItems', emit, {passive: true})\n\nconst selectedItemsToSet = computed({\n  get: () => new Set([...selectedItemsModel.value]),\n  set: (val) => {\n    selectedItemsModel.value = [...val]\n  },\n})\n/**\n * This is to avoid the issue of directly mutating the array structure and to properly trigger the computed setter.\n * The utils also conveniently emit the proper events after\n */\nconst selectedItemsSetUtilities = {\n  add: (item: TableItem) => {\n    const value = new Set(selectedItemsToSet.value)\n    value.add(item)\n    selectedItemsToSet.value = value\n    emit('row-selected', item)\n  },\n  clear: () => {\n    selectedItemsToSet.value.forEach((item) => {\n      emit('row-unselected', item)\n    })\n    selectedItemsToSet.value = new Set()\n  },\n  delete: (item: TableItem) => {\n    const value = new Set(selectedItemsToSet.value)\n    value.delete(item)\n    selectedItemsToSet.value = value\n    emit('row-unselected', item)\n  },\n  /* TODO\n  This has method and the delete method suffer from an error when using a non-reactive source as the items prop\n  ```ts\n  const items = [{first_name: 'Geneva', last_name: 'Wilson', age: 89},{first_name: 'Jami', last_name: 'Carney', age: 38}]\n  ```\n  For some reason, the reference of the object gets lost. However, when you use an actual ref(), it works just fine\n  Getting the reference properly will fix all outstanding issues\n  */\n  has: (item: TableItem) => selectedItemsToSet.value.has(item),\n} as const\n\n/**\n * Only stores data that is fetched when using the provider\n */\nconst internalItems = ref<TableItem[]>([])\n\nconst sortDescBoolean = useBooleanish(sortDescModel)\nconst busyBoolean = useBooleanish(busyModel)\nconst noProviderPagingBoolean = useBooleanish(() => props.noProviderPaging)\nconst noProviderSortingBoolean = useBooleanish(() => props.noProviderSorting)\nconst noProviderFilteringBoolean = useBooleanish(() => props.noProviderFiltering)\nconst selectableBoolean = useBooleanish(() => props.selectable)\nconst noSortableIconBoolean = useBooleanish(() => props.noSortableIcon)\n\nconst perPageNumber = useToNumber(() => props.perPage, {method: 'parseInt'})\nconst currentPageNumber = useToNumber(() => props.currentPage, {method: 'parseInt'})\n\nconst isFilterableTable = toRef(() => !!props.filter)\nconst usesProvider = toRef(() => props.provider !== undefined)\nconst isSelecting = toRef(() => selectedItemsToSet.value.size > 0)\n\nconst isSortable = computed(\n  () =>\n    sortByModel.value !== undefined ||\n    props.fields.some((field) => (typeof field === 'string' ? false : field.sortable))\n)\n\nconst computedFields = computed<TableField[]>(() =>\n  props.fields.map((el) =>\n    typeof el === 'string'\n      ? el\n      : {\n          ...el,\n          thAttr: {\n            'aria-sort':\n              isSortable.value === false\n                ? undefined\n                : sortByModel.value !== el.key\n                ? 'none'\n                : sortDescBoolean.value === true\n                ? 'descending'\n                : 'ascending',\n            ...el.thAttr,\n          },\n        }\n  )\n)\n\nconst tableClasses = computed(() => ({\n  'b-table-busy': busyBoolean.value,\n  'b-table-selectable': selectableBoolean.value,\n  'user-select-none': selectableBoolean.value && isSelecting.value,\n}))\n// All three of these are similar, even though the two following are not computeds\nconst getBusyRowClasses = computed(() => [\n  props.tbodyTrClass\n    ? typeof props.tbodyTrClass === 'function'\n      ? props.tbodyTrClass(null, 'table-busy')\n      : props.tbodyTrClass\n    : null,\n])\nconst getFieldColumnClasses = (field: TableFieldObject) => [\n  {\n    'b-table-sortable-column': isSortable.value && field.sortable,\n  },\n]\n// TODO this class has issues if the table has a variant already applied\n// Also the row should technically have aria-selected . Both things could probably just use a function with tbodyTrAttrs\n// But functional tbodyTrAttrs are not supported yet\n// Also the stuff for resolving functions could probably be made a util\nconst getRowClasses = (item: TableItem | null, type: string) => [\n  {\n    [`selected table-${props.selectionVariant}`]:\n      selectableBoolean.value && item && selectedItemsSetUtilities.has(item),\n  },\n  props.tbodyTrClass\n    ? typeof props.tbodyTrClass === 'function'\n      ? props.tbodyTrClass(item, type)\n      : props.tbodyTrClass\n    : null,\n]\nconst getIconStyle = (field: TableFieldObject): StyleValue =>\n  sortByModel.value !== field.key ? {opacity: 0.5} : {}\n\nconst computedItems = computed<TableItem[]>(() => {\n  const sortItems = (items: TableItem[]) => {\n    const sortKey = sortByModel.value\n\n    if (sortKey === undefined) {\n      return items\n    }\n\n    const sortField = computedFields.value.find((el) => {\n      if (typeof el === 'string') return false\n      return el.key === sortKey\n    })\n\n    // Explicit field? === false check because undefined means it's sortable. Only strict === means its not sortable (no falsy)\n    if (typeof sortField !== 'string' && sortField?.sortable === false) {\n      return items\n    }\n\n    return [...items].sort((a, b) => {\n      if (props.sortCompare !== undefined)\n        return props.sortCompare(a, b, sortKey, sortDescBoolean.value)\n\n      const realVal = (ob: unknown): string =>\n        typeof ob === 'object' && ob !== null ? JSON.stringify(ob) : ob?.toString() ?? ''\n\n      if (realVal(a[sortKey]) > realVal(b[sortKey])) {\n        return sortDescBoolean.value ? -1 : 1\n      }\n\n      if (realVal(b[sortKey]) > realVal(a[sortKey])) {\n        return sortDescBoolean.value ? 1 : -1\n      }\n\n      return 0\n    })\n  }\n\n  const filterItems = (items: TableItem[]) =>\n    items.filter((item) =>\n      Object.entries(item).some(([key, val]) => {\n        if (!val || key[0] === '_' || !props.filterable?.includes(key)) return false\n        const itemValue: string =\n          typeof val === 'object' ? JSON.stringify(Object.values(val)) : val.toString()\n        return itemValue.toLowerCase().includes(props.filter?.toLowerCase() ?? '')\n      })\n    )\n\n  let mappedItems = usesProvider.value ? internalItems.value : props.items\n\n  if (\n    (isFilterableTable.value === true && !usesProvider.value) ||\n    (isFilterableTable.value === true && usesProvider.value && noProviderFilteringBoolean.value)\n  ) {\n    mappedItems = filterItems(mappedItems)\n  }\n\n  if (\n    (isSortable.value === true && !usesProvider.value) ||\n    (isSortable.value === true && usesProvider.value && noProviderSortingBoolean.value)\n  ) {\n    mappedItems = sortItems(mappedItems)\n  }\n\n  return mappedItems\n})\n\n// The benefit of this is that it doesn't allow you a page out of bounds even if the user does it manually\n// This does not work due to https://github.com/vueuse/vueuse/issues/3542\n// const {currentPage: resolvedCurrentPage, currentPageSize: resolvedCurrentPageSize} =\n//   useOffsetPagination({\n//     total: () => computedItems.value.length,\n//     page: currentPageNumber,\n//     // If its zero, it does all\n//     pageSize: () => perPageNumber.value || Infinity,\n//   })\n\nconst computedDisplayItems = computed<TableItem[]>(() => {\n  if (Number.isNaN(perPageNumber.value) || (usesProvider.value && !noProviderPagingBoolean.value)) {\n    return computedItems.value\n  }\n\n  return computedItems.value.slice(\n    (currentPageNumber.value - 1) * (perPageNumber.value || Infinity),\n    currentPageNumber.value * (perPageNumber.value || Infinity)\n  )\n})\n\nconst handleRowSelection = (\n  row: TableItem,\n  index: number,\n  shiftClicked = false,\n  ctrlClicked = false,\n  metaClicked = false\n) => {\n  if (!selectableBoolean.value) return\n\n  if (props.selectMode === 'single' || props.selectMode === 'multi') {\n    // Do nothing when these items are held\n    if (shiftClicked || ctrlClicked) return\n    // Delete if item is in\n    if (selectedItemsSetUtilities.has(row)) {\n      selectedItemsSetUtilities.delete(row)\n    } else {\n      // If it is single, we clear out everything first\n      if (props.selectMode === 'single') {\n        selectedItemsSetUtilities.clear()\n      }\n      // Then set the item\n      selectedItemsSetUtilities.add(row)\n    }\n  } else {\n    if (ctrlClicked || metaClicked) {\n      // Delete if in the object\n      if (selectedItemsSetUtilities.has(row)) {\n        selectedItemsSetUtilities.delete(row)\n        // Otherwise add. Functions similarly to 'multi' at this point\n      } else {\n        selectedItemsSetUtilities.add(row)\n      }\n      // This is where range is different, due to the difference in shift\n    } else if (shiftClicked) {\n      const lastSelectedItem = [...selectedItemsToSet.value].pop()\n      const lastSelectedIndex = props.items.findIndex((i) => i === lastSelectedItem)\n      const selectStartIndex = Math.min(lastSelectedIndex, index)\n      const selectEndIndex = Math.max(lastSelectedIndex, index)\n      props.items.slice(selectStartIndex, selectEndIndex + 1).forEach((item) => {\n        if (!selectedItemsSetUtilities.has(item)) {\n          selectedItemsSetUtilities.add(item)\n        }\n      })\n      // If nothing is being held, then we just behave like it's single mode\n    } else {\n      selectedItemsSetUtilities.clear()\n      selectedItemsSetUtilities.add(row)\n    }\n  }\n  // Notify\n  notifySelectionEvent()\n}\n\nconst onRowClick = (row: TableItem, index: number, e: MouseEvent) => {\n  handleRowSelection(row, index, e.shiftKey, e.ctrlKey, e.metaKey)\n  emit('row-clicked', row, index, e)\n}\n\nconst handleFieldSorting = (field: TableField) => {\n  if (!isSortable.value) return\n\n  const fieldKey = typeof field === 'string' ? field : field.key\n  const fieldSortable = typeof field === 'string' ? false : field.sortable\n\n  if (!(isSortable.value === true && fieldSortable === true)) return\n\n  if (sortByModel.value !== fieldKey) {\n    sortByModel.value = fieldKey\n    sortDescModel.value = false\n  } else {\n    if (sortDescBoolean.value === false) {\n      sortDescModel.value = true\n    } else {\n      sortByModel.value = undefined\n      sortDescModel.value = false\n    }\n  }\n  emit('sorted', fieldKey, sortByModel.value === undefined ? false : !sortDescBoolean.value)\n}\n\nconst onFieldHeadClick = (\n  fieldKey: LiteralUnion<string>,\n  field: TableField,\n  event: MouseEvent,\n  isFooter = false\n) => {\n  emit('head-clicked', fieldKey, field, event, isFooter)\n  handleFieldSorting(field)\n}\n\nconst callItemsProvider = async () => {\n  if (!usesProvider.value || props.provider === undefined || busyBoolean.value) return\n  busyModel.value = true\n  const response = props.provider({\n    currentPage: currentPageNumber.value,\n    filter: props.filter,\n    sortBy: sortByModel.value,\n    sortDesc: props.sortDesc,\n    perPage: perPageNumber.value,\n  })\n  try {\n    const items = response instanceof Promise ? await response : response\n\n    if (items === undefined) return\n    internalItems.value = items\n  } finally {\n    busyModel.value = false\n  }\n}\n\nconst notifySelectionEvent = () => {\n  if (!selectableBoolean.value) return\n  emit('selection', [...selectedItemsToSet.value])\n}\nconst notifyFilteredItems = async () => {\n  if (usesProvider.value) {\n    await callItemsProvider()\n    return\n  }\n  emit('filtered', computedItems.value)\n}\n\nconst providerPropsWatch = async (prop: string, val: unknown, oldVal: unknown) => {\n  if (val === oldVal) return\n\n  //stop provide when paging\n  const inNoProvider = (key: NoProviderTypes) => props.noProvider?.includes(key) === true\n  const noProvideWhenPaging =\n    (prop === 'currentPage' || prop === 'perPage') &&\n    (inNoProvider('paging') || noProviderPagingBoolean.value === true)\n  const noProvideWhenFiltering =\n    prop === 'filter' && (inNoProvider('filtering') || noProviderFilteringBoolean.value === true)\n  const noProvideWhenSorting =\n    (prop === 'sortBy' || prop === 'sortDesc') &&\n    (inNoProvider('sorting') || noProviderSortingBoolean.value === true)\n\n  if (noProvideWhenPaging || noProvideWhenFiltering || noProvideWhenSorting) return\n\n  await callItemsProvider()\n\n  if (!(prop === 'currentPage' || prop === 'perPage')) notifyFilteredItems()\n}\n\nwatch(\n  () => props.filter,\n  (filter, oldFilter) => {\n    providerPropsWatch('filter', filter, oldFilter)\n\n    if (filter === oldFilter || usesProvider.value) return\n    if (!filter) {\n      emit('filtered', computedItems.value)\n    }\n  }\n)\nwatch(currentPageNumber, (val, oldVal) => {\n  providerPropsWatch('currentPage', val, oldVal)\n})\nwatch(perPageNumber, (val, oldVal) => {\n  providerPropsWatch('perPage', val, oldVal)\n})\nwatch(sortByModel, (val, oldVal) => {\n  providerPropsWatch('sortBy', val, oldVal)\n})\nwatch(sortDescBoolean, (val, oldVal) => {\n  providerPropsWatch('sortDesc', val, oldVal)\n})\n\nwatch(\n  () => props.provider,\n  (newValue) => {\n    // Reset the internal values if the provider stops getting used\n    if (newValue === undefined) {\n      internalItems.value = []\n      return\n    }\n    // Otherwise we should refresh the table on such a change\n    callItemsProvider()\n  }\n)\n\nonMounted(callItemsProvider)\n\ndefineExpose({\n  // The row selection methods are really for compat. Users should probably use the v-model though\n  clearSelected: () => {\n    if (!selectableBoolean.value) return\n    selectedItemsSetUtilities.clear()\n    notifySelectionEvent()\n  },\n  refresh: callItemsProvider,\n  selectAllRows: () => {\n    if (!selectableBoolean.value) return\n    const unselectableItems = selectedItemsToSet.value.size > 0 ? [...selectedItemsToSet.value] : []\n    selectedItemsToSet.value = new Set([...computedItems.value])\n    selectedItemsToSet.value.forEach((item) => {\n      if (unselectableItems.includes(item)) return\n      emit('row-selected', item)\n    })\n    notifySelectionEvent()\n  },\n  selectRow: (index: number) => {\n    if (!selectableBoolean.value) return\n    const item = computedItems.value[index]\n    if (!item || selectedItemsSetUtilities.has(item)) return\n    selectedItemsSetUtilities.add(item)\n    notifySelectionEvent()\n  },\n  unselectRow: (index: number) => {\n    if (!selectableBoolean.value) return\n    const item = computedItems.value[index]\n    if (!item || !selectedItemsSetUtilities.has(item)) return\n    selectedItemsSetUtilities.delete(item)\n    notifySelectionEvent()\n  },\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    ref=\"el\"\n    class=\"tab-pane\"\n    :class=\"computedClasses\"\n    role=\"tabpanel\"\n    :aria-labelledby=\"buttonId\"\n    v-bind=\"attrs\"\n  >\n    <slot v-if=\"showSlot\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, inject, onMounted, onUnmounted, ref, toRef, useAttrs, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ClassValue, TabType} from '../../types'\nimport {tabsInjectionKey} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    active?: Booleanish\n    buttonId?: string\n    disabled?: Booleanish\n    id?: string\n    lazy?: Booleanish\n    lazyOnce?: Booleanish\n    noBody?: Booleanish\n    tag?: string\n    title?: string\n    titleItemClass?: ClassValue\n    titleLinkAttributes?: Record<string, unknown>\n    titleLinkClass?: ClassValue\n  }>(),\n  {\n    active: false,\n    buttonId: undefined,\n    disabled: false,\n    id: undefined,\n    lazy: undefined,\n    lazyOnce: undefined,\n    noBody: false,\n    tag: 'div',\n    title: undefined,\n    titleItemClass: undefined,\n    titleLinkAttributes: undefined,\n    titleLinkClass: undefined,\n  }\n)\n\nconst slots = defineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  default?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  title?: (props: Record<string, never>) => any\n}>()\n\nconst emit = defineEmits<{\n  'update:active': [value: boolean]\n}>()\n\ndefineOptions({\n  inheritAttrs: false,\n})\n\nconst parentData = inject(tabsInjectionKey, null)\nconst computedId = useId(() => props.id, 'tabpane')\nconst buttonId = useId(() => props.buttonId, 'tab')\n\nconst activeBoolean = useBooleanish(() => props.active)\nconst disabledBoolean = useBooleanish(() => props.disabled)\nconst lazyBoolean = useBooleanish(() => props.lazyOnce ?? props.lazy)\nconst noBodyBoolean = useBooleanish(() => props.noBody)\n\nconst lazyRenderCompleted = ref(false)\nconst el = ref<HTMLElement | null>(null)\n\nconst {onClick, ...attrs} = useAttrs()\n\nconst tab = computed(\n  () =>\n    ({\n      id: computedId.value,\n      buttonId: buttonId.value,\n      disabled: disabledBoolean.value,\n      title: props.title,\n      titleComponent: slots.title,\n      titleItemClass: props.titleItemClass,\n      titleLinkAttributes: props.titleLinkAttributes,\n      titleLinkClass: props.titleLinkClass,\n      onClick,\n      el: el.value,\n    }) as TabType\n)\n\nonMounted(() => {\n  if (!parentData) return\n  parentData.registerTab(tab)\n  if (activeBoolean.value) {\n    parentData.activateTab(computedId.value)\n  }\n})\n\nonUnmounted(() => {\n  if (!parentData) return\n  parentData.unregisterTab(computedId.value)\n})\n\nconst isActive = toRef(() => parentData?.activeId.value === computedId.value)\nconst show = ref(isActive.value)\n\nconst computedLazy = toRef(() => !!(parentData?.lazy.value || lazyBoolean.value))\nconst computedLazyOnce = toRef(() => props.lazyOnce !== undefined)\n\nconst computedActive = toRef(() => isActive.value && !disabledBoolean.value)\nconst showSlot = toRef(\n  () =>\n    computedActive.value ||\n    !computedLazy.value ||\n    (computedLazy.value && computedLazyOnce.value && lazyRenderCompleted.value)\n)\n\nwatch(isActive, (active) => {\n  if (active) {\n    emit('update:active', true)\n    setTimeout(() => {\n      show.value = true\n    }, 0)\n    return\n  }\n  show.value = false\n  emit('update:active', false)\n})\nwatch(activeBoolean, (active) => {\n  if (!parentData) return\n  if (!active) {\n    if (isActive.value) {\n      parentData.activateTab(undefined)\n    }\n    return\n  }\n  parentData.activateTab(computedId.value)\n})\n\nconst computedClasses = computed(() => [\n  {\n    'active': isActive.value,\n    'show': show.value,\n    'card-body': parentData?.card.value && noBodyBoolean.value === false,\n    'fade': !parentData?.noFade.value,\n  },\n  show.value && parentData?.activeTabClass ? parentData.activeTabClass : null,\n])\n\nwatch(showSlot, (shown) => {\n  if (shown && !lazyRenderCompleted.value) lazyRenderCompleted.value = true\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"tabs\" :class=\"computedClasses\">\n    <div v-if=\"endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <slot />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n    <div\n      :class=\"[navWrapperClass, {'card-header': cardBoolean, 'ms-auto': vertical && endBoolean}]\"\n    >\n      <ul\n        class=\"nav\"\n        :class=\"[navTabsClasses, navClass]\"\n        role=\"tablist\"\n        :aria-orientation=\"vertical ? 'vertical' : 'horizontal'\"\n      >\n        <slot name=\"tabs-start\" />\n        <li\n          v-for=\"(tab, idx) in tabs\"\n          :key=\"tab.id\"\n          class=\"nav-item\"\n          :class=\"tab.titleItemClass\"\n          role=\"presentation\"\n        >\n          <button\n            :id=\"tab.buttonId\"\n            class=\"nav-link\"\n            :class=\"tab.navItemClasses\"\n            role=\"tab\"\n            :aria-controls=\"tab.id\"\n            :aria-selected=\"tab.active\"\n            v-bind=\"tab.titleLinkAttributes\"\n            @keydown.left.stop.prevent=\"keynav(-1)\"\n            @keydown.right.stop.prevent=\"keynav(1)\"\n            @keydown.page-up.stop.prevent=\"keynav(-999)\"\n            @keydown.page-down.stop.prevent=\"keynav(999)\"\n            @click.stop.prevent=\"(e) => handleClick(e, idx)\"\n          >\n            <component :is=\"tab.titleComponent\" v-if=\"tab.titleComponent\" />\n            <template v-else>\n              {{ tab.title }}\n            </template>\n          </button>\n        </li>\n        <slot name=\"tabs-end\" />\n      </ul>\n    </div>\n    <!-- Tab Content Below Tabs-->\n    <div v-if=\"!endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <slot />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, nextTick, provide, type Ref, ref, toRef, unref, watch} from 'vue'\nimport {BvEvent, tabsInjectionKey} from '../../utils'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport type {AlignmentJustifyContent, Booleanish, ClassValue, TabType} from '../../types'\nimport {useVModel} from '@vueuse/core'\n// TODO this component needs a desperate refactoring to use provide/inject and not the complicated slot manipulation logic it's doing now\n\nconst props = withDefaults(\n  defineProps<{\n    activeId?: string\n    activeNavItemClass?: ClassValue\n    activeTabClass?: ClassValue\n    align?: AlignmentJustifyContent\n    card?: Booleanish\n    contentClass?: ClassValue\n    end?: Booleanish\n    fill?: Booleanish\n    id?: string\n    justified?: Booleanish\n    lazy?: Booleanish\n    modelValue?: number\n    navClass?: ClassValue\n    navWrapperClass?: ClassValue\n    noFade?: Booleanish\n    // noKeyNav?: Booleanish,\n    noNavStyle?: Booleanish\n    pills?: Booleanish\n    small?: Booleanish\n    tag?: string\n    vertical?: Booleanish\n  }>(),\n  {\n    activeId: undefined,\n    activeNavItemClass: undefined,\n    activeTabClass: undefined,\n    align: undefined,\n    card: false,\n    contentClass: undefined,\n    end: false,\n    fill: false,\n    id: undefined,\n    justified: false,\n    lazy: false,\n    modelValue: -1,\n    navClass: undefined,\n    navWrapperClass: undefined,\n    noFade: false,\n    // noKeyNav: false,\n    noNavStyle: false,\n    pills: false,\n    small: false,\n    tag: 'div',\n    vertical: false,\n  }\n)\n\nconst emit = defineEmits<{\n  'activate-tab': [v1: number, v2: number, v3: BvEvent]\n  'click': [] // TODO click event is never used\n  'update:activeId': [value: string]\n  'update:modelValue': [value: number]\n}>()\n\ndefineSlots<{\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'default'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'empty'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tabs-end'?: (props: Record<string, never>) => any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  'tabs-start'?: (props: Record<string, never>) => any\n}>()\n\nconst modelValue = useVModel(props, 'modelValue', emit, {passive: true})\nconst activeId = useVModel(props, 'activeId', emit, {passive: true})\n\nconst cardBoolean = useBooleanish(() => props.card)\nconst endBoolean = useBooleanish(() => props.end)\nconst fillBoolean = useBooleanish(() => props.fill)\nconst justifiedBoolean = useBooleanish(() => props.justified)\nconst lazyBoolean = useBooleanish(() => props.lazy)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst noNavStyleBoolean = useBooleanish(() => props.noNavStyle)\nconst pillsBoolean = useBooleanish(() => props.pills)\nconst smallBoolean = useBooleanish(() => props.small)\nconst verticalBoolean = useBooleanish(() => props.vertical)\n\nconst tabsInternal = ref<Ref<TabType>[]>([])\n\nconst tabs = computed(() =>\n  tabsInternal.value.map((_tab) => {\n    const tab = unref(_tab)\n    const active = tab.id === activeId.value\n\n    return {\n      ...tab,\n      active,\n      navItemClasses: [\n        {\n          active,\n          disabled: tab.disabled,\n        },\n        active && props.activeNavItemClass ? props.activeNavItemClass : null,\n        tab.titleLinkClass,\n      ],\n    }\n  })\n)\n\nconst showEmpty = toRef(() => !(tabs?.value && tabs.value.length > 0))\n\nconst computedClasses = computed(() => ({\n  'd-flex': verticalBoolean.value,\n  'align-items-start': verticalBoolean.value,\n}))\n\nconst alignment = useAlignment(() => props.align)\n\nconst navTabsClasses = computed(() => ({\n  'nav-pills': pillsBoolean.value,\n  'flex-column me-3': verticalBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'nav-fill': fillBoolean.value,\n  'card-header-tabs': cardBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  'nav-tabs': !noNavStyleBoolean.value && !pillsBoolean.value,\n  'small': smallBoolean.value,\n}))\n\nconst activateTab = (index: number): void => {\n  if (index !== undefined) {\n    const id = tabs.value[index]?.id\n    if (\n      index > -1 &&\n      index < tabs.value.length &&\n      !tabs.value[index].disabled &&\n      (modelValue.value < 0 || activeId.value !== id || modelValue.value !== index)\n    ) {\n      const tabEvent = new BvEvent('activate-tab', {cancelable: true})\n      emit('activate-tab', index, modelValue.value, tabEvent)\n      if (!tabEvent.defaultPrevented) {\n        if (activeId.value !== id) activeId.value = id\n        if (modelValue.value !== index) modelValue.value = index\n      }\n    }\n  }\n}\n\nconst handleClick = (event: MouseEvent, index: number) => {\n  activateTab(index)\n  if (\n    index >= 0 &&\n    !tabs.value[index].disabled &&\n    tabs.value[index]?.onClick &&\n    typeof tabs.value[index].onClick === 'function'\n  ) {\n    tabs.value[index].onClick?.(event)\n  }\n}\n\nconst keynav = (direction: number) => {\n  if (tabs.value.length <= 0) return\n  modelValue.value = nextIndex(modelValue.value + direction, direction)\n  document.getElementById(tabs.value[modelValue.value]?.buttonId)?.focus()\n}\n\nconst nextIndex = (start: number, direction: number) => {\n  if (tabs.value.length <= 0) return -1\n  let index = start\n  const maxIdx = tabs.value.map((tab) => !tab.disabled).lastIndexOf(true)\n  const minIdx = tabs.value.map((tab) => !tab.disabled).indexOf(true)\n  while (index >= minIdx && index <= maxIdx && tabs.value[index].disabled) {\n    index += direction\n  }\n  if (index < minIdx) index = minIdx\n  if (index >= maxIdx) index = maxIdx\n  return index\n}\n\nwatch(modelValue, (newValue, oldValue) => {\n  if (newValue === oldValue) return\n  if (tabs.value.length <= 0) {\n    return\n  }\n\n  const index = nextIndex(newValue, newValue > oldValue ? 1 : -1)\n  nextTick(() => {\n    activateTab(index)\n  })\n})\n\nwatch(activeId, (newValue, oldValue) => {\n  const index = tabs.value.findIndex((t) => t.id === newValue)\n  if (newValue === oldValue) return\n  if (tabs.value.length <= 0) {\n    return\n  }\n  if (index === -1) {\n    activateTab(nextIndex(0, 1))\n    return\n  }\n  activateTab(index)\n})\n\nconst registerTab = (tab: Ref<TabType>) => {\n  if (!tabsInternal.value.find((t) => t.value.id === tab.value.id)) {\n    tabsInternal.value.push(tab)\n  } else {\n    tabsInternal.value[tabsInternal.value.findIndex((t) => t.value.id === tab.value.id)] = tab\n  }\n  tabsInternal.value = tabsInternal.value.sort((a, b) => {\n    if (!Node || !a.value.el || !b.value.el) return 0\n    const position = a.value.el.compareDocumentPosition(b.value.el)\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) return -1\n    if (position & Node.DOCUMENT_POSITION_PRECEDING) return 1\n    return 0\n  })\n}\nconst unregisterTab = (id: string) => {\n  if (tabsInternal.value.find((t) => t.value.id === id)) {\n    tabsInternal.value.splice(\n      tabsInternal.value.findIndex((t) => t.value.id === id),\n      1\n    )\n  }\n}\n\nwatch(\n  tabsInternal,\n  () => {\n    findActive()\n  },\n  {deep: true}\n)\n\nconst findActive = () => {\n  if (tabs.value.length === 0) {\n    modelValue.value = -1\n    activeId.value = undefined\n    return\n  }\n  if (modelValue.value >= 0 && !activeId.value) {\n    activeId.value = tabs.value[modelValue.value]?.id\n  }\n  if (tabs.value.find((t) => t.id === activeId.value)) {\n    activateTab(tabs.value.findIndex((t) => t.id === activeId.value))\n    return\n  }\n  activateTab(tabs.value.map((tab) => !tab.disabled).indexOf(true))\n}\n\nprovide(tabsInjectionKey, {\n  lazy: lazyBoolean,\n  card: cardBoolean,\n  noFade: noFadeBoolean,\n  activeTabClass: toRef(() => props.activeTabClass),\n  registerTab,\n  unregisterTab,\n  activeId,\n  activateTab: (id) => {\n    const idx = tabs.value.findIndex((t) => t.id === id)\n    if (id === undefined || idx === -1) {\n      activateTab(nextIndex(0, 1))\n      return\n    }\n    activateTab(idx)\n  },\n})\n</script>\n","<template>\n  <BTransition :no-fade=\"noFadeBoolean\">\n    <div\n      v-if=\"isToastVisible\"\n      :id=\"id\"\n      ref=\"element\"\n      class=\"toast\"\n      :class=\"[toastClass, computedClasses]\"\n      tabindex=\"0\"\n      :role=\"!isToastVisible ? undefined : isStatusBoolean ? 'status' : 'alert'\"\n      :aria-live=\"!isToastVisible ? undefined : isStatusBoolean ? 'polite' : 'assertive'\"\n      :aria-atomic=\"!isToastVisible ? undefined : true\"\n    >\n      <component :is=\"headerTag\" v-if=\"$slots.title || title\" class=\"toast-header\">\n        <slot name=\"title\" :hide=\"hide\">\n          <strong class=\"me-auto\">\n            {{ title }}\n          </strong>\n        </slot>\n        <BCloseButton v-if=\"!noCloseButtonBoolean\" @click=\"hide\" />\n      </component>\n      <template v-if=\"$slots.default || body\">\n        <component\n          :is=\"computedTag\"\n          class=\"toast-body\"\n          style=\"display: block\"\n          :class=\"bodyClass\"\n          v-bind=\"computedLinkProps\"\n          @click=\"computedLink ? hide : () => {}\"\n        >\n          <slot :hide=\"hide\">\n            {{ body }}\n          </slot>\n        </component>\n      </template>\n      <BProgress\n        v-if=\"typeof modelValue === 'number' && progressProps !== undefined\"\n        :animated=\"progressProps.animated\"\n        :precision=\"progressProps.precision\"\n        :show-progress=\"progressProps.showProgress\"\n        :show-value=\"progressProps.showValue\"\n        :striped=\"progressProps.striped\"\n        :variant=\"progressProps.variant\"\n        :max=\"modelValue\"\n        :value=\"remainingMs\"\n        height=\"4px\"\n      />\n    </div>\n  </BTransition>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, onBeforeUnmount, ref, toRef, watch, watchEffect} from 'vue'\nimport {\n  useBLinkHelper,\n  useBooleanish,\n  useColorVariantClasses,\n  useCountdown,\n} from '../../composables'\nimport type {BToastProps} from '../../types'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BLink from '../BLink/BLink.vue'\nimport {useElementHover, useToNumber, useVModel} from '@vueuse/core'\nimport BProgress from '../BProgress/BProgress.vue'\n\n// TODO scheduling issue -- when multiple are opened in quick succession, and closed in quick succession,\n// Find index can get lost, leading to one or multiple staying orphaned\n// TODO appendToast from BToaster\n\nconst props = withDefaults(defineProps<BToastProps>(), {\n  animation: true,\n  autoHide: true,\n  bgVariant: null,\n  body: undefined,\n  bodyClass: undefined,\n  delay: 5000,\n  headerClass: undefined,\n  headerTag: 'div',\n  id: undefined,\n  interval: 1000,\n  isStatus: false,\n  modelValue: false,\n  noCloseButton: false,\n  noFade: false,\n  noHoverPause: false,\n  progressProps: undefined,\n  showOnPause: true,\n  solid: false,\n  textVariant: null,\n  title: undefined,\n  toastClass: undefined,\n  // Link props\n  // All others use defaults\n  active: undefined,\n  activeClass: undefined,\n  append: undefined,\n  disabled: undefined,\n  exactActiveClass: undefined,\n  href: undefined,\n  icon: undefined,\n  opacity: undefined,\n  opacityHover: undefined,\n  rel: undefined,\n  replace: undefined,\n  routerComponentName: undefined,\n  target: undefined,\n  to: undefined,\n  underlineOffset: undefined,\n  underlineOffsetHover: undefined,\n  underlineOpacity: undefined,\n  underlineOpacityHover: undefined,\n  underlineVariant: undefined,\n  variant: undefined,\n  // End link props\n})\n\nconst emit = defineEmits<{\n  'close': []\n  'close-countdown': [value: number]\n  'closed': []\n  'destroyed': []\n  'update:modelValue': [value: boolean | number]\n}>()\n\nconst element = ref<HTMLElement | null>(null)\n\nconst isHovering = useElementHover(element)\nconst modelValue = useVModel(props, 'modelValue', emit)\n\nconst {computedLink, computedLinkProps} = useBLinkHelper(props)\n\n// TODO animation is never used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst animationBoolean = useBooleanish(() => props.animation)\nconst isStatusBoolean = useBooleanish(() => props.isStatus)\n// TODO autohide is never used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst autoHideBoolean = useBooleanish(() => props.autoHide)\nconst noCloseButtonBoolean = useBooleanish(() => props.noCloseButton)\nconst noFadeBoolean = useBooleanish(() => props.noFade)\nconst noHoverPauseBoolean = useBooleanish(() => props.noHoverPause)\nconst showOnPauseBoolean = useBooleanish(() => props.showOnPause)\nconst intervalNumber = useToNumber(() => props.interval)\n// TODO solid is never used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst solidBoolean = useBooleanish(() => props.solid)\nconst resolvedBackgroundClasses = useColorVariantClasses(props)\nconst countdownLength = toRef(() => (typeof modelValue.value === 'boolean' ? 0 : modelValue.value))\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(countdownLength, intervalNumber, {\n  immediate: typeof modelValue.value === 'number',\n})\n\nwatchEffect(() => {\n  emit('close-countdown', remainingMs.value)\n})\n\nconst computedTag = toRef(() => (computedLink.value ? BLink : 'div'))\n\nconst isToastVisible = toRef(() =>\n  typeof modelValue.value === 'boolean'\n    ? modelValue.value\n    : isActive.value || (showOnPauseBoolean.value && isPaused.value)\n)\n\n// Unlike the Alert counterpart, we actually want to emit to fully destroy our Toast (handled by the toaster)\nwatch(isActive, (newValue) => {\n  if (newValue === false && isPaused.value === false) {\n    emit('destroyed')\n  }\n})\n\nconst computedClasses = computed(() => [\n  resolvedBackgroundClasses.value,\n  {\n    show: isToastVisible.value,\n  },\n])\n\nconst hide = () => {\n  emit('close')\n\n  if (typeof modelValue.value === 'boolean') {\n    modelValue.value = false\n  } else {\n    modelValue.value = 0\n    stop()\n  }\n\n  emit('closed')\n}\n\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\n\nwatch(isHovering, (newValue) => {\n  if (newValue) {\n    onMouseEnter()\n    return\n  }\n  resume()\n})\n\nonBeforeUnmount(stop)\n\ndefineExpose({\n  pause,\n  restart,\n  resume,\n  stop,\n})\n</script>\n","<template>\n  <Teleport :to=\"teleportTo\" :disabled=\"teleportDisabledBoolean\">\n    <div id=\"__BVID__toaster-container\">\n      <div\n        v-for=\"(value, key) in toastPositions\"\n        :key=\"key\"\n        :class=\"value\"\n        class=\"toast-container position-fixed p-3\"\n      >\n        <BToast\n          v-for=\"toast in toasts.filter((el) => el.pos === key)\"\n          :key=\"toast.self\"\n          v-model=\"toast.value\"\n          v-bind=\"pluckToastItem(toast)\"\n          @destroyed=\"hide(toast.self)\"\n        />\n      </div>\n    </div>\n  </Teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport type {RendererElement} from 'vue'\nimport {useBooleanish, useToast} from '../../composables'\nimport type {Booleanish, Toast} from '../../types'\nimport BToast from './BToast.vue'\nimport {omit} from '../../utils'\n\nconst props = withDefaults(\n  defineProps<{\n    teleportDisabled?: Booleanish\n    teleportTo?: string | RendererElement | null | undefined\n    // TODO this\n    // appendToast?: Booleanish\n  }>(),\n  {\n    teleportDisabled: false,\n    teleportTo: 'body',\n  }\n)\n\nconst teleportDisabledBoolean = useBooleanish(() => props.teleportDisabled)\n\nconst toastPositions = {\n  'top-left': 'top-0 start-0',\n  'top-center': 'top-0 start-50 translate-middle-x',\n  'top-right': 'top-0 end-0',\n  'middle-left': 'top-50 start-0 translate-middle-y',\n  'middle-center': 'top-50 start-50 translate-middle',\n  'middle-right': 'top-50 end-0 translate-middle-y',\n  'bottom-left': 'bottom-0 start-0',\n  'bottom-center': 'bottom-0 start-50 translate-middle-x',\n  'bottom-right': 'bottom-0 end-0',\n} as const\n\nconst {hide, toasts, show} = useToast()\n\nconst pluckToastItem = (payload: Toast & {self: symbol}) => omit(payload, ['value', 'self', 'pos'])\n\ndefineExpose({\n  hide,\n  show,\n})\n</script>\n","<template>\n  <BPopover ref=\"popover\" tooltip v-bind=\"$props\">\n    <template v-for=\"(_, name) in $slots\" #[name]=\"slotData\">\n      <slot :name=\"name\" v-bind=\"slotData\" />\n    </template>\n  </BPopover>\n</template>\n\n<script setup lang=\"ts\">\nimport {ref} from 'vue'\nimport BPopover from './BPopover.vue'\nimport type {BPopoverProps} from '../types'\n\nwithDefaults(defineProps<Omit<BPopoverProps, 'tooltip'>>(), {\n  click: undefined,\n  container: undefined,\n  content: undefined,\n  customClass: undefined,\n  delay: undefined,\n  floatingMiddleware: undefined,\n  hide: undefined,\n  html: undefined,\n  id: undefined,\n  inline: undefined,\n  manual: undefined,\n  modelValue: undefined,\n  noAutoClose: undefined,\n  noFade: undefined,\n  noFlip: undefined,\n  noHide: undefined,\n  noShift: undefined,\n  noninteractive: true,\n  offset: undefined,\n  placement: undefined,\n  realtime: undefined,\n  reference: undefined,\n  strategy: undefined,\n  target: undefined,\n  title: undefined,\n  variant: undefined,\n})\n\nconst popover = ref<null | InstanceType<typeof BPopover>>(null)\n\ndefineExpose({\n  hide: popover.value?.hide,\n  show: popover.value?.show,\n  toggle: popover.value?.toggle,\n})\n</script>\n","import type {App, Plugin} from 'vue'\nimport type {BootstrapVueOptions} from './types'\n\nimport './styles/styles.scss'\n\nimport * as Components from './components'\nimport * as Directives from './directives'\nimport type {ComponentType, DirectiveType} from './types/BootstrapVueOptions'\nimport parseActiveImports from './utils/parseActiveImports'\n\ndeclare module '@vue/runtime-core' {\n  export interface GlobalComponents {\n    BFormFile: typeof Components.BFormFile\n    BAccordion: typeof Components.BAccordion\n    BAccordionItem: typeof Components.BAccordionItem\n    BAlert: typeof Components.BAlert\n    BAvatar: typeof Components.BAvatar\n    BAvatarGroup: typeof Components.BAvatarGroup\n    BBadge: typeof Components.BBadge\n    BBreadcrumb: typeof Components.BBreadcrumb\n    BBreadcrumbItem: typeof Components.BBreadcrumbItem\n    BButton: typeof Components.BButton\n    BButtonGroup: typeof Components.BButtonGroup\n    BButtonToolbar: typeof Components.BButtonToolbar\n    BCard: typeof Components.BCard\n    BCardBody: typeof Components.BCardBody\n    BCardFooter: typeof Components.BCardFooter\n    BCardGroup: typeof Components.BCardGroup\n    BCardHeader: typeof Components.BCardHeader\n    BCardImg: typeof Components.BCardImg\n    BCardSubtitle: typeof Components.BCardSubtitle\n    BCardText: typeof Components.BCardText\n    BCardTitle: typeof Components.BCardTitle\n    BCarousel: typeof Components.BCarousel\n    BCarouselSlide: typeof Components.BCarouselSlide\n    BCloseButton: typeof Components.BCloseButton\n    BCol: typeof Components.BCol\n    BCollapse: typeof Components.BCollapse\n    BContainer: typeof Components.BContainer\n    BDropdown: typeof Components.BDropdown\n    BDropdownDivider: typeof Components.BDropdownDivider\n    BDropdownForm: typeof Components.BDropdownForm\n    BDropdownGroup: typeof Components.BDropdownGroup\n    BDropdownHeader: typeof Components.BDropdownHeader\n    BDropdownItem: typeof Components.BDropdownItem\n    BDropdownItemButton: typeof Components.BDropdownItemButton\n    BDropdownText: typeof Components.BDropdownText\n    BForm: typeof Components.BForm\n    BFormCheckbox: typeof Components.BFormCheckbox\n    BFormCheckboxGroup: typeof Components.BFormCheckboxGroup\n    BFormFloatingLabel: typeof Components.BFormFloatingLabel\n    BFormGroup: typeof Components.BFormGroup\n    BFormInput: typeof Components.BFormInput\n    BFormInvalidFeedback: typeof Components.BFormInvalidFeedback\n    BFormRadio: typeof Components.BFormRadio\n    BFormRadioGroup: typeof Components.BFormRadioGroup\n    BFormRow: typeof Components.BFormRow\n    BFormSelect: typeof Components.BFormSelect\n    BFormSelectOption: typeof Components.BFormSelectOption\n    BFormSelectOptionGroup: typeof Components.BFormSelectOptionGroup\n    BFormText: typeof Components.BFormText\n    BFormTextarea: typeof Components.BFormTextarea\n    BFormTag: typeof Components.BFormTag\n    BFormTags: typeof Components.BFormTags\n    BFormSpinbutton: typeof Components.BFormSpinbutton\n    BFormValidFeedback: typeof Components.BFormValidFeedback\n    BImg: typeof Components.BImg\n    BInputGroup: typeof Components.BInputGroup\n    BInputGroupAddon: typeof Components.BInputGroupAddon\n    BInputGroupAppend: typeof Components.BInputGroupAppend\n    BInputGroupPrepend: typeof Components.BInputGroupPrepend\n    BInputGroupText: typeof Components.BInputGroupText\n    BLink: typeof Components.BLink\n    BListGroup: typeof Components.BListGroup\n    BListGroupItem: typeof Components.BListGroupItem\n    BModal: typeof Components.BModal\n    BNav: typeof Components.BNav\n    BNavForm: typeof Components.BNavForm\n    BNavText: typeof Components.BNavText\n    BNavbar: typeof Components.BNavbar\n    BNavbarBrand: typeof Components.BNavbarBrand\n    BNavbarNav: typeof Components.BNavbarNav\n    BNavbarToggle: typeof Components.BNavbarToggle\n    BNavItem: typeof Components.BNavItem\n    BNavItemDropdown: typeof Components.BNavItemDropdown\n    BOffcanvas: typeof Components.BOffcanvas\n    BOverlay: typeof Components.BOverlay\n    BPagination: typeof Components.BPagination\n    BPlaceholder: typeof Components.BPlaceholder\n    BPlaceholderButton: typeof Components.BPlaceholderButton\n    BPlaceholderCard: typeof Components.BPlaceholderCard\n    BPlaceholderTable: typeof Components.BPlaceholderTable\n    BPlaceholderWrapper: typeof Components.BPlaceholderWrapper\n    BPopover: typeof Components.BPopover\n    BProgress: typeof Components.BProgress\n    BProgressBar: typeof Components.BProgressBar\n    BRow: typeof Components.BRow\n    BSpinner: typeof Components.BSpinner\n    BTab: typeof Components.BTab\n    BTable: typeof Components.BTable\n    BTableSimple: typeof Components.BTableSimple\n    BTbody: typeof Components.BTbody\n    BTd: typeof Components.BTd\n    BTfoot: typeof Components.BTfoot\n    BTh: typeof Components.BTh\n    BThead: typeof Components.BThead\n    BTr: typeof Components.BTr\n    BToast: typeof Components.BToast\n    BToaster: typeof Components.BToaster\n    BTooltip: typeof Components.BTooltip\n    BTabs: typeof Components.BTabs\n    BTransition: typeof Components.BTransition\n  }\n}\n\n// Main app plugin\nconst plugin: Plugin = {\n  install(app: App, options: BootstrapVueOptions = {components: true, directives: true}) {\n    const selectedComponents =\n      typeof options.components === 'boolean' || typeof options.components === 'undefined'\n        ? {all: true}\n        : options.components\n\n    const componentKeys = Object.keys(Components) as unknown as ComponentType[]\n    parseActiveImports(selectedComponents, componentKeys).forEach((name) => {\n      const component = Components[name]\n      app.component(name, component)\n    })\n\n    const selectedDirectives =\n      typeof options?.directives === 'boolean' || typeof options.directives === 'undefined'\n        ? {all: true}\n        : options?.directives\n\n    const directiveKeys = Object.keys(Directives) as unknown as DirectiveType[]\n    parseActiveImports(selectedDirectives, directiveKeys).forEach((name) => {\n      const parsedName = name.toLowerCase().startsWith('v') ? name.slice(1) : name\n      const directive = Directives[name]\n      app.directive(parsedName, directive)\n    })\n  },\n}\n\nexport * from './components'\nexport * as Components from './components'\nexport * from './directives'\nexport * as Directives from './directives'\nexport * from './composables/exports'\nexport * as Composables from './composables/exports'\nexport * from './utils/exports'\nexport * as Utils from './utils/exports'\nexport * from './types/exports'\nexport * as Types from './types/exports'\n\nexport {plugin as BootstrapVueNext}\nexport default plugin\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAKA,MAAqBA,EAAA,CAAQ;EA6B3BC,YACEC,CAAA,EACAC,CAAA,GAAkE,IAClE;IA/BOC,EAAA,qBAAsB;IACtBA,EAAA,sBAA6B;IAC9BA,EAAA,4BAAoB;IACnBA,EAAA,oBAAoB;IACpBA,EAAA,sBAA6B;IAC9BA,EAAA;IACCA,EAAA,wBAAoC;IACpCA,EAAA,iBAA6B;IAyBpC,IAAI,CAACF,CAAA,EACH,MAAM,IAAIG,SAAA,CACR,wBAAwB,KAAKJ,WAAA,CAAYK,IAAI,2BAA2BC,SAAA,CAAUC,MAAM;IAM5FC,MAAA,CAAOC,MAAA,CAAO,MAAMV,EAAA,CAAQW,QAAA,EAAUR,CAAA,EAAW;MAACS,SAAA,EAAAV;IAAA,CAAU,GAEvD,KAAAW,eAAA,GAAkB,YAA2B;MAC5C,KAAKC,UAAA,KACP,KAAKC,gBAAA,GAAmB;IAC1B;EAEJ;EAAA;EAAA;EArCA,IAAWA,iBAAA,EAAmB;IAC5B,OAAO,KAAKC,iBAAA;EACd;EACA,IAAcD,iBAAiBb,CAAA,EAAM;IACnC,KAAKc,iBAAA,GAAoBd,CAAA;EAC3B;EAAA;EAAA;EAAA;EAIA,IAAWe,eAAA,EAAiB;IAC1B,OAAO,KAAKJ,eAAA;EACd;EAAA;EAAA;EAGA,IAAcI,eAAef,CAAA,EAAoB;IAC/C,KAAKW,eAAA,GAAkBX,CAAA;EACzB;EAuBA,WAAWS,SAAA,EAAW;IACb;MACLG,UAAA,EAAY;MACZI,WAAA,EAAa;MACbN,SAAA,EAAW;MACXO,WAAA,EAAa;MACbC,aAAA,EAAe;MACfC,MAAA,EAAQ;IAAA;EAEZ;AACF;AC/DA,MAAqBC,EAAA,SAA2BtB,EAAA,CAAQ;EAGtDC,YACEE,CAAA,EACAoB,CAAA,GAA6E,IAC7E;IACA,MAAMpB,CAAA,EAAWoB,CAAS;IANnBnB,EAAA,kBAAyB;IAUhCK,MAAA,CAAOC,MAAA,CAAO,MAAMV,EAAA,CAAQW,QAAA,EAAUY,CAAA,EAAW;MAACX,SAAA,EAAAT;IAAA,CAAU;EAC9D;EAEA,WAAWQ,SAAA,EAAW;IACb;MACL,GAAG,MAAMA,QAAA;MACTa,OAAA,EAAS;IAAA;EAEb;AACF;ACpBA,MAAqBC,EAAA,SAAwBzB,EAAA,CAAQ;EAKnDC,YACEE,CAAA,EACAoB,CAAA,EAKA;IACA,MAAMpB,CAAA,EAAWoB,CAAS;IAZnBnB,EAAA;IACAA,EAAA;IACAA,EAAA;IAWPK,MAAA,CAAOC,MAAA,CAAO,MAAMV,EAAA,CAAQW,QAAA,EAAUY,CAAA,EAAW;MAACX,SAAA,EAAAT;IAAA,CAAU;IAC5D,MAAM;MAACuB,IAAA,EAAAC,CAAA;MAAMC,SAAA,EAAAC,CAAA;MAAWC,EAAA,EAAAC;IAAA,IAAMR,CAAA;IAC9B,KAAKG,IAAA,GAAOC,CAAA,EACZ,KAAKG,EAAA,GAAKC,CAAA,EACV,KAAKH,SAAA,GAAYC,CAAA;EACnB;EAEA,WAAWlB,SAAA,EAAW;IACb;MACL,GAAG,MAAMA;IAAA;EAEb;AACF;AC5BO,MAAMqB,EAAA,GAAgB;EAChBC,EAAA,GAAiB;EACjBC,EAAA,GAAsB;EACtBC,EAAA,GAA4B;EAC5BC,EAAA,GAAiB;EACjBC,EAAA,GAAU;EACVC,EAAA,GAAa;EAEbC,EAAA,GAAuB;EACvBC,EAAA,GAAoB;EACpBC,EAAA,GAAY;ECOZC,EAAA,GAAWC,CAACC,CAAA,EAAc1C,CAAA,GAAS,MAC9C,OAAO0C,CAAA,IAAQ,WACXA,CAAA,GACqBA,CAAA,IAAQ,OAC7B,KACAC,KAAA,CAAMC,OAAA,CAAQF,CAAG,KAChBnC,MAAA,CAAOsC,SAAA,CAAUJ,QAAA,CAASK,IAAA,CAAKJ,CAAG,MAAM,qBACvCA,CAAA,CAAID,QAAA,KAAalC,MAAA,CAAOsC,SAAA,CAAUJ,QAAA,GACpCM,IAAA,CAAKC,SAAA,CAAUN,CAAA,EAAK,MAAM1C,CAAM,IAChCiD,MAAA,CAAOP,CAAG;EAMHQ,EAAA,GAAaR,CAAA,IACxBA,CAAA,CACGS,OAAA,CAAQrB,EAAA,EAAe,GAAG,EAC1BqB,OAAA,CAAQpB,EAAA,EAAgB,CAAC/B,CAAA,EAAGC,CAAA,EAAIoB,CAAA,KAAO,GAAGpB,CAAE,IAAIoB,CAAE,EAAE,EACpD8B,OAAA,CAAQlB,EAAA,EAA2B,CAACjC,CAAA,EAAGC,CAAA,EAAIoB,CAAA,KAAOpB,CAAA,GAAKoB,CAAA,CAAG+B,WAAA,CAAa;EAM/DC,EAAA,GAAaX,CAAA,IACxBA,CAAA,CACGS,OAAA,CAAQrB,EAAA,EAAe,GAAG,EAC1BqB,OAAA,CAAQpB,EAAA,EAAgB,CAAC/B,CAAA,EAAGC,CAAA,EAAIoB,CAAA,KAAO,GAAGpB,CAAE,IAAIoB,CAAE,EAAE,EACpD8B,OAAA,CAAQnB,EAAA,EAAqB,CAAChC,CAAA,EAAGC,CAAA,EAAIoB,CAAA,KAAOpB,CAAA,GAAKoB,CAAA,CAAG+B,WAAA,CAAa;EAQzDE,EAAA,GAAcZ,CAAA,IAAwB;IAC3C,MAAA1C,CAAA,GAAO0C,CAAA,CAAIa,IAAA;IACV,OAAAvD,CAAA,CAAKwD,MAAA,CAAO,CAAC,EAAEJ,WAAA,KAAgBpD,CAAA,CAAKyD,KAAA,CAAM,CAAC;EACpD;EAQaC,EAAA,GAAgBhB,CAAA,IAAwBA,CAAA,CAAIS,OAAA,CAAQb,EAAA,EAAmB,MAAM;EAS7EqB,EAAA,GAAqBjB,CAAA,IAChCgB,EAAA,CAAahB,CAAG,EAAES,OAAA,CAAQZ,EAAA,EAAW,KAAK;ECzEtCqB,EAAA,GAAclB,CAAA,IAAkB,KAAKA,CAAK;EAQjCmB,EAAA,GAACnB,CAAA,IAA2B;IACnC,MAAA1C,CAAA,GAAMwC,EAAA,CAASE,CAAK;MAEpB;QAACpC,MAAA,EAAAL;MAAU,IAAAD,CAAA;MACXqB,CAAA,GAAgBrB,CAAA,CAAI8D,UAAA,CAAW,CAAC;IAE/B,OAAA9D,CAAA,CAAI+D,KAAA,CAAM,EAAE,EAAEC,MAAA,CAAO,CAACvC,CAAA,EAAgBE,CAAA,EAAcE,CAAA,KAAkB;MACrE,MAAAoC,CAAA,GAAWjE,CAAA,CAAI8D,UAAA,CAAWjC,CAAK;MAGrC,OAAIoC,CAAA,KAAa,IACR,GAAGxC,CAAM;MAAA;MAMhBwC,CAAA,KAAa;MAAA;MAEZA,CAAA,IAAY,KAAUA,CAAA,IAAY;MAAA;MAElCpC,CAAA,KAAU,KAAKoC,CAAA,IAAY,MAAUA,CAAA,IAAY;MAAA;MAAA;MAGjDpC,CAAA,KAAU,KAAKoC,CAAA,IAAY,MAAUA,CAAA,IAAY,MAAU5C,CAAA,KAAkB,KAGvEI,CAAA,GAASmC,EAAA,CAAW,GAAGK,CAAA,CAASxB,QAAA,CAAS,EAAE,CAAC,GAAG;MAAA;MAMtDZ,CAAA,KAAU;MAAA;MAEVoC,CAAA,KAAa;MAAA;MAEbhE,CAAA,KAAW,IAGJwB,CAAA,GAASmC,EAAA,CAAWjC,CAAI;MAAA;MAM/BsC,CAAA,IAAY;MAAA;MAEZA,CAAA,KAAa;MAAA;MAEbA,CAAA,KAAa;MAAA;MAEZA,CAAA,IAAY,MAAUA,CAAA,IAAY;MAAA;MAElCA,CAAA,IAAY,MAAUA,CAAA,IAAY;MAAA;MAElCA,CAAA,IAAY,MAAUA,CAAA,IAAY,MAG5BxC,CAAA,GAASE,CAAA,GAKXF,CAAA,GAASmC,EAAA,CAAWjC,CAAI;IAAA,GAC9B,EAAE;EACP;ECzEauC,EAAA,GAAqB,OAAOC,MAAA,GAAW;EAIvCC,EAAA,GAAuB,OAAOC,QAAA,GAAa;EAI3CC,EAAA,GAAsB,OAAOC,OAAA,GAAY;EAIzCC,EAAA,GAAwB,OAAOC,SAAA,GAAc;EAS7CC,EAAA,GAAaR,EAAA,IAAsBE,EAAA,IAAwBI,EAAA;EAM3DG,EAAA,GAAST,EAAA,GAAqBC,MAAA,GAAU;EAKxCS,EAAA,GAAWR,EAAA,GAAuBC,QAAA,GAAY;CAMjB,MAAM;EAC9C,IAAI3B,CAAA,GAAwB;EAC5B,IAAI,CAACgC,EAAA,EAAmB,OAAAhC,CAAA;EACpB;IACF,MAAM1C,CAAA,GAAU;MAAA;MAAA;MAGd,IAAI6E,QAAA,EAAU;QACY,OAAAnC,CAAA,OACjBA,CAAA;MACT;IAAA;IAEE,sBAAsBiC,EAAA,IAAU,OAAOA,EAAA,CAAOG,gBAAA,IAAqB,cAC9DH,EAAA,CAAAG,gBAAA,CAAiB,QAAQ9E,CAAA,EAASA,CAAO,GAE9C,yBAAyB2E,EAAA,IAAU,OAAOA,EAAA,CAAOI,mBAAA,IAAwB,cACpEJ,EAAA,CAAAI,mBAAA,CAAoB,QAAQ/E,CAAA,EAASA,CAAO;EACrD,QACM;IACkB0C,CAAA;EAC1B;AACF,GAAG;AC3DU,MAAAsC,EAAA,GAAqB,OAAOb,MAAA,GAAW;EAIvCc,EAAA,GAAuB,OAAOZ,QAAA,GAAa;EAI3Ca,EAAA,GAAwB,OAAOT,SAAA,GAAc;EAI7CU,EAAA,GAAaH,EAAA,IAAsBC,EAAA,IAAwBC,EAAA;EAK3DE,EAAA,GAASJ,EAAA,GAAqBb,MAAA,GAAU;EAMxCkB,EAAA,IAA6B,MAAM;IAC9C,IAAI3C,CAAA,GAAwB;IAC5B,IAAIyC,EAAA,EACE;MACF,MAAMnF,CAAA,GAAU;QAAA;QAAA;QAGd,IAAI6E,QAAA,EAAU;UACYnC,CAAA;QAG1B;MAAA;MAIK0C,EAAA,CAAAN,gBAAA,CAAiB,QAAQ9E,CAAA,EAASA,CAAO,GAGzCoF,EAAA,CAAAL,mBAAA,CAAoB,QAAQ/E,CAAA,EAASA,CAAO;IAAA,QAC7C;MACkB0C,CAAA;IAC1B;IAEK,OAAAA,CAAA;EACT,GAAG;ECzCG4C,EAAA,GAAgBhB,EAAA,GAAsBC,OAAA,CAAQ1B,SAAA,GAAY;EAKnD0C,EAAA,GAAa7C,CAAA,IACxB,CAAC,EAAEA,CAAA,IAAM,OAAOA,CAAA,IAAO,YAAY,cAAcA,CAAA,IAAMA,CAAA,CAAG8C,QAAA,KAAaC,IAAA,CAAKC,YAAA;EAKjEC,EAAA,GAAUjD,CAAA,IAAqB6C,EAAA,CAAU7C,CAAE,IAAIA,CAAA,CAAGkD,qBAAA,CAA0B;EAK5EC,EAAA,GAAmBC,CAACpD,CAAA,GAAW,OAAuB;IAC3D;MAACqD,aAAA,EAAA/F;IAAiB,IAAAqE,QAAA;IACjB,OAAArE,CAAA,IAAiB,CAAC0C,CAAA,CAASsD,IAAA,CAAM/F,CAAA,IAAoBA,CAAA,KAAOD,CAAa,IAC5EA,CAAA,GACA;EACN;EAKaiG,EAAA,GAAmBvD,CAAA,IAC9B6C,EAAA,CAAU7C,CAAE,KAAKA,CAAA,KAAOmD,EAAA;EAKbK,EAAA,GAAeC,CAACzD,CAAA,EAAiB1C,CAAA,GAAU,OAAgB;IAClE;MACF0C,CAAA,CAAG0D,KAAA,CAAMpG,CAAO;IAAA,SACTC,CAAA,EAAG;MAEVoG,OAAA,CAAQC,KAAA,CAAMrG,CAAC;IACjB;IACA,OAAOgG,EAAA,CAAgBvD,CAAE;EAC3B;EAsBa6D,EAAA,GAAWC,CAAC9D,CAAA,EAAiB1C,CAAA,KACxCA,CAAA,IAAQuF,EAAA,CAAU7C,CAAE,KAAIA,CAAA,CAAG+D,YAAA,CAAazG,CAAI,KAAK;EAUtC0G,EAAA,GAAahE,CAAA,IAA6B;IAMrD,IAAI6D,EAAA,CAAS7D,CAAA,EAAI,SAAS,MAAM,QAEvB;IAKH,MAAA1C,CAAA,GAAM2F,EAAA,CAAOjD,CAAE;IACrB,OAAO,CAAC,EAAE1C,CAAA,IAAOA,CAAA,CAAI2G,MAAA,GAAS,KAAK3G,CAAA,CAAI4G,KAAA,GAAQ;EACjD;EAKaC,EAAA,GAAenE,CAAA,MAAmCA,CAAA,oBAAAA,CAAA,OAAU,IAAIpC,MAAA,KAAW;EAU3EwG,EAAA,GAASC,CAACrE,CAAA,EAAkB1C,CAAA,MACtCuF,EAAA,CAAUvF,CAAI,IAAIA,CAAA,GAAO4E,EAAA,EAAUoC,aAAA,CAActE,CAAQ,KAAK;EAKpDuE,EAAA,GAAYC,CAACxE,CAAA,EAAkB1C,CAAA,KAC1C2C,KAAA,CAAMnB,IAAA,CAAK,EAAE+D,EAAA,CAAUvF,CAAI,IAAIA,CAAA,GAAO4E,EAAA,EAAUuC,gBAAA,CAAiBzE,CAAQ,CAAC,CAAC;EAKhE0E,EAAA,GAAUC,CAAC3E,CAAA,EAA2B1C,CAAA,KACjDA,CAAA,IAAQuF,EAAA,CAAU7C,CAAE,IAAIA,CAAA,CAAG+D,YAAA,CAAazG,CAAI,IAAI;EAMrCsH,EAAA,GAAW5E,CAAA,IACtBkC,EAAA,CAAS2C,cAAA,CAAe,KAAKC,IAAA,CAAK9E,CAAE,IAAIA,CAAA,CAAGe,KAAA,CAAM,CAAC,IAAIf,CAAE,KAAK;EAKlD+E,EAAA,GAAUC,CAAChF,CAAA,EAAiB1C,CAAA,EAAcC,CAAA,KAAwB;IACzED,CAAA,IAAQuF,EAAA,CAAU7C,CAAE,KACnBA,CAAA,CAAAiF,YAAA,CAAa3H,CAAA,EAAMC,CAAK;EAE/B;EASa2H,EAAA,GAAaC,CAACnF,CAAA,EAAiB1C,CAAA,KAAuB;IAC7DA,CAAA,IAAQuF,EAAA,CAAU7C,CAAE,KACtBA,CAAA,CAAGoF,eAAA,CAAgB9H,CAAI;EAE3B;EAKa+H,EAAA,GAAQC,CAACtF,CAAA,EAAa1C,CAAA,KACjCwC,EAAA,CAASE,CAAG,EAAEuF,WAAA,OAAkBzF,EAAA,CAASxC,CAAI,EAAEiI,WAAA,CAAY;EAmBhDC,EAAA,GAAUC,CAACzF,CAAA,EAAa1C,CAAA,KACnCuF,EAAA,CAAU7C,CAAE,IAAIA,CAAA,CAAGyF,OAAA,CAAQnI,CAAQ,IAAI;EAO5BoI,EAAA,IACX9C,EAAA,oBAAAA,EAAA,CAAe+C,OAAA,KACf,UAAyB3F,CAAA,EAAa;IACpC,IAAI1C,CAAA,GAAkC;IACtC,IAAI,CAACA,CAAA,EAAW;IACb;MAED,IAAIuF,EAAA,CAAUvF,CAAE,KAAKA,CAAA,CAAGmI,OAAA,CAAQzF,CAAG,GAAU,OAAA1C,CAAA;MAExCA,CAAA,GAAAA,CAAA,CAAGsI,aAAA,IAAiBtI,CAAA,CAAGuI,UAAA;IAAA,SACrBvI,CAAA,KAAO,QAAQA,CAAA,CAAGwF,QAAA,KAAaC,IAAA,CAAKC,YAAA;IACtC;EACT;EAUW8C,EAAA,GAAUH,CAAC3F,CAAA,EAAkB1C,CAAA,EAAeC,CAAA,GAAc,OAAU;IAC3E,KAACsF,EAAA,CAAUvF,CAAI,GACV;IAET,MAAMqB,CAAA,GAAK+G,EAAA,CAAUtF,IAAA,CAAK9C,CAAA,EAAM0C,CAAQ;IAIxC,OAAOzC,CAAA,GAAcoB,CAAA,GAAKA,CAAA,KAAOrB,CAAA,GAAO,OAAOqB,CAAA;EACjD;EAKaoH,EAAA,GAAsB/F,CAAA,IAAyB;IACpD,MAAA1C,CAAA,GAAQmE,MAAA,CAAOuE,gBAAA,CAAiBhG,CAAO;MAEvCzC,CAAA,GAAkBD,CAAA,CAAM2I,eAAA,CAAgB5E,KAAA,CAAM,GAAG,EAAE,CAAC,KAAK;MACzD1C,CAAA,GAAqBrB,CAAA,CAAM4I,kBAAA,CAAmB7E,KAAA,CAAM,GAAG,EAAE,CAAC,KAAK;MAC/DtC,CAAA,GAAoBoH,MAAA,CAAO5I,CAAA,CAAgBwD,KAAA,CAAM,GAAG,EAAE,CAAC,IAAI;MAC3D9B,CAAA,GAAuBkH,MAAA,CAAOxH,CAAA,CAAmBoC,KAAA,CAAM,GAAG,EAAE,CAAC,IAAI;IACvE,OAAOhC,CAAA,GAAoBE,CAAA;EAC7B;ECrOMmH,EAAA,GAAkB,CAAC,MAAM,MAAM,IAAI;EAInCC,EAAA,GAAc,CAClB,KACA;EAAA;EACA,UACA;EAAA;EACA,wCACA,yCACA,2CACA,iBACA,mBACA,mBACA,qBACA,4CACF,CAAEC,IAAA,CAAK,GAAG;EAIKC,EAAA,GAACvG,CAAA,IAAiB;IAE/B,IAAI,CAACA,CAAA,IAAS,CAACA,CAAA,CAAMvB,MAAA,EACZ;IAET,MAAMnB,CAAA,GAAK0C,CAAA,CAAMvB,MAAA;IAEZ,kBAAcnB,CAAA,IAAMA,CAAA,CAAGkJ,QAAA,IAAaJ,EAAA,CAAgBK,OAAA,CAAQnJ,CAAA,CAAGoJ,OAAO,MAAM,IACxE;IAGL,IAAAZ,EAAA,CAAQ,kBAAkBxI,CAAE,GACvB;IAET,MAAMC,CAAA,GAAQD,CAAA,CAAGoJ,OAAA,KAAY,UAAUpJ,CAAA,GAAKwI,EAAA,CAAQ,SAASxI,CAAE;IAI/D,IAAIC,CAAA,EAAO;MACH,MAAAoB,CAAA,GAAW+F,EAAA,CAAQnH,CAAA,EAAO,KAAK;QAC/BwB,CAAA,GAAQJ,CAAA,GAAWiG,EAAA,CAAQjG,CAAQ,IAAIyF,EAAA,CAAO,2BAA2B7G,CAAK;MAChF,IAAAwB,CAAA,IAAS,CAACA,CAAA,CAAMyH,QAAA,EACX;IAEX;IAIO,OAAAhB,EAAA,CAAQlI,CAAA,EAAI+I,EAAW;EAChC;ECpDMM,EAAA,GAAQ,CAAC,OAAO,SAAS,UAAU,MAAM;EACzCC,EAAA,GAAa,CAAC,SAAS,KAAK;EAC5BC,EAAA,GAA0B,eAAAF,EAAA,CAAMrF,MAAA,CAAO,CAACtB,CAAA,EAAK1C,CAAA,KAAS0C,CAAA,CAAI8G,MAAA,CAAOxJ,CAAA,EAAMA,CAAA,GAAO,MAAMsJ,EAAA,CAAW,CAAC,GAAGtJ,CAAA,GAAO,MAAMsJ,EAAA,CAAW,CAAC,CAAC,GAAG,EAAE;EAClIG,EAAA,GAAMC,IAAA,CAAKC,GAAA;EACXC,EAAA,GAAMF,IAAA,CAAKG,GAAA;EACXC,EAAA,GAAQJ,IAAA,CAAKK,KAAA;EACbC,EAAA,GAAQN,IAAA,CAAKO,KAAA;EACbC,EAAA,GAAexH,CAAA,KAAM;IACzByH,CAAA,EAAGzH,CAAA;IACH0H,CAAA,EAAG1H;EACL;EACM2H,EAAA,GAAkB;IACtBC,IAAA,EAAM;IACNC,KAAA,EAAO;IACPC,MAAA,EAAQ;IACRC,GAAA,EAAK;EACP;EACMC,EAAA,GAAuB;IAC3BC,KAAA,EAAO;IACPC,GAAA,EAAK;EACP;AACA,SAASC,GAAMnI,CAAA,EAAO1C,CAAA,EAAOC,CAAA,EAAK;EAChC,OAAO2J,EAAA,CAAIlH,CAAA,EAAO+G,EAAA,CAAIzJ,CAAA,EAAOC,CAAG,CAAC;AACnC;AACA,SAAS6K,GAASpI,CAAA,EAAO1C,CAAA,EAAO;EAC9B,OAAO,OAAO0C,CAAA,IAAU,aAAaA,CAAA,CAAM1C,CAAK,IAAI0C,CAAA;AACtD;AACA,SAASqI,GAAQrI,CAAA,EAAW;EAC1B,OAAOA,CAAA,CAAUqB,KAAA,CAAM,GAAG,EAAE,CAAC;AAC/B;AACA,SAASiH,GAAatI,CAAA,EAAW;EAC/B,OAAOA,CAAA,CAAUqB,KAAA,CAAM,GAAG,EAAE,CAAC;AAC/B;AACA,SAASkH,GAAgBvI,CAAA,EAAM;EAC7B,OAAOA,CAAA,KAAS,MAAM,MAAM;AAC9B;AACA,SAASwI,GAAcxI,CAAA,EAAM;EAC3B,OAAOA,CAAA,KAAS,MAAM,WAAW;AACnC;AACA,SAASyI,GAAYzI,CAAA,EAAW;EAC9B,OAAO,CAAC,OAAO,QAAQ,EAAE0I,QAAA,CAASL,EAAA,CAAQrI,CAAS,CAAC,IAAI,MAAM;AAChE;AACA,SAAS2I,GAAiB3I,CAAA,EAAW;EACnC,OAAOuI,EAAA,CAAgBE,EAAA,CAAYzI,CAAS,CAAC;AAC/C;AACA,SAAS4I,GAAkB5I,CAAA,EAAW1C,CAAA,EAAOC,CAAA,EAAK;EAC5CA,CAAA,KAAQ,WACVA,CAAA,GAAM;EAER,MAAMoB,CAAA,GAAY2J,EAAA,CAAatI,CAAS;IAClCjB,CAAA,GAAgB4J,EAAA,CAAiB3I,CAAS;IAC1Cf,CAAA,GAASuJ,EAAA,CAAczJ,CAAa;EAC1C,IAAII,CAAA,GAAoBJ,CAAA,KAAkB,MAAMJ,CAAA,MAAepB,CAAA,GAAM,QAAQ,WAAW,UAAU,SAASoB,CAAA,KAAc,UAAU,WAAW;EAC9I,OAAIrB,CAAA,CAAMuL,SAAA,CAAU5J,CAAM,IAAI3B,CAAA,CAAMwL,QAAA,CAAS7J,CAAM,MACjDE,CAAA,GAAoB4J,EAAA,CAAqB5J,CAAiB,IAErD,CAACA,CAAA,EAAmB4J,EAAA,CAAqB5J,CAAiB,CAAC;AACpE;AACA,SAAS6J,GAAsBhJ,CAAA,EAAW;EACxC,MAAM1C,CAAA,GAAoByL,EAAA,CAAqB/I,CAAS;EACxD,OAAO,CAACiJ,EAAA,CAA8BjJ,CAAS,GAAG1C,CAAA,EAAmB2L,EAAA,CAA8B3L,CAAiB,CAAC;AACvH;AACA,SAAS2L,GAA8BjJ,CAAA,EAAW;EAChD,OAAOA,CAAA,CAAUS,OAAA,CAAQ,cAAcnD,CAAA,IAAa0K,EAAA,CAAqB1K,CAAS,CAAC;AACrF;AACA,SAAS4L,GAAYlJ,CAAA,EAAM1C,CAAA,EAASC,CAAA,EAAK;EACvC,MAAMoB,CAAA,GAAK,CAAC,QAAQ,OAAO;IACrBI,CAAA,GAAK,CAAC,SAAS,MAAM;IACrBE,CAAA,GAAK,CAAC,OAAO,QAAQ;IACrBE,CAAA,GAAK,CAAC,UAAU,KAAK;EAC3B,QAAQa,CAAA;IACN,KAAK;IACL,KAAK;MACH,OAAIzC,CAAA,GAAYD,CAAA,GAAUyB,CAAA,GAAKJ,CAAA,GACxBrB,CAAA,GAAUqB,CAAA,GAAKI,CAAA;IACxB,KAAK;IACL,KAAK;MACH,OAAOzB,CAAA,GAAU2B,CAAA,GAAKE,CAAA;IACxB;MACE,OAAO;EACV;AACH;AACA,SAASgK,GAA0BnJ,CAAA,EAAW1C,CAAA,EAAeC,CAAA,EAAWoB,CAAA,EAAK;EAC3E,MAAMI,CAAA,GAAYuJ,EAAA,CAAatI,CAAS;EACxC,IAAIf,CAAA,GAAOiK,EAAA,CAAYb,EAAA,CAAQrI,CAAS,GAAGzC,CAAA,KAAc,SAASoB,CAAG;EACrE,OAAII,CAAA,KACFE,CAAA,GAAOA,CAAA,CAAKmK,GAAA,CAAIjK,CAAA,IAAQA,CAAA,GAAO,MAAMJ,CAAS,GAC1CzB,CAAA,KACF2B,CAAA,GAAOA,CAAA,CAAK6H,MAAA,CAAO7H,CAAA,CAAKmK,GAAA,CAAIH,EAA6B,CAAC,KAGvDhK,CAAA;AACT;AACA,SAAS8J,GAAqB/I,CAAA,EAAW;EACvC,OAAOA,CAAA,CAAUS,OAAA,CAAQ,0BAA0BnD,CAAA,IAAQqK,EAAA,CAAgBrK,CAAI,CAAC;AAClF;AACA,SAAS+L,GAAoBrJ,CAAA,EAAS;EACpC,OAAO;IACL+H,GAAA,EAAK;IACLF,KAAA,EAAO;IACPC,MAAA,EAAQ;IACRF,IAAA,EAAM;IACN,GAAG5H;EACP;AACA;AACA,SAASsJ,GAAiBtJ,CAAA,EAAS;EACjC,OAAO,OAAOA,CAAA,IAAY,WAAWqJ,EAAA,CAAoBrJ,CAAO,IAAI;IAClE+H,GAAA,EAAK/H,CAAA;IACL6H,KAAA,EAAO7H,CAAA;IACP8H,MAAA,EAAQ9H,CAAA;IACR4H,IAAA,EAAM5H;EACV;AACA;AACA,SAASuJ,GAAiBvJ,CAAA,EAAM;EAC9B,OAAO;IACL,GAAGA,CAAA;IACH+H,GAAA,EAAK/H,CAAA,CAAK0H,CAAA;IACVE,IAAA,EAAM5H,CAAA,CAAKyH,CAAA;IACXI,KAAA,EAAO7H,CAAA,CAAKyH,CAAA,GAAIzH,CAAA,CAAKkE,KAAA;IACrB4D,MAAA,EAAQ9H,CAAA,CAAK0H,CAAA,GAAI1H,CAAA,CAAKiE;EAC1B;AACA;ACtHA,SAASuF,GAA2BxJ,CAAA,EAAM1C,CAAA,EAAWC,CAAA,EAAK;EACxD,IAAI;IACFsL,SAAA,EAAAlK,CAAA;IACAmK,QAAA,EAAA/J;EACD,IAAGiB,CAAA;EACJ,MAAMf,CAAA,GAAWwJ,EAAA,CAAYnL,CAAS;IAChC6B,CAAA,GAAgBwJ,EAAA,CAAiBrL,CAAS;IAC1CiE,CAAA,GAAciH,EAAA,CAAcrJ,CAAa;IACzCsK,CAAA,GAAOpB,EAAA,CAAQ/K,CAAS;IACxBoM,CAAA,GAAazK,CAAA,KAAa;IAC1B0K,CAAA,GAAUhL,CAAA,CAAU8I,CAAA,GAAI9I,CAAA,CAAUuF,KAAA,GAAQ,IAAInF,CAAA,CAASmF,KAAA,GAAQ;IAC/D0F,CAAA,GAAUjL,CAAA,CAAU+I,CAAA,GAAI/I,CAAA,CAAUsF,MAAA,GAAS,IAAIlF,CAAA,CAASkF,MAAA,GAAS;IACjE4F,CAAA,GAAclL,CAAA,CAAU4C,CAAW,IAAI,IAAIxC,CAAA,CAASwC,CAAW,IAAI;EACzE,IAAImG,CAAA;EACJ,QAAQ+B,CAAA;IACN,KAAK;MACH/B,CAAA,GAAS;QACPD,CAAA,EAAGkC,CAAA;QACHjC,CAAA,EAAG/I,CAAA,CAAU+I,CAAA,GAAI3I,CAAA,CAASkF;MAClC;MACM;IACF,KAAK;MACHyD,CAAA,GAAS;QACPD,CAAA,EAAGkC,CAAA;QACHjC,CAAA,EAAG/I,CAAA,CAAU+I,CAAA,GAAI/I,CAAA,CAAUsF;MACnC;MACM;IACF,KAAK;MACHyD,CAAA,GAAS;QACPD,CAAA,EAAG9I,CAAA,CAAU8I,CAAA,GAAI9I,CAAA,CAAUuF,KAAA;QAC3BwD,CAAA,EAAGkC;MACX;MACM;IACF,KAAK;MACHlC,CAAA,GAAS;QACPD,CAAA,EAAG9I,CAAA,CAAU8I,CAAA,GAAI1I,CAAA,CAASmF,KAAA;QAC1BwD,CAAA,EAAGkC;MACX;MACM;IACF;MACElC,CAAA,GAAS;QACPD,CAAA,EAAG9I,CAAA,CAAU8I,CAAA;QACbC,CAAA,EAAG/I,CAAA,CAAU+I;MACrB;EACG;EACD,QAAQY,EAAA,CAAahL,CAAS;IAC5B,KAAK;MACHoK,CAAA,CAAOvI,CAAa,KAAK0K,CAAA,IAAetM,CAAA,IAAOmM,CAAA,GAAa,KAAK;MACjE;IACF,KAAK;MACHhC,CAAA,CAAOvI,CAAa,KAAK0K,CAAA,IAAetM,CAAA,IAAOmM,CAAA,GAAa,KAAK;MACjE;EACH;EACD,OAAOhC,CAAA;AACT;AASA,MAAMoC,EAAA,GAAkB,MAAAC,CAAO/J,CAAA,EAAW1C,CAAA,EAAUC,CAAA,KAAW;EAC7D,MAAM;MACJyM,SAAA,EAAArL,CAAA,GAAY;MACZsL,QAAA,EAAAlL,CAAA,GAAW;MACXmL,UAAA,EAAAjL,CAAA,GAAa,EAAE;MACfkL,QAAA,EAAAhL;IACD,IAAG5B,CAAA;IACEgE,CAAA,GAAkBtC,CAAA,CAAWmL,MAAA,CAAOC,OAAO;IAC3CZ,CAAA,GAAM,OAAOtK,CAAA,CAASmL,KAAA,IAAS,OAAO,SAASnL,CAAA,CAASmL,KAAA,CAAMhN,CAAQ;EAC5E,IAAIoM,CAAA,GAAQ,MAAMvK,CAAA,CAASoL,eAAA,CAAgB;MACzC1B,SAAA,EAAA7I,CAAA;MACA8I,QAAA,EAAAxL,CAAA;MACA2M,QAAA,EAAAlL;IACJ,CAAG;IACG;MACF0I,CAAA,EAAAkC,CAAA;MACAjC,CAAA,EAAAkC;IACD,IAAGJ,EAAA,CAA2BE,CAAA,EAAO/K,CAAA,EAAW8K,CAAG;IAChDI,CAAA,GAAoBlL,CAAA;IACpB+I,CAAA,GAAiB;IACjB8C,CAAA,GAAa;EACjB,SAASC,CAAA,GAAI,GAAGA,CAAA,GAAIlJ,CAAA,CAAgB3D,MAAA,EAAQ6M,CAAA,IAAK;IAC/C,MAAM;QACJ/M,IAAA,EAAAgN,CAAA;QACAC,EAAA,EAAAC;MACN,IAAQrJ,CAAA,CAAgBkJ,CAAC;MACf;QACJhD,CAAA,EAAGoD,CAAA;QACHnD,CAAA,EAAGoD,CAAA;QACHC,IAAA,EAAAC,CAAA;QACAC,KAAA,EAAAC;MACD,IAAG,MAAMN,CAAA,CAAG;QACXnD,CAAA,EAAAkC,CAAA;QACAjC,CAAA,EAAAkC,CAAA;QACAuB,gBAAA,EAAkBxM,CAAA;QAClBqL,SAAA,EAAWH,CAAA;QACXI,QAAA,EAAAlL,CAAA;QACAqM,cAAA,EAAA1D,CAAA;QACA2D,KAAA,EAAA3B,CAAA;QACAS,QAAA,EAAAhL,CAAA;QACAmM,QAAA,EAAU;UACRzC,SAAA,EAAA7I,CAAA;UACA8I,QAAA,EAAAxL;QACD;MACP,CAAK;IAUD,IATAqM,CAAA,GAAIkB,CAAA,IAAwBlB,CAAA,EAC5BC,CAAA,GAAIkB,CAAA,IAAwBlB,CAAA,EAC5BlC,CAAA,GAAiB;MACf,GAAGA,CAAA;MACH,CAACgD,CAAI,GAAG;QACN,GAAGhD,CAAA,CAAegD,CAAI;QACtB,GAAGM;MACJ;IACP,GACQE,CAAA,IAASV,CAAA,IAAc,IAAI;MAC7BA,CAAA,IACI,OAAOU,CAAA,IAAU,aACfA,CAAA,CAAMlB,SAAA,KACRH,CAAA,GAAoBqB,CAAA,CAAMlB,SAAA,GAExBkB,CAAA,CAAMG,KAAA,KACR3B,CAAA,GAAQwB,CAAA,CAAMG,KAAA,KAAU,KAAO,MAAMlM,CAAA,CAASoL,eAAA,CAAgB;QAC5D1B,SAAA,EAAA7I,CAAA;QACA8I,QAAA,EAAAxL,CAAA;QACA2M,QAAA,EAAAlL;MACZ,CAAW,IAAImM,CAAA,CAAMG,KAAA,GAEZ;QACC5D,CAAA,EAAAkC,CAAA;QACAjC,CAAA,EAAAkC;MACD,IAAGJ,EAAA,CAA2BE,CAAA,EAAOG,CAAA,EAAmBJ,CAAG,IAE9DgB,CAAA,GAAI;MACJ;IACD;EACF;EACD,OAAO;IACLhD,CAAA,EAAAkC,CAAA;IACAjC,CAAA,EAAAkC,CAAA;IACAI,SAAA,EAAWH,CAAA;IACXI,QAAA,EAAAlL,CAAA;IACAqM,cAAA,EAAA1D;EACJ;AACA;AAUA,eAAe6D,GAAevL,CAAA,EAAO1C,CAAA,EAAS;EAC5C,IAAIC,CAAA;EACAD,CAAA,KAAY,WACdA,CAAA,GAAU;EAEZ,MAAM;MACJmK,CAAA,EAAA9I,CAAA;MACA+I,CAAA,EAAA3I,CAAA;MACAoL,QAAA,EAAAlL,CAAA;MACAoM,KAAA,EAAAlM,CAAA;MACAmM,QAAA,EAAA/J,CAAA;MACA0I,QAAA,EAAAR;IACD,IAAGzJ,CAAA;IACE;MACJwL,QAAA,EAAA9B,CAAA,GAAW;MACX+B,YAAA,EAAA9B,CAAA,GAAe;MACf+B,cAAA,EAAA9B,CAAA,GAAiB;MACjB+B,WAAA,EAAA9B,CAAA,GAAc;MACd+B,OAAA,EAAAlE,CAAA,GAAU;IACd,IAAMU,EAAA,CAAS9K,CAAA,EAAS0C,CAAK;IACrBwK,CAAA,GAAgBlB,EAAA,CAAiB5B,CAAO;IAExCgD,CAAA,GAAUnJ,CAAA,CAASsI,CAAA,GADND,CAAA,KAAmB,aAAa,cAAc,aACbA,CAAc;IAC5DgB,CAAA,GAAqBrB,EAAA,CAAiB,MAAMtK,CAAA,CAAS4M,eAAA,CAAgB;MACzEC,OAAA,GAAWvO,CAAA,GAAwB,OAAO0B,CAAA,CAAS8M,SAAA,IAAa,OAAO,SAAS9M,CAAA,CAAS8M,SAAA,CAAUrB,CAAO,OAAO,QAAOnN,CAAA,GAAgCmN,CAAA,GAAUA,CAAA,CAAQsB,cAAA,KAAmB,OAAO/M,CAAA,CAASgN,kBAAA,IAAsB,OAAO,SAAShN,CAAA,CAASgN,kBAAA,CAAmB1K,CAAA,CAASuH,QAAQ;MAChS0C,QAAA,EAAA9B,CAAA;MACA+B,YAAA,EAAA9B,CAAA;MACAM,QAAA,EAAAR;IACD,EAAC;IACIoB,CAAA,GAAOjB,CAAA,KAAmB,aAAa;MAC3C,GAAGzK,CAAA,CAAM2J,QAAA;MACTrB,CAAA,EAAA9I,CAAA;MACA+I,CAAA,EAAA3I;IACJ,IAAMI,CAAA,CAAM0J,SAAA;IACJiC,CAAA,GAAe,OAAO7L,CAAA,CAASiN,eAAA,IAAmB,OAAO,SAASjN,CAAA,CAASiN,eAAA,CAAgB3K,CAAA,CAASuH,QAAQ;IAC5GkC,CAAA,GAAe,QAAO/L,CAAA,CAAS8M,SAAA,IAAa,OAAO,SAAS9M,CAAA,CAAS8M,SAAA,CAAUjB,CAAY,MAAO,QAAO7L,CAAA,CAASkN,QAAA,IAAY,OAAO,SAASlN,CAAA,CAASkN,QAAA,CAASrB,CAAY,OAAO;MACvLrD,CAAA,EAAG;MACHC,CAAA,EAAG;IACP,IAAM;MACFD,CAAA,EAAG;MACHC,CAAA,EAAG;IACP;IACQwD,CAAA,GAAoB3B,EAAA,CAAiBtK,CAAA,CAASmN,qDAAA,GAAwD,MAAMnN,CAAA,CAASmN,qDAAA,CAAsD;MAC/KC,IAAA,EAAAxB,CAAA;MACAyB,YAAA,EAAAxB,CAAA;MACAb,QAAA,EAAAR;IACJ,CAAG,IAAIoB,CAAI;EACT,OAAO;IACL9C,GAAA,GAAM6C,CAAA,CAAmB7C,GAAA,GAAMmD,CAAA,CAAkBnD,GAAA,GAAMyC,CAAA,CAAczC,GAAA,IAAOiD,CAAA,CAAYtD,CAAA;IACxFI,MAAA,GAASoD,CAAA,CAAkBpD,MAAA,GAAS8C,CAAA,CAAmB9C,MAAA,GAAS0C,CAAA,CAAc1C,MAAA,IAAUkD,CAAA,CAAYtD,CAAA;IACpGE,IAAA,GAAOgD,CAAA,CAAmBhD,IAAA,GAAOsD,CAAA,CAAkBtD,IAAA,GAAO4C,CAAA,CAAc5C,IAAA,IAAQoD,CAAA,CAAYvD,CAAA;IAC5FI,KAAA,GAAQqD,CAAA,CAAkBrD,KAAA,GAAQ+C,CAAA,CAAmB/C,KAAA,GAAQ2C,CAAA,CAAc3C,KAAA,IAASmD,CAAA,CAAYvD;EACpG;AACA;AAOA,MAAM8E,EAAA,GAAQvM,CAAA,KAAY;EACxBtC,IAAA,EAAM;EACN8O,OAAA,EAAAxM,CAAA;EACA,MAAM2K,GAAGrN,CAAA,EAAO;IACd,MAAM;QACJmK,CAAA,EAAAlK,CAAA;QACAmK,CAAA,EAAA/I,CAAA;QACAqL,SAAA,EAAAjL,CAAA;QACAsM,KAAA,EAAApM,CAAA;QACAkL,QAAA,EAAAhL,CAAA;QACAmM,QAAA,EAAA/J,CAAA;QACA6J,cAAA,EAAA3B;MACD,IAAGnM,CAAA;MAEE;QACJwO,OAAA,EAAApC,CAAA;QACAkC,OAAA,EAAAjC,CAAA,GAAU;MACX,IAAGvB,EAAA,CAASpI,CAAA,EAAS1C,CAAK,KAAK;IAChC,IAAIoM,CAAA,IAAW,MACb,OAAO;IAET,MAAME,CAAA,GAAgBN,EAAA,CAAiBK,CAAO;MACxCE,CAAA,GAAS;QACbpC,CAAA,EAAAlK,CAAA;QACAmK,CAAA,EAAA/I;MACN;MACU+I,CAAA,GAAOiB,EAAA,CAAiB5J,CAAS;MACjCyL,CAAA,GAAShC,EAAA,CAAcd,CAAI;MAC3B+C,CAAA,GAAkB,MAAMtL,CAAA,CAASsN,aAAA,CAAc/C,CAAO;MACtDgB,CAAA,GAAUhD,CAAA,KAAS;MACnBkD,CAAA,GAAUF,CAAA,GAAU,QAAQ;MAC5BG,CAAA,GAAUH,CAAA,GAAU,WAAW;MAC/BI,CAAA,GAAaJ,CAAA,GAAU,iBAAiB;MACxCM,CAAA,GAAU/L,CAAA,CAAM4J,SAAA,CAAU2B,CAAM,IAAIvL,CAAA,CAAM4J,SAAA,CAAUnB,CAAI,IAAImC,CAAA,CAAOnC,CAAI,IAAIzI,CAAA,CAAM6J,QAAA,CAAS0B,CAAM;MAChGU,CAAA,GAAYrB,CAAA,CAAOnC,CAAI,IAAIzI,CAAA,CAAM4J,SAAA,CAAUnB,CAAI;MAC/CgF,CAAA,GAAoB,OAAOvN,CAAA,CAAS+M,eAAA,IAAmB,OAAO,SAAS/M,CAAA,CAAS+M,eAAA,CAAgBxC,CAAO;IAC7G,IAAIiD,CAAA,GAAaD,CAAA,GAAoBA,CAAA,CAAkB5B,CAAU,IAAI;IAGrE,CAAI,CAAC6B,CAAA,IAAc,EAAE,OAAOxN,CAAA,CAAS4M,SAAA,IAAa,OAAO,SAAS5M,CAAA,CAAS4M,SAAA,CAAUW,CAAiB,SACpGC,CAAA,GAAapL,CAAA,CAASuH,QAAA,CAASgC,CAAU,KAAK7L,CAAA,CAAM6J,QAAA,CAAS0B,CAAM;IAErE,MAAMoC,CAAA,GAAoB5B,CAAA,GAAU,IAAIE,CAAA,GAAY;MAI9C2B,CAAA,GAAyBF,CAAA,GAAa,IAAIlC,CAAA,CAAgBD,CAAM,IAAI,IAAI;MACxEsC,CAAA,GAAa/F,EAAA,CAAI6C,CAAA,CAAcgB,CAAO,GAAGiC,CAAsB;MAC/DE,CAAA,GAAahG,EAAA,CAAI6C,CAAA,CAAciB,CAAO,GAAGgC,CAAsB;MAI/DG,CAAA,GAAQF,CAAA;MACRG,CAAA,GAAMN,CAAA,GAAalC,CAAA,CAAgBD,CAAM,IAAIuC,CAAA;MAC7CG,CAAA,GAASP,CAAA,GAAa,IAAIlC,CAAA,CAAgBD,CAAM,IAAI,IAAIoC,CAAA;MACxDO,CAAA,GAAShF,EAAA,CAAM6E,CAAA,EAAOE,CAAA,EAAQD,CAAG;MAMjCG,EAAA,GAAkB,CAAC3D,CAAA,CAAe4D,KAAA,IAAS/E,EAAA,CAAavJ,CAAS,KAAK,QAAQmO,CAAA,IAAUC,CAAA,IAAUlO,CAAA,CAAM4J,SAAA,CAAU2B,CAAM,IAAI,KAAK0C,CAAA,GAASF,CAAA,GAAQF,CAAA,GAAaC,CAAA,IAActC,CAAA,CAAgBD,CAAM,IAAI,IAAI;MAC3M8C,EAAA,GAAkBF,EAAA,GAAkBF,CAAA,GAASF,CAAA,GAAQE,CAAA,GAASF,CAAA,GAAQE,CAAA,GAASD,CAAA,GAAM;IAC3F,OAAO;MACL,CAACvF,CAAI,GAAGmC,CAAA,CAAOnC,CAAI,IAAI4F,EAAA;MACvBvC,IAAA,EAAM;QACJ,CAACrD,CAAI,GAAGyF,CAAA;QACRI,YAAA,EAAcL,CAAA,GAASC,CAAA,GAASG,EAAA;QAChC,IAAIF,EAAA,IAAmB;UACrBI,eAAA,EAAAF;QACV;MACO;MACDrC,KAAA,EAAOmC;IACb;EACG;AACH;AAEA,SAASK,GAAiBzN,CAAA,EAAW1C,CAAA,EAAeC,CAAA,EAAmB;EAErE,QAD2CyC,CAAA,GAAY,CAAC,GAAGzC,CAAA,CAAkB6M,MAAA,CAAOrL,CAAA,IAAauJ,EAAA,CAAavJ,CAAS,MAAMiB,CAAS,GAAG,GAAGzC,CAAA,CAAkB6M,MAAA,CAAOrL,CAAA,IAAauJ,EAAA,CAAavJ,CAAS,MAAMiB,CAAS,CAAC,IAAIzC,CAAA,CAAkB6M,MAAA,CAAOrL,CAAA,IAAasJ,EAAA,CAAQtJ,CAAS,MAAMA,CAAS,GACxPqL,MAAA,CAAOrL,CAAA,IAC3CiB,CAAA,GACKsI,EAAA,CAAavJ,CAAS,MAAMiB,CAAA,KAAc1C,CAAA,GAAgB2L,EAAA,CAA8BlK,CAAS,MAAMA,CAAA,GAAY,MAErH,EACR;AACH;AAOA,MAAM2O,EAAA,GAAgB,SAAAC,CAAU3N,CAAA,EAAS;IACvC,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,KAEL;MACLtC,IAAA,EAAM;MACN8O,OAAA,EAAAxM,CAAA;MACA,MAAM2K,GAAGrN,CAAA,EAAO;QACd,IAAIC,CAAA,EAAuBoB,CAAA,EAAwBI,CAAA;QACnD,MAAM;YACJsM,KAAA,EAAApM,CAAA;YACAmM,cAAA,EAAAjM,CAAA;YACA6K,SAAA,EAAAzI,CAAA;YACA4I,QAAA,EAAAV,CAAA;YACA6B,QAAA,EAAA5B;UACD,IAAGpM,CAAA;UACE;YACJsQ,SAAA,EAAAjE,CAAA,GAAY;YACZkE,SAAA,EAAAjE,CAAA;YACAkE,iBAAA,EAAAjE,CAAA,GAAoBhD,EAAA;YACpBkH,aAAA,EAAArG,CAAA,GAAgB;YAChB,GAAG8C;UACX,IAAUpC,EAAA,CAASpI,CAAA,EAAS1C,CAAK;UACrBmN,CAAA,GAAeb,CAAA,KAAc,UAAaC,CAAA,KAAsBhD,EAAA,GAAa4G,EAAA,CAAiB7D,CAAA,IAAa,MAAMlC,CAAA,EAAemC,CAAiB,IAAIA,CAAA;UACrJa,CAAA,GAAW,MAAMa,EAAA,CAAejO,CAAA,EAAOkN,CAAqB;UAC5DI,CAAA,KAAiBrN,CAAA,GAAwB4B,CAAA,CAAewO,aAAA,KAAkB,OAAO,SAASpQ,CAAA,CAAsByQ,KAAA,KAAU;UAC1HnD,CAAA,GAAmBJ,CAAA,CAAaG,CAAY;QAClD,IAAIC,CAAA,IAAoB,MACtB,OAAO;QAET,MAAMC,CAAA,GAAiBlC,EAAA,CAAkBiC,CAAA,EAAkB5L,CAAA,EAAO,OAAOwK,CAAA,CAASa,KAAA,IAAS,OAAO,SAASb,CAAA,CAASa,KAAA,CAAMZ,CAAA,CAASZ,QAAQ,EAAE;QAG7I,IAAIvH,CAAA,KAAcsJ,CAAA,EAChB,OAAO;UACLI,KAAA,EAAO;YACLjB,SAAA,EAAWS,CAAA,CAAa,CAAC;UAC1B;QACX;QAEM,MAAMO,CAAA,GAAmB,CAACN,CAAA,CAASrC,EAAA,CAAQwC,CAAgB,CAAC,GAAGH,CAAA,CAASI,CAAA,CAAe,CAAC,CAAC,GAAGJ,CAAA,CAASI,CAAA,CAAe,CAAC,CAAC,CAAC;UACjHI,CAAA,GAAe,CAAC,MAAMvM,CAAA,GAAyBQ,CAAA,CAAewO,aAAA,KAAkB,OAAO,SAAShP,CAAA,CAAuBsP,SAAA,KAAc,EAAE,GAAG;YAC9IjE,SAAA,EAAWa,CAAA;YACXoD,SAAA,EAAWjD;UACnB,CAAO;UACK0B,CAAA,GAAgBjC,CAAA,CAAaG,CAAA,GAAe,CAAC;QAGnD,IAAI8B,CAAA,EACF,OAAO;UACL3B,IAAA,EAAM;YACJiD,KAAA,EAAOpD,CAAA,GAAe;YACtBqD,SAAA,EAAW/C;UACZ;UACDD,KAAA,EAAO;YACLjB,SAAA,EAAW0C;UACZ;QACX;QAEM,MAAMC,CAAA,GAA8BzB,CAAA,CAAa9B,GAAA,CAAI0D,CAAA,IAAK;YACxD,MAAMC,CAAA,GAAYzE,EAAA,CAAawE,CAAA,CAAE9C,SAAS;YAC1C,OAAO,CAAC8C,CAAA,CAAE9C,SAAA,EAAW+C,CAAA,IAAapD,CAAA;YAAA;YAElCmD,CAAA,CAAEmB,SAAA,CAAUlN,KAAA,CAAM,GAAG,CAAC,EAAEO,MAAA,CAAO,CAAC0L,CAAA,EAAKC,CAAA,KAAMD,CAAA,GAAMC,CAAA,EAAG,CAAC;YAAA;YAErDH,CAAA,CAAEmB,SAAA,CAAU,CAAC,GAAGnB,CAAA,CAAEmB,SAAS;UACnC,CAAO,EAAEC,IAAA,CAAK,CAACpB,CAAA,EAAGC,CAAA,KAAMD,CAAA,CAAE,CAAC,IAAIC,CAAA,CAAE,CAAC,CAAC;UAKvBF,CAAA,KAAmB9N,CAAA,GAJW4N,CAAA,CAA4BvC,MAAA,CAAO0C,CAAA,IAAKA,CAAA,CAAE,CAAC,EAAE/L,KAAA,CAAM;UAAA;UAAA;UAGvFuH,EAAA,CAAawE,CAAA,CAAE,CAAC,CAAC,IAAI,IAAI,CAAC,EAAEqB,KAAA,CAAMpB,CAAA,IAAKA,CAAA,IAAK,CAAC,CAAC,EAC+B,CAAC,MAAM,OAAO,SAAShO,CAAA,CAAsB,CAAC,MAAM4N,CAAA,CAA4B,CAAC,EAAE,CAAC;QACjK,OAAIE,CAAA,KAAmBtL,CAAA,GACd;UACLwJ,IAAA,EAAM;YACJiD,KAAA,EAAOpD,CAAA,GAAe;YACtBqD,SAAA,EAAW/C;UACZ;UACDD,KAAA,EAAO;YACLjB,SAAA,EAAW6C;UACZ;QACX,IAEa;MACR;IACL;EACA;EAQMuB,EAAA,GAAO,SAAAC,CAAUrO,CAAA,EAAS;IAC9B,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,KAEL;MACLtC,IAAA,EAAM;MACN8O,OAAA,EAAAxM,CAAA;MACA,MAAM2K,GAAGrN,CAAA,EAAO;QACd,IAAIC,CAAA,EAAuBoB,CAAA;QAC3B,MAAM;YACJqL,SAAA,EAAAjL,CAAA;YACAqM,cAAA,EAAAnM,CAAA;YACAoM,KAAA,EAAAlM,CAAA;YACAgM,gBAAA,EAAA5J,CAAA;YACA4I,QAAA,EAAAV,CAAA;YACA6B,QAAA,EAAA5B;UACD,IAAGpM,CAAA;UACE;YACJgR,QAAA,EAAU3E,CAAA,GAAgB;YAC1BiE,SAAA,EAAWhE,CAAA,GAAiB;YAC5B2E,kBAAA,EAAoB1E,CAAA;YACpB2E,gBAAA,EAAA9G,CAAA,GAAmB;YACnB+G,yBAAA,EAAAjE,CAAA,GAA4B;YAC5BkE,aAAA,EAAAjE,CAAA,GAAgB;YAChB,GAAGC;UACX,IAAUtC,EAAA,CAASpI,CAAA,EAAS1C,CAAK;QAM3B,KAAKC,CAAA,GAAwB0B,CAAA,CAAeoO,KAAA,KAAU,QAAQ9P,CAAA,CAAsBiQ,eAAA,EAClF,OAAO;QAET,MAAM5C,CAAA,GAAOvC,EAAA,CAAQtJ,CAAS;UACxB8L,CAAA,GAAkBxC,EAAA,CAAQ9G,CAAgB,MAAMA,CAAA;UAChDuJ,CAAA,GAAM,OAAOrB,CAAA,CAASa,KAAA,IAAS,OAAO,SAASb,CAAA,CAASa,KAAA,CAAMZ,CAAA,CAASZ,QAAQ;UAC/EkC,CAAA,GAAqBnB,CAAA,KAAgCgB,CAAA,IAAmB,CAACJ,CAAA,GAAgB,CAAC1B,EAAA,CAAqBxH,CAAgB,CAAC,IAAIyH,EAAA,CAAsBzH,CAAgB;QAC5K,CAACsI,CAAA,IAA+BW,CAAA,KAA8B,UAChEQ,CAAA,CAAmB2D,IAAA,CAAK,GAAGxF,EAAA,CAA0B5H,CAAA,EAAkBkJ,CAAA,EAAeD,CAAA,EAA2BM,CAAG,CAAC;QAEvH,MAAMI,CAAA,GAAa,CAAC3J,CAAA,EAAkB,GAAGyJ,CAAkB;UACrD0B,CAAA,GAAW,MAAMnB,EAAA,CAAejO,CAAA,EAAOoN,CAAqB;UAC5DiC,CAAA,GAAY;QAClB,IAAIC,CAAA,KAAkBjO,CAAA,GAAuBM,CAAA,CAAeoP,IAAA,KAAS,OAAO,SAAS1P,CAAA,CAAqBsP,SAAA,KAAc;QAIxH,IAHItE,CAAA,IACFgD,CAAA,CAAUgC,IAAA,CAAKjC,CAAA,CAAS9B,CAAI,CAAC,GAE3BhB,CAAA,EAAgB;UAClB,MAAMoD,CAAA,GAAQpE,EAAA,CAAkB7J,CAAA,EAAWI,CAAA,EAAO2L,CAAG;UACrD6B,CAAA,CAAUgC,IAAA,CAAKjC,CAAA,CAASM,CAAA,CAAM,CAAC,CAAC,GAAGN,CAAA,CAASM,CAAA,CAAM,CAAC,CAAC,CAAC;QACtD;QAOD,IANAJ,CAAA,GAAgB,CAAC,GAAGA,CAAA,EAAe;UACjC5C,SAAA,EAAAjL,CAAA;UACAkP,SAAA,EAAAtB;QACR,CAAO,GAGG,CAACA,CAAA,CAAUwB,KAAA,CAAMnB,CAAA,IAAQA,CAAA,IAAQ,CAAC,GAAG;UACvC,IAAIH,CAAA,EAAuBC,CAAA;UAC3B,MAAME,CAAA,MAAeH,CAAA,GAAwB5N,CAAA,CAAeoP,IAAA,KAAS,OAAO,SAASxB,CAAA,CAAsBmB,KAAA,KAAU,KAAK;YACpHf,CAAA,GAAgB/B,CAAA,CAAW8B,CAAS;UAC1C,IAAIC,CAAA,EAEF,OAAO;YACLlC,IAAA,EAAM;cACJiD,KAAA,EAAOhB,CAAA;cACPiB,SAAA,EAAWrB;YACZ;YACD3B,KAAA,EAAO;cACLjB,SAAA,EAAWiD;YACZ;UACb;UAKQ,IAAIC,CAAA,IAAkBJ,CAAA,GAAwBF,CAAA,CAAcxC,MAAA,CAAO+C,CAAA,IAAKA,CAAA,CAAEc,SAAA,CAAU,CAAC,KAAK,CAAC,EAAEC,IAAA,CAAK,CAACf,CAAA,EAAGC,EAAA,KAAMD,CAAA,CAAEc,SAAA,CAAU,CAAC,IAAIb,EAAA,CAAEa,SAAA,CAAU,CAAC,CAAC,EAAE,CAAC,MAAM,OAAO,SAASnB,CAAA,CAAsB9C,SAAA;UAG1L,IAAI,CAACkD,CAAA,EACH,QAAQxF,CAAA;YACN,KAAK;cACH;gBACE,IAAIqF,CAAA;gBACJ,MAAMI,CAAA,IAAaJ,CAAA,GAAwBH,CAAA,CAAcxD,GAAA,CAAIgE,EAAA,IAAK,CAACA,EAAA,CAAEpD,SAAA,EAAWoD,EAAA,CAAEa,SAAA,CAAU7D,MAAA,CAAOkD,EAAA,IAAYA,EAAA,GAAW,CAAC,EAAEhM,MAAA,CAAO,CAACgM,EAAA,EAAKsB,EAAA,KAAatB,EAAA,GAAMsB,EAAA,EAAU,CAAC,CAAC,CAAC,EAAEV,IAAA,CAAK,CAACd,EAAA,EAAGE,EAAA,KAAMF,EAAA,CAAE,CAAC,IAAIE,EAAA,CAAE,CAAC,CAAC,EAAE,CAAC,MAAM,OAAO,SAASP,CAAA,CAAsB,CAAC;gBAClPI,CAAA,KACFD,CAAA,GAAiBC,CAAA;gBAEnB;cACD;YACH,KAAK;cACHD,CAAA,GAAiB3L,CAAA;cACjB;UACH;UAEH,IAAIxC,CAAA,KAAcmO,CAAA,EAChB,OAAO;YACLjC,KAAA,EAAO;cACLjB,SAAA,EAAWkD;YACZ;UACb;QAEO;QACD,OAAO;MACR;IACL;EACA;AAEA,SAAS2B,GAAe7O,CAAA,EAAU1C,CAAA,EAAM;EACtC,OAAO;IACLyK,GAAA,EAAK/H,CAAA,CAAS+H,GAAA,GAAMzK,CAAA,CAAK2G,MAAA;IACzB4D,KAAA,EAAO7H,CAAA,CAAS6H,KAAA,GAAQvK,CAAA,CAAK4G,KAAA;IAC7B4D,MAAA,EAAQ9H,CAAA,CAAS8H,MAAA,GAASxK,CAAA,CAAK2G,MAAA;IAC/B2D,IAAA,EAAM5H,CAAA,CAAS4H,IAAA,GAAOtK,CAAA,CAAK4G;EAC/B;AACA;AACA,SAAS4K,GAAsB9O,CAAA,EAAU;EACvC,OAAO2G,EAAA,CAAMrD,IAAA,CAAKhG,CAAA,IAAQ0C,CAAA,CAAS1C,CAAI,KAAK,CAAC;AAC/C;AAMA,MAAMyR,EAAA,GAAO,SAAAC,CAAUhP,CAAA,EAAS;EAC9B,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,KAEL;IACLtC,IAAA,EAAM;IACN8O,OAAA,EAAAxM,CAAA;IACA,MAAM2K,GAAGrN,CAAA,EAAO;MACd,MAAM;UACJ+N,KAAA,EAAA9N;QACD,IAAGD,CAAA;QACE;UACJ2M,QAAA,EAAAtL,CAAA,GAAW;UACX,GAAGI;QACX,IAAUqJ,EAAA,CAASpI,CAAA,EAAS1C,CAAK;MAC3B,QAAQqB,CAAA;QACN,KAAK;UACH;YACE,MAAMM,CAAA,GAAW,MAAMsM,EAAA,CAAejO,CAAA,EAAO;gBAC3C,GAAGyB,CAAA;gBACH2M,cAAA,EAAgB;cAC9B,CAAa;cACKvM,CAAA,GAAU0P,EAAA,CAAe5P,CAAA,EAAU1B,CAAA,CAAMsL,SAAS;YACxD,OAAO;cACLkC,IAAA,EAAM;gBACJkE,sBAAA,EAAwB9P,CAAA;gBACxB+P,eAAA,EAAiBJ,EAAA,CAAsB3P,CAAO;cAC/C;YACf;UACW;QACH,KAAK;UACH;YACE,MAAMF,CAAA,GAAW,MAAMsM,EAAA,CAAejO,CAAA,EAAO;gBAC3C,GAAGyB,CAAA;gBACH4M,WAAA,EAAa;cAC3B,CAAa;cACKxM,CAAA,GAAU0P,EAAA,CAAe5P,CAAA,EAAU1B,CAAA,CAAMuL,QAAQ;YACvD,OAAO;cACLiC,IAAA,EAAM;gBACJoE,cAAA,EAAgBhQ,CAAA;gBAChBiQ,OAAA,EAASN,EAAA,CAAsB3P,CAAO;cACvC;YACf;UACW;QACH;UAEI,OAAO;MAEZ;IACF;EACL;AACA;AAEA,SAASkQ,GAAgBrP,CAAA,EAAO;EAC9B,MAAM1C,CAAA,GAAOyJ,EAAA,CAAI,GAAG/G,CAAA,CAAMoJ,GAAA,CAAInK,CAAA,IAAQA,CAAA,CAAK2I,IAAI,CAAC;IAC1CrK,CAAA,GAAOwJ,EAAA,CAAI,GAAG/G,CAAA,CAAMoJ,GAAA,CAAInK,CAAA,IAAQA,CAAA,CAAK8I,GAAG,CAAC;IACzCpJ,CAAA,GAAOuI,EAAA,CAAI,GAAGlH,CAAA,CAAMoJ,GAAA,CAAInK,CAAA,IAAQA,CAAA,CAAK4I,KAAK,CAAC;IAC3C9I,CAAA,GAAOmI,EAAA,CAAI,GAAGlH,CAAA,CAAMoJ,GAAA,CAAInK,CAAA,IAAQA,CAAA,CAAK6I,MAAM,CAAC;EAClD,OAAO;IACLL,CAAA,EAAGnK,CAAA;IACHoK,CAAA,EAAGnK,CAAA;IACH2G,KAAA,EAAOvF,CAAA,GAAOrB,CAAA;IACd2G,MAAA,EAAQlF,CAAA,GAAOxB;EACnB;AACA;AACA,SAAS+R,GAAetP,CAAA,EAAO;EAC7B,MAAM1C,CAAA,GAAc0C,CAAA,CAAMe,KAAA,CAAK,EAAGmN,IAAA,CAAK,CAACnP,CAAA,EAAGE,CAAA,KAAMF,CAAA,CAAE2I,CAAA,GAAIzI,CAAA,CAAEyI,CAAC;IACpDnK,CAAA,GAAS;EACf,IAAIoB,CAAA,GAAW;EACf,SAASI,CAAA,GAAI,GAAGA,CAAA,GAAIzB,CAAA,CAAYM,MAAA,EAAQmB,CAAA,IAAK;IAC3C,MAAME,CAAA,GAAO3B,CAAA,CAAYyB,CAAC;IACtB,CAACJ,CAAA,IAAYM,CAAA,CAAKyI,CAAA,GAAI/I,CAAA,CAAS+I,CAAA,GAAI/I,CAAA,CAASsF,MAAA,GAAS,IACvD1G,CAAA,CAAOoR,IAAA,CAAK,CAAC1P,CAAI,CAAC,IAElB1B,CAAA,CAAOA,CAAA,CAAOK,MAAA,GAAS,CAAC,EAAE+Q,IAAA,CAAK1P,CAAI,GAErCN,CAAA,GAAWM,CAAA;EACZ;EACD,OAAO1B,CAAA,CAAO6L,GAAA,CAAIrK,CAAA,IAAQwK,EAAA,CAAiB8F,EAAA,CAAgBtQ,CAAI,CAAC,CAAC;AACnE;AAMA,MAAMwQ,EAAA,GAAS,SAAAC,CAAUxP,CAAA,EAAS;EAChC,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,KAEL;IACLtC,IAAA,EAAM;IACN8O,OAAA,EAAAxM,CAAA;IACA,MAAM2K,GAAGrN,CAAA,EAAO;MACd,MAAM;UACJ0M,SAAA,EAAAzM,CAAA;UACA+N,QAAA,EAAA3M,CAAA;UACA0M,KAAA,EAAAtM,CAAA;UACAoL,QAAA,EAAAlL,CAAA;UACAgL,QAAA,EAAA9K;QACD,IAAG7B,CAAA;QAIE;UACJsO,OAAA,EAAArK,CAAA,GAAU;UACVkG,CAAA,EAAAgC,CAAA;UACA/B,CAAA,EAAAgC;QACR,IAAUtB,EAAA,CAASpI,CAAA,EAAS1C,CAAK;QACrBqM,CAAA,GAAoB1J,KAAA,CAAMnB,IAAA,CAAM,QAAOG,CAAA,CAASwQ,cAAA,IAAkB,OAAO,SAASxQ,CAAA,CAASwQ,cAAA,CAAe9Q,CAAA,CAASkK,SAAS,OAAO,EAAE;QACrIe,CAAA,GAAc0F,EAAA,CAAe3F,CAAiB;QAC9CE,CAAA,GAAWN,EAAA,CAAiB8F,EAAA,CAAgB1F,CAAiB,CAAC;QAC9DjC,CAAA,GAAgB4B,EAAA,CAAiB/H,CAAO;MAC9C,SAASiJ,EAAA,EAAwB;QAE/B,IAAIZ,CAAA,CAAYhM,MAAA,KAAW,KAAKgM,CAAA,CAAY,CAAC,EAAEhC,IAAA,GAAOgC,CAAA,CAAY,CAAC,EAAE/B,KAAA,IAAS4B,CAAA,IAAK,QAAQC,CAAA,IAAK,MAE9F,OAAOE,CAAA,CAAY8F,IAAA,CAAKhF,CAAA,IAAQjB,CAAA,GAAIiB,CAAA,CAAK9C,IAAA,GAAOF,CAAA,CAAcE,IAAA,IAAQ6B,CAAA,GAAIiB,CAAA,CAAK7C,KAAA,GAAQH,CAAA,CAAcG,KAAA,IAAS6B,CAAA,GAAIgB,CAAA,CAAK3C,GAAA,GAAML,CAAA,CAAcK,GAAA,IAAO2B,CAAA,GAAIgB,CAAA,CAAK5C,MAAA,GAASJ,CAAA,CAAcI,MAAM,KAAK+B,CAAA;QAI/L,IAAID,CAAA,CAAYhM,MAAA,IAAU,GAAG;UAC3B,IAAI6K,EAAA,CAAYlL,CAAS,MAAM,KAAK;YAClC,MAAMuP,CAAA,GAAYlD,CAAA,CAAY,CAAC;cACzBmD,CAAA,GAAWnD,CAAA,CAAYA,CAAA,CAAYhM,MAAA,GAAS,CAAC;cAC7CoP,CAAA,GAAQ3E,EAAA,CAAQ9K,CAAS,MAAM;cAC/B0P,CAAA,GAAMH,CAAA,CAAU/E,GAAA;cAChBmF,CAAA,GAASH,CAAA,CAASjF,MAAA;cAClBqF,CAAA,GAAOH,CAAA,GAAQF,CAAA,CAAUlF,IAAA,GAAOmF,CAAA,CAASnF,IAAA;cACzCwF,EAAA,GAAQJ,CAAA,GAAQF,CAAA,CAAUjF,KAAA,GAAQkF,CAAA,CAASlF,KAAA;cAC3CyF,EAAA,GAAQF,EAAA,GAAQD,CAAA;cAChByB,EAAA,GAAS1B,CAAA,GAASD,CAAA;YACxB,OAAO;cACLlF,GAAA,EAAAkF,CAAA;cACAnF,MAAA,EAAAoF,CAAA;cACAtF,IAAA,EAAAuF,CAAA;cACAtF,KAAA,EAAAuF,EAAA;cACAlJ,KAAA,EAAAoJ,EAAA;cACArJ,MAAA,EAAA2K,EAAA;cACAnH,CAAA,EAAG0F,CAAA;cACHzF,CAAA,EAAGuF;YACjB;UACW;UACD,MAAMvC,CAAA,GAAarC,EAAA,CAAQ9K,CAAS,MAAM;YACpCqN,CAAA,GAAW1D,EAAA,CAAI,GAAG0C,CAAA,CAAYR,GAAA,CAAI0D,CAAA,IAAQA,CAAA,CAAKjF,KAAK,CAAC;YACrDgD,CAAA,GAAU9D,EAAA,CAAI,GAAG6C,CAAA,CAAYR,GAAA,CAAI0D,CAAA,IAAQA,CAAA,CAAKlF,IAAI,CAAC;YACnDkD,CAAA,GAAelB,CAAA,CAAYQ,MAAA,CAAO0C,CAAA,IAAQpC,CAAA,GAAaoC,CAAA,CAAKlF,IAAA,KAASiD,CAAA,GAAUiC,CAAA,CAAKjF,KAAA,KAAU+C,CAAQ;YACtGI,CAAA,GAAMF,CAAA,CAAa,CAAC,EAAE/C,GAAA;YACtBmD,CAAA,GAASJ,CAAA,CAAaA,CAAA,CAAalN,MAAA,GAAS,CAAC,EAAEkK,MAAA;YAC/C4E,CAAA,GAAO7B,CAAA;YACP8B,CAAA,GAAQ/B,CAAA;YACRgC,CAAA,GAAQD,CAAA,GAAQD,CAAA;YAChBG,CAAA,GAAS3B,CAAA,GAASF,CAAA;UACxB,OAAO;YACLjD,GAAA,EAAAiD,CAAA;YACAlD,MAAA,EAAAoD,CAAA;YACAtD,IAAA,EAAA8E,CAAA;YACA7E,KAAA,EAAA8E,CAAA;YACAzI,KAAA,EAAA0I,CAAA;YACA3I,MAAA,EAAA4I,CAAA;YACApF,CAAA,EAAGiF,CAAA;YACHhF,CAAA,EAAGsD;UACf;QACS;QACD,OAAOnB,CAAA;MACR;MACD,MAAMY,CAAA,GAAa,MAAMxL,CAAA,CAASsL,eAAA,CAAgB;QAChD1B,SAAA,EAAW;UACT3F,qBAAA,EAAAsH;QACD;QACD1B,QAAA,EAAUnK,CAAA,CAASmK,QAAA;QACnBmB,QAAA,EAAA9K;MACR,CAAO;MACD,OAAIJ,CAAA,CAAM8J,SAAA,CAAUpB,CAAA,KAAMgD,CAAA,CAAW5B,SAAA,CAAUpB,CAAA,IAAK1I,CAAA,CAAM8J,SAAA,CAAUnB,CAAA,KAAM+C,CAAA,CAAW5B,SAAA,CAAUnB,CAAA,IAAK3I,CAAA,CAAM8J,SAAA,CAAU3E,KAAA,KAAUuG,CAAA,CAAW5B,SAAA,CAAU3E,KAAA,IAASnF,CAAA,CAAM8J,SAAA,CAAU5E,MAAA,KAAWwG,CAAA,CAAW5B,SAAA,CAAU5E,MAAA,GACnM;QACLgH,KAAA,EAAO;UACLI,KAAA,EAAOZ;QACR;MACX,IAEa;IACR;EACL;AACA;AAIA,eAAekF,GAAqB3P,CAAA,EAAO1C,CAAA,EAAS;EAClD,MAAM;MACJ0M,SAAA,EAAAzM,CAAA;MACA4M,QAAA,EAAAxL,CAAA;MACA2M,QAAA,EAAAvM;IACD,IAAGiB,CAAA;IACEf,CAAA,GAAM,OAAON,CAAA,CAAS2L,KAAA,IAAS,OAAO,SAAS3L,CAAA,CAAS2L,KAAA,CAAMvL,CAAA,CAAS+J,QAAQ;IAC/E3J,CAAA,GAAOkJ,EAAA,CAAQ9K,CAAS;IACxBgE,CAAA,GAAY+G,EAAA,CAAa/K,CAAS;IAClCkM,CAAA,GAAahB,EAAA,CAAYlL,CAAS,MAAM;IACxCmM,CAAA,GAAgB,CAAC,QAAQ,KAAK,EAAEhB,QAAA,CAASvJ,CAAI,IAAI,KAAK;IACtDwK,CAAA,GAAiB1K,CAAA,IAAOwK,CAAA,GAAa,KAAK;IAC1CG,CAAA,GAAWxB,EAAA,CAAS9K,CAAA,EAAS0C,CAAK;EAGxC,IAAI;IACFsO,QAAA,EAAAzE,CAAA;IACA+D,SAAA,EAAAlG,CAAA;IACAkI,aAAA,EAAApF;EACJ,IAAM,OAAOZ,CAAA,IAAa,WAAW;IACjC0E,QAAA,EAAU1E,CAAA;IACVgE,SAAA,EAAW;IACXgC,aAAA,EAAe;EACnB,IAAM;IACFtB,QAAA,EAAU;IACVV,SAAA,EAAW;IACXgC,aAAA,EAAe;IACf,GAAGhG;EACP;EACE,OAAIrI,CAAA,IAAa,OAAOiJ,CAAA,IAAkB,aACxC9C,CAAA,GAAYnG,CAAA,KAAc,QAAQiJ,CAAA,GAAgB,KAAKA,CAAA,GAElDf,CAAA,GAAa;IAClBhC,CAAA,EAAGC,CAAA,GAAYiC,CAAA;IACfjC,CAAA,EAAGmC,CAAA,GAAWH;EAClB,IAAM;IACFjC,CAAA,EAAGoC,CAAA,GAAWH,CAAA;IACdhC,CAAA,EAAGA,CAAA,GAAYiC;EACnB;AACA;AASA,MAAMkG,EAAA,GAAS,SAAAC,CAAU9P,CAAA,EAAS;IAChC,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,IAEL;MACLtC,IAAA,EAAM;MACN8O,OAAA,EAAAxM,CAAA;MACA,MAAM2K,GAAGrN,CAAA,EAAO;QACd,MAAM;YACJmK,CAAA,EAAAlK,CAAA;YACAmK,CAAA,EAAA/I;UACD,IAAGrB,CAAA;UACEyB,CAAA,GAAa,MAAM4Q,EAAA,CAAqBrS,CAAA,EAAO0C,CAAO;QAC5D,OAAO;UACLyH,CAAA,EAAGlK,CAAA,GAAIwB,CAAA,CAAW0I,CAAA;UAClBC,CAAA,EAAG/I,CAAA,GAAII,CAAA,CAAW2I,CAAA;UAClBqD,IAAA,EAAMhM;QACd;MACK;IACL;EACA;EAOMgR,EAAA,GAAQ,SAAAC,CAAUhQ,CAAA,EAAS;IAC/B,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,KAEL;MACLtC,IAAA,EAAM;MACN8O,OAAA,EAAAxM,CAAA;MACA,MAAM2K,GAAGrN,CAAA,EAAO;QACd,MAAM;YACJmK,CAAA,EAAAlK,CAAA;YACAmK,CAAA,EAAA/I,CAAA;YACAqL,SAAA,EAAAjL;UACD,IAAGzB,CAAA;UACE;YACJgR,QAAA,EAAUrP,CAAA,GAAgB;YAC1B2O,SAAA,EAAWzO,CAAA,GAAiB;YAC5B8Q,OAAA,EAAA1O,CAAA,GAAU;cACRoJ,EAAA,EAAID,CAAA,IAAQ;gBACV,IAAI;kBACFjD,CAAA,EAAAmD,CAAA;kBACAlD,CAAA,EAAAmD;gBACD,IAAGH,CAAA;gBACJ,OAAO;kBACLjD,CAAA,EAAAmD,CAAA;kBACAlD,CAAA,EAAAmD;gBACd;cACW;YACF;YACD,GAAGpB;UACX,IAAUrB,EAAA,CAASpI,CAAA,EAAS1C,CAAK;UACrBoM,CAAA,GAAS;YACbjC,CAAA,EAAAlK,CAAA;YACAmK,CAAA,EAAA/I;UACR;UACYgL,CAAA,GAAW,MAAM4B,EAAA,CAAejO,CAAA,EAAOmM,CAAqB;UAC5DG,CAAA,GAAYnB,EAAA,CAAYJ,EAAA,CAAQtJ,CAAS,CAAC;UAC1C8K,CAAA,GAAWtB,EAAA,CAAgBqB,CAAS;QAC1C,IAAIlC,CAAA,GAAgBgC,CAAA,CAAOG,CAAQ;UAC/BW,CAAA,GAAiBd,CAAA,CAAOE,CAAS;QACrC,IAAI3K,CAAA,EAAe;UACjB,MAAMyL,CAAA,GAAUb,CAAA,KAAa,MAAM,QAAQ;YACrCe,CAAA,GAAUf,CAAA,KAAa,MAAM,WAAW;YACxCgB,CAAA,GAAMnD,CAAA,GAAgBiC,CAAA,CAASe,CAAO;YACtCI,CAAA,GAAMpD,CAAA,GAAgBiC,CAAA,CAASiB,CAAO;UAC5ClD,CAAA,GAAgBS,EAAA,CAAM0C,CAAA,EAAKnD,CAAA,EAAeoD,CAAG;QAC9C;QACD,IAAI3L,CAAA,EAAgB;UAClB,MAAMuL,CAAA,GAAUd,CAAA,KAAc,MAAM,QAAQ;YACtCgB,CAAA,GAAUhB,CAAA,KAAc,MAAM,WAAW;YACzCiB,CAAA,GAAML,CAAA,GAAiBb,CAAA,CAASe,CAAO;YACvCI,CAAA,GAAMN,CAAA,GAAiBb,CAAA,CAASiB,CAAO;UAC7CJ,CAAA,GAAiBrC,EAAA,CAAM0C,CAAA,EAAKL,CAAA,EAAgBM,CAAG;QAChD;QACD,MAAML,CAAA,GAAgBlJ,CAAA,CAAQoJ,EAAA,CAAG;UAC/B,GAAGrN,CAAA;UACH,CAACuM,CAAQ,GAAGnC,CAAA;UACZ,CAACkC,CAAS,GAAGY;QACrB,CAAO;QACD,OAAO;UACL,GAAGC,CAAA;UACHM,IAAA,EAAM;YACJtD,CAAA,EAAGgD,CAAA,CAAchD,CAAA,GAAIlK,CAAA;YACrBmK,CAAA,EAAG+C,CAAA,CAAc/C,CAAA,GAAI/I;UACtB;QACT;MACK;IACL;EACA;EA4EMuR,EAAA,GAAO,SAAAC,CAAUnQ,CAAA,EAAS;IAC9B,OAAIA,CAAA,KAAY,WACdA,CAAA,GAAU,KAEL;MACLtC,IAAA,EAAM;MACN8O,OAAA,EAAAxM,CAAA;MACA,MAAM2K,GAAGrN,CAAA,EAAO;QACd,MAAM;YACJ0M,SAAA,EAAAzM,CAAA;YACA8N,KAAA,EAAA1M,CAAA;YACAwL,QAAA,EAAApL,CAAA;YACAuM,QAAA,EAAArM;UACD,IAAG3B,CAAA;UACE;YACJ8S,KAAA,EAAAjR,CAAA,GAAQiR,CAAA,KAAM,CAAE;YAChB,GAAG7O;UACX,IAAU6G,EAAA,CAASpI,CAAA,EAAS1C,CAAK;UACrBmM,CAAA,GAAW,MAAM8B,EAAA,CAAejO,CAAA,EAAOiE,CAAqB;UAC5DmI,CAAA,GAAOrB,EAAA,CAAQ9K,CAAS;UACxBoM,CAAA,GAAYrB,EAAA,CAAa/K,CAAS;UAClCqM,CAAA,GAAUnB,EAAA,CAAYlL,CAAS,MAAM;UACrC;YACJ2G,KAAA,EAAA2F,CAAA;YACA5F,MAAA,EAAAyD;UACR,IAAU/I,CAAA,CAAMmK,QAAA;QACV,IAAI0B,CAAA,EACAC,CAAA;QACAf,CAAA,KAAS,SAASA,CAAA,KAAS,YAC7Bc,CAAA,GAAad,CAAA,EACbe,CAAA,GAAYd,CAAA,MAAgB,QAAO5K,CAAA,CAASuL,KAAA,IAAS,OAAO,SAASvL,CAAA,CAASuL,KAAA,CAAMrL,CAAA,CAAS6J,QAAQ,MAAM,UAAU,SAAS,SAAS,YAEvI2B,CAAA,GAAYf,CAAA,EACZc,CAAA,GAAab,CAAA,KAAc,QAAQ,QAAQ;QAE7C,MAAMe,CAAA,GAA0BhD,CAAA,GAAS+B,CAAA,CAASe,CAAU;UACtDI,CAAA,GAAyBf,CAAA,GAAQJ,CAAA,CAASgB,CAAS;UACnDI,CAAA,GAAU,CAACvN,CAAA,CAAM8N,cAAA,CAAe4E,KAAA;QACtC,IAAIlF,CAAA,GAAkBJ,CAAA;UAClBM,CAAA,GAAiBJ,CAAA;QACrB,IAAIhB,CAAA,EAAS;UACX,MAAM8C,CAAA,GAAuB7C,CAAA,GAAQJ,CAAA,CAAS7B,IAAA,GAAO6B,CAAA,CAAS5B,KAAA;UAC9DmD,CAAA,GAAiBrB,CAAA,IAAakB,CAAA,GAAU9D,EAAA,CAAI6D,CAAA,EAAwB8B,CAAoB,IAAIA,CAAA;QACpG,OAAa;UACL,MAAMA,CAAA,GAAwBhF,CAAA,GAAS+B,CAAA,CAAS1B,GAAA,GAAM0B,CAAA,CAAS3B,MAAA;UAC/DgD,CAAA,GAAkBnB,CAAA,IAAakB,CAAA,GAAU9D,EAAA,CAAI2D,CAAA,EAAyBgC,CAAqB,IAAIA,CAAA;QAChG;QACD,IAAI7B,CAAA,IAAW,CAAClB,CAAA,EAAW;UACzB,MAAM+C,CAAA,GAAOxF,EAAA,CAAIuC,CAAA,CAAS7B,IAAA,EAAM,CAAC;YAC3B+E,CAAA,GAAOzF,EAAA,CAAIuC,CAAA,CAAS5B,KAAA,EAAO,CAAC;YAC5B+E,CAAA,GAAO1F,EAAA,CAAIuC,CAAA,CAAS1B,GAAA,EAAK,CAAC;YAC1B8E,CAAA,GAAO3F,EAAA,CAAIuC,CAAA,CAAS3B,MAAA,EAAQ,CAAC;UAC/B8B,CAAA,GACFoB,CAAA,GAAiBnB,CAAA,GAAQ,KAAK6C,CAAA,KAAS,KAAKC,CAAA,KAAS,IAAID,CAAA,GAAOC,CAAA,GAAOzF,EAAA,CAAIuC,CAAA,CAAS7B,IAAA,EAAM6B,CAAA,CAAS5B,KAAK,KAExGiD,CAAA,GAAkBpD,CAAA,GAAS,KAAKkF,CAAA,KAAS,KAAKC,CAAA,KAAS,IAAID,CAAA,GAAOC,CAAA,GAAO3F,EAAA,CAAIuC,CAAA,CAAS1B,GAAA,EAAK0B,CAAA,CAAS3B,MAAM;QAE7G;QACD,MAAM3I,CAAA,CAAM;UACV,GAAG7B,CAAA;UACH+S,cAAA,EAAArF,CAAA;UACAsF,eAAA,EAAAxF;QACR,CAAO;QACD,MAAMI,CAAA,GAAiB,MAAMnM,CAAA,CAAS0N,aAAA,CAAcxN,CAAA,CAAS6J,QAAQ;QACrE,OAAIe,CAAA,KAAUqB,CAAA,CAAehH,KAAA,IAASwD,CAAA,KAAWwD,CAAA,CAAejH,MAAA,GACvD;UACLgH,KAAA,EAAO;YACLI,KAAA,EAAO;UACR;QACX,IAEa;MACR;IACL;EACA;ACh/BA,SAASkF,GAAYvQ,CAAA,EAAM;EACzB,OAAIwQ,EAAA,CAAOxQ,CAAI,KACLA,CAAA,CAAKyQ,QAAA,IAAY,IAAIlL,WAAA,CAAW,IAKnC;AACT;AACA,SAASmL,GAAU1Q,CAAA,EAAM;EACvB,IAAI1C,CAAA;EACJ,QAAQ0C,CAAA,IAAQ,SAAiB1C,CAAA,GAAsB0C,CAAA,CAAK2Q,aAAA,KAAkB,OAAvD,SAAuErT,CAAA,CAAoBsT,WAAA,KAAgBnP,MAAA;AACpI;AACA,SAASoP,GAAmB7Q,CAAA,EAAM;EAChC,IAAI1C,CAAA;EACJ,QAAQA,CAAA,IAAQkT,EAAA,CAAOxQ,CAAI,IAAIA,CAAA,CAAK2Q,aAAA,GAAgB3Q,CAAA,CAAK2B,QAAA,KAAaF,MAAA,CAAOE,QAAA,KAAa,OAAO,SAASrE,CAAA,CAAKwT,eAAA;AACjH;AACA,SAASN,GAAOxQ,CAAA,EAAO;EACrB,OAAOA,CAAA,YAAiB+C,IAAA,IAAQ/C,CAAA,YAAiB0Q,EAAA,CAAU1Q,CAAK,EAAE+C,IAAA;AACpE;AACA,SAASgO,GAAU/Q,CAAA,EAAO;EACxB,OAAOA,CAAA,YAAiB6B,OAAA,IAAW7B,CAAA,YAAiB0Q,EAAA,CAAU1Q,CAAK,EAAE6B,OAAA;AACvE;AACA,SAASmP,GAAchR,CAAA,EAAO;EAC5B,OAAOA,CAAA,YAAiBiR,WAAA,IAAejR,CAAA,YAAiB0Q,EAAA,CAAU1Q,CAAK,EAAEiR,WAAA;AAC3E;AACA,SAASC,GAAalR,CAAA,EAAO;EAE3B,OAAI,OAAOmR,UAAA,GAAe,MACjB,KAEFnR,CAAA,YAAiBmR,UAAA,IAAcnR,CAAA,YAAiB0Q,EAAA,CAAU1Q,CAAK,EAAEmR,UAAA;AAC1E;AACA,SAASC,GAAkBpR,CAAA,EAAS;EAClC,MAAM;IACJqR,QAAA,EAAA/T,CAAA;IACAgU,SAAA,EAAA/T,CAAA;IACAgU,SAAA,EAAA5S,CAAA;IACA6S,OAAA,EAAAzS;EACJ,IAAM0S,EAAA,CAAiBzR,CAAO;EAC5B,OAAO,kCAAkC8E,IAAA,CAAKxH,CAAA,GAAWqB,CAAA,GAAYpB,CAAS,KAAK,CAAC,CAAC,UAAU,UAAU,EAAEmL,QAAA,CAAS3J,CAAO;AAC7H;AACA,SAAS2S,GAAe1R,CAAA,EAAS;EAC/B,OAAO,CAAC,SAAS,MAAM,IAAI,EAAE0I,QAAA,CAAS6H,EAAA,CAAYvQ,CAAO,CAAC;AAC5D;AACA,SAAS2R,GAAkB3R,CAAA,EAAS;EAClC,MAAM1C,CAAA,GAAS4B,EAAA;IACT3B,CAAA,GAAMkU,EAAA,CAAiBzR,CAAO;EAGpC,OAAOzC,CAAA,CAAIqU,SAAA,KAAc,UAAUrU,CAAA,CAAIsU,WAAA,KAAgB,WAAWtU,CAAA,CAAIuU,aAAA,GAAgBvU,CAAA,CAAIuU,aAAA,KAAkB,WAAW,OAAU,CAACxU,CAAA,KAAWC,CAAA,CAAIwU,cAAA,GAAiBxU,CAAA,CAAIwU,cAAA,KAAmB,SAAS,OAAU,CAACzU,CAAA,KAAWC,CAAA,CAAI6M,MAAA,GAAS7M,CAAA,CAAI6M,MAAA,KAAW,SAAS,OAAU,CAAC,aAAa,eAAe,QAAQ,EAAE9G,IAAA,CAAK3E,CAAA,KAAUpB,CAAA,CAAIyU,UAAA,IAAc,IAAItJ,QAAA,CAAS/J,CAAK,CAAC,KAAK,CAAC,SAAS,UAAU,UAAU,SAAS,EAAE2E,IAAA,CAAK3E,CAAA,KAAUpB,CAAA,CAAI0U,OAAA,IAAW,IAAIvJ,QAAA,CAAS/J,CAAK,CAAC;AACnc;AACA,SAASuT,GAAmBlS,CAAA,EAAS;EACnC,IAAI1C,CAAA,GAAc6U,EAAA,CAAcnS,CAAO;EACvC,OAAOgR,EAAA,CAAc1T,CAAW,KAAK,CAAC8U,EAAA,CAAsB9U,CAAW,IAAG;IACxE,IAAIqU,EAAA,CAAkBrU,CAAW,GAC/B,OAAOA,CAAA;IAEPA,CAAA,GAAc6U,EAAA,CAAc7U,CAAW;EAE1C;EACD,OAAO;AACT;AACA,SAAS4B,GAAA,EAAW;EAClB,OAAI,OAAOmT,GAAA,GAAQ,OAAe,CAACA,GAAA,CAAIC,QAAA,GAAiB,KACjDD,GAAA,CAAIC,QAAA,CAAS,2BAA2B,MAAM;AACvD;AACA,SAASF,GAAsBpS,CAAA,EAAM;EACnC,OAAO,CAAC,QAAQ,QAAQ,WAAW,EAAE0I,QAAA,CAAS6H,EAAA,CAAYvQ,CAAI,CAAC;AACjE;AACA,SAASyR,GAAiBzR,CAAA,EAAS;EACjC,OAAO0Q,EAAA,CAAU1Q,CAAO,EAAEgG,gBAAA,CAAiBhG,CAAO;AACpD;AACA,SAASuS,GAAcvS,CAAA,EAAS;EAC9B,OAAI+Q,EAAA,CAAU/Q,CAAO,IACZ;IACLwS,UAAA,EAAYxS,CAAA,CAAQwS,UAAA;IACpBC,SAAA,EAAWzS,CAAA,CAAQyS;EACzB,IAES;IACLD,UAAA,EAAYxS,CAAA,CAAQ0S,WAAA;IACpBD,SAAA,EAAWzS,CAAA,CAAQ2S;EACvB;AACA;AACA,SAASR,GAAcnS,CAAA,EAAM;EAC3B,IAAIuQ,EAAA,CAAYvQ,CAAI,MAAM,QACxB,OAAOA,CAAA;EAET,MAAM1C,CAAA;EAAA;EAEN0C,CAAA,CAAK4S,YAAA;EAAA;EAEL5S,CAAA,CAAK6F,UAAA;EAAA;EAELqL,EAAA,CAAalR,CAAI,KAAKA,CAAA,CAAK6S,IAAA;EAAA;EAE3BhC,EAAA,CAAmB7Q,CAAI;EACvB,OAAOkR,EAAA,CAAa5T,CAAM,IAAIA,CAAA,CAAOuV,IAAA,GAAOvV,CAAA;AAC9C;AACA,SAASwV,GAA2B9S,CAAA,EAAM;EACxC,MAAM1C,CAAA,GAAa6U,EAAA,CAAcnS,CAAI;EACrC,OAAIoS,EAAA,CAAsB9U,CAAU,IAC3B0C,CAAA,CAAK2Q,aAAA,GAAgB3Q,CAAA,CAAK2Q,aAAA,CAAcoC,IAAA,GAAO/S,CAAA,CAAK+S,IAAA,GAEzD/B,EAAA,CAAc1T,CAAU,KAAK8T,EAAA,CAAkB9T,CAAU,IACpDA,CAAA,GAEFwV,EAAA,CAA2BxV,CAAU;AAC9C;AACA,SAAS0V,GAAqBhT,CAAA,EAAM1C,CAAA,EAAMC,CAAA,EAAiB;EACzD,IAAIoB,CAAA;EACArB,CAAA,KAAS,WACXA,CAAA,GAAO,KAELC,CAAA,KAAoB,WACtBA,CAAA,GAAkB;EAEpB,MAAMwB,CAAA,GAAqB+T,EAAA,CAA2B9S,CAAI;IACpDf,CAAA,GAASF,CAAA,OAAyBJ,CAAA,GAAuBqB,CAAA,CAAK2Q,aAAA,KAAkB,OAAO,SAAShS,CAAA,CAAqBoU,IAAA;IACrH5T,CAAA,GAAMuR,EAAA,CAAU3R,CAAkB;EACxC,OAAIE,CAAA,GACK3B,CAAA,CAAKwJ,MAAA,CAAO3H,CAAA,EAAKA,CAAA,CAAI8T,cAAA,IAAkB,EAAE,EAAE7B,EAAA,CAAkBrS,CAAkB,IAAIA,CAAA,GAAqB,IAAII,CAAA,CAAI+T,YAAA,IAAgB3V,CAAA,GAAkByV,EAAA,CAAqB7T,CAAA,CAAI+T,YAAY,IAAI,EAAE,IAE/L5V,CAAA,CAAKwJ,MAAA,CAAO/H,CAAA,EAAoBiU,EAAA,CAAqBjU,CAAA,EAAoB,EAAE,EAAExB,CAAe,CAAC;AACtG;ACvHA,SAAS4V,GAAiBnT,CAAA,EAAS;EACjC,MAAM1C,CAAA,GAAMmU,EAAA,CAAiBzR,CAAO;EAGpC,IAAIzC,CAAA,GAAQ6V,UAAA,CAAW9V,CAAA,CAAI4G,KAAK,KAAK;IACjCvF,CAAA,GAASyU,UAAA,CAAW9V,CAAA,CAAI2G,MAAM,KAAK;EACvC,MAAMlF,CAAA,GAAYiS,EAAA,CAAchR,CAAO;IACjCf,CAAA,GAAcF,CAAA,GAAYiB,CAAA,CAAQqT,WAAA,GAAc9V,CAAA;IAChD4B,CAAA,GAAeJ,CAAA,GAAYiB,CAAA,CAAQsT,YAAA,GAAe3U,CAAA;IAClD4C,CAAA,GAAiB6F,EAAA,CAAM7J,CAAK,MAAM0B,CAAA,IAAemI,EAAA,CAAMzI,CAAM,MAAMQ,CAAA;EACzE,OAAIoC,CAAA,KACFhE,CAAA,GAAQ0B,CAAA,EACRN,CAAA,GAASQ,CAAA,GAEJ;IACL+E,KAAA,EAAA3G,CAAA;IACA0G,MAAA,EAAAtF,CAAA;IACAgO,CAAA,EAAGpL;EACP;AACA;AAEA,SAASgS,GAAcvT,CAAA,EAAS;EAC9B,OAAQ+Q,EAAA,CAAU/Q,CAAO,IAA6BA,CAAA,GAAzBA,CAAA,CAAQgM,cAAA;AACvC;AAEA,SAASwH,GAASxT,CAAA,EAAS;EACzB,MAAM1C,CAAA,GAAaiW,EAAA,CAAcvT,CAAO;EACxC,IAAI,CAACgR,EAAA,CAAc1T,CAAU,GAC3B,OAAOkK,EAAA,CAAa,CAAC;EAEvB,MAAMjK,CAAA,GAAOD,CAAA,CAAW4F,qBAAA;IAClB;MACJgB,KAAA,EAAAvF,CAAA;MACAsF,MAAA,EAAAlF,CAAA;MACA4N,CAAA,EAAA1N;IACJ,IAAMkU,EAAA,CAAiB7V,CAAU;EAC/B,IAAI6B,CAAA,IAAKF,CAAA,GAAImI,EAAA,CAAM7J,CAAA,CAAK2G,KAAK,IAAI3G,CAAA,CAAK2G,KAAA,IAASvF,CAAA;IAC3C4C,CAAA,IAAKtC,CAAA,GAAImI,EAAA,CAAM7J,CAAA,CAAK0G,MAAM,IAAI1G,CAAA,CAAK0G,MAAA,IAAUlF,CAAA;EAIjD,QAAI,CAACI,CAAA,IAAK,CAACgH,MAAA,CAAOsN,QAAA,CAAStU,CAAC,OAC1BA,CAAA,GAAI,KAEF,CAACoC,CAAA,IAAK,CAAC4E,MAAA,CAAOsN,QAAA,CAASlS,CAAC,OAC1BA,CAAA,GAAI,IAEC;IACLkG,CAAA,EAAAtI,CAAA;IACAuI,CAAA,EAAAnG;EACJ;AACA;AAEA,MAAMmS,EAAA,GAAyB,eAAAlM,EAAA,CAAa,CAAC;AAC7C,SAASmM,GAAiB3T,CAAA,EAAS;EACjC,MAAM1C,CAAA,GAAMoT,EAAA,CAAU1Q,CAAO;EAC7B,OAAI,CAACd,EAAA,CAAQ,KAAM,CAAC5B,CAAA,CAAI2V,cAAA,GACfS,EAAA,GAEF;IACLjM,CAAA,EAAGnK,CAAA,CAAI2V,cAAA,CAAeW,UAAA;IACtBlM,CAAA,EAAGpK,CAAA,CAAI2V,cAAA,CAAeY;EAC1B;AACA;AACA,SAASC,GAAuB9T,CAAA,EAAS1C,CAAA,EAASC,CAAA,EAAsB;EAItE,OAHID,CAAA,KAAY,WACdA,CAAA,GAAU,KAER,CAACC,CAAA,IAAwBD,CAAA,IAAWC,CAAA,KAAyBmT,EAAA,CAAU1Q,CAAO,IACzE,KAEF1C,CAAA;AACT;AAEA,SAASyW,GAAsB/T,CAAA,EAAS1C,CAAA,EAAcC,CAAA,EAAiBoB,CAAA,EAAc;EAC/ErB,CAAA,KAAiB,WACnBA,CAAA,GAAe,KAEbC,CAAA,KAAoB,WACtBA,CAAA,GAAkB;EAEpB,MAAMwB,CAAA,GAAaiB,CAAA,CAAQkD,qBAAA;IACrBjE,CAAA,GAAasU,EAAA,CAAcvT,CAAO;EACxC,IAAIb,CAAA,GAAQqI,EAAA,CAAa,CAAC;EACtBlK,CAAA,KACEqB,CAAA,GACEoS,EAAA,CAAUpS,CAAY,MACxBQ,CAAA,GAAQqU,EAAA,CAAS7U,CAAY,KAG/BQ,CAAA,GAAQqU,EAAA,CAASxT,CAAO;EAG5B,MAAMuB,CAAA,GAAgBuS,EAAA,CAAuB7U,CAAA,EAAY1B,CAAA,EAAiBoB,CAAY,IAAIgV,EAAA,CAAiB1U,CAAU,IAAIuI,EAAA,CAAa,CAAC;EACvI,IAAIiC,CAAA,IAAK1K,CAAA,CAAW6I,IAAA,GAAOrG,CAAA,CAAckG,CAAA,IAAKtI,CAAA,CAAMsI,CAAA;IAChDiC,CAAA,IAAK3K,CAAA,CAAWgJ,GAAA,GAAMxG,CAAA,CAAcmG,CAAA,IAAKvI,CAAA,CAAMuI,CAAA;IAC/CiC,CAAA,GAAQ5K,CAAA,CAAWmF,KAAA,GAAQ/E,CAAA,CAAMsI,CAAA;IACjCmC,CAAA,GAAS7K,CAAA,CAAWkF,MAAA,GAAS9E,CAAA,CAAMuI,CAAA;EACvC,IAAIzI,CAAA,EAAY;IACd,MAAM4K,CAAA,GAAM6G,EAAA,CAAUzR,CAAU;MAC1ByI,CAAA,GAAY/I,CAAA,IAAgBoS,EAAA,CAAUpS,CAAY,IAAI+R,EAAA,CAAU/R,CAAY,IAAIA,CAAA;IACtF,IAAI6L,CAAA,GAAgBX,CAAA,CAAIqJ,YAAA;IACxB,OAAO1I,CAAA,IAAiB7L,CAAA,IAAgB+I,CAAA,KAAcmC,CAAA,GAAK;MACzD,MAAMY,CAAA,GAAc+I,EAAA,CAAShJ,CAAa;QACpCE,CAAA,GAAaF,CAAA,CAActH,qBAAA;QAC3B0H,CAAA,GAAM6G,EAAA,CAAiBjH,CAAa;QACpCK,CAAA,GAAOH,CAAA,CAAW9C,IAAA,IAAQ4C,CAAA,CAAcwJ,UAAA,GAAaZ,UAAA,CAAWxI,CAAA,CAAIqJ,WAAW,KAAKxJ,CAAA,CAAYhD,CAAA;QAChGqD,CAAA,GAAMJ,CAAA,CAAW3C,GAAA,IAAOyC,CAAA,CAAc0J,SAAA,GAAYd,UAAA,CAAWxI,CAAA,CAAIuJ,UAAU,KAAK1J,CAAA,CAAY/C,CAAA;MAClG+B,CAAA,IAAKgB,CAAA,CAAYhD,CAAA,EACjBiC,CAAA,IAAKe,CAAA,CAAY/C,CAAA,EACjBiC,CAAA,IAASc,CAAA,CAAYhD,CAAA,EACrBmC,CAAA,IAAUa,CAAA,CAAY/C,CAAA,EACtB+B,CAAA,IAAKoB,CAAA,EACLnB,CAAA,IAAKoB,CAAA,EACLN,CAAA,GAAgBkG,EAAA,CAAUlG,CAAa,EAAE0I,YAAA;IAC1C;EACF;EACD,OAAO3J,EAAA,CAAiB;IACtBrF,KAAA,EAAAyF,CAAA;IACA1F,MAAA,EAAA2F,CAAA;IACAnC,CAAA,EAAAgC,CAAA;IACA/B,CAAA,EAAAgC;EACJ,CAAG;AACH;AAEA,SAAS0K,GAAsDpU,CAAA,EAAM;EACnE,IAAI;IACFqM,IAAA,EAAA/O,CAAA;IACAgP,YAAA,EAAA/O,CAAA;IACA0M,QAAA,EAAAtL;EACD,IAAGqB,CAAA;EACJ,MAAMjB,CAAA,GAA0BiS,EAAA,CAAczT,CAAY;IACpD0B,CAAA,GAAkB4R,EAAA,CAAmBtT,CAAY;EACvD,IAAIA,CAAA,KAAiB0B,CAAA,EACnB,OAAO3B,CAAA;EAET,IAAI6B,CAAA,GAAS;MACXqT,UAAA,EAAY;MACZC,SAAA,EAAW;IACf;IACMlR,CAAA,GAAQiG,EAAA,CAAa,CAAC;EAC1B,MAAMiC,CAAA,GAAUjC,EAAA,CAAa,CAAC;EAC9B,KAAIzI,CAAA,IAA2B,CAACA,CAAA,IAA2BJ,CAAA,KAAa,cAClE4R,EAAA,CAAYhT,CAAY,MAAM,UAAU6T,EAAA,CAAkBnS,CAAe,OAC3EE,CAAA,GAASoT,EAAA,CAAchV,CAAY,IAEjCyT,EAAA,CAAczT,CAAY,IAAG;IAC/B,MAAMmM,CAAA,GAAaqK,EAAA,CAAsBxW,CAAY;IACrDgE,CAAA,GAAQiS,EAAA,CAASjW,CAAY,GAC7BkM,CAAA,CAAQhC,CAAA,GAAIiC,CAAA,CAAWjC,CAAA,GAAIlK,CAAA,CAAayW,UAAA,EACxCvK,CAAA,CAAQ/B,CAAA,GAAIgC,CAAA,CAAWhC,CAAA,GAAInK,CAAA,CAAa2W,SAAA;EACzC;EAEH,OAAO;IACLhQ,KAAA,EAAO5G,CAAA,CAAK4G,KAAA,GAAQ3C,CAAA,CAAMkG,CAAA;IAC1BxD,MAAA,EAAQ3G,CAAA,CAAK2G,MAAA,GAAS1C,CAAA,CAAMmG,CAAA;IAC5BD,CAAA,EAAGnK,CAAA,CAAKmK,CAAA,GAAIlG,CAAA,CAAMkG,CAAA,GAAItI,CAAA,CAAOqT,UAAA,GAAajR,CAAA,CAAMkG,CAAA,GAAIgC,CAAA,CAAQhC,CAAA;IAC5DC,CAAA,EAAGpK,CAAA,CAAKoK,CAAA,GAAInG,CAAA,CAAMmG,CAAA,GAAIvI,CAAA,CAAOsT,SAAA,GAAYlR,CAAA,CAAMmG,CAAA,GAAI+B,CAAA,CAAQ/B;EAC/D;AACA;AAEA,SAAS2M,GAAerU,CAAA,EAAS;EAC/B,OAAOC,KAAA,CAAMnB,IAAA,CAAKkB,CAAA,CAAQyP,cAAA,CAAgB;AAC5C;AAEA,SAAS6E,GAAoBtU,CAAA,EAAS;EAGpC,OAAO+T,EAAA,CAAsBlD,EAAA,CAAmB7Q,CAAO,CAAC,EAAE4H,IAAA,GAAO2K,EAAA,CAAcvS,CAAO,EAAEwS,UAAA;AAC1F;AAIA,SAAS+B,GAAgBvU,CAAA,EAAS;EAChC,MAAM1C,CAAA,GAAOuT,EAAA,CAAmB7Q,CAAO;IACjCzC,CAAA,GAASgV,EAAA,CAAcvS,CAAO;IAC9BrB,CAAA,GAAOqB,CAAA,CAAQ2Q,aAAA,CAAcoC,IAAA;IAC7BhU,CAAA,GAAQmI,EAAA,CAAI5J,CAAA,CAAKkX,WAAA,EAAalX,CAAA,CAAKmX,WAAA,EAAa9V,CAAA,CAAK6V,WAAA,EAAa7V,CAAA,CAAK8V,WAAW;IAClFxV,CAAA,GAASiI,EAAA,CAAI5J,CAAA,CAAKoX,YAAA,EAAcpX,CAAA,CAAKqX,YAAA,EAAchW,CAAA,CAAK+V,YAAA,EAAc/V,CAAA,CAAKgW,YAAY;EAC7F,IAAIxV,CAAA,GAAI,CAAC5B,CAAA,CAAOiV,UAAA,GAAa8B,EAAA,CAAoBtU,CAAO;EACxD,MAAMuB,CAAA,GAAI,CAAChE,CAAA,CAAOkV,SAAA;EAClB,OAAIhB,EAAA,CAAiB9S,CAAI,EAAEK,SAAA,KAAc,UACvCG,CAAA,IAAK+H,EAAA,CAAI5J,CAAA,CAAKmX,WAAA,EAAa9V,CAAA,CAAK8V,WAAW,IAAI1V,CAAA,GAE1C;IACLmF,KAAA,EAAAnF,CAAA;IACAkF,MAAA,EAAAhF,CAAA;IACAwI,CAAA,EAAAtI,CAAA;IACAuI,CAAA,EAAAnG;EACJ;AACA;AAEA,SAASqT,GAAgB5U,CAAA,EAAS1C,CAAA,EAAU;EAC1C,MAAMC,CAAA,GAAMmT,EAAA,CAAU1Q,CAAO;IACvBrB,CAAA,GAAOkS,EAAA,CAAmB7Q,CAAO;IACjCjB,CAAA,GAAiBxB,CAAA,CAAI0V,cAAA;EAC3B,IAAIhU,CAAA,GAAQN,CAAA,CAAK8V,WAAA;IACbtV,CAAA,GAASR,CAAA,CAAKgW,YAAA;IACdpT,CAAA,GAAI;IACJkI,CAAA,GAAI;EACR,IAAI1K,CAAA,EAAgB;IAClBE,CAAA,GAAQF,CAAA,CAAemF,KAAA,EACvB/E,CAAA,GAASJ,CAAA,CAAekF,MAAA;IACxB,MAAMyF,CAAA,GAAsBxK,EAAA;IAC5B,CAAI,CAACwK,CAAA,IAAuBA,CAAA,IAAuBpM,CAAA,KAAa,aAC9DiE,CAAA,GAAIxC,CAAA,CAAe6U,UAAA,EACnBnK,CAAA,GAAI1K,CAAA,CAAe8U,SAAA;EAEtB;EACD,OAAO;IACL3P,KAAA,EAAAjF,CAAA;IACAgF,MAAA,EAAA9E,CAAA;IACAsI,CAAA,EAAAlG,CAAA;IACAmG,CAAA,EAAA+B;EACJ;AACA;AAGA,SAASoL,GAA2B7U,CAAA,EAAS1C,CAAA,EAAU;EACrD,MAAMC,CAAA,GAAawW,EAAA,CAAsB/T,CAAA,EAAS,IAAM1C,CAAA,KAAa,OAAO;IACtEqB,CAAA,GAAMpB,CAAA,CAAWwK,GAAA,GAAM/H,CAAA,CAAQkU,SAAA;IAC/BnV,CAAA,GAAOxB,CAAA,CAAWqK,IAAA,GAAO5H,CAAA,CAAQgU,UAAA;IACjC/U,CAAA,GAAQ+R,EAAA,CAAchR,CAAO,IAAIwT,EAAA,CAASxT,CAAO,IAAIwH,EAAA,CAAa,CAAC;IACnErI,CAAA,GAAQa,CAAA,CAAQyU,WAAA,GAAcxV,CAAA,CAAMwI,CAAA;IACpClG,CAAA,GAASvB,CAAA,CAAQ2U,YAAA,GAAe1V,CAAA,CAAMyI,CAAA;IACtC+B,CAAA,GAAI1K,CAAA,GAAOE,CAAA,CAAMwI,CAAA;IACjBiC,CAAA,GAAI/K,CAAA,GAAMM,CAAA,CAAMyI,CAAA;EACtB,OAAO;IACLxD,KAAA,EAAA/E,CAAA;IACA8E,MAAA,EAAA1C,CAAA;IACAkG,CAAA,EAAAgC,CAAA;IACA/B,CAAA,EAAAgC;EACJ;AACA;AACA,SAASoL,GAAkC9U,CAAA,EAAS1C,CAAA,EAAkBC,CAAA,EAAU;EAC9E,IAAIoB,CAAA;EACJ,IAAIrB,CAAA,KAAqB,YACvBqB,CAAA,GAAOiW,EAAA,CAAgB5U,CAAA,EAASzC,CAAQ,WAC/BD,CAAA,KAAqB,YAC9BqB,CAAA,GAAO4V,EAAA,CAAgB1D,EAAA,CAAmB7Q,CAAO,CAAC,WACzC+Q,EAAA,CAAUzT,CAAgB,GACnCqB,CAAA,GAAOkW,EAAA,CAA2BvX,CAAA,EAAkBC,CAAQ,OACvD;IACL,MAAMwB,CAAA,GAAgB4U,EAAA,CAAiB3T,CAAO;IAC9CrB,CAAA,GAAO;MACL,GAAGrB,CAAA;MACHmK,CAAA,EAAGnK,CAAA,CAAiBmK,CAAA,GAAI1I,CAAA,CAAc0I,CAAA;MACtCC,CAAA,EAAGpK,CAAA,CAAiBoK,CAAA,GAAI3I,CAAA,CAAc2I;IAC5C;EACG;EACD,OAAO6B,EAAA,CAAiB5K,CAAI;AAC9B;AACA,SAASoW,GAAyB/U,CAAA,EAAS1C,CAAA,EAAU;EACnD,MAAMC,CAAA,GAAa4U,EAAA,CAAcnS,CAAO;EACxC,OAAIzC,CAAA,KAAeD,CAAA,IAAY,CAACyT,EAAA,CAAUxT,CAAU,KAAK6U,EAAA,CAAsB7U,CAAU,IAChF,KAEFkU,EAAA,CAAiBlU,CAAU,EAAEyX,QAAA,KAAa,WAAWD,EAAA,CAAyBxX,CAAA,EAAYD,CAAQ;AAC3G;AAKA,SAAS2X,GAA4BjV,CAAA,EAAS1C,CAAA,EAAO;EACnD,MAAMC,CAAA,GAAeD,CAAA,CAAM4X,GAAA,CAAIlV,CAAO;EACtC,IAAIzC,CAAA,EACF,OAAOA,CAAA;EAET,IAAIoB,CAAA,GAASqU,EAAA,CAAqBhT,CAAA,EAAS,IAAI,EAAK,EAAEoK,MAAA,CAAO7I,CAAA,IAAMwP,EAAA,CAAUxP,CAAE,KAAKgP,EAAA,CAAYhP,CAAE,MAAM,MAAM;IAC1GxC,CAAA,GAAsC;EAC1C,MAAME,CAAA,GAAiBwS,EAAA,CAAiBzR,CAAO,EAAEgV,QAAA,KAAa;EAC9D,IAAI7V,CAAA,GAAcF,CAAA,GAAiBkT,EAAA,CAAcnS,CAAO,IAAIA,CAAA;EAG5D,OAAO+Q,EAAA,CAAU5R,CAAW,KAAK,CAACiT,EAAA,CAAsBjT,CAAW,IAAG;IACpE,MAAMoC,CAAA,GAAgBkQ,EAAA,CAAiBtS,CAAW;MAC5CsK,CAAA,GAA0BkI,EAAA,CAAkBxS,CAAW;IACzD,CAACsK,CAAA,IAA2BlI,CAAA,CAAcyT,QAAA,KAAa,YACzDjW,CAAA,GAAsC,QAEVE,CAAA,GAAiB,CAACwK,CAAA,IAA2B,CAAC1K,CAAA,GAAsC,CAAC0K,CAAA,IAA2BlI,CAAA,CAAcyT,QAAA,KAAa,YAAY,CAAC,CAACjW,CAAA,IAAuC,CAAC,YAAY,OAAO,EAAE2J,QAAA,CAAS3J,CAAA,CAAoCiW,QAAQ,KAAK5D,EAAA,CAAkBjS,CAAW,KAAK,CAACsK,CAAA,IAA2BsL,EAAA,CAAyB/U,CAAA,EAASb,CAAW,KAGvZR,CAAA,GAASA,CAAA,CAAOyL,MAAA,CAAOT,CAAA,IAAYA,CAAA,KAAaxK,CAAW,IAG3DJ,CAAA,GAAsCwC,CAAA,EAExCpC,CAAA,GAAcgT,EAAA,CAAchT,CAAW;EACxC;EACD,OAAA7B,CAAA,CAAM6X,GAAA,CAAInV,CAAA,EAASrB,CAAM,GAClBA,CAAA;AACT;AAIA,SAASyW,GAAgBpV,CAAA,EAAM;EAC7B,IAAI;IACF8L,OAAA,EAAAxO,CAAA;IACAkO,QAAA,EAAAjO,CAAA;IACAkO,YAAA,EAAA9M,CAAA;IACAsL,QAAA,EAAAlL;EACD,IAAGiB,CAAA;EAEJ,MAAMb,CAAA,GAAoB,CAAC,IADM5B,CAAA,KAAa,sBAAsB0X,EAAA,CAA4B3X,CAAA,EAAS,KAAK+X,EAAE,IAAI,GAAGvO,MAAA,CAAOvJ,CAAQ,IAC9EoB,CAAY;IAC9D4C,CAAA,GAAwBpC,CAAA,CAAkB,CAAC;IAC3CsK,CAAA,GAAetK,CAAA,CAAkBmC,MAAA,CAAO,CAACoI,CAAA,EAASC,CAAA,KAAqB;MAC3E,MAAMC,CAAA,GAAOkL,EAAA,CAAkCxX,CAAA,EAASqM,CAAA,EAAkB5K,CAAQ;MAClF,OAAA2K,CAAA,CAAQ3B,GAAA,GAAMb,EAAA,CAAI0C,CAAA,CAAK7B,GAAA,EAAK2B,CAAA,CAAQ3B,GAAG,GACvC2B,CAAA,CAAQ7B,KAAA,GAAQd,EAAA,CAAI6C,CAAA,CAAK/B,KAAA,EAAO6B,CAAA,CAAQ7B,KAAK,GAC7C6B,CAAA,CAAQ5B,MAAA,GAASf,EAAA,CAAI6C,CAAA,CAAK9B,MAAA,EAAQ4B,CAAA,CAAQ5B,MAAM,GAChD4B,CAAA,CAAQ9B,IAAA,GAAOV,EAAA,CAAI0C,CAAA,CAAKhC,IAAA,EAAM8B,CAAA,CAAQ9B,IAAI,GACnC8B,CAAA;IACR,GAAEoL,EAAA,CAAkCxX,CAAA,EAASiE,CAAA,EAAuBxC,CAAQ,CAAC;EAC9E,OAAO;IACLmF,KAAA,EAAOuF,CAAA,CAAa5B,KAAA,GAAQ4B,CAAA,CAAa7B,IAAA;IACzC3D,MAAA,EAAQwF,CAAA,CAAa3B,MAAA,GAAS2B,CAAA,CAAa1B,GAAA;IAC3CN,CAAA,EAAGgC,CAAA,CAAa7B,IAAA;IAChBF,CAAA,EAAG+B,CAAA,CAAa1B;EACpB;AACA;AAEA,SAASuN,GAActV,CAAA,EAAS;EAC9B,OAAOmT,EAAA,CAAiBnT,CAAO;AACjC;AAEA,SAASuV,GAA8BvV,CAAA,EAAS1C,CAAA,EAAcC,CAAA,EAAU;EACtE,MAAMoB,CAAA,GAA0BqS,EAAA,CAAc1T,CAAY;IACpDyB,CAAA,GAAkB8R,EAAA,CAAmBvT,CAAY;IACjD2B,CAAA,GAAU1B,CAAA,KAAa;IACvB4B,CAAA,GAAO4U,EAAA,CAAsB/T,CAAA,EAAS,IAAMf,CAAA,EAAS3B,CAAY;EACvE,IAAIiE,CAAA,GAAS;IACXiR,UAAA,EAAY;IACZC,SAAA,EAAW;EACf;EACE,MAAMhJ,CAAA,GAAUjC,EAAA,CAAa,CAAC;EAC9B,IAAI7I,CAAA,IAA2B,CAACA,CAAA,IAA2B,CAACM,CAAA,EAI1D,KAHIsR,EAAA,CAAYjT,CAAY,MAAM,UAAU8T,EAAA,CAAkBrS,CAAe,OAC3EwC,CAAA,GAASgR,EAAA,CAAcjV,CAAY,IAEjCqB,CAAA,EAAyB;IAC3B,MAAM+K,CAAA,GAAaqK,EAAA,CAAsBzW,CAAA,EAAc,IAAM2B,CAAA,EAAS3B,CAAY;IAClFmM,CAAA,CAAQhC,CAAA,GAAIiC,CAAA,CAAWjC,CAAA,GAAInK,CAAA,CAAa0W,UAAA,EACxCvK,CAAA,CAAQ/B,CAAA,GAAIgC,CAAA,CAAWhC,CAAA,GAAIpK,CAAA,CAAa4W,SAAA;EACzC,OAAUnV,CAAA,KACT0K,CAAA,CAAQhC,CAAA,GAAI6M,EAAA,CAAoBvV,CAAe;EAGnD,OAAO;IACL0I,CAAA,EAAGtI,CAAA,CAAKyI,IAAA,GAAOrG,CAAA,CAAOiR,UAAA,GAAa/I,CAAA,CAAQhC,CAAA;IAC3CC,CAAA,EAAGvI,CAAA,CAAK4I,GAAA,GAAMxG,CAAA,CAAOkR,SAAA,GAAYhJ,CAAA,CAAQ/B,CAAA;IACzCxD,KAAA,EAAO/E,CAAA,CAAK+E,KAAA;IACZD,MAAA,EAAQ9E,CAAA,CAAK8E;EACjB;AACA;AAEA,SAASuR,GAAoBxV,CAAA,EAAS1C,CAAA,EAAU;EAC9C,OAAI,CAAC0T,EAAA,CAAchR,CAAO,KAAKyR,EAAA,CAAiBzR,CAAO,EAAEgV,QAAA,KAAa,UAC7D,OAEL1X,CAAA,GACKA,CAAA,CAAS0C,CAAO,IAElBA,CAAA,CAAQsM,YAAA;AACjB;AAIA,SAASmJ,GAAgBzV,CAAA,EAAS1C,CAAA,EAAU;EAC1C,MAAMC,CAAA,GAASmT,EAAA,CAAU1Q,CAAO;EAChC,IAAI,CAACgR,EAAA,CAAchR,CAAO,GACxB,OAAOzC,CAAA;EAET,IAAIoB,CAAA,GAAe6W,EAAA,CAAoBxV,CAAA,EAAS1C,CAAQ;EACxD,OAAOqB,CAAA,IAAgB+S,EAAA,CAAe/S,CAAY,KAAK8S,EAAA,CAAiB9S,CAAY,EAAEqW,QAAA,KAAa,WACjGrW,CAAA,GAAe6W,EAAA,CAAoB7W,CAAA,EAAcrB,CAAQ;EAE3D,OAAIqB,CAAA,KAAiB4R,EAAA,CAAY5R,CAAY,MAAM,UAAU4R,EAAA,CAAY5R,CAAY,MAAM,UAAU8S,EAAA,CAAiB9S,CAAY,EAAEqW,QAAA,KAAa,YAAY,CAACrD,EAAA,CAAkBhT,CAAY,KACnLpB,CAAA,GAEFoB,CAAA,IAAgBuT,EAAA,CAAmBlS,CAAO,KAAKzC,CAAA;AACxD;AAEA,MAAMmY,EAAA,GAAkB,eAAAnL,CAAgBvK,CAAA,EAAM;EAC5C,IAAI;IACF6I,SAAA,EAAAvL,CAAA;IACAwL,QAAA,EAAAvL,CAAA;IACA0M,QAAA,EAAAtL;EACD,IAAGqB,CAAA;EACJ,MAAMjB,CAAA,GAAoB,KAAKmN,eAAA,IAAmBuJ,EAAA;IAC5CxW,CAAA,GAAkB,KAAKwN,aAAA;EAC7B,OAAO;IACL5D,SAAA,EAAW0M,EAAA,CAA8BjY,CAAA,EAAW,MAAMyB,CAAA,CAAkBxB,CAAQ,GAAGoB,CAAQ;IAC/FmK,QAAA,EAAU;MACRrB,CAAA,EAAG;MACHC,CAAA,EAAG;MACH,IAAI,MAAMzI,CAAA,CAAgB1B,CAAQ;IACnC;EACL;AACA;AAEA,SAASoY,GAAM3V,CAAA,EAAS;EACtB,OAAOyR,EAAA,CAAiBzR,CAAO,EAAEhB,SAAA,KAAc;AACjD;AAEA,MAAM4W,EAAA,GAAW;EACfxJ,qDAAA,EAAAgI,EAAA;EACAnI,kBAAA,EAAA4E,EAAA;EACAhF,eAAA,EAAAuJ,EAAA;EACAlJ,eAAA,EAAAuJ,EAAA;EACAlL,eAAA,EAAAmL,EAAA;EACAjG,cAAA,EAAA4E,EAAA;EACA5H,aAAA,EAAA6I,EAAA;EACAnJ,QAAA,EAAAqH,EAAA;EACAzH,SAAA,EAAAgF,EAAA;EACAzG,KAAA,EAAAqL;AACF;AAGA,SAASE,GAAY7V,CAAA,EAAS1C,CAAA,EAAQ;EACpC,IAAIC,CAAA,GAAK;IACLoB,CAAA;EACJ,MAAMI,CAAA,GAAO8R,EAAA,CAAmB7Q,CAAO;EACvC,SAASf,EAAA,EAAU;IACjB6W,YAAA,CAAanX,CAAS,GACtBpB,CAAA,IAAMA,CAAA,CAAGwY,UAAA,IACTxY,CAAA,GAAK;EACN;EACD,SAAS4B,EAAQoC,CAAA,EAAMkI,CAAA,EAAW;IAC5BlI,CAAA,KAAS,WACXA,CAAA,GAAO,KAELkI,CAAA,KAAc,WAChBA,CAAA,GAAY,IAEdxK,CAAA;IACA,MAAM;MACJ2I,IAAA,EAAA8B,CAAA;MACA3B,GAAA,EAAA4B,CAAA;MACAzF,KAAA,EAAA0F,CAAA;MACA3F,MAAA,EAAA4F;IACN,IAAQ7J,CAAA,CAAQkD,qBAAA;IAIZ,IAHK3B,CAAA,IACHjE,CAAA,IAEE,CAACsM,CAAA,IAAS,CAACC,CAAA,EACb;IAEF,MAAMnC,CAAA,GAAWJ,EAAA,CAAMqC,CAAG;MACpBa,CAAA,GAAalD,EAAA,CAAMvI,CAAA,CAAK0V,WAAA,IAAe/K,CAAA,GAAOE,CAAA,CAAM;MACpDa,CAAA,GAAcnD,EAAA,CAAMvI,CAAA,CAAK4V,YAAA,IAAgBhL,CAAA,GAAME,CAAA,CAAO;MACtDa,CAAA,GAAYpD,EAAA,CAAMoC,CAAI;MAEtBmB,CAAA,GAAU;QACdmL,UAAA,EAFiB,CAACtO,CAAA,GAAW,QAAQ,CAAC8C,CAAA,GAAa,QAAQ,CAACC,CAAA,GAAc,QAAQ,CAACC,CAAA,GAAY;QAG/FuL,SAAA,EAAW/O,EAAA,CAAI,GAAGH,EAAA,CAAI,GAAG0C,CAAS,CAAC,KAAK;MAC9C;IACI,IAAIqB,CAAA,GAAgB;IACpB,SAASE,EAAcE,CAAA,EAAS;MAC9B,MAAMwB,CAAA,GAAQxB,CAAA,CAAQ,CAAC,EAAEgL,iBAAA;MACzB,IAAIxJ,CAAA,KAAUjD,CAAA,EAAW;QACvB,IAAI,CAACqB,CAAA,EACH,OAAO3L,CAAA,CAAO;QAEXuN,CAAA,GAKHvN,CAAA,CAAQ,IAAOuN,CAAK,IAJpB/N,CAAA,GAAYwX,UAAA,CAAW,MAAM;UAC3BhX,CAAA,CAAQ,IAAO,IAAI;QACpB,GAAE,GAAG;MAIT;MACD2L,CAAA,GAAgB;IACjB;IAID,IAAI;MACFvN,CAAA,GAAK,IAAI6Y,oBAAA,CAAqBpL,CAAA,EAAe;QAC3C,GAAGH,CAAA;QAAA;QAEHwL,IAAA,EAAMtX,CAAA,CAAK4R;MACnB,CAAO;IACF,QAAW;MACVpT,CAAA,GAAK,IAAI6Y,oBAAA,CAAqBpL,CAAA,EAAeH,CAAO;IACrD;IACDtN,CAAA,CAAG+Y,OAAA,CAAQtW,CAAO;EACnB;EACD,OAAAb,CAAA,CAAQ,EAAI,GACLF,CAAA;AACT;AAUA,SAASsX,GAAWvW,CAAA,EAAW1C,CAAA,EAAUC,CAAA,EAAQoB,CAAA,EAAS;EACpDA,CAAA,KAAY,WACdA,CAAA,GAAU;EAEZ,MAAM;MACJ6X,cAAA,EAAAzX,CAAA,GAAiB;MACjB0X,cAAA,EAAAxX,CAAA,GAAiB;MACjByX,aAAA,EAAAvX,CAAA,GAAgB,OAAOwX,cAAA,IAAmB;MAC1CC,WAAA,EAAArV,CAAA,GAAc,OAAO6U,oBAAA,IAAyB;MAC9CS,cAAA,EAAApN,CAAA,GAAiB;IAClB,IAAG9K,CAAA;IACE+K,CAAA,GAAc6J,EAAA,CAAcvT,CAAS;IACrC2J,CAAA,GAAY5K,CAAA,IAAkBE,CAAA,GAAiB,CAAC,IAAIyK,CAAA,GAAcsJ,EAAA,CAAqBtJ,CAAW,IAAI,KAAK,GAAGsJ,EAAA,CAAqB1V,CAAQ,CAAC,IAAI;EACtJqM,CAAA,CAAUmN,OAAA,CAAQlM,CAAA,IAAY;IAC5B7L,CAAA,IAAkB6L,CAAA,CAASxI,gBAAA,CAAiB,UAAU7E,CAAA,EAAQ;MAC5D4E,OAAA,EAAS;IACf,CAAK,GACDlD,CAAA,IAAkB2L,CAAA,CAASxI,gBAAA,CAAiB,UAAU7E,CAAM;EAChE,CAAG;EACD,MAAMqM,CAAA,GAAYF,CAAA,IAAenI,CAAA,GAAcsU,EAAA,CAAYnM,CAAA,EAAanM,CAAM,IAAI;EAClF,IAAIsM,CAAA,GAAiB;IACjBnC,CAAA,GAAiB;EACjBvI,CAAA,KACFuI,CAAA,GAAiB,IAAIiP,cAAA,CAAe/L,CAAA,IAAQ;IAC1C,IAAI,CAACC,CAAU,IAAID,CAAA;IACfC,CAAA,IAAcA,CAAA,CAAWpM,MAAA,KAAWiL,CAAA,IAAehC,CAAA,KAGrDA,CAAA,CAAeqP,SAAA,CAAUzZ,CAAQ,GACjC0Z,oBAAA,CAAqBnN,CAAc,GACnCA,CAAA,GAAiBoN,qBAAA,CAAsB,MAAM;MAC3CvP,CAAA,IAAkBA,CAAA,CAAe4O,OAAA,CAAQhZ,CAAQ;IAC3D,CAAS,IAEHC,CAAA;EACN,CAAK,GACGmM,CAAA,IAAe,CAACD,CAAA,IAClB/B,CAAA,CAAe4O,OAAA,CAAQ5M,CAAW,GAEpChC,CAAA,CAAe4O,OAAA,CAAQhZ,CAAQ;EAEjC,IAAIkN,CAAA;IACAC,CAAA,GAAchB,CAAA,GAAiBsK,EAAA,CAAsB/T,CAAS,IAAI;EAClEyJ,CAAA,IACFiB,CAAA;EAEF,SAASA,EAAA,EAAY;IACnB,MAAME,CAAA,GAAcmJ,EAAA,CAAsB/T,CAAS;IAC/CyK,CAAA,KAAgBG,CAAA,CAAYnD,CAAA,KAAMgD,CAAA,CAAYhD,CAAA,IAAKmD,CAAA,CAAYlD,CAAA,KAAM+C,CAAA,CAAY/C,CAAA,IAAKkD,CAAA,CAAY1G,KAAA,KAAUuG,CAAA,CAAYvG,KAAA,IAAS0G,CAAA,CAAY3G,MAAA,KAAWwG,CAAA,CAAYxG,MAAA,KACtK1G,CAAA,IAEFkN,CAAA,GAAcG,CAAA,EACdJ,CAAA,GAAUyM,qBAAA,CAAsBvM,CAAS;EAC1C;EACD,OAAAnN,CAAA,IACO,MAAM;IACXoM,CAAA,CAAUmN,OAAA,CAAQlM,CAAA,IAAY;MAC5B7L,CAAA,IAAkB6L,CAAA,CAASvI,mBAAA,CAAoB,UAAU9E,CAAM,GAC/D0B,CAAA,IAAkB2L,CAAA,CAASvI,mBAAA,CAAoB,UAAU9E,CAAM;IACrE,CAAK,GACDqM,CAAA,IAAaA,CAAA,CAAS,GACtBlC,CAAA,IAAkBA,CAAA,CAAeqO,UAAA,IACjCrO,CAAA,GAAiB,MACb+B,CAAA,IACFuN,oBAAA,CAAqBxM,CAAO;EAElC;AACA;AAOA,MAAM0M,EAAA,GAAkBnN,CAAC/J,CAAA,EAAW1C,CAAA,EAAUC,CAAA,KAAY;EAIxD,MAAMoB,CAAA,GAAQ,mBAAIwY,GAAA;IACZpY,CAAA,GAAgB;MACpBoL,QAAA,EAAAyL,EAAA;MACA,GAAGrY;IACP;IACQ0B,CAAA,GAAoB;MACxB,GAAGF,CAAA,CAAcoL,QAAA;MACjBkL,EAAA,EAAI1W;IACR;EACE,OAAOmL,EAAA,CAAkB9J,CAAA,EAAW1C,CAAA,EAAU;IAC5C,GAAGyB,CAAA;IACHoL,QAAA,EAAUlL;EACd,CAAG;AACH;ACjlBA,SAASmY,GAAcpX,CAAA,EAAS;EAC9B,IAAI1C,CAAA;EACJ,QAAQA,CAAA,GAAO0C,CAAA,IAAW,OAAO,SAASA,CAAA,CAAQqX,GAAA,KAAQ,OAAO/Z,CAAA,GAAO0C,CAAA;AAC1E;AAOA,SAASsX,GAAMtX,CAAA,EAAS;EACtB,OAAO;IACLtC,IAAA,EAAM;IACN8O,OAAA,EAAAxM,CAAA;IACA2K,GAAGrN,CAAA,EAAM;MACP,MAAMC,CAAA,GAAU6Z,EAAA,CAAcG,CAAA,CAAMvX,CAAA,CAAQ8L,OAAO,CAAC;MACpD,OAAIvO,CAAA,IAAW,OACN,KAEFgP,EAAA,CAAQ;QACbT,OAAA,EAAAvO,CAAA;QACAqO,OAAA,EAAS5L,CAAA,CAAQ4L;MACzB,CAAO,EAAEjB,EAAA,CAAGrN,CAAI;IACX;EACL;AACA;AAEA,SAASka,GAAOxX,CAAA,EAAS;EACvB,OAAI,OAAOyB,MAAA,GAAW,MACb,KAEGzB,CAAA,CAAQ2Q,aAAA,CAAcC,WAAA,IAAenP,MAAA,EACtCgW,gBAAA,IAAoB;AACjC;AAEA,SAASC,GAAW1X,CAAA,EAAS1C,CAAA,EAAO;EAClC,MAAMC,CAAA,GAAMia,EAAA,CAAOxX,CAAO;EAC1B,OAAOgH,IAAA,CAAKK,KAAA,CAAM/J,CAAA,GAAQC,CAAG,IAAIA,CAAA;AACnC;AASA,SAASoa,GAAY3X,CAAA,EAAW1C,CAAA,EAAUC,CAAA,EAAS;EAC7CA,CAAA,KAAY,WACdA,CAAA,GAAU;EAEZ,MAAMoB,CAAA,GAA6BpB,CAAA,CAAQqa,oBAAA;IACrC7Y,CAAA,GAAa8Y,CAAA,CAAS,MAAM;MAChC,IAAIlL,CAAA;MACJ,QAAQA,CAAA,GAAS4K,CAAA,CAAMha,CAAA,CAAQua,IAAI,MAAM,OAAOnL,CAAA,GAAS;IAC7D,CAAG;IACK1N,CAAA,GAAmB4Y,CAAA,CAAS,MAAMN,CAAA,CAAMha,CAAA,CAAQ2M,UAAU,CAAC;IAC3D/K,CAAA,GAAkB0Y,CAAA,CAAS,MAAM;MACrC,IAAIlL,CAAA;MACJ,QAAQA,CAAA,GAAU4K,CAAA,CAAMha,CAAA,CAAQyM,SAAS,MAAM,OAAO2C,CAAA,GAAU;IACpE,CAAG;IACKpL,CAAA,GAAiBsW,CAAA,CAAS,MAAM;MACpC,IAAIlL,CAAA;MACJ,QAAQA,CAAA,GAAU4K,CAAA,CAAMha,CAAA,CAAQ0M,QAAQ,MAAM,OAAO0C,CAAA,GAAU;IACnE,CAAG;IACKlD,CAAA,GAAkBoO,CAAA,CAAS,MAAM;MACrC,IAAIlL,CAAA;MACJ,QAAQA,CAAA,GAAU4K,CAAA,CAAMha,CAAA,CAAQqU,SAAS,MAAM,OAAOjF,CAAA,GAAU;IACpE,CAAG;IACKjD,CAAA,GAAmBmO,CAAA,CAAS,MAAMT,EAAA,CAAcpX,CAAA,CAAU+X,KAAK,CAAC;IAChEpO,CAAA,GAAkBkO,CAAA,CAAS,MAAMT,EAAA,CAAc9Z,CAAA,CAASya,KAAK,CAAC;IAC9DnO,CAAA,GAAIoO,CAAA,CAAI,CAAC;IACTnO,CAAA,GAAImO,CAAA,CAAI,CAAC;IACTtQ,CAAA,GAAWsQ,CAAA,CAAIzW,CAAA,CAAewW,KAAK;IACnCvN,CAAA,GAAYwN,CAAA,CAAI7Y,CAAA,CAAgB4Y,KAAK;IACrCtN,CAAA,GAAiBwN,EAAA,CAAW,EAAE;IAC9BvN,CAAA,GAAesN,CAAA,CAAI,EAAK;IACxBpN,CAAA,GAAiBiN,CAAA,CAAS,MAAM;MACpC,MAAMlL,CAAA,GAAgB;QACpBqI,QAAA,EAAUtN,CAAA,CAASqQ,KAAA;QACnBnQ,IAAA,EAAM;QACNG,GAAA,EAAK;MACX;MACI,IAAI,CAAC4B,CAAA,CAAgBoO,KAAA,EACnB,OAAOpL,CAAA;MAET,MAAMC,CAAA,GAAO8K,EAAA,CAAW/N,CAAA,CAAgBoO,KAAA,EAAOnO,CAAA,CAAEmO,KAAK;QAChDlL,CAAA,GAAO6K,EAAA,CAAW/N,CAAA,CAAgBoO,KAAA,EAAOlO,CAAA,CAAEkO,KAAK;MACtD,OAAItO,CAAA,CAAgBsO,KAAA,GACX;QACL,GAAGpL,CAAA;QACHiF,SAAA,EAAW,eAAehF,CAAA,GAAO,SAASC,CAAA,GAAO;QACjD,IAAI2K,EAAA,CAAO7N,CAAA,CAAgBoO,KAAK,KAAK,OAAO;UAC1C/F,UAAA,EAAY;QACtB;MACA,IAEW;QACLgD,QAAA,EAAUtN,CAAA,CAASqQ,KAAA;QACnBnQ,IAAA,EAAMgF,CAAA,GAAO;QACb7E,GAAA,EAAK8E,CAAA,GAAO;MAClB;IACA,CAAG;EACD,IAAIhC,CAAA;EACJ,SAASC,EAAA,EAAS;IACZpB,CAAA,CAAiBqO,KAAA,IAAS,QAAQpO,CAAA,CAAgBoO,KAAA,IAAS,QAG/Db,EAAA,CAAgBxN,CAAA,CAAiBqO,KAAA,EAAOpO,CAAA,CAAgBoO,KAAA,EAAO;MAC7D7N,UAAA,EAAYjL,CAAA,CAAiB8Y,KAAA;MAC7B/N,SAAA,EAAW7K,CAAA,CAAgB4Y,KAAA;MAC3B9N,QAAA,EAAU1I,CAAA,CAAewW;IAC/B,CAAK,EAAEG,IAAA,CAAKvL,CAAA,IAAY;MAClB/C,CAAA,CAAEmO,KAAA,GAAQpL,CAAA,CAASlF,CAAA,EACnBoC,CAAA,CAAEkO,KAAA,GAAQpL,CAAA,CAASjF,CAAA,EACnBA,CAAA,CAASqQ,KAAA,GAAQpL,CAAA,CAAS1C,QAAA,EAC1BO,CAAA,CAAUuN,KAAA,GAAQpL,CAAA,CAAS3C,SAAA,EAC3BS,CAAA,CAAesN,KAAA,GAAQpL,CAAA,CAASvB,cAAA,EAChCV,CAAA,CAAaqN,KAAA,GAAQ;IAC3B,CAAK;EACF;EACD,SAAS/M,EAAA,EAAU;IACb,OAAOH,CAAA,IAAgC,eACzCA,CAAA,IACAA,CAAA,GAA8B;EAEjC;EACD,SAASK,EAAA,EAAS;IAEhB,IADAF,CAAA,IACIrM,CAAA,KAA+B,QAAW;MAC5CmM,CAAA;MACA;IACD;IACD,IAAIpB,CAAA,CAAiBqO,KAAA,IAAS,QAAQpO,CAAA,CAAgBoO,KAAA,IAAS,MAAM;MACnElN,CAAA,GAA8BlM,CAAA,CAA2B+K,CAAA,CAAiBqO,KAAA,EAAOpO,CAAA,CAAgBoO,KAAA,EAAOjN,CAAM;MAC9G;IACD;EACF;EACD,SAAS4B,EAAA,EAAQ;IACV3N,CAAA,CAAWgZ,KAAA,KACdrN,CAAA,CAAaqN,KAAA,GAAQ;EAExB;EACD,OAAAI,EAAA,CAAM,CAAClZ,CAAA,EAAkBE,CAAA,EAAiBoC,CAAc,GAAGuJ,CAAA,EAAQ;IACjEsN,KAAA,EAAO;EACX,CAAG,GACDD,EAAA,CAAM,CAACzO,CAAA,EAAkBC,CAAe,GAAGuB,CAAA,EAAQ;IACjDkN,KAAA,EAAO;EACX,CAAG,GACDD,EAAA,CAAMpZ,CAAA,EAAY2N,CAAA,EAAO;IACvB0L,KAAA,EAAO;EACX,CAAG,GACGC,EAAA,CAAe,KACjBC,EAAA,CAAetN,CAAO,GAEjB;IACLvD,CAAA,EAAG8Q,EAAA,CAAgB3O,CAAC;IACpBlC,CAAA,EAAG6Q,EAAA,CAAgB1O,CAAC;IACpBI,QAAA,EAAUsO,EAAA,CAAgB7Q,CAAQ;IAClCsC,SAAA,EAAWuO,EAAA,CAAgB/N,CAAS;IACpCY,cAAA,EAAgBmN,EAAA,CAAgB9N,CAAc;IAC9C+N,YAAA,EAAcD,EAAA,CAAgB7N,CAAY;IAC1C+N,cAAA,EAAA7N,CAAA;IACA8N,MAAA,EAAA5N;EACJ;AACA;AClKA,MAAM6N,EAAA,sBAAoBC,GAAA,CAAI,CAC5B,cACA,QACA,QACA,YACA,YACA,UACA,OACA,aACD;EAEKC,EAAA,GAAyB;EAOzBC,EAAA,GAAmB;EAOnBC,EAAA,GACJ;EAEIC,EAAA,GAAmBC,CAACjZ,CAAA,EAAiB1C,CAAA,KAA8C;IACjF,MAAAC,CAAA,GAAgByC,CAAA,CAAUyQ,QAAA,CAASlL,WAAA,CAAY;IAEjD,OAAAjI,CAAA,CAAqBoL,QAAA,CAASnL,CAAa,IACzCob,EAAA,CAAcO,GAAA,CAAI3b,CAAa,IAC1B,GACLub,EAAA,CAAiBhU,IAAA,CAAK9E,CAAA,CAAUmZ,SAAA,IAAa,EAAE,KAC7CJ,EAAA,CAAiBjU,IAAA,CAAK9E,CAAA,CAAUmZ,SAAA,IAAa,EAAE,KAI9C,KAIF7b,CAAA,CACJ8M,MAAA,CAAQzL,CAAA,IAA6CA,CAAA,YAA0Bya,MAAM,EACrF9V,IAAA,CAAM3E,CAAA,IAAUA,CAAA,CAAMmG,IAAA,CAAKvH,CAAa,CAAC;EAC9C;EAEa8b,EAAA,GAAmB;IAAA;IAE9B,KAAK,CAAC,SAAS,OAAO,MAAM,QAAQ,QAAQR,EAAsB;IAClEla,CAAA,EAAK,CAAC,UAAU,QAAQ,SAAS,KAAK;IACtC2a,IAAA,EAAQ,EAAC;IACT9O,CAAA,EAAK,EAAC;IACN+O,EAAA,EAAM,EAAC;IACPC,GAAA,EAAO,EAAC;IACRC,IAAA,EAAQ,EAAC;IACTC,GAAA,EAAO,EAAC;IACRC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACPC,EAAA,EAAM,EAAC;IACP/a,CAAA,EAAK,EAAC;IACNgb,GAAA,EAAO,CAAC,OAAO,UAAU,OAAO,SAAS,SAAS,QAAQ;IAC1D7C,EAAA,EAAM,EAAC;IACP8C,EAAA,EAAM,EAAC;IACPvQ,CAAA,EAAK,EAAC;IACNwQ,GAAA,EAAO,EAAC;IACR9Y,CAAA,EAAK,EAAC;IACN+Y,KAAA,EAAS,EAAC;IACVC,IAAA,EAAQ,EAAC;IACTC,GAAA,EAAO,EAAC;IACRC,GAAA,EAAO,EAAC;IACRC,MAAA,EAAU,EAAC;IACXjR,CAAA,EAAK,EAAC;IACNnH,EAAA,EAAM;EACR;EAEaqY,EAAA,GAAeC,CAC1B5a,CAAA,EACA1C,CAAA,EACAC,CAAA,KACG;IACC,KAACyC,CAAA,CAAWpC,MAAA,EACP,OAAAoC,CAAA;IAGL,IAAAzC,CAAA,IAAoB,OAAOA,CAAA,IAAqB,YAClD,OAAOA,CAAA,CAAiByC,CAAU;IAIpC,MAAMjB,CAAA,GADY,IAAI0C,MAAA,CAAOoZ,SAAA,GACKC,eAAA,CAAgB9a,CAAA,EAAY,WAAW;MACnEf,CAAA,GAAgCF,CAAA,CAAgBgU,IAAA,CAAKtO,gBAAA,CAAiB,GAAG;IAE/E,WAAWtF,CAAA,IAAWF,CAAA,EAAU;MACxB,MAAAsC,CAAA,GAAcpC,CAAA,CAAQsR,QAAA,CAASlL,WAAA,CAAY;MAEjD,IAAI,CAAC1H,MAAA,CAAOkd,IAAA,CAAKzd,CAAS,EAAEoL,QAAA,CAASnH,CAAW,GAAG;QACjDpC,CAAA,CAAQ6b,MAAA,CAAO;QAEf;MACF;MAEA,MAAMvR,CAAA,GAAgBtK,CAAA,CAAQ8b,UAAA;QACxBvR,CAAA,GAAoB,CAAC,IAAIpM,CAAA,CAAU,GAAG,KAAK,KAAK,IAAIA,CAAA,CAAUiE,CAAW,KAAK,EAAG;MAEvF,WAAWoI,CAAA,IAAaF,CAAA,EACjBuP,EAAA,CAAiBrP,CAAA,EAAWD,CAAiB,KACxCvK,CAAA,CAAAiG,eAAA,CAAgBuE,CAAA,CAAU8G,QAAQ;IAGhD;IAEA,OAAO1R,CAAA,CAAgBgU,IAAA,CAAKmI,SAAA;EAC9B;AC9EA,SAASC,GAAkBnb,CAAA,EAAI;EAC7B,OAAIqY,EAAA,CAAe,KACjBC,EAAA,CAAetY,CAAE,GACV,MAEF;AACT;AAyBA,SAASob,GAAkBpb,CAAA,EAAc;EACvC,IAAI1C,CAAA,GAAc;IACdC,CAAA;EACJ,MAAMoB,CAAA,GAAQ0c,EAAA,CAAY,EAAI;EAC9B,OAAO,IAAItc,CAAA,MACJzB,CAAA,KACHC,CAAA,GAAQoB,CAAA,CAAM2c,GAAA,CAAI,MAAMtb,CAAA,CAAa,GAAGjB,CAAI,CAAC,GAC7CzB,CAAA,GAAc,KAETC,CAAA;AAEX;AAsCA,SAASge,GAAuBvb,CAAA,EAAY;EAC1C,IAAI1C,CAAA,GAAc;IACdC,CAAA;IACAoB,CAAA;EACJ,MAAMI,CAAA,GAAUyc,CAAA,KAAM;IACpBle,CAAA,IAAe,GACXqB,CAAA,IAASrB,CAAA,IAAe,MAC1BqB,CAAA,CAAM8c,IAAA,CAAI,GACVle,CAAA,GAAQ,QACRoB,CAAA,GAAQ;EAEd;EACE,OAAO,IAAIM,CAAA,MACT3B,CAAA,IAAe,GACVC,CAAA,KACHoB,CAAA,GAAQ0c,EAAA,CAAY,EAAI,GACxB9d,CAAA,GAAQoB,CAAA,CAAM2c,GAAA,CAAI,MAAMtb,CAAA,CAAW,GAAGf,CAAI,CAAC,IAE7Ckc,EAAA,CAAkBpc,CAAO,GAClBxB,CAAA;AAEX;AA2DA,SAASme,GAAQ1b,CAAA,EAAG;EAClB,OAAO,OAAOA,CAAA,IAAM,aAAaA,CAAA,CAAC,IAAKuX,CAAA,CAAMvX,CAAC;AAChD;AA4EA,MAAM2b,EAAA,GAAW,OAAOla,MAAA,GAAW,OAAe,OAAOE,QAAA,GAAa;AACrD,OAAOia,iBAAA,GAAsB,OAAeC,UAAA,YAAsBD,iBAAA;AACnF,MAAME,EAAA,GAAS9b,CAAA,IAAQ,OAAOA,CAAA,GAAQ;EAMhC+b,EAAA,GAAWle,MAAA,CAAOsC,SAAA,CAAUJ,QAAA;EAC5Bic,EAAA,GAAYhc,CAAA,IAAQ+b,EAAA,CAAS3b,IAAA,CAAKJ,CAAG,MAAM;EAI3Cic,EAAA,GAAOC,CAAA,KAAM,CACnB;EAOMC,EAAA,GAAwB,eAAAC,EAAA,CAAQ;AACtC,SAASA,GAAA,EAAW;EAClB,IAAIpc,CAAA;EACJ,OAAO2b,EAAA,MAAc3b,CAAA,GAAKyB,MAAA,IAAU,OAAO,SAASA,MAAA,CAAOM,SAAA,KAAc,OAAO,SAAS/B,CAAA,CAAGqc,SAAA,KAA8B,gCAAiBvX,IAAA,CAAKrD,MAAA,CAAOM,SAAA,CAAUsa,SAAS;AAC5K;AAEA,SAASC,GAAoBtc,CAAA,EAAQ1C,CAAA,EAAI;EACvC,SAASC,EAAA,GAAWoB,CAAA,EAAM;IACxB,OAAO,IAAI4d,OAAA,CAAQ,CAACxd,CAAA,EAASE,CAAA,KAAW;MACtCsd,OAAA,CAAQC,OAAA,CAAQxc,CAAA,CAAO,MAAM1C,CAAA,CAAG8S,KAAA,CAAM,MAAMzR,CAAI,GAAG;QAAEgM,EAAA,EAAArN,CAAA;QAAImf,OAAA,EAAS;QAAMC,IAAA,EAAA/d;MAAI,CAAE,CAAC,EAAEuZ,IAAA,CAAKnZ,CAAO,EAAE4d,KAAA,CAAM1d,CAAM;IACjH,CAAK;EACF;EACD,OAAO1B,CAAA;AACT;AACA,MAAMqf,EAAA,GAAgB5c,CAAA,IACbA,CAAA,CAAM;AAEf,SAAS6c,GAAe7c,CAAA,EAAI1C,CAAA,GAAU,IAAI;EACxC,IAAIC,CAAA;IACAoB,CAAA;IACAI,CAAA,GAAekd,EAAA;EACnB,MAAMhd,CAAA,GAAiBsC,CAAA,IAAW;IAChCuU,YAAA,CAAavU,CAAM,GACnBxC,CAAA,IACAA,CAAA,GAAekd,EAAA;EACnB;EA+BE,OA9BgB1a,CAAA,IAAW;IACzB,MAAMkI,CAAA,GAAWiS,EAAA,CAAQ1b,CAAE;MACrB0J,CAAA,GAAcgS,EAAA,CAAQpe,CAAA,CAAQwf,OAAO;IAG3C,OAFIvf,CAAA,IACF0B,CAAA,CAAc1B,CAAK,GACjBkM,CAAA,IAAY,KAAKC,CAAA,KAAgB,UAAUA,CAAA,IAAe,KACxD/K,CAAA,KACFM,CAAA,CAAcN,CAAQ,GACtBA,CAAA,GAAW,OAEN4d,OAAA,CAAQC,OAAA,CAAQjb,CAAA,CAAM,CAAE,KAE1B,IAAIgb,OAAA,CAAQ,CAAC5S,CAAA,EAASC,CAAA,KAAW;MACtC7K,CAAA,GAAezB,CAAA,CAAQyf,cAAA,GAAiBnT,CAAA,GAASD,CAAA,EAC7CD,CAAA,IAAe,CAAC/K,CAAA,KAClBA,CAAA,GAAWwX,UAAA,CAAW,MAAM;QACtB5Y,CAAA,IACF0B,CAAA,CAAc1B,CAAK,GACrBoB,CAAA,GAAW,MACXgL,CAAA,CAAQpI,CAAA,CAAM,CAAE;MACjB,GAAEmI,CAAW,IAEhBnM,CAAA,GAAQ4Y,UAAA,CAAW,MAAM;QACnBxX,CAAA,IACFM,CAAA,CAAcN,CAAQ,GACxBA,CAAA,GAAW,MACXgL,CAAA,CAAQpI,CAAA,CAAM,CAAE;MACjB,GAAEkI,CAAQ;IACjB,CAAK;EACL;AAEA;AA+CA,SAASuT,GAAehd,CAAA,GAAe4c,EAAA,EAAc;EACnD,MAAMtf,CAAA,GAAW0a,CAAA,CAAI,EAAI;EACzB,SAASza,EAAA,EAAQ;IACfD,CAAA,CAASya,KAAA,GAAQ;EAClB;EACD,SAASpZ,EAAA,EAAS;IAChBrB,CAAA,CAASya,KAAA,GAAQ;EAClB;EACD,MAAMhZ,CAAA,GAAcke,CAAA,GAAIhe,CAAA,KAAS;IAC3B3B,CAAA,CAASya,KAAA,IACX/X,CAAA,CAAa,GAAGf,CAAI;EAC1B;EACE,OAAO;IAAEie,QAAA,EAAUC,EAAA,CAAS7f,CAAQ;IAAG8f,KAAA,EAAA7f,CAAA;IAAO8f,MAAA,EAAA1e,CAAA;IAAQse,WAAA,EAAAle;EAAA;AACxD;AAmFA,SAASue,GAAA,GAAStd,CAAA,EAAM;EACtB,IAAIA,CAAA,CAAKpC,MAAA,KAAW,GAClB,OAAO2f,CAAA,CAAQ,GAAGvd,CAAI;EACxB,MAAM1C,CAAA,GAAI0C,CAAA,CAAK,CAAC;EAChB,OAAO,OAAO1C,CAAA,IAAM,aAAa6f,EAAA,CAASK,EAAA,CAAU,OAAO;IAAEtI,GAAA,EAAK5X,CAAA;IAAG6X,GAAA,EAAK8G;EAAI,EAAG,CAAC,IAAIjE,CAAA,CAAI1a,CAAC;AAC7F;AAmCA,SAASmgB,GAAczd,CAAA,EAAI1C,CAAA,GAAK,KAAKC,CAAA,GAAU,IAAI;EACjD,OAAO+e,EAAA,CACLO,EAAA,CAAevf,CAAA,EAAIC,CAAO,GAC1ByC,CACJ;AACA;AA4GA,SAAS0d,GAAgB1d,CAAA,EAAQ1C,CAAA,EAAIC,CAAA,GAAU,IAAI;EACjD,MAAM;IACJ0f,WAAA,EAAAte,CAAA,GAAcie,EAAA;IACd,GAAG7d;EACJ,IAAGxB,CAAA;EACJ,OAAO4a,EAAA,CACLnY,CAAA,EACAsc,EAAA,CACE3d,CAAA,EACArB,CACD,GACDyB,CACJ;AACA;AAEA,SAAS4e,GAAc3d,CAAA,EAAQ1C,CAAA,EAAIC,CAAA,GAAU,IAAI;EAC/C,MAAM;MACJ0f,WAAA,EAAate,CAAA;MACb,GAAGI;IACJ,IAAGxB,CAAA;IACE;MAAE0f,WAAA,EAAAhe,CAAA;MAAame,KAAA,EAAAje,CAAA;MAAOke,MAAA,EAAA9b,CAAA;MAAQ2b,QAAA,EAAAzT;IAAA,IAAauT,EAAA,CAAere,CAAM;EAStE,OAAO;IAAE8c,IAAA,EARIiC,EAAA,CACX1d,CAAA,EACA1C,CAAA,EACA;MACE,GAAGyB,CAAA;MACHke,WAAA,EAAAhe;IACD,CACL;IACiBme,KAAA,EAAAje,CAAA;IAAOke,MAAA,EAAA9b,CAAA;IAAQ2b,QAAA,EAAAzT;EAAQ;AACxC;AAqGA,SAASmU,GAAa5d,CAAA,EAAI1C,CAAA,GAAO,IAAM;EACjCugB,EAAA,CAAoB,IACtBC,EAAA,CAAU9d,CAAE,IACL1C,CAAA,GACP0C,CAAA,KAEA+d,EAAA,CAAS/d,CAAE;AACf;AAkVA,SAASge,GAAche,CAAA,EAAI1C,CAAA,GAAW,KAAKC,CAAA,GAAU,IAAI;EACvD,MAAM;IACJ0gB,SAAA,EAAAtf,CAAA,GAAY;IACZuf,iBAAA,EAAAnf,CAAA,GAAoB;EACrB,IAAGxB,CAAA;EACJ,IAAI0B,CAAA,GAAQ;EACZ,MAAME,CAAA,GAAW6Y,CAAA,CAAI,EAAK;EAC1B,SAASzW,EAAA,EAAQ;IACXtC,CAAA,KACFkf,aAAA,CAAclf,CAAK,GACnBA,CAAA,GAAQ;EAEX;EACD,SAASwK,EAAA,EAAQ;IACftK,CAAA,CAAS4Y,KAAA,GAAQ,IACjBxW,CAAA;EACD;EACD,SAASmI,EAAA,EAAS;IAChB,MAAMC,CAAA,GAAgB+R,EAAA,CAAQpe,CAAQ;IAClCqM,CAAA,IAAiB,MAErBxK,CAAA,CAAS4Y,KAAA,GAAQ,IACbhZ,CAAA,IACFiB,CAAA,IACFuB,CAAA,IACAtC,CAAA,GAAQmf,WAAA,CAAYpe,CAAA,EAAI2J,CAAa;EACtC;EAGD,IAFIhL,CAAA,IAAagd,EAAA,IACfjS,CAAA,IACE0Q,EAAA,CAAM9c,CAAQ,KAAK,OAAOA,CAAA,IAAa,YAAY;IACrD,MAAMqM,CAAA,GAAYwO,EAAA,CAAM7a,CAAA,EAAU,MAAM;MAClC6B,CAAA,CAAS4Y,KAAA,IAAS4D,EAAA,IACpBjS,CAAA;IACR,CAAK;IACDyR,EAAA,CAAkBxR,CAAS;EAC5B;EACD,OAAAwR,EAAA,CAAkB1R,CAAK,GAChB;IACLyT,QAAA,EAAA/d,CAAA;IACAie,KAAA,EAAA3T,CAAA;IACA4T,MAAA,EAAA3T;EACJ;AACA;AAsGA,SAAS2U,GAAYre,CAAA,EAAO1C,CAAA,GAAU,IAAI;EACxC,MAAM;IACJghB,MAAA,EAAA/gB,CAAA,GAAS;IACTghB,KAAA,EAAA5f,CAAA;IACA6f,SAAA,EAAAzf;EACD,IAAGzB,CAAA;EACJ,OAAOua,CAAA,CAAS,MAAM;IACpB,IAAI5Y,CAAA,GAAWyc,EAAA,CAAQ1b,CAAK;IAC5B,OAAI,OAAOf,CAAA,IAAa,aACtBA,CAAA,GAAWkH,MAAA,CAAO5I,CAAM,EAAE0B,CAAA,EAAUN,CAAK,IACvCI,CAAA,IAAaoH,MAAA,CAAOsY,KAAA,CAAMxf,CAAQ,MACpCA,CAAA,GAAW,IACNA,CAAA;EACX,CAAG;AACH;AC3lCA,SAASyf,GAAa1e,CAAA,EAAO;EAC3B,IAAI1C,CAAA;EACJ,MAAMC,CAAA,GAAQme,EAAA,CAAQ1b,CAAK;EAC3B,QAAQ1C,CAAA,GAAKC,CAAA,IAAS,OAAO,SAASA,CAAA,CAAM8Z,GAAA,KAAQ,OAAO/Z,CAAA,GAAKC,CAAA;AAClE;AAEA,MAAMohB,EAAA,GAAgBhD,EAAA,GAAWla,MAAA,GAAS;AAK1C,SAASmd,GAAA,GAAoB5e,CAAA,EAAM;EACjC,IAAI1C,CAAA,EACAC,CAAA,EACAoB,CAAA,EACAI,CAAA;EAOJ,IANI,OAAOiB,CAAA,CAAK,CAAC,KAAM,YAAYC,KAAA,CAAMC,OAAA,CAAQF,CAAA,CAAK,CAAC,CAAC,KACtD,CAACzC,CAAA,EAAQoB,CAAA,EAAWI,CAAO,IAAIiB,CAAA,EAC/B1C,CAAA,GAASqhB,EAAA,IAET,CAACrhB,CAAA,EAAQC,CAAA,EAAQoB,CAAA,EAAWI,CAAO,IAAIiB,CAAA,EAErC,CAAC1C,CAAA,EACH,OAAO2e,EAAA;EACJhc,KAAA,CAAMC,OAAA,CAAQ3C,CAAM,MACvBA,CAAA,GAAS,CAACA,CAAM,IACb0C,KAAA,CAAMC,OAAA,CAAQvB,CAAS,MAC1BA,CAAA,GAAY,CAACA,CAAS;EACxB,MAAMM,CAAA,GAAW;IACXE,CAAA,GAAU0f,CAAA,KAAM;MACpB5f,CAAA,CAAS6X,OAAA,CAASnN,CAAA,IAAOA,CAAA,CAAI,IAC7B1K,CAAA,CAASrB,MAAA,GAAS;IACtB;IACQ2D,CAAA,GAAWud,CAACnV,CAAA,EAAIC,CAAA,EAAOC,CAAA,EAAUnC,CAAA,MACrCiC,CAAA,CAAGvH,gBAAA,CAAiBwH,CAAA,EAAOC,CAAA,EAAUnC,CAAQ,GACtC,MAAMiC,CAAA,CAAGtH,mBAAA,CAAoBuH,CAAA,EAAOC,CAAA,EAAUnC,CAAQ;IAEzD+B,CAAA,GAAY0O,EAAA,CAChB,MAAM,CAACuG,EAAA,CAAaphB,CAAM,GAAGoe,EAAA,CAAQ3c,CAAO,CAAC,GAC7C,CAAC,CAAC4K,CAAA,EAAIC,CAAQ,MAAM;MAElB,IADAzK,CAAA,IACI,CAACwK,CAAA,EACH;MACF,MAAME,CAAA,GAAemS,EAAA,CAASpS,CAAQ,IAAI;QAAE,GAAGA;MAAU,IAAGA,CAAA;MAC5D3K,CAAA,CAAS0P,IAAA,CACP,GAAGpR,CAAA,CAAOwhB,OAAA,CAASrX,CAAA,IACV/I,CAAA,CAAUyK,GAAA,CAAKoB,CAAA,IAAajJ,CAAA,CAASoI,CAAA,EAAIjC,CAAA,EAAO8C,CAAA,EAAUX,CAAY,CAAC,CAC/E,CACT;IACK,GACD;MAAEoU,SAAA,EAAW;MAAM7F,KAAA,EAAO;IAAQ,CACtC;IACQ1O,CAAA,GAAO+R,CAAA,KAAM;MACjBhS,CAAA,IACAtK,CAAA;IACJ;EACE,OAAAgc,EAAA,CAAkBzR,CAAI,GACfA,CAAA;AACT;AAEA,IAAIsV,EAAA,GAAiB;AACrB,SAASC,GAAejf,CAAA,EAAQ1C,CAAA,EAASC,CAAA,GAAU,IAAI;EACrD,MAAM;IAAEkE,MAAA,EAAA9C,CAAA,GAASggB,EAAA;IAAeO,MAAA,EAAAngB,CAAA,GAAS,EAAE;IAAEogB,OAAA,EAAAlgB,CAAA,GAAU;IAAMmgB,YAAA,EAAAjgB,CAAA,GAAe;EAAO,IAAG5B,CAAA;EACtF,IAAI,CAACoB,CAAA,EACH;EACEwd,EAAA,IAAS,CAAC6C,EAAA,KACZA,EAAA,GAAiB,IACjB/e,KAAA,CAAMnB,IAAA,CAAKH,CAAA,CAAOgD,QAAA,CAASoR,IAAA,CAAKsM,QAAQ,EAAEvI,OAAA,CAASjN,CAAA,IAAOA,CAAA,CAAGzH,gBAAA,CAAiB,SAAS6Z,EAAI,CAAC,GAC5Ftd,CAAA,CAAOgD,QAAA,CAASmP,eAAA,CAAgB1O,gBAAA,CAAiB,SAAS6Z,EAAI;EAEhE,IAAI1a,CAAA,GAAe;EACnB,MAAMkI,CAAA,GAAgBI,CAAA,IACb9K,CAAA,CAAOuE,IAAA,CAAMoE,CAAA,IAAY;MAC9B,IAAI,OAAOA,CAAA,IAAY,UACrB,OAAOzH,KAAA,CAAMnB,IAAA,CAAKH,CAAA,CAAOgD,QAAA,CAAS8C,gBAAA,CAAiBiD,CAAO,CAAC,EAAEpE,IAAA,CAAMkH,CAAA,IAAOA,CAAA,KAAOX,CAAA,CAAMpL,MAAA,IAAUoL,CAAA,CAAMyV,YAAA,CAAY,EAAG5W,QAAA,CAAS8B,CAAE,CAAC;MAC7H;QACL,MAAMA,CAAA,GAAKkU,EAAA,CAAahX,CAAO;QAC/B,OAAO8C,CAAA,KAAOX,CAAA,CAAMpL,MAAA,KAAW+L,CAAA,IAAMX,CAAA,CAAMyV,YAAA,GAAe5W,QAAA,CAAS8B,CAAE;MACtE;IACP,CAAK;IAcGb,CAAA,GAAU,CACdiV,EAAA,CAAiBjgB,CAAA,EAAQ,SAbTkL,CAAA,IAAU;MAC1B,MAAMnC,CAAA,GAAKgX,EAAA,CAAa1e,CAAM;MAC9B,IAAI,GAAC0H,CAAA,IAAMA,CAAA,KAAOmC,CAAA,CAAMpL,MAAA,IAAUoL,CAAA,CAAMyV,YAAA,CAAY,EAAG5W,QAAA,CAAShB,CAAE,IAIlE;QAAA,IAFImC,CAAA,CAAM0V,MAAA,KAAW,MACnBhe,CAAA,GAAe,CAACkI,CAAA,CAAaI,CAAK,IAChC,CAACtI,CAAA,EAAc;UACjBA,CAAA,GAAe;UACf;QACD;QACDjE,CAAA,CAAQuM,CAAK;MAAA;IACjB,GAEgD;MAAE1H,OAAA,EAAS;MAAMgd,OAAA,EAAAlgB;IAAA,CAAS,GACtE2f,EAAA,CAAiBjgB,CAAA,EAAQ,eAAgBkL,CAAA,IAAM;MAC7C,MAAMnC,CAAA,GAAKgX,EAAA,CAAa1e,CAAM;MAC9BuB,CAAA,GAAe,CAACkI,CAAA,CAAaI,CAAC,KAAK,CAAC,EAAEnC,CAAA,IAAM,CAACmC,CAAA,CAAEyV,YAAA,CAAc,EAAC5W,QAAA,CAAShB,CAAE;IAC/E,GAAO;MAAEvF,OAAA,EAAS;IAAA,CAAM,GACpBhD,CAAA,IAAgByf,EAAA,CAAiBjgB,CAAA,EAAQ,QAASkL,CAAA,IAAU;MAC1DsM,UAAA,CAAW,MAAM;QACf,IAAIzO,CAAA;QACJ,MAAM8C,CAAA,GAAKkU,EAAA,CAAa1e,CAAM;QAC9B,EAAM0H,CAAA,GAAK/I,CAAA,CAAOgD,QAAA,CAAS0B,aAAA,KAAkB,OAAO,SAASqE,CAAA,CAAGhB,OAAA,MAAa,YAAY,EAAE8D,CAAA,IAAM,QAAgBA,CAAA,CAAGgV,QAAA,CAAS7gB,CAAA,CAAOgD,QAAA,CAAS0B,aAAa,MACxJ/F,CAAA,CAAQuM,CAAK;MAChB,GAAE,CAAC;IACV,CAAK,EACL,CAAIO,MAAA,CAAOC,OAAO;EAEhB,OADa,MAAMV,CAAA,CAAQmN,OAAA,CAASjN,CAAA,IAAOA,CAAA,CAAE,CAAE;AAEjD;AAEA,SAAS4V,GAAmBzf,CAAA,EAAW;EACrC,OAAI,OAAOA,CAAA,IAAc,aAChBA,CAAA,GACA,OAAOA,CAAA,IAAc,WACpB1C,CAAA,IAAUA,CAAA,CAAMoiB,GAAA,KAAQ1f,CAAA,GACzBC,KAAA,CAAMC,OAAA,CAAQF,CAAS,IACtB1C,CAAA,IAAU0C,CAAA,CAAU0I,QAAA,CAASpL,CAAA,CAAMoiB,GAAG,IACzC,MAAM;AACf;AACA,SAASC,GAAA,GAAe3f,CAAA,EAAM;EAC5B,IAAI1C,CAAA;IACAC,CAAA;IACAoB,CAAA,GAAU;EACVqB,CAAA,CAAKpC,MAAA,KAAW,KAClBN,CAAA,GAAM0C,CAAA,CAAK,CAAC,GACZzC,CAAA,GAAUyC,CAAA,CAAK,CAAC,GAChBrB,CAAA,GAAUqB,CAAA,CAAK,CAAC,KACPA,CAAA,CAAKpC,MAAA,KAAW,IACrB,OAAOoC,CAAA,CAAK,CAAC,KAAM,YACrB1C,CAAA,GAAM,IACNC,CAAA,GAAUyC,CAAA,CAAK,CAAC,GAChBrB,CAAA,GAAUqB,CAAA,CAAK,CAAC,MAEhB1C,CAAA,GAAM0C,CAAA,CAAK,CAAC,GACZzC,CAAA,GAAUyC,CAAA,CAAK,CAAC,MAGlB1C,CAAA,GAAM,IACNC,CAAA,GAAUyC,CAAA,CAAK,CAAC;EAElB,MAAM;MACJvB,MAAA,EAAAM,CAAA,GAAS4f,EAAA;MACTiB,SAAA,EAAA3gB,CAAA,GAAY;MACZkD,OAAA,EAAAhD,CAAA,GAAU;MACV0gB,MAAA,EAAAte,CAAA,GAAS;IACV,IAAG5C,CAAA;IACE8K,CAAA,GAAYgW,EAAA,CAAmBniB,CAAG;EAOxC,OAAOshB,EAAA,CAAiB7f,CAAA,EAAQE,CAAA,EANd0K,CAAA,IAAM;IAClBA,CAAA,CAAEmW,MAAA,IAAUpE,EAAA,CAAQna,CAAM,KAE1BkI,CAAA,CAAUE,CAAC,KACbpM,CAAA,CAAQoM,CAAC;EACf,GACuDxK,CAAO;AAC9D;AA0IA,SAAS4gB,GAAA,EAAa;EACpB,MAAM/f,CAAA,GAAYgY,CAAA,CAAI,EAAK;EAC3B,OAAI6F,EAAA,CAAkB,KACpBC,EAAA,CAAU,MAAM;IACd9d,CAAA,CAAU+X,KAAA,GAAQ;EACxB,CAAK,GAEI/X,CAAA;AACT;AAEA,SAASggB,GAAahgB,CAAA,EAAU;EAC9B,MAAM1C,CAAA,GAAYyiB,EAAA;EAClB,OAAOlI,CAAA,CAAS,OACdva,CAAA,CAAUya,KAAA,EACH,EAAQ/X,CAAA,CAAQ,EACxB;AACH;AAokBA,SAASigB,GAAcjgB,CAAA,EAAO1C,CAAA,GAAU,IAAI;EAC1C,MAAM;MAAEmE,MAAA,EAAAlE,CAAA,GAASohB;IAAe,IAAGrhB,CAAA;IAC7BqB,CAAA,GAAcqhB,EAAA,CAAa,MAAMziB,CAAA,IAAU,gBAAgBA,CAAA,IAAU,OAAOA,CAAA,CAAO2iB,UAAA,IAAe,UAAU;EAClH,IAAInhB,CAAA;EACJ,MAAME,CAAA,GAAU+Y,CAAA,CAAI,EAAK;IACnB7Y,CAAA,GAAWuK,CAAA,IAAU;MACzBzK,CAAA,CAAQ8Y,KAAA,GAAQrO,CAAA,CAAMjE,OAAA;IAC1B;IACQlE,CAAA,GAAUsd,CAAA,KAAM;MACf9f,CAAA,KAED,yBAAyBA,CAAA,GAC3BA,CAAA,CAAWsD,mBAAA,CAAoB,UAAUlD,CAAO,IAEhDJ,CAAA,CAAWohB,cAAA,CAAehhB,CAAO;IACvC;IACQsK,CAAA,GAAY2W,EAAA,CAAY,MAAM;MAC7BzhB,CAAA,CAAYoZ,KAAA,KAEjBxW,CAAA,IACAxC,CAAA,GAAaxB,CAAA,CAAO2iB,UAAA,CAAWxE,EAAA,CAAQ1b,CAAK,CAAC,GACzC,sBAAsBjB,CAAA,GACxBA,CAAA,CAAWqD,gBAAA,CAAiB,UAAUjD,CAAO,IAE7CJ,CAAA,CAAWshB,WAAA,CAAYlhB,CAAO,GAChCF,CAAA,CAAQ8Y,KAAA,GAAQhZ,CAAA,CAAW0G,OAAA;IAC/B,CAAG;EACD,OAAA0V,EAAA,CAAkB,MAAM;IACtB1R,CAAA,IACAlI,CAAA,IACAxC,CAAA,GAAa;EACjB,CAAG,GACME,CAAA;AACT;AA0WA,SAASqhB,GAAYtgB,CAAA,EAAQ;EAC3B,OAAOK,IAAA,CAAKkgB,KAAA,CAAMlgB,IAAA,CAAKC,SAAA,CAAUN,CAAM,CAAC;AAC1C;AAyBA,MAAMwgB,EAAA,GAAU,OAAO3E,UAAA,GAAe,MAAcA,UAAA,GAAa,OAAOpa,MAAA,GAAW,MAAcA,MAAA,GAAS,OAAOgf,MAAA,GAAW,MAAcA,MAAA,GAAS,OAAOC,IAAA,GAAS,MAAcA,IAAA,GAAO;EAClLC,EAAA,GAAY;EACZC,EAAA,GAA2B,eAAAC,EAAA,CAAW;AAC5C,SAASA,GAAA,EAAc;EACrB,OAAMF,EAAA,IAAaH,EAAA,KACjBA,EAAA,CAAQG,EAAS,IAAIH,EAAA,CAAQG,EAAS,KAAK,KACtCH,EAAA,CAAQG,EAAS;AAC1B;AACA,SAASG,GAAc9gB,CAAA,EAAK1C,CAAA,EAAU;EACpC,OAAOsjB,EAAA,CAAS5gB,CAAG,KAAK1C,CAAA;AAC1B;AAKA,SAASyjB,GAAoB/gB,CAAA,EAAS;EACpC,OAAOA,CAAA,IAAW,OAAO,QAAQA,CAAA,YAAmB4Y,GAAA,GAAM,QAAQ5Y,CAAA,YAAmBmX,GAAA,GAAM,QAAQnX,CAAA,YAAmBghB,IAAA,GAAO,SAAS,OAAOhhB,CAAA,IAAY,YAAY,YAAY,OAAOA,CAAA,IAAY,WAAW,WAAW,OAAOA,CAAA,IAAY,WAAW,WAAYmG,MAAA,CAAOsY,KAAA,CAAMze,CAAO,IAAe,QAAX;AAC9R;AAEA,MAAMihB,EAAA,GAAqB;IACzBC,OAAA,EAAS;MACPC,IAAA,EAAOnhB,CAAA,IAAMA,CAAA,KAAM;MACnBohB,KAAA,EAAQphB,CAAA,IAAMO,MAAA,CAAOP,CAAC;IACvB;IACDqhB,MAAA,EAAQ;MACNF,IAAA,EAAOnhB,CAAA,IAAMK,IAAA,CAAKkgB,KAAA,CAAMvgB,CAAC;MACzBohB,KAAA,EAAQphB,CAAA,IAAMK,IAAA,CAAKC,SAAA,CAAUN,CAAC;IAC/B;IACDshB,MAAA,EAAQ;MACNH,IAAA,EAAOnhB,CAAA,IAAMmG,MAAA,CAAOiN,UAAA,CAAWpT,CAAC;MAChCohB,KAAA,EAAQphB,CAAA,IAAMO,MAAA,CAAOP,CAAC;IACvB;IACDuhB,GAAA,EAAK;MACHJ,IAAA,EAAOnhB,CAAA,IAAMA,CAAA;MACbohB,KAAA,EAAQphB,CAAA,IAAMO,MAAA,CAAOP,CAAC;IACvB;IACDwhB,MAAA,EAAQ;MACNL,IAAA,EAAOnhB,CAAA,IAAMA,CAAA;MACbohB,KAAA,EAAQphB,CAAA,IAAMO,MAAA,CAAOP,CAAC;IACvB;IACDoJ,GAAA,EAAK;MACH+X,IAAA,EAAOnhB,CAAA,IAAM,IAAImX,GAAA,CAAI9W,IAAA,CAAKkgB,KAAA,CAAMvgB,CAAC,CAAC;MAClCohB,KAAA,EAAQphB,CAAA,IAAMK,IAAA,CAAKC,SAAA,CAAUL,KAAA,CAAMnB,IAAA,CAAKkB,CAAA,CAAEyhB,OAAA,CAAO,CAAE,CAAC;IACrD;IACDtM,GAAA,EAAK;MACHgM,IAAA,EAAOnhB,CAAA,IAAM,IAAI4Y,GAAA,CAAIvY,IAAA,CAAKkgB,KAAA,CAAMvgB,CAAC,CAAC;MAClCohB,KAAA,EAAQphB,CAAA,IAAMK,IAAA,CAAKC,SAAA,CAAUL,KAAA,CAAMnB,IAAA,CAAKkB,CAAC,CAAC;IAC3C;IACD0hB,IAAA,EAAM;MACJP,IAAA,EAAOnhB,CAAA,IAAM,IAAIghB,IAAA,CAAKhhB,CAAC;MACvBohB,KAAA,EAAQphB,CAAA,IAAMA,CAAA,CAAE2hB,WAAA,CAAa;IAC9B;EACH;EACMC,EAAA,GAAyB;AAC/B,SAASC,GAAW7hB,CAAA,EAAK1C,CAAA,EAAUC,CAAA,EAASoB,CAAA,GAAU,IAAI;EACxD,IAAII,CAAA;EACJ,MAAM;MACJqZ,KAAA,EAAAnZ,CAAA,GAAQ;MACR6iB,IAAA,EAAA3iB,CAAA,GAAO;MACP4iB,sBAAA,EAAAxgB,CAAA,GAAyB;MACzBygB,aAAA,EAAAvY,CAAA,GAAgB;MAChBwY,aAAA,EAAAvY,CAAA,GAAgB;MAChBwY,OAAA,EAAAvY,CAAA;MACAlI,MAAA,EAAAmI,CAAA,GAAS+U,EAAA;MACT1B,WAAA,EAAApT,CAAA;MACAsY,OAAA,EAAAza,CAAA,GAAWmF,CAAA,IAAM;QACflJ,OAAA,CAAQC,KAAA,CAAMiJ,CAAC;MAChB;MACDuV,aAAA,EAAA5X;IACD,IAAG7L,CAAA;IACE8L,CAAA,IAAQd,CAAA,GAAUsO,EAAA,GAAaD,CAAA,EAAK,OAAO1a,CAAA,IAAa,aAAaA,CAAA,KAAaA,CAAQ;EAChG,IAAI,CAACC,CAAA,EACH,IAAI;IACFA,CAAA,GAAUujB,EAAA,CAAc,qBAAqB,MAAM;MACjD,IAAIjU,CAAA;MACJ,QAAQA,CAAA,GAAM8R,EAAA,KAAkB,OAAO,SAAS9R,CAAA,CAAIwV,YAAA;IACrD;EACF,SAAQxV,CAAA,EAAG;IACVnF,CAAA,CAAQmF,CAAC;EACV;EAEH,IAAI,CAACtP,CAAA,EACH,OAAOkN,CAAA;EACT,MAAMC,CAAA,GAAUgR,EAAA,CAAQpe,CAAQ;IAC1BsN,CAAA,GAAOmW,EAAA,CAAoBrW,CAAO;IAClCG,CAAA,IAAc9L,CAAA,GAAKJ,CAAA,CAAQ2jB,UAAA,KAAe,OAAOvjB,CAAA,GAAKkiB,EAAA,CAAmBrW,CAAI;IAC7E;MAAEwS,KAAA,EAAOtS,CAAA;MAAYuS,MAAA,EAAQrS;IAAa,IAAG2S,EAAA,CACjDlT,CAAA,EACA,MAAMS,CAAA,CAAMT,CAAA,CAAKsN,KAAK,GACtB;MAAEK,KAAA,EAAAnZ,CAAA;MAAO6iB,IAAA,EAAA3iB,CAAA;MAAM8d,WAAA,EAAApT;IAAa,CAChC;EACE,OAAID,CAAA,IAAUrI,CAAA,IACZqc,EAAA,CAAa,MAAM;IACjBgB,EAAA,CAAiBhV,CAAA,EAAQ,WAAWgD,CAAM,GAC1CgS,EAAA,CAAiBhV,CAAA,EAAQgY,EAAA,EAAwBjV,CAAqB,GAClEnC,CAAA,IACFoC,CAAA;EACR,CAAK,GAEEpC,CAAA,IACHoC,CAAA,IACKnC,CAAA;EACP,SAASS,EAAM2B,CAAA,EAAG;IAChB,IAAI;MACF,IAAIA,CAAA,IAAK,MACPtP,CAAA,CAAQglB,UAAA,CAAWviB,CAAG,OACjB;QACL,MAAM8M,CAAA,GAAajC,CAAA,CAAWuW,KAAA,CAAMvU,CAAC;UAC/BE,CAAA,GAAWxP,CAAA,CAAQilB,OAAA,CAAQxiB,CAAG;QAChC+M,CAAA,KAAaD,CAAA,KACfvP,CAAA,CAAQklB,OAAA,CAAQziB,CAAA,EAAK8M,CAAU,GAC3BlD,CAAA,IACFA,CAAA,CAAO8Y,aAAA,CAAc,IAAIC,WAAA,CAAYf,EAAA,EAAwB;UAC3DrC,MAAA,EAAQ;YACNG,GAAA,EAAA1f,CAAA;YACA4iB,QAAA,EAAA7V,CAAA;YACA8V,QAAA,EAAU/V,CAAA;YACVgW,WAAA,EAAavlB;UACd;QACF,EAAC;MAGP;IACF,SAAQuP,CAAA,EAAG;MACVpF,CAAA,CAAQoF,CAAC;IACV;EACF;EACD,SAASJ,EAAKG,CAAA,EAAO;IACnB,MAAMC,CAAA,GAAWD,CAAA,GAAQA,CAAA,CAAMgW,QAAA,GAAWtlB,CAAA,CAAQilB,OAAA,CAAQxiB,CAAG;IAC7D,IAAI8M,CAAA,IAAY,MACd,OAAIrD,CAAA,IAAiBiB,CAAA,KAAY,QAC/BnN,CAAA,CAAQklB,OAAA,CAAQziB,CAAA,EAAK6K,CAAA,CAAWuW,KAAA,CAAM1W,CAAO,CAAC,GACzCA,CAAA;IACF,IAAI,CAACmC,CAAA,IAASnD,CAAA,EAAe;MAClC,MAAMqD,CAAA,GAAQlC,CAAA,CAAWsW,IAAA,CAAKrU,CAAQ;MACtC,OAAI,OAAOpD,CAAA,IAAkB,aACpBA,CAAA,CAAcqD,CAAA,EAAOrC,CAAO,IAC5BE,CAAA,KAAS,YAAY,CAAC3K,KAAA,CAAMC,OAAA,CAAQ6M,CAAK,IACzC;QAAE,GAAGrC,CAAA;QAAS,GAAGqC;MAAA,IACnBA,CAAA;IACb,OAAW,OAAI,OAAOD,CAAA,IAAa,WACtBA,CAAA,GAEAjC,CAAA,CAAWsW,IAAA,CAAKrU,CAAQ;EAElC;EACD,SAASH,EAAsBE,CAAA,EAAO;IACpCD,CAAA,CAAOC,CAAA,CAAM0S,MAAM;EACpB;EACD,SAAS3S,EAAOC,CAAA,EAAO;IACrB,IAAI,EAAAA,CAAA,IAASA,CAAA,CAAMiW,WAAA,KAAgBvlB,CAAA,GAEnC;MAAA,IAAIsP,CAAA,IAASA,CAAA,CAAM6S,GAAA,IAAO,MAAM;QAC9BjV,CAAA,CAAKsN,KAAA,GAAQrN,CAAA;QACb;MACD;MACD,IAAI,EAAAmC,CAAA,IAASA,CAAA,CAAM6S,GAAA,KAAQ1f,CAAA,GAE3B;QAAA8K,CAAA;QACA,IAAI;UACF,CAAK+B,CAAA,IAAS,OAAO,SAASA,CAAA,CAAMgW,QAAA,MAAchY,CAAA,CAAWuW,KAAA,CAAM3W,CAAA,CAAKsN,KAAK,MAC3EtN,CAAA,CAAKsN,KAAA,GAAQrL,CAAA,CAAKG,CAAK;QAC1B,SAAQC,CAAA,EAAG;UACVpF,CAAA,CAAQoF,CAAC;QACf,UAAc;UACJD,CAAA,GACFkR,EAAA,CAAS/S,CAAW,IAEpBA,CAAA;QACH;MAAA;IAAA;EACF;AACH;AAEA,SAAS+X,GAAiB/iB,CAAA,EAAS;EACjC,OAAOigB,EAAA,CAAc,gCAAgCjgB,CAAO;AAC9D;AAEA,SAASgjB,GAAahjB,CAAA,GAAU,IAAI;EAClC,MAAM;MACJijB,QAAA,EAAA3lB,CAAA,GAAW;MACX4lB,SAAA,EAAA3lB,CAAA,GAAY;MACZ4lB,YAAA,EAAAxkB,CAAA,GAAe;MACf8C,MAAA,EAAA1C,CAAA,GAAS4f,EAAA;MACTyE,OAAA,EAAAnkB,CAAA;MACAokB,UAAA,EAAAlkB,CAAA,GAAa;MACb4iB,sBAAA,EAAAxgB,CAAA,GAAyB;MACzB+hB,UAAA,EAAA7Z,CAAA;MACA8Z,QAAA,EAAA7Z,CAAA;MACA8Z,iBAAA,EAAA7Z,CAAA,GAAoB;IACrB,IAAG3J,CAAA;IACE4J,CAAA,GAAQ;MACZ6Z,IAAA,EAAM;MACNC,KAAA,EAAO;MACPC,IAAA,EAAM;MACN,IAAG3jB,CAAA,CAAQ4jB,KAAA,IAAS,CAAE;IAC1B;IACQ/Z,CAAA,GAAgBkZ,EAAA,CAAiB;MAAEthB,MAAA,EAAA1C;IAAQ;IAC3C2I,CAAA,GAASmQ,CAAA,CAAS,MAAMhO,CAAA,CAAckO,KAAA,GAAQ,SAAS,OAAO;IAC9DvN,CAAA,GAAQf,CAAA,KAAetK,CAAA,IAAc,OAAOme,EAAA,CAAM3e,CAAY,IAAIkjB,EAAA,CAAW1iB,CAAA,EAAYR,CAAA,EAAcM,CAAA,EAAS;MAAEwC,MAAA,EAAA1C,CAAA;MAAQgjB,sBAAA,EAAAxgB;IAAwB;IAClJkJ,CAAA,GAAQoN,CAAA,CAAS,MAAMrN,CAAA,CAAMuN,KAAA,KAAU,SAASrQ,CAAA,CAAOqQ,KAAA,GAAQvN,CAAA,CAAMuN,KAAK;IAC1ErN,CAAA,GAAkBoW,EAAA,CACtB,mBACA,CAAC9V,CAAA,EAAWE,CAAA,EAAYwB,CAAA,KAAU;MAChC,MAAMC,CAAA,GAAK,OAAO3B,CAAA,IAAc,WAAWjM,CAAA,IAAU,OAAO,SAASA,CAAA,CAAO4C,QAAA,CAAS2C,aAAA,CAAc0G,CAAS,IAAI0T,EAAA,CAAa1T,CAAS;MACtI,IAAI,CAAC2B,CAAA,EACH;MACF,IAAIC,CAAA;MACJ,IAAIjD,CAAA,EAAmB;QACrBiD,CAAA,GAAQ7N,CAAA,CAAO4C,QAAA,CAASkiB,aAAA,CAAc,OAAO;QAC7C,MAAMhX,CAAA,GAAc;QACpBD,CAAA,CAAMkX,WAAA,CAAYniB,QAAA,CAASoiB,cAAA,CAAelX,CAAW,CAAC,GACtD9N,CAAA,CAAO4C,QAAA,CAASqiB,IAAA,CAAKF,WAAA,CAAYlX,CAAK;MACvC;MACD,IAAI1B,CAAA,KAAe,SAAS;QAC1B,MAAM2B,CAAA,GAAUH,CAAA,CAAMrL,KAAA,CAAM,KAAK;QACjCxD,MAAA,CAAOomB,MAAA,CAAOra,CAAK,EAAEmV,OAAA,CAASjS,CAAA,KAAOA,CAAA,IAAK,IAAIzL,KAAA,CAAM,KAAK,CAAC,EAAE+I,MAAA,CAAOC,OAAO,EAAEyM,OAAA,CAAShK,CAAA,IAAM;UACrFD,CAAA,CAAQnE,QAAA,CAASoE,CAAC,IACpBH,CAAA,CAAGuX,SAAA,CAAUC,GAAA,CAAIrX,CAAC,IAElBH,CAAA,CAAGuX,SAAA,CAAUlJ,MAAA,CAAOlO,CAAC;QACjC,CAAS;MACT,OACQH,CAAA,CAAG1H,YAAA,CAAaiG,CAAA,EAAYwB,CAAK;MAE/B/C,CAAA,KACF5K,CAAA,CAAOiH,gBAAA,CAAiB4G,CAAK,EAAEwX,OAAA,EAC/BziB,QAAA,CAASqiB,IAAA,CAAKK,WAAA,CAAYzX,CAAK;IAElC,CACL;EACE,SAAShC,EAAiBI,CAAA,EAAM;IAC9B,IAAIE,CAAA;IACJR,CAAA,CAAgBpN,CAAA,EAAUC,CAAA,GAAY2N,CAAA,GAAKtB,CAAA,CAAMoB,CAAI,MAAM,OAAOE,CAAA,GAAKF,CAAI;EAC5E;EACD,SAASH,EAAUG,CAAA,EAAM;IACnBhL,CAAA,CAAQskB,SAAA,GACVtkB,CAAA,CAAQskB,SAAA,CAAUtZ,CAAA,EAAMJ,CAAgB,IAExCA,CAAA,CAAiBI,CAAI;EACxB;EACDmN,EAAA,CAAM1N,CAAA,EAAOI,CAAA,EAAW;IAAEuN,KAAA,EAAO;IAAQ6F,SAAA,EAAW;EAAI,CAAE,GAC1DL,EAAA,CAAa,MAAM/S,CAAA,CAAUJ,CAAA,CAAMsN,KAAK,CAAC;EACzC,MAAMjN,CAAA,GAAO+M,CAAA,CAAS;IACpB3C,IAAA,EAAM;MACJ,OAAOxL,CAAA,GAAWc,CAAA,CAAMuN,KAAA,GAAQtN,CAAA,CAAMsN,KAAA;IACvC;IACD5C,IAAInK,CAAA,EAAG;MACLR,CAAA,CAAMuN,KAAA,GAAQ/M,CAAA;IACf;EACL,CAAG;EACD,IAAI;IACF,OAAOnN,MAAA,CAAOC,MAAA,CAAOgN,CAAA,EAAM;MAAEyZ,KAAA,EAAA/Z,CAAA;MAAOga,MAAA,EAAA9c,CAAA;MAAQ+c,KAAA,EAAAha;IAAK,CAAE;EACpD,QAAW;IACV,OAAOK,CAAA;EACR;AACH;AA6zBA,SAAS4Z,GAAgB1kB,CAAA,EAAI1C,CAAA,GAAU,IAAI;EACzC,MAAM;MACJqnB,UAAA,EAAApnB,CAAA,GAAa;MACbqnB,UAAA,EAAAjmB,CAAA,GAAa;MACb8C,MAAA,EAAA1C,CAAA,GAAS4f;IACV,IAAGrhB,CAAA;IACE2B,CAAA,GAAY+Y,CAAA,CAAI,EAAK;EAC3B,IAAI7Y,CAAA;EACJ,MAAMoC,CAAA,GAAUkI,CAAA,IAAa;IAC3B,MAAMC,CAAA,GAAQD,CAAA,GAAWlM,CAAA,GAAaoB,CAAA;IAClCQ,CAAA,KACF2W,YAAA,CAAa3W,CAAK,GAClBA,CAAA,GAAQ,SAENuK,CAAA,GACFvK,CAAA,GAAQgX,UAAA,CAAW,MAAMlX,CAAA,CAAU8Y,KAAA,GAAQtO,CAAA,EAAUC,CAAK,IAE1DzK,CAAA,CAAU8Y,KAAA,GAAQtO,CAAA;EACxB;EACE,OAAK1K,CAAA,KAEL6f,EAAA,CAAiB5e,CAAA,EAAI,cAAc,MAAMuB,CAAA,CAAO,EAAI,GAAG;IAAEY,OAAA,EAAS;EAAI,CAAE,GACxEyc,EAAA,CAAiB5e,CAAA,EAAI,cAAc,MAAMuB,CAAA,CAAO,EAAK,GAAG;IAAEY,OAAA,EAAS;EAAI,CAAE,IAClElD,CAAA;AACT;AA8uBA,SAAS4lB,GAAS7kB,CAAA,EAAQ1C,CAAA,GAAU,IAAI;EACtC,MAAM;MAAE6lB,YAAA,EAAA5lB,CAAA,GAAe;MAAOunB,YAAA,EAAAnmB,CAAA,GAAe;IAAK,IAAKrB,CAAA;IACjDyB,CAAA,GAAeiZ,CAAA,CAAI,EAAK;IACxB/Y,CAAA,GAAgB4Y,CAAA,CAAS,MAAM6G,EAAA,CAAa1e,CAAM,CAAC;EACzD4e,EAAA,CAAiB3f,CAAA,EAAe,SAAUsC,CAAA,IAAU;IAClD,IAAIkI,CAAA,EAAIC,CAAA;IACR,CAAI,CAAC/K,CAAA,KAAkB+K,CAAA,IAAMD,CAAA,GAAKlI,CAAA,CAAM9C,MAAA,EAAQgH,OAAA,KAAY,QAAgBiE,CAAA,CAAGtJ,IAAA,CAAKqJ,CAAA,EAAI,gBAAgB,OACtG1K,CAAA,CAAagZ,KAAA,GAAQ;EAC3B,CAAG,GACD6G,EAAA,CAAiB3f,CAAA,EAAe,QAAQ,MAAMF,CAAA,CAAagZ,KAAA,GAAQ,EAAK;EACxE,MAAM5Y,CAAA,GAAU0Y,CAAA,CAAS;IACvB3C,GAAA,EAAKA,CAAA,KAAMnW,CAAA,CAAagZ,KAAA;IACxB5C,IAAI5T,CAAA,EAAO;MACT,IAAIkI,CAAA,EAAIC,CAAA;MACJ,CAACnI,CAAA,IAASxC,CAAA,CAAagZ,KAAA,IACxBtO,CAAA,GAAKxK,CAAA,CAAc8Y,KAAA,KAAU,QAAgBtO,CAAA,CAAGsb,IAAA,KAC1CxjB,CAAA,IAAS,CAACxC,CAAA,CAAagZ,KAAA,MAC7BrO,CAAA,GAAKzK,CAAA,CAAc8Y,KAAA,KAAU,QAAgBrO,CAAA,CAAGhG,KAAA;IACpD;EACL,CAAG;EACD,OAAAyU,EAAA,CACElZ,CAAA,EACA,MAAM;IACJE,CAAA,CAAQ4Y,KAAA,GAAQxa,CAAA;EACjB,GACD;IAAE0gB,SAAA,EAAW;IAAM7F,KAAA,EAAO;EAAQ,CACtC,GACS;IAAE4M,OAAA,EAAA7lB;EAAO;AAClB;AAsiBA,SAAS8lB,GAAejlB,CAAA,EAAI;EAC1B,OAAI,OAAOklB,MAAA,GAAW,OAAellB,CAAA,YAAcklB,MAAA,GAC1CllB,CAAA,CAAG2B,QAAA,CAASmP,eAAA,GACjB,OAAOqU,QAAA,GAAa,OAAenlB,CAAA,YAAcmlB,QAAA,GAC5CnlB,CAAA,CAAG8Q,eAAA,GACL9Q,CAAA;AACT;AAkdA,MAAMolB,EAAA,GAA4B;EAChCC,IAAA,EAAOrlB,CAAA,IAAU,CAACA,CAAA,CAAMslB,KAAA,EAAOtlB,CAAA,CAAMulB,KAAK;EAC1CC,MAAA,EAASxlB,CAAA,IAAU,CAACA,CAAA,CAAMylB,OAAA,EAASzlB,CAAA,CAAM0lB,OAAO;EAChDC,MAAA,EAAS3lB,CAAA,IAAU,CAACA,CAAA,CAAM4lB,OAAA,EAAS5lB,CAAA,CAAM6lB,OAAO;EAChDC,QAAA,EAAW9lB,CAAA,IAAUA,CAAA,YAAiB+lB,KAAA,GAAQ,OAAO,CAAC/lB,CAAA,CAAMgmB,SAAA,EAAWhmB,CAAA,CAAMimB,SAAS;AACxF;AACA,SAASC,GAASlmB,CAAA,GAAU,IAAI;EAC9B,MAAM;IACJmmB,IAAA,EAAA7oB,CAAA,GAAO;IACP8oB,KAAA,EAAA7oB,CAAA,GAAQ;IACR8oB,gBAAA,EAAA1nB,CAAA,GAAmB;IACnBwkB,YAAA,EAAApkB,CAAA,GAAe;MAAE0I,CAAA,EAAG;MAAGC,CAAA,EAAG;IAAG;IAC7BjG,MAAA,EAAAxC,CAAA,GAAS0f,EAAA;IACTlgB,MAAA,EAAAU,CAAA,GAASF,CAAA;IACTqnB,MAAA,EAAA/kB,CAAA,GAAS;IACT0b,WAAA,EAAAxT;EACD,IAAGzJ,CAAA;EACJ,IAAI0J,CAAA,GAAkB;EACtB,MAAMC,CAAA,GAAIqO,CAAA,CAAIjZ,CAAA,CAAa0I,CAAC;IACtBmC,CAAA,GAAIoO,CAAA,CAAIjZ,CAAA,CAAa2I,CAAC;IACtBmC,CAAA,GAAamO,CAAA,CAAI,IAAI;IACrBtQ,CAAA,GAAY,OAAOpK,CAAA,IAAS,aAAaA,CAAA,GAAO8nB,EAAA,CAA0B9nB,CAAI;IAC9EkN,CAAA,GAAgBU,CAAA,IAAU;MAC9B,MAAMwB,CAAA,GAAShF,CAAA,CAAUwD,CAAK;MAC9BxB,CAAA,GAAkBwB,CAAA,EACdwB,CAAA,KACF,CAAC/C,CAAA,CAAEoO,KAAA,EAAOnO,CAAA,CAAEmO,KAAK,IAAIrL,CAAA,EACrB7C,CAAA,CAAWkO,KAAA,GAAQ;IAEzB;IACQtN,CAAA,GAAgBS,CAAA,IAAU;MAC9B,IAAIA,CAAA,CAAMqb,OAAA,CAAQ3oB,MAAA,GAAS,GAAG;QAC5B,MAAM8O,CAAA,GAAShF,CAAA,CAAUwD,CAAA,CAAMqb,OAAA,CAAQ,CAAC,CAAC;QACrC7Z,CAAA,KACF,CAAC/C,CAAA,CAAEoO,KAAA,EAAOnO,CAAA,CAAEmO,KAAK,IAAIrL,CAAA,EACrB7C,CAAA,CAAWkO,KAAA,GAAQ;MAEtB;IACL;IACQrN,CAAA,GAAgB8b,CAAA,KAAM;MAC1B,IAAI,CAAC9c,CAAA,IAAmB,CAACzK,CAAA,EACvB;MACF,MAAMiM,CAAA,GAAMxD,CAAA,CAAUgC,CAAe;MACjCA,CAAA,YAA2B+c,UAAA,IAAcvb,CAAA,KAC3CvB,CAAA,CAAEoO,KAAA,GAAQ7M,CAAA,CAAI,CAAC,IAAIjM,CAAA,CAAOynB,OAAA,EAC1B9c,CAAA,CAAEmO,KAAA,GAAQ7M,CAAA,CAAI,CAAC,IAAIjM,CAAA,CAAO0nB,OAAA;IAEhC;IACQ/b,CAAA,GAAQK,CAAA,KAAM;MAClBtB,CAAA,CAAEoO,KAAA,GAAQhZ,CAAA,CAAa0I,CAAA,EACvBmC,CAAA,CAAEmO,KAAA,GAAQhZ,CAAA,CAAa2I,CAAA;IAC3B;IACQmD,CAAA,GAAsBpB,CAAA,GAAeyB,CAAA,IAAUzB,CAAA,CAAY,MAAMe,CAAA,CAAaU,CAAK,GAAG,CAAE,KAAKA,CAAA,IAAUV,CAAA,CAAaU,CAAK;IACzHJ,CAAA,GAAsBrB,CAAA,GAAeyB,CAAA,IAAUzB,CAAA,CAAY,MAAMgB,CAAA,CAAaS,CAAK,GAAG,CAAE,KAAKA,CAAA,IAAUT,CAAA,CAAaS,CAAK;IACzHF,CAAA,GAAuBvB,CAAA,GAAc,MAAMA,CAAA,CAAY,MAAMiB,CAAA,CAAa,GAAI,CAAE,KAAI,MAAMA,CAAA;EAChG,IAAIvL,CAAA,EAAQ;IACV,MAAM+L,CAAA,GAAkB;MAAE/I,OAAA,EAAS;IAAA;IACnCyc,EAAA,CAAiBzf,CAAA,EAAQ,CAAC,aAAa,UAAU,GAAG0L,CAAA,EAAqBK,CAAe,GACpF3N,CAAA,IAASD,CAAA,KAAS,eACpBshB,EAAA,CAAiBzf,CAAA,EAAQ,CAAC,cAAc,WAAW,GAAG2L,CAAA,EAAqBI,CAAe,GACtFvM,CAAA,IACFigB,EAAA,CAAiBzf,CAAA,EAAQ,YAAYyL,CAAA,EAAOM,CAAe,IAE3D3J,CAAA,IAAUjE,CAAA,KAAS,UACrBshB,EAAA,CAAiB3f,CAAA,EAAQ,UAAU+L,CAAA,EAAsB;MAAE7I,OAAA,EAAS;IAAI,CAAE;EAC7E;EACD,OAAO;IACLsF,CAAA,EAAAkC,CAAA;IACAjC,CAAA,EAAAkC,CAAA;IACAgd,UAAA,EAAA/c;EACJ;AACA;AAEA,SAASgd,GAAkB7mB,CAAA,EAAQ1C,CAAA,GAAU,IAAI;EAC/C,MAAM;MACJwpB,aAAA,EAAAvpB,CAAA,GAAgB;MAChBkE,MAAA,EAAA9C,CAAA,GAASggB;IACV,IAAGrhB,CAAA;IACEyB,CAAA,GAAOzB,CAAA,CAAQ6oB,IAAA,IAAQ;IACvB;MAAE1e,CAAA,EAAAxI,CAAA;MAAGyI,CAAA,EAAAvI,CAAA;MAAGynB,UAAA,EAAArlB;IAAU,IAAK2kB,EAAA,CAAS5oB,CAAO;IACvCmM,CAAA,GAAYuO,CAAA,CAAIhY,CAAA,KAA0BrB,CAAA,IAAU,OAAO,SAASA,CAAA,CAAOgD,QAAA,CAASoR,IAAA,CAAI;IACxFrJ,CAAA,GAAWsO,CAAA,CAAI,CAAC;IAChBrO,CAAA,GAAWqO,CAAA,CAAI,CAAC;IAChBpO,CAAA,GAAmBoO,CAAA,CAAI,CAAC;IACxBnO,CAAA,GAAmBmO,CAAA,CAAI,CAAC;IACxBtQ,CAAA,GAAgBsQ,CAAA,CAAI,CAAC;IACrBxN,CAAA,GAAewN,CAAA,CAAI,CAAC;IACpBvN,CAAA,GAAYuN,CAAA,CAAI,EAAI;EAC1B,IAAItN,CAAA,GAAO+Q,CAAA,KAAM,CACnB;EACE,OAAI9c,CAAA,KACF+L,CAAA,GAAOyN,EAAA,CACL,CAAC1O,CAAA,EAAWxK,CAAA,EAAGE,CAAC,GAChB,MAAM;IACJ,MAAMyL,CAAA,GAAK8T,EAAA,CAAajV,CAAS;IACjC,IAAI,CAACmB,CAAA,EACH;IACF,MAAM;MACJhD,IAAA,EAAAiD,CAAA;MACA9C,GAAA,EAAA+C,CAAA;MACA5G,KAAA,EAAA8G,CAAA;MACA/G,MAAA,EAAAiH;IACV,IAAYN,CAAA,CAAG1H,qBAAA;IACP0G,CAAA,CAAiBmO,KAAA,GAAQlN,CAAA,IAAQ9L,CAAA,KAAS,SAASJ,CAAA,CAAO+T,WAAA,GAAc,IACxE7I,CAAA,CAAiBkO,KAAA,GAAQjN,CAAA,IAAO/L,CAAA,KAAS,SAASJ,CAAA,CAAOgU,WAAA,GAAc,IACvEjL,CAAA,CAAcqQ,KAAA,GAAQ7M,CAAA,EACtBV,CAAA,CAAauN,KAAA,GAAQ/M,CAAA;IACrB,MAAM0B,CAAA,GAAMzN,CAAA,CAAE8Y,KAAA,GAAQnO,CAAA,CAAiBmO,KAAA;MACjCpL,CAAA,GAAMxN,CAAA,CAAE4Y,KAAA,GAAQlO,CAAA,CAAiBkO,KAAA;IACvCtN,CAAA,CAAUsN,KAAA,GAAQ/M,CAAA,KAAU,KAAKE,CAAA,KAAW,KAAKwB,CAAA,GAAM,KAAKC,CAAA,GAAM,KAAKD,CAAA,GAAM1B,CAAA,IAAS2B,CAAA,GAAMzB,CAAA,GACxF3N,CAAA,IAAiB,CAACkN,CAAA,CAAUsN,KAAA,MAC9BrO,CAAA,CAASqO,KAAA,GAAQrL,CAAA,EACjB/C,CAAA,CAASoO,KAAA,GAAQpL,CAAA;EAEpB,GACD;IAAEsR,SAAA,EAAW;EAAM,CACzB,GACIW,EAAA,CAAiBjd,QAAA,EAAU,cAAc,MAAM;IAC7C8I,CAAA,CAAUsN,KAAA,GAAQ;EACxB,CAAK,IAEI;IACLtQ,CAAA,EAAAxI,CAAA;IACAyI,CAAA,EAAAvI,CAAA;IACAynB,UAAA,EAAArlB,CAAA;IACAwlB,QAAA,EAAArd,CAAA;IACAsd,QAAA,EAAArd,CAAA;IACAsd,gBAAA,EAAArd,CAAA;IACAsd,gBAAA,EAAArd,CAAA;IACAsd,aAAA,EAAAzf,CAAA;IACA0f,YAAA,EAAA5c,CAAA;IACA6c,SAAA,EAAA5c,CAAA;IACAgR,IAAA,EAAA/Q;EACJ;AACA;AAosBA,SAAS4c,GAAoBtnB,CAAA,EAAK;EAChC,MAAM1C,CAAA,GAAQmE,MAAA,CAAOuE,gBAAA,CAAiBhG,CAAG;EACzC,IAAI1C,CAAA,CAAMgU,SAAA,KAAc,YAAYhU,CAAA,CAAMiU,SAAA,KAAc,YAAYjU,CAAA,CAAMgU,SAAA,KAAc,UAAUtR,CAAA,CAAIyU,WAAA,GAAczU,CAAA,CAAIwU,WAAA,IAAelX,CAAA,CAAMiU,SAAA,KAAc,UAAUvR,CAAA,CAAI2U,YAAA,GAAe3U,CAAA,CAAI0U,YAAA,EAC1L,OAAO;EACF;IACL,MAAMnX,CAAA,GAASyC,CAAA,CAAI6F,UAAA;IACnB,OAAI,CAACtI,CAAA,IAAUA,CAAA,CAAOmJ,OAAA,KAAY,SACzB,KACF4gB,EAAA,CAAoB/pB,CAAM;EAClC;AACH;AACA,SAASgqB,GAAevnB,CAAA,EAAU;EAChC,MAAM1C,CAAA,GAAI0C,CAAA,IAAYyB,MAAA,CAAO+lB,KAAA;IACvBjqB,CAAA,GAAUD,CAAA,CAAEmB,MAAA;EAClB,OAAI6oB,EAAA,CAAoB/pB,CAAO,IACtB,KACLD,CAAA,CAAEipB,OAAA,CAAQ3oB,MAAA,GAAS,IACd,MACLN,CAAA,CAAEe,cAAA,IACJf,CAAA,CAAEe,cAAA,CAAc,GACX;AACT;AACA,MAAMopB,EAAA,GAAoC,mBAAIC,OAAA;AAC9C,SAASC,GAAc3nB,CAAA,EAAS1C,CAAA,GAAe,IAAO;EACpD,MAAMC,CAAA,GAAWya,CAAA,CAAI1a,CAAY;EACjC,IAAIqB,CAAA,GAAwB;IACxBI,CAAA;EACJoZ,EAAA,CAAMmF,EAAA,CAAMtd,CAAO,GAAIuB,CAAA,IAAO;IAC5B,MAAMkI,CAAA,GAASwb,EAAA,CAAevJ,EAAA,CAAQna,CAAE,CAAC;IACzC,IAAIkI,CAAA,EAAQ;MACV,MAAMC,CAAA,GAAMD,CAAA;MACPge,EAAA,CAAkBvS,GAAA,CAAIxL,CAAG,KAC5B+d,EAAA,CAAkBtS,GAAA,CAAIzL,CAAA,EAAK3K,CAAe,GACxCxB,CAAA,CAASwa,KAAA,KACXrO,CAAA,CAAIke,KAAA,CAAMvW,QAAA,GAAW;IACxB;EACL,GAAK;IACD4M,SAAA,EAAW;EACf,CAAG;EACD,MAAMhf,CAAA,GAAO4oB,CAAA,KAAM;MACjB,MAAMtmB,CAAA,GAAK0jB,EAAA,CAAevJ,EAAA,CAAQ1b,CAAO,CAAC;MACtC,CAACuB,CAAA,IAAMhE,CAAA,CAASwa,KAAA,KAEhBoE,EAAA,KACFxd,CAAA,GAAwBigB,EAAA,CACtBrd,CAAA,EACA,aACCkI,CAAA,IAAM;QACL8d,EAAA,CAAe9d,CAAC;MACjB,GACD;QAAEtH,OAAA,EAAS;MAAO,CAC1B,IAEIZ,CAAA,CAAGqmB,KAAA,CAAMvW,QAAA,GAAW,UACpB9T,CAAA,CAASwa,KAAA,GAAQ;IACrB;IACQ5Y,CAAA,GAAS2oB,CAAA,KAAM;MACnB,IAAIvmB,CAAA;MACJ,MAAMkI,CAAA,GAAKwb,EAAA,CAAevJ,EAAA,CAAQ1b,CAAO,CAAC;MACtC,CAACyJ,CAAA,IAAM,CAAClM,CAAA,CAASwa,KAAA,KAErBoE,EAAA,KAAUxd,CAAA,IAAyB,QAAgBA,CAAA,CAAuB,IAC1E8K,CAAA,CAAGme,KAAA,CAAMvW,QAAA,IAAY9P,CAAA,GAAKkmB,EAAA,CAAkBvS,GAAA,CAAIzL,CAAE,MAAM,OAAOlI,CAAA,GAAK,IACpEkmB,EAAA,CAAkBM,MAAA,CAAOte,CAAE,GAC3BlM,CAAA,CAASwa,KAAA,GAAQ;IACrB;EACE,OAAAoD,EAAA,CAAkBhc,CAAM,GACjB0Y,CAAA,CAAS;IACd3C,IAAA,EAAM;MACJ,OAAO3X,CAAA,CAASwa,KAAA;IACjB;IACD5C,IAAI5T,CAAA,EAAG;MACDA,CAAA,GACFtC,CAAA,KAEAE,CAAA;IACH;EACL,CAAG;AACH;AAmbA,SAAS6oB,GAAShoB,CAAA,EAAQ1C,CAAA,GAAU,IAAI;EACtC,MAAM;MACJ2Y,SAAA,EAAA1Y,CAAA,GAAY;MACZ0qB,OAAA,EAAAtpB,CAAA;MACAupB,UAAA,EAAAnpB,CAAA;MACAopB,YAAA,EAAAlpB,CAAA;MACAkD,OAAA,EAAAhD,CAAA,GAAU;MACVsC,MAAA,EAAAF,CAAA,GAASod;IACV,IAAGrhB,CAAA;IACEmM,CAAA,GAAc2e,EAAA,CAAS;MAAE3gB,CAAA,EAAG;MAAGC,CAAA,EAAG;IAAC,CAAE;IACrCgC,CAAA,GAAY0e,EAAA,CAAS;MAAE3gB,CAAA,EAAG;MAAGC,CAAA,EAAG;IAAC,CAAE;IACnCiC,CAAA,GAAQkO,CAAA,CAAS,MAAMpO,CAAA,CAAYhC,CAAA,GAAIiC,CAAA,CAAUjC,CAAC;IAClDmC,CAAA,GAAQiO,CAAA,CAAS,MAAMpO,CAAA,CAAY/B,CAAA,GAAIgC,CAAA,CAAUhC,CAAC;IAClD;MAAEP,GAAA,EAAA0C,CAAA;MAAKwe,GAAA,EAAA3gB;IAAK,IAAGV,IAAA;IACfwD,CAAA,GAAsBqN,CAAA,CAAS,MAAMhO,CAAA,CAAInC,CAAA,CAAIiC,CAAA,CAAMoO,KAAK,GAAGrQ,CAAA,CAAIkC,CAAA,CAAMmO,KAAK,CAAC,KAAKxa,CAAS;IACzFkN,CAAA,GAAYuN,CAAA,CAAI,EAAK;IACrBtN,CAAA,GAAYmN,CAAA,CAAS,MACpBrN,CAAA,CAAoBuN,KAAA,GAErBrQ,CAAA,CAAIiC,CAAA,CAAMoO,KAAK,IAAIrQ,CAAA,CAAIkC,CAAA,CAAMmO,KAAK,IAC7BpO,CAAA,CAAMoO,KAAA,GAAQ,IAAI,SAAS,UAE3BnO,CAAA,CAAMmO,KAAA,GAAQ,IAAI,OAAO,SAJzB,MAMV;IACKnN,CAAA,GAAuBiC,CAAA,IAAM,CAACA,CAAA,CAAE0Z,OAAA,CAAQ,CAAC,EAAEd,OAAA,EAAS5Y,CAAA,CAAE0Z,OAAA,CAAQ,CAAC,EAAEb,OAAO;IACxE7a,CAAA,GAAoByd,CAACzb,CAAA,EAAGC,CAAA,KAAM;MAClCrD,CAAA,CAAYhC,CAAA,GAAIoF,CAAA,EAChBpD,CAAA,CAAY/B,CAAA,GAAIoF,CAAA;IACpB;IACQhC,CAAA,GAAkByd,CAAC1b,CAAA,EAAGC,CAAA,KAAM;MAChCpD,CAAA,CAAUjC,CAAA,GAAIoF,CAAA,EACdnD,CAAA,CAAUhC,CAAA,GAAIoF,CAAA;IAClB;EACE,IAAI9B,CAAA;EACJ,MAAME,CAAA,GAA0Bsd,EAAA,CAAyBjnB,CAAA,IAAU,OAAO,SAASA,CAAA,CAAOI,QAAQ;EAC7FxC,CAAA,GAGH6L,CAAA,GAAkBE,CAAA,GAA0B;IAAE/I,OAAA,EAAS;EAAI,IAAK;IAAEgd,OAAA,EAAS;EAAA,IAF3EnU,CAAA,GAAkBE,CAAA,GAA0B;IAAE/I,OAAA,EAAS;IAAOgd,OAAA,EAAS;EAAA,IAAS;IAAEA,OAAA,EAAS;EAAA;EAG7F,MAAMzS,CAAA,GAAcG,CAAA,IAAM;MACpBpC,CAAA,CAAUsN,KAAA,KACZhZ,CAAA,IAAc,QAAgBA,CAAA,CAAW8N,CAAA,EAAGnC,CAAA,CAAUqN,KAAK,IAC7DtN,CAAA,CAAUsN,KAAA,GAAQ;IACtB;IACQpL,CAAA,GAAQ,CACZiS,EAAA,CAAiB5e,CAAA,EAAQ,cAAe6M,CAAA,IAAM;MAC5C,IAAIA,CAAA,CAAE0Z,OAAA,CAAQ3oB,MAAA,KAAW,GACvB;MACEoN,CAAA,CAAgBmU,OAAA,IAAW,CAACnU,CAAA,CAAgB7I,OAAA,IAC9C0K,CAAA,CAAExO,cAAA,CAAc;MAClB,MAAM,CAACyO,CAAA,EAAGC,CAAC,IAAInC,CAAA,CAAoBiC,CAAC;MACpChC,CAAA,CAAkBiC,CAAA,EAAGC,CAAC,GACtBjC,CAAA,CAAgBgC,CAAA,EAAGC,CAAC,GACpB9N,CAAA,IAAgB,QAAgBA,CAAA,CAAa4N,CAAC;IAC/C,GAAE7B,CAAe,GAClB4T,EAAA,CAAiB5e,CAAA,EAAQ,aAAc6M,CAAA,IAAM;MAC3C,IAAIA,CAAA,CAAE0Z,OAAA,CAAQ3oB,MAAA,KAAW,GACvB;MACF,MAAM,CAACkP,CAAA,EAAGC,CAAC,IAAInC,CAAA,CAAoBiC,CAAC;MACpC/B,CAAA,CAAgBgC,CAAA,EAAGC,CAAC,GAChB,CAACtC,CAAA,CAAUsN,KAAA,IAASvN,CAAA,CAAoBuN,KAAA,KAC1CtN,CAAA,CAAUsN,KAAA,GAAQ,KAChBtN,CAAA,CAAUsN,KAAA,KACZpZ,CAAA,IAAW,QAAgBA,CAAA,CAAQkO,CAAC;IACvC,GAAE7B,CAAe,GAClB4T,EAAA,CAAiB5e,CAAA,EAAQ,CAAC,YAAY,aAAa,GAAG0M,CAAA,EAAY1B,CAAe,EACrF;EAEE,OAAO;IACLyd,uBAAA,EAAAvd,CAAA;IACAwd,SAAA,EAAAje,CAAA;IACAzL,SAAA,EAAA0L,CAAA;IACAie,WAAA,EAAAlf,CAAA;IACAmf,SAAA,EAAAlf,CAAA;IACAmf,OAAA,EAASlf,CAAA;IACTmf,OAAA,EAASlf,CAAA;IACT6R,IAAA,EATWA,CAAA,KAAM9O,CAAA,CAAMmK,OAAA,CAASjK,CAAA,IAAMA,CAAA,CAAC,CAAE;EAU7C;AACA;AACA,SAAS2b,GAAyBxoB,CAAA,EAAU;EAC1C,IAAI,CAACA,CAAA,EACH,OAAO;EACT,IAAI1C,CAAA,GAAkB;EACtB,MAAMC,CAAA,GAAe;IACnB,IAAI4E,QAAA,EAAU;MACZ,OAAA7E,CAAA,GAAkB,IACX;IACR;EACL;EACE,OAAA0C,CAAA,CAASoC,gBAAA,CAAiB,KAAK6Z,EAAA,EAAM1e,CAAY,GACjDyC,CAAA,CAASqC,mBAAA,CAAoB,KAAK4Z,EAAI,GAC/B3e,CAAA;AACT;AAwlBA,SAASyrB,GAAU/oB,CAAA,EAAO1C,CAAA,EAAKC,CAAA,EAAMoB,CAAA,GAAU,IAAI;EAC9C,IAACI,CAAA,EAAIE,CAAA,EAAIE,CAAA;EACZ,MAAM;MACJ6pB,KAAA,EAAAznB,CAAA,GAAQ;MACRY,OAAA,EAAAsH,CAAA,GAAU;MACVmW,SAAA,EAAAlW,CAAA;MACAoY,IAAA,EAAAnY,CAAA,GAAO;MACPsf,YAAA,EAAArf,CAAA;MACAsf,UAAA,EAAArf;IACD,IAAGlL,CAAA;IACE+I,CAAA,GAAKmW,EAAA;IACLrT,CAAA,GAAQjN,CAAA,KAASmK,CAAA,IAAM,OAAO,SAASA,CAAA,CAAGyhB,IAAA,OAAWpqB,CAAA,GAAK2I,CAAA,IAAM,OAAO,SAASA,CAAA,CAAG0hB,KAAA,KAAU,OAAO,SAASrqB,CAAA,CAAGsqB,IAAA,CAAK3hB,CAAE,QAAQvI,CAAA,IAAMF,CAAA,GAAKyI,CAAA,IAAM,OAAO,SAASA,CAAA,CAAG4hB,KAAA,KAAU,OAAO,SAASrqB,CAAA,CAAGmqB,KAAA,KAAU,OAAO,SAASjqB,CAAA,CAAGkqB,IAAA,CAAK3hB,CAAA,IAAM,OAAO,SAASA,CAAA,CAAG4hB,KAAK;EACtQ,IAAI7e,CAAA,GAAQf,CAAA;EACPpM,CAAA,KAODA,CAAA,GAAM,eAGVmN,CAAA,GAAQA,CAAA,IAAS,UAAUnN,CAAA,CAAIyC,QAAA,CAAU;EACzC,MAAM2K,CAAA,GAAWI,CAAA,IAASvJ,CAAA,GAAc,OAAOA,CAAA,IAAU,aAAaA,CAAA,CAAMuJ,CAAG,IAAIwV,EAAA,CAAYxV,CAAG,IAAhEA,CAAA;IAC5BF,CAAA,GAAW2e,CAAA,KAAMzN,EAAA,CAAM9b,CAAA,CAAM1C,CAAG,CAAC,IAAIoN,CAAA,CAAQ1K,CAAA,CAAM1C,CAAG,CAAC,IAAIsM,CAAA;IAC3DiB,CAAA,GAAeC,CAAA,IAAU;MACzBjB,CAAA,GACEA,CAAA,CAAWiB,CAAK,KAClBN,CAAA,CAAMC,CAAA,EAAOK,CAAK,IAEpBN,CAAA,CAAMC,CAAA,EAAOK,CAAK;IAExB;EACE,IAAIrB,CAAA,EAAS;IACX,MAAMqB,CAAA,GAAeF,CAAA;MACfI,CAAA,GAAQgN,CAAA,CAAIlN,CAAY;IAC9B,IAAII,CAAA,GAAa;IACjB,OAAAiN,EAAA,CACE,MAAMnY,CAAA,CAAM1C,CAAG,GACdoP,CAAA,IAAM;MACAxB,CAAA,KACHA,CAAA,GAAa,IACbF,CAAA,CAAM+M,KAAA,GAAQrN,CAAA,CAAQgC,CAAC,GACvBqR,EAAA,CAAS,MAAM7S,CAAA,GAAa,EAAK;IAEpC,CACP,GACIiN,EAAA,CACEnN,CAAA,EACC0B,CAAA,IAAM;MACD,CAACxB,CAAA,KAAewB,CAAA,KAAM1M,CAAA,CAAM1C,CAAG,KAAKqM,CAAA,KACtCkB,CAAA,CAAY6B,CAAC;IAChB,GACD;MAAEoV,IAAA,EAAAnY;IAAM,CACd,GACWqB,CAAA;EACX,OACI,OAAO6M,CAAA,CAAS;IACd3C,IAAA,EAAM;MACJ,OAAOtK,CAAA,CAAQ;IAChB;IACDuK,IAAIrK,CAAA,EAAO;MACTD,CAAA,CAAYC,CAAK;IAClB;EACP,CAAK;AAEL;AC/2MA,MAAA0e,EAAA,GAAgBxpB,CAAA,IACd6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAQmsB,EAAA,CAAQzpB,CAAK;IAC3B,OAAQ1C,CAAA,GAAa,mBAAmBA,CAAK,KAA7B;EAClB,CAAC;ECJGosB,EAAA,GAAgB1pB,CAAA,IACpB,OAAOA,CAAA,IAAU,aAAaA,CAAA,KAAU,MAAMA,CAAA,KAAU,UAAUA,CAAA,KAAU;EAK9E2pB,CAAA,GAAmB3pB,CAAA,IACjB6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAQmsB,EAAA,CAAQzpB,CAAE;IACxB,OACG0pB,EAAA,CAAapsB,CAAK,IAEf,OAAOA,CAAA,IAAU,YACjBA,CAAA,GACAA,CAAA,KAAU,MAAMA,CAAA,KAAU,SAH1BA,CAAA;EAOR,CAAC;ECjBHssB,EAAA,GAAeC,CACb7pB,CAAA,EACA1C,CAAA,KACG;IACG,MAAAC,CAAA,GAAsBosB,CAAA,CAAc3pB,CAAW;MAC/CrB,CAAA,GAAgB4e,CAAA,CAAMjgB,CAAK;IAE1B,OAAAua,CAAA,CAAS,MACdta,CAAA,CAAoBwa,KAAA,KAAU,KAC1B,SACA,OAAOxa,CAAA,CAAoBwa,KAAA,IAAU,WACrCxa,CAAA,CAAoBwa,KAAA,GACpBpZ,CAAA,CAAcoZ,KAAA,KAAU,KACxB,SACAxa,CAAA,CAAoBwa,KAAA,KAAU,KAC9B,UACA;EAER;ECnBA+R,EAAA,GAAeC,CACb/pB,CAAA,EACA1C,CAAA,KACG;IACG,MAAAC,CAAA,GAAoBggB,CAAA,CAAMjgB,CAAS;MACnCqB,CAAA,GAAgB4e,CAAA,CAAMvd,CAAK;MAE3BjB,CAAA,GAAewe,CAAA,CAAM,MAAMyM,EAAA,CAAOrrB,CAAA,CAAcoZ,KAAK,CAAC;MACtD9Y,CAAA,GAAoB4Y,CAAA,CAAS,MACjC9Y,CAAA,CAAagZ,KAAA,GACTkS,EAAA,CACEtrB,CAAA,CAAcoZ,KAAA,EACdxa,CAAA,CAAkBwa,KAAA,IAAS,CACzB,UACA,eACA,UACA,QACA,OACA,WACA,uBACA,UACA,MACA,WACA,WACA,gBACA,oBACA,mBACA,wBACA,oBACA,wBACF,IAEF,CAAC;IAGA;MAACmS,YAAA,EAAAnrB,CAAA;MAAcorB,iBAAA,EAAAlrB;IAAA;EACxB;ECnCemrB,EAAA,GAAAhP,EAAA,CAAkB,MAAM;IAC/B,MAAApb,CAAA,GAAQooB,EAAA,CAA2B,EAAE;IAKpC;MAACiC,KAAA,EAAArqB,CAAA;MAAOiL,KAAA,EAJDA,CAAA,KAAY;QAClBjL,CAAA,CAAAsqB,MAAA,CAAO,GAAGtqB,CAAA,CAAMpC,MAAM;MAAA;IAAA;EAIhC,CAAC;ECDD2sB,EAAA,GAAeC,CAACxqB,CAAA,GAAyB,OAAO;IACxC,MAAA1C,CAAA,GAAU0C,CAAA,CAAKyqB,OAAA,IAAW;MAC1BltB,CAAA,GAAY;MACZoB,CAAA,GAAW;IACjB,OAAOqkB,EAAA,CAAa;MAClBE,SAAA,EAAA3lB,CAAA;MACA0lB,QAAA,EAAAtkB,CAAA;MACA0kB,UAAA,EACE/lB,CAAA,KAAY,KACR,YAAY0C,CAAA,CAAKkjB,SAAA,IAAa3lB,CAAS,IAAIyC,CAAA,CAAKijB,QAAA,IAAYtkB,CAAQ,KACpE;MACN,GAAGqB;IAAA,CACJ;EACH;ECpBA0qB,EAAA,GAAgB1qB,CAAA,IACd6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAQmsB,EAAA,CAAQzpB,CAAG;IAClB;MACL,CAAC,WAAW1C,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;MAChD,CAAC,QAAQrtB,CAAA,CAAMstB,WAAW,EAAE,GAAGttB,CAAA,CAAMstB,WAAA,KAAgB,QAAQttB,CAAA,CAAMqtB,OAAA,KAAY;MAC/E,CAAC,MAAMrtB,CAAA,CAAMutB,SAAS,EAAE,GAAGvtB,CAAA,CAAMutB,SAAA,KAAc,QAAQvtB,CAAA,CAAMqtB,OAAA,KAAY;IAAA;EAE7E,CAAC;ECRHG,EAAA,GAAgB9qB,CAAA,IACd6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAgBmsB,EAAA,CAAQzpB,CAAK;IAC5B;MACL+qB,SAAA,EAAWztB,CAAA,KAAkB;MAC7B,CAAC,aAAaA,CAAa,EAAE,GAAG,OAAOA,CAAA,IAAkB;IAAA;EAE7D,CAAC;ECaH0tB,EAAA,GAAeC,CACbjrB,CAAA,EACA1C,CAAA,GAAqC0a,CAAA,CAAI,GAAI,GAC7Cza,CAAA,GAAqC,OACjB;IACpB,MAAMoB,CAAA,GAAiBwe,EAAA,CAASI,CAAA,CAAMvd,CAAM,CAAC;MAEvCjB,CAAA,GAAmBoe,EAAA,CAASI,CAAA,CAAMjgB,CAAQ,CAAC;MAE3C2B,CAAA,GAAW+Y,CAAA,CAAI,EAAK;MAEpB7Y,CAAA,GAAkB6Y,CAAA,CAAI,CAAC;MAEvBzW,CAAA,GAAoBgc,CAAA,CAAM,MAAMvW,IAAA,CAAKkkB,IAAA,CAAKvsB,CAAA,CAAeoZ,KAAA,GAAQhZ,CAAA,CAAiBgZ,KAAK,CAAC;MAExFtO,CAAA,GAAQ8T,CAAA,CAAM,MAClB3T,CAAA,CAASmO,KAAA,IAAS9Y,CAAA,CAAS8Y,KAAA,GACvB/Q,IAAA,CAAKK,KAAA,CAAM1I,CAAA,CAAeoZ,KAAA,GAAQ5Y,CAAA,CAAgB4Y,KAAA,GAAQhZ,CAAA,CAAiBgZ,KAAK,IAChF;MAGA;QAACqF,KAAA,EAAA1T,CAAA;QAAO2T,MAAA,EAAA1T,CAAA;QAAQuT,QAAA,EAAAtT;MAAY,IAAAoU,EAAA,CAChC,MAAM;QACY7e,CAAA,CAAA4Y,KAAA,GAAQ5Y,CAAA,CAAgB4Y,KAAA,GAAQ;MAClD,GACAza,CAAA,EACAC,CAAA;MAGIsM,CAAA,GAAUshB,CAAA,KAAM;QACpBlsB,CAAA,CAAS8Y,KAAA,GAAQ,IACjB5Y,CAAA,CAAgB4Y,KAAA,GAAQ,GACjBpO,CAAA;MAAA;MAGHjC,CAAA,GAAO+T,CAAA,KAAM;QACjBxc,CAAA,CAAS8Y,KAAA,GAAQ,IACjB5Y,CAAA,CAAgB4Y,KAAA,GAAQxW,CAAA,CAAkBwW,KAAA;MAAA;IAG5CqI,EAAA,CAAY,MAAM;MACZjhB,CAAA,CAAgB4Y,KAAA,GAAQxW,CAAA,CAAkBwW,KAAA,KAC5C5Y,CAAA,CAAgB4Y,KAAA,GAAQxW,CAAA,CAAkBwW,KAAA,GAExC5Y,CAAA,CAAgB4Y,KAAA,KAAUxW,CAAA,CAAkBwW,KAAA,IACxCrO,CAAA;IACR,CACD,GAEDyO,EAAA,CAAM,CAACpZ,CAAA,EAAkBJ,CAAc,GAAG,MAAM;MACzC+I,CAAA,IACGmC,CAAA;IAAA,CACT;IAED,MAAMW,CAAA,GAAU4gB,CAAA,KAAM;QAChBxhB,CAAA,CAASmO,KAAA,KAAU,OACvB9Y,CAAA,CAAS8Y,KAAA,GAAQ,IACXrO,CAAA;MAAA;MAGFe,CAAA,GAAW4gB,CAAA,KAAM;QACjBlsB,CAAA,CAAgB4Y,KAAA,KAAUxW,CAAA,CAAkBwW,KAAA,KAChD9Y,CAAA,CAAS8Y,KAAA,GAAQ,IACVpO,CAAA;MAAA;IAGF;MACLuT,QAAA,EAAUC,EAAA,CAASvT,CAAQ;MAC3B0hB,QAAA,EAAUnO,EAAA,CAASle,CAAQ;MAC3BksB,OAAA,EAAAthB,CAAA;MACA4R,IAAA,EAAA/T,CAAA;MACA0V,KAAA,EAAO5S,CAAA;MACP6S,MAAA,EAAQ5S,CAAA;MACRsN,KAAA,EAAAtO;IAAA;EAEJ;EChGA8hB,EAAA,GAAgBvrB,CAAA,IACd6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAgBmsB,EAAA,CAAQzpB,CAAK;IAEnC,OAAO1C,CAAA,KAAkB,KAAO,aAAaA,CAAA,KAAkB,KAAQ,eAAe;EACxF,CAAC;ECMGkuB,EAAA,GAAcxrB,CAAA,IAClB6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAgBmsB,EAAA,CAAQzpB,CAAK;IAC5B;MACL,cAAc1C,CAAA,CAAcmuB,KAAA,KAAU,MAASnuB,CAAA,CAAcouB,MAAA,KAAW;MACxE,qBAAqBpuB,CAAA,CAAckS,MAAA,KAAW;MAC9C,eAAelS,CAAA,CAAcquB,MAAA,KAAW;MACxC,CAAC,gBAAgBruB,CAAA,CAAc6S,IAAI,EAAE,GACnC7S,CAAA,CAAc6S,IAAA,KAAS,UACvB7S,CAAA,CAAc6S,IAAA,KAAS,QACvB7S,CAAA,CAAcouB,MAAA,KAAW;IAAA;EAE/B,CAAC;EAQGE,EAAA,GAAmB5rB,CAAA,IAAoD;IACrE,MAAA1C,CAAA,GAAgBigB,CAAA,CAAMvd,CAAK;MAE3BzC,CAAA,GAAaguB,EAAA,CAAc,MAAMjuB,CAAA,CAAcya,KAAA,CAAM0M,KAAA,IAAS,IAAI;IAExE,OAAO5M,CAAA,CAAS,MAAM,CACpBta,CAAA,CAAWwa,KAAA,EACX;MACE,oBACEza,CAAA,CAAcya,KAAA,CAAM0T,KAAA,KAAU,MAASnuB,CAAA,CAAcya,KAAA,CAAM2T,MAAA,KAAW;MACxE,aAAapuB,CAAA,CAAcya,KAAA,CAAM2T,MAAA,KAAW;IAC9C,EACD;EACH;EASMG,EAAA,GAAmB7rB,CAAA,IACvB6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAgBmsB,EAAA,CAAQzpB,CAAK;IAC5B;MACL,oBAAoB1C,CAAA,CAAcmuB,KAAA,KAAU,MAASnuB,CAAA,CAAcouB,MAAA,KAAW;MAC9EI,GAAA,EAAOxuB,CAAA,CAAcouB,MAAA,KAAW;MAChC,CAAC,OAAOpuB,CAAA,CAAcyuB,aAAa,EAAE,GACnCzuB,CAAA,CAAcouB,MAAA,KAAW,MACzBpuB,CAAA,CAAcyuB,aAAA,KAAkB,UAChCzuB,CAAA,CAAcyuB,aAAA,KAAkB;MAClC,CAAC,OAAOzuB,CAAA,CAAc6S,IAAI,EAAE,GAC1B7S,CAAA,CAAcouB,MAAA,IAAUpuB,CAAA,CAAc6S,IAAA,IAAQ7S,CAAA,CAAc6S,IAAA,KAAS;IAAA;EAE3E,CAAC;EAQG6b,EAAA,GAAgBhsB,CAAA,IAAiD;IAC/D,MAAA1C,CAAA,GAAgBigB,CAAA,CAAMvd,CAAK;MAC3BzC,CAAA,GAAsBqsB,EAAA,CAC1B,MAAMtsB,CAAA,CAAcya,KAAA,CAAMkU,WAAA,EAC1B,MAAM3uB,CAAA,CAAcya,KAAA,CAAM0M,KAAA;IAE5B,OAAO5M,CAAA,CAAS,OAAO;MACrB,gBAAgBta,CAAA,CAAoBwa,KAAA;MACpC,iBAAiBza,CAAA,CAAcya,KAAA,CAAMmU,QAAA,KAAa,KAAO,KAAO;IAChE;EACJ;EASMC,EAAA,GAAmBnsB,CAAA,IACvB6X,CAAA,CAAS,MAAM;IACP,MAAAva,CAAA,GAAgBmsB,EAAA,CAAQzpB,CAAK;IAC5B;MACL,iBAAiB1C,CAAA,CAAc8uB,SAAA,KAAc;MAC7C,aAAa9uB,CAAA,CAAc+uB,OAAA,KAAY,MAAQ/uB,CAAA,CAAcgvB,OAAA,KAAY;MACzE,sBAAsBhvB,CAAA,CAAcgvB,OAAA,KAAY,MAAQhvB,CAAA,CAAc+uB,OAAA,KAAY;MAClF,CAAC,aAAa/uB,CAAA,CAAc6S,IAAI,EAAE,GAAG7S,CAAA,CAAc6S,IAAA,KAAS;IAAA;EAEhE,CAAC;ECrGHoc,EAAA,GAAeC,CAACxsB,CAAA,EAA2C1C,CAAA,KACzDua,CAAA,CAAS,MAAM4R,EAAA,CAAQzpB,CAAE,KAAKysB,EAAA,CAAMnvB,CAAM,CAAC;EC4B7CovB,EAAA,GAAeC,CACb3sB,CAAA,EAEA1C,CAAA,KAOG;IACG,MAAAC,CAAA,GAAQya,CAAA,CAA6B,IAAI;MAEzCrZ,CAAA,GAAaoqB,EAAA,CAAU/oB,CAAA,EAAO,cAAc1C,CAAI;MAEhDyB,CAAA,GAAawtB,EAAA,CAAM,MAAMvsB,CAAA,CAAM4sB,EAAA,EAAI,OAAO;MAC1C3tB,CAAA,GAAmB0qB,CAAA,CAAc,MAAM3pB,CAAA,CAAM6sB,SAAS;MACtD1tB,CAAA,GAAkBwqB,CAAA,CAAc,MAAM3pB,CAAA,CAAMwG,QAAQ;MACpDjF,CAAA,GAAcooB,CAAA,CAAc,MAAM3pB,CAAA,CAAM8sB,IAAI;MAC5CrjB,CAAA,GAAuBkgB,CAAA,CAAc,MAAM3pB,CAAA,CAAM+sB,aAAa;MAC9DrjB,CAAA,GAAgBigB,CAAA,CAAc,MAAM3pB,CAAA,CAAMshB,MAAM;MAChD3X,CAAA,GAAeggB,CAAA,CAAc,MAAM3pB,CAAA,CAAMykB,KAAK;MAC9C7a,CAAA,GAAc+f,CAAA,CAAc,MAAM3pB,CAAA,CAAMa,IAAI;MAC5CgJ,CAAA,GAAiBwU,EAAA,CAAY,MAAMre,CAAA,CAAMgtB,QAAA,IAAY,CAAC;MACtDtlB,CAAA,GAAwB2W,EAAA,CAAY,MAAMre,CAAA,CAAMitB,eAAA,IAAmBC,GAAG;MAEtE1iB,CAAA,GAA2BiT,EAAA,CAC9B5Q,CAAA,IAAuC;QACtClO,CAAA,CAAWoZ,KAAA,GAAQlL,CAAA;MACrB,GACA,MAAOtL,CAAA,CAAYwW,KAAA,KAAU,KAAO,IAAIlO,CAAA,CAAekO,KAAA,EACvD;QAAC+E,OAAA,EAASA,CAAA,KAAOvb,CAAA,CAAYwW,KAAA,KAAU,KAAOmV,GAAA,GAAMxlB,CAAA,CAAsBqQ;MAAM;MAG5EtN,CAAA,GAAmB0iB,CAACtgB,CAAA,EAAoCC,CAAA,GAAQ,OAAU;QAC1EvL,CAAA,CAAYwW,KAAA,KAAU,MAAQjL,CAAA,KAAU,MAC5CtC,CAAA,CAAyBqC,CAAK;MAAA;MAG1B;QAACmY,OAAA,EAAAta;MAAA,IAAWma,EAAA,CAAStnB,CAAA,EAAO;QAChC4lB,YAAA,EAAclkB,CAAA,CAAiB8Y;MAAA,CAChC;MAEKnN,CAAA,GAAewiB,CAACvgB,CAAA,EAAeC,CAAA,EAAYC,CAAA,GAAQ,OACnD/M,CAAA,CAAMqtB,SAAA,KAAc,WAAc,CAAC5jB,CAAA,CAAqBsO,KAAA,IAAShL,CAAA,IAC5D/M,CAAA,CAAMqtB,SAAA,CAAUxgB,CAAA,EAAOC,CAAG,IAE5BD,CAAA;MAGHhC,CAAA,GAAkBgC,CAAA,IAClBjD,CAAA,CAAYmO,KAAA,GAAclL,CAAA,CAAMhM,IAAA,KAChC6I,CAAA,CAAcqO,KAAA,GAAc5R,MAAA,CAAOiN,UAAA,CAAWvG,CAAK,IAEhDA,CAAA;IAGTiR,EAAA,CAAU,MAAM;;MACVvgB,CAAA,CAAMwa,KAAA,KACRxa,CAAA,CAAMwa,KAAA,CAAMA,KAAA,KAAQlL,CAAA,GAAAlO,CAAA,CAAWoZ,KAAA,KAAX,gBAAAlL,CAAA,CAAkB9M,QAAA,OAAc;IACtD,CACD,GAEDutB,EAAA,CAAY,MAAM;MAChBvP,EAAA,CAAS,MAAM;QACT9e,CAAA,CAAiB8Y,KAAA,KACnBrN,CAAA,CAAQqN,KAAA,GAAQ;MAClB,CACD;IAAA,CACF;IAED,MAAMjN,CAAA,GAAsB8e,EAAA,CAAe,MAAM5pB,CAAA,CAAMisB,WAAA,EAAatiB,CAAY;IA0DzE;MACL4jB,KAAA,EAAAhwB,CAAA;MACAiwB,UAAA,EAAAzuB,CAAA;MACA0uB,mBAAA,EAAA3iB,CAAA;MACA4iB,OAAA,EA5De7gB,CAAA,IAAe;QACxB;YAACkL,KAAA,EAAAjL;UAAK,IAAID,CAAA,CAAIpO,MAAA;UACdsO,CAAA,GAAiBnC,CAAA,CAAakC,CAAA,EAAOD,CAAG;QAC9C,IAAIA,CAAA,CAAI1O,gBAAA,EAAkB;UACxB0O,CAAA,CAAIxO,cAAA,CAAe;UACnB;QACF;QAEM,MAAA2O,CAAA,GAAYnC,CAAA,CAAekC,CAAc;QAE/CtC,CAAA,CAAiBuC,CAAS,GAE1B1P,CAAA,CAAK,SAASyP,CAAc;MAAA;MAiD5B4gB,QAAA,EA9CgB9gB,CAAA,IAAe;QACzB;YAACkL,KAAA,EAAAjL;UAAK,IAAID,CAAA,CAAIpO,MAAA;UACdsO,CAAA,GAAiBnC,CAAA,CAAakC,CAAA,EAAOD,CAAG;QAC9C,IAAIA,CAAA,CAAI1O,gBAAA,EAAkB;UACxB0O,CAAA,CAAIxO,cAAA,CAAe;UACnB;QACF;QAEM,MAAA2O,CAAA,GAAYnC,CAAA,CAAekC,CAAc;QAC3CpO,CAAA,CAAWoZ,KAAA,KAAU/K,CAAA,IACvBvC,CAAA,CAAiBsC,CAAA,EAAgB,EAAI,GAGvCzP,CAAA,CAAK,UAAUyP,CAAc;MAAA;MAkC7B6gB,MAAA,EA/Bc/gB,CAAA,IAAoB;QAElC,IADAvP,CAAA,CAAK,QAAQuP,CAAG,GACZ,CAACtL,CAAA,CAAYwW,KAAA,IAAS,CAACtO,CAAA,CAAqBsO,KAAA,EAAO;QAEjD;YAACA,KAAA,EAAAjL;UAAK,IAAID,CAAA,CAAIpO,MAAA;UACdsO,CAAA,GAAiBnC,CAAA,CAAakC,CAAA,EAAOD,CAAA,EAAK,EAAI;UAE9CG,CAAA,GAAYnC,CAAA,CAAekC,CAAc;QAC3CpO,CAAA,CAAWoZ,KAAA,KAAU/K,CAAA,IACvBvC,CAAA,CAAiBsC,CAAA,EAAgB,EAAI;MACvC;MAsBArJ,KAAA,EAnBYA,CAAA,KAAM;QACbvE,CAAA,CAAgB4Y,KAAA,KACnBrN,CAAA,CAAQqN,KAAA,GAAQ;MAClB;MAiBAgN,IAAA,EAdWA,CAAA,KAAM;QACZ5lB,CAAA,CAAgB4Y,KAAA,KACnBrN,CAAA,CAAQqN,KAAA,GAAQ;MAClB;IAWA;EAEJ;EC1KM8V,EAAA,GAAaC,CAAC9tB,CAAA,EAAU1C,CAAA,KAAsB;IAClD,IAAI,CAAC0C,CAAA,EAAY,OAAAA,CAAA;IACjB,IAAI1C,CAAA,IAAQ0C,CAAA,EAAK,OAAOA,CAAA,CAAI1C,CAAI;IAE1B,MAAAC,CAAA,GAAQD,CAAA,CAAK+D,KAAA,CAAM,GAAG;IAE5B,OAAOwsB,EAAA,CAAW7tB,CAAA,CAAIzC,CAAA,CAAM,CAAC,CAAC,GAAGA,CAAA,CAAM+sB,MAAA,CAAO,CAAC,EAAEhkB,IAAA,CAAK,GAAG,CAAC;EAC5D;EAEMynB,EAAA,GAAmBC,CAEvBhuB,CAAA,EACA1C,CAAA,GAAqB,MACrBC,CAAA,EAEAoB,CAAA,KACG;IACH,IAAId,MAAA,CAAOsC,SAAA,CAAUJ,QAAA,CAASK,IAAA,CAAKJ,CAAM,MAAM,mBAAmB;MAChE,MAAMjB,CAAA,GAAQ8uB,EAAA,CAAW7tB,CAAA,EAAQrB,CAAA,CAAMsvB,UAAU;QAC3ChvB,CAAA,GAAO4uB,EAAA,CAAW7tB,CAAA,EAAQrB,CAAA,CAAMuvB,SAAS;QACzC/uB,CAAA,GAAO0uB,EAAA,CAAW7tB,CAAA,EAAQrB,CAAA,CAAMwvB,SAAS;QACzC5sB,CAAA,GAAWssB,EAAA,CAAW7tB,CAAA,EAAQrB,CAAA,CAAMyvB,aAAa;QAEjD3kB,CAAA,GAAUzJ,CAAA,CAAOrB,CAAA,CAAM0vB,YAAY,KAAK;MAC9C,OAAI5kB,CAAA,KAAY,OACP;QACL6kB,KAAA,EAAO/tB,MAAA,CAAOstB,EAAA,CAAW7tB,CAAA,EAAQrB,CAAA,CAAM4vB,UAAU,KAAKtvB,CAAI;QAC1DuN,OAAA,EAASgiB,EAAA,CAAiB/kB,CAAA,EAASlM,CAAA,EAAeoB,CAAK;MAAA,IAIpD;QACLoZ,KAAA,EAAO,OAAOhZ,CAAA,GAAU,MAAczB,CAAA,IAAO2B,CAAA,GAAOF,CAAA;QACpD0vB,IAAA,EAAMluB,MAAA,CAAO,OAAOtB,CAAA,GAAS,MAAc3B,CAAA,GAAM2B,CAAI;QACrDyvB,IAAA,EAAAvvB,CAAA;QACAqH,QAAA,EAAU,EAAQjF;MAAQ;IAE9B;IACO;MACLwW,KAAA,EAAOza,CAAA,IAAO0C,CAAA;MACdyuB,IAAA,EAAMluB,MAAA,CAAOP,CAAM;MACnBwG,QAAA,EAAU;IAAA;EAEd;EAEMgoB,EAAA,GAAmBG,CAEvB3uB,CAAA,EACA1C,CAAA,EACAC,CAAA,KAGI0C,KAAA,CAAMC,OAAA,CAAQF,CAAO,IAChBA,CAAA,CAAQoJ,GAAA,CAAKzK,CAAA,IAAWovB,EAAA,CAAiBpvB,CAAA,EAAQ,MAAMrB,CAAA,EAAeC,CAAK,CAAC,IAC1EM,MAAA,CAAOsC,SAAA,CAAUJ,QAAA,CAASK,IAAA,CAAKJ,CAAO,MAAM,qBAE7C2D,OAAA,CAAAirB,IAAA,CACN,wBAAwBtxB,CAAa,wFAGhCO,MAAA,CAAOkd,IAAA,CAAK/a,CAAO,EAAEoJ,GAAA,CAAKzK,CAAA,IAAgB;IAEzC,MAAAI,CAAA,GAAUiB,CAAA,CAAQrB,CAAG;IAC3B,QAAQ,OAAOI,CAAA;MACb,KAAK;QACI,OAAAgvB,EAAA,CAAiBhvB,CAAA,CAAG0vB,IAAA,EAAMluB,MAAA,CAAOxB,CAAA,CAAGgZ,KAAK,GAAGza,CAAA,EAAeC,CAAK;MACzE;QACE,OAAOwwB,EAAA,CAAiBhvB,CAAA,EAAIwB,MAAA,CAAO5B,CAAG,GAAGrB,CAAA,EAAeC,CAAK;IACjE;EAAA,CACD,KAGI;EC9DHsxB,EAAA,GAAqB;EAEdC,EAAA,GAAsBvT,EAAA,CAAuB,MAAM;IAIxD,MAAAvb,CAAA,GAA0CiY,EAAA,CAAW,EAAE;MAEvD3a,CAAA,GAAaigB,CAAA,CAAM,MAAMvd,CAAA,CAAM+X,KAAA,CAAMna,MAAM;MAC3CL,CAAA,GAAYggB,CAAA,CAAM,MAAMvd,CAAA,CAAM+X,KAAA,CAAM/X,CAAA,CAAM+X,KAAA,CAAMna,MAAA,GAAS,CAAC,CAAC;MAE3De,CAAA,GAAagL,CAAA,IAAqC;QACtD3J,CAAA,CAAM+X,KAAA,GAAQ,CAAC,GAAG/X,CAAA,CAAM+X,KAAA,EAAOpO,CAAK;MAAA;MAEhC5K,CAAA,GAAe4K,CAAA,IAAqC;QAClD3J,CAAA,CAAA+X,KAAA,GAAQ/X,CAAA,CAAM+X,KAAA,CAAM3N,MAAA,CAAQR,CAAA,IAASA,CAAA,CAAKmlB,GAAA,KAAQplB,CAAA,CAAMolB,GAAG;MAAA;MAM7D9vB,CAAA,GAA6CgZ,EAAA,CAAW,EAAE;MAI1D9Y,CAAA,GAAgBwK,CAAA,IAAqC;QACzD1K,CAAA,CAAS8Y,KAAA,GAAQ,CAAC,GAAG9Y,CAAA,CAAS8Y,KAAA,EAAOpO,CAAK;MAAA;MAEtCpI,CAAA,GAAkBoI,CAAA,IAAqC;QAClD1K,CAAA,CAAA8Y,KAAA,GAAQ9Y,CAAA,CAAS8Y,KAAA,CAAM3N,MAAA,CAAQR,CAAA,IAASA,CAAA,CAAKmlB,GAAA,KAAQplB,CAAA,CAAMolB,GAAG;MAAA;MAMnEtlB,CAAA,GAAWE,CAAA,IAA2C;QAC1D5K,CAAA,CAAY4K,CAAK,GACjBpI,CAAA,CAAeoI,CAAK;MAAA;MAGhBD,CAAA,GAAkBoX,EAAA,CAAc,mBAAmB,CAACnX,CAAA,EAAUC,CAAA,EAAWC,CAAA,KAAU;QACjF,MAAAnC,CAAA,GACJ,OAAOiC,CAAA,IAAa,WAChBlI,MAAA,oBAAAA,MAAA,CAAQE,QAAA,CAAS2C,aAAA,CAAcqF,CAAA,IAC/B+U,EAAA,CAAa/U,CAAQ;QACtBjC,CAAA,KAEDkC,CAAA,KAAc,UAChBlC,CAAA,CAAGwc,SAAA,CAAU8K,MAAA,CAAOH,EAAA,EAAoBhlB,CAAA,KAAUglB,EAAkB,IAEjEnnB,CAAA,CAAAzC,YAAA,CAAa2E,CAAA,EAAWC,CAAK;MAClC,CACD;IAED,OAAAsR,EAAA,CAAkB,MAAM;MACNzR,CAAA,SAAQ,SAAS,EAAE;IAAA,CACpC,GAEKyO,EAAA,CAAA7a,CAAA,EAAaqM,CAAA,IAAa;MAC9BD,CAAA,CAAgB,QAAQ,SAASC,CAAA,GAAW,IAAIklB,EAAA,GAAqB,EAAE;IAAA,CACxE,GAEM;MACLI,QAAA,EAAAhwB,CAAA;MACAiwB,KAAA,EAAAlvB,CAAA;MACAmvB,SAAA,EAAA5xB,CAAA;MACA6xB,UAAA,EAAA9xB,CAAA;MACA+xB,SAAA,EAAA1wB,CAAA;MACA2wB,WAAA,EAAAvwB,CAAA;MACAwwB,YAAA,EAAApwB,CAAA;MACAqwB,cAAA,EAAAjuB,CAAA;MACAia,OAAA,EAAA/R;IAAA;EAEJ,CAAC;EAEcgmB,EAAA,GAACzvB,CAAA,IAA4B;IACpC;QAACuvB,YAAA,EAAAjyB,CAAA;QAAc+xB,SAAA,EAAA9xB,CAAA;QAAW+xB,WAAA,EAAA3wB,CAAA;QAAauwB,KAAA,EAAAnwB,CAAA;QAAOyc,OAAA,EAAAvc,CAAA;QAASmwB,UAAA,EAAAjwB;MAAA,IAAc2vB,EAAA;MAErEvtB,CAAA,GAAesc,EAAA;IAErB,IAAI,CAACtc,CAAA,IAAgBA,CAAA,CAAa4kB,IAAA,CAAKuJ,MAAA,KAAW,UAC1C,UAAIC,KAAA,CAAM,mDAAmD;IAGrE,OAAAryB,CAAA,CAAaiE,CAAY,GAEzB4Z,EAAA,CAAkB,MAAM;MACtBlc,CAAA,CAAQsC,CAAY;IAAA,CACrB,GAED4W,EAAA,CACEnY,CAAA,EACA,CAACyJ,CAAA,EAAUC,CAAA,KAAa;MAClBD,CAAA,GACFlM,CAAA,CAAUgE,CAAY,IACbmI,CAAA,IAAY,CAACD,CAAA,IACtB9K,CAAA,CAAY4C,CAAY;IAE5B,GACA;MAAC0c,SAAA,EAAW;IAAI,IAGX;MACL2R,cAAA,EAAgB/X,CAAA,CAAS,MACvB9Y,CAAA,CAAMgZ,KAAA,CAAM8X,SAAA,CAAWpmB,CAAA,IAAO;;QAAA,SAAAC,CAAA,GAAAD,CAAA,CAAGqmB,OAAA,KAAH,gBAAApmB,CAAA,CAAYkjB,EAAA,QAAOjjB,CAAA,GAAApI,CAAA,CAAauuB,OAAA,KAAb,gBAAAnmB,CAAA,CAAsBijB,EAAA;MAAA,CAAE,CAC3E;MACAmD,gBAAA,EAAkB5wB;IAAA;EAEtB;EC7GA6wB,EAAA,GAAeC,CAACjwB,CAAA,GAA2C,WAAc;IACjE;QAACivB,QAAA,EAAA3xB;MAAA,IAAYwxB,EAAA;MACbvxB,CAAA,GAAWsgB,EAAA;MAEXlf,CAAA,GAAiBkZ,CAAA,CAAS,MAAM;QAC9B,MAAA5Y,CAAA,GAAawqB,EAAA,CAAQzpB,CAAE;QAC7B,OAAIf,CAAA,GACK3B,CAAA,CAASya,KAAA,CAAMrI,IAAA,CAAMvQ,CAAA,IAAU;;UAAA,SAAAoC,CAAA,GAAApC,CAAA,CAAM2wB,OAAA,KAAN,gBAAAvuB,CAAA,CAAeqrB,EAAA,CAAG7U,KAAA,MAAU9Y,CAAA;QAAA,CAAU,KAAK,OAG9E1B,CAAA,GAIE2yB,EAAA,CAAW3yB,CAAQ,IAHjB;MAGiB,CAC3B;MAEKwB,CAAA,GAAQwe,CAAA,CAAM;;QAAM,QAAAte,CAAA,GAAAN,CAAA,CAAeoZ,KAAA,KAAf,gBAAA9Y,CAAA,CAAsBqqB,KAAA;MAAA,CAAK;IAE9C;MACL6G,KAAA,EAAO;;QACU,CAAAhxB,CAAA,IAAAF,CAAA,GAAAN,CAAA,CAAAoZ,KAAA,qBAAA9Y,CAAA,CAAO6wB,OAAA,KAAP,QAAA3wB,CAAA,CAAgBgxB,IAAA;MACjC;MACAnhB,KAAK/P,CAAA,GAAU,IAAI;;QACF,CAAAsC,CAAA,IAAApC,CAAA,GAAAR,CAAA,CAAAoZ,KAAA,qBAAA5Y,CAAA,CAAO2wB,OAAA,KAAP,QAAAvuB,CAAA,CAAgByN,IAAA,CAAK/P,CAAA;MACtC;MACAmxB,KAAA,EAAArxB;IAAA;EAEJ;EAEMmxB,EAAA,GAAclwB,CAAA,IACbA,CAAA,CAAUqwB,MAAA,GAIXrwB,CAAA,CAAUqwB,MAAA,CAAOlK,IAAA,CAAKuJ,MAAA,KAAW,WAC5B1vB,CAAA,CAAUqwB,MAAA,GAGZH,EAAA,CAAWlwB,CAAA,CAAUqwB,MAAM,IAPzB;ECxCXC,EAAA,GAAeC,CAAA,KAAM;IACnB,MAAM;MAACpB,SAAA,EAAAnvB,CAAA;MAAWkvB,KAAA,EAAA5xB;IAAK,IAAIwxB,EAAA,CAAoB;IAcxC;MACL9f,IAAA,EAbWA,CAACjQ,CAAA,GAAU,OAAO;;QACzBiB,CAAA,CAAU+X,KAAA,MACF9Y,CAAA,GAAAe,CAAA,CAAA+X,KAAA,CAAM+X,OAAA,KAAN,QAAA7wB,CAAA,CAAe+P,IAAA,CAAKjQ,CAAA;MAChC;MAWAyxB,OAAA,EARcA,CAACzxB,CAAA,GAAU,OAAO;;QACrB,WAAAI,CAAA,IAAS7B,CAAA,CAAMya,KAAA,EAClB,CAAA9Y,CAAA,GAAAE,CAAA,CAAA2wB,OAAA,aAAA7wB,CAAA,CAAS+P,IAAA,CAAKjQ,CAAA;MACtB;MAAA;IAKA;EAGJ;EClBe0xB,EAAA,GAACzwB,CAAA,IAAoD;IAC5D,MAAA1C,CAAA,GAAuBozB,CAC3BjnB,CAAA,EACAC,CAAA,KACW;QACX,MAAMC,CAAA,GAAWD,CAAA,KAAQ,OAAO,KAAK,GAAGA,CAAG;QAEpC,OAAAD,CAAA,KAAU,WACb,GAAGE,CAAQ,mBACXF,CAAA,KAAU,SACV,GAAGE,CAAQ,iBACX,OAAOF,CAAA,IAAU,YACjBA,CAAA,KAAU,OACVA,CAAA,KAAU,OACVA,CAAA,KAAU,OACVA,CAAA,KAAU,OACVA,CAAA,KAAU,OACVA,CAAA,KAAU,MACV,GAAGE,CAAQ,WAAWF,CAAK,KAC3BA,CAAA,KAAU,SACV,GAAGE,CAAQ,cACXF,CAAA,KAAU,OACV,GAAGE,CAAQ,cACXF,CAAA,KAAU,OACV,GAAGE,CAAQ,cACX,GAAGA,CAAQ;MAAA;MAGXpM,CAAA,GAAQ4f,EAAA,CAASI,CAAA,CAAMvd,CAAG,CAAC;MAC3BrB,CAAA,GAAiBgrB,CAAA,CAAc,MAAMpsB,CAAA,CAAMwa,KAAA,CAAM4Y,OAAO;MACxD5xB,CAAA,GAAoB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMwa,KAAA,CAAM6Y,UAAU;MAC9D3xB,CAAA,GAAuB0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMwa,KAAA,CAAM8Y,aAAa;MACpE1xB,CAAA,GAAsBwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMwa,KAAA,CAAM+Y,YAAY;MAClEvvB,CAAA,GAAoBooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMwa,KAAA,CAAMgZ,UAAU;IACpE,OAAOlZ,CAAA,CAAS,OAAO;MACrB,CAAC,GAAGva,CAAA,CAAqBqB,CAAA,CAAeoZ,KAAA,EAAkC,IAAI,CAAC,EAAE,GAC/E,CAAC,CAACpZ,CAAA,CAAeoZ,KAAA;MACnB,CAAC,GAAGza,CAAA,CAAqByB,CAAA,CAAkBgZ,KAAA,EAAkC,KAAK,CAAC,EAAE,GACnF,CAAC,CAAChZ,CAAA,CAAkBgZ,KAAA;MACtB,CAAC,GAAGza,CAAA,CAAqB2B,CAAA,CAAqB8Y,KAAA,EAAkC,QAAQ,CAAC,EAAE,GACzF,CAAC,CAAC9Y,CAAA,CAAqB8Y,KAAA;MACzB,CAAC,GAAGza,CAAA,CAAqB6B,CAAA,CAAoB4Y,KAAA,EAAkC,OAAO,CAAC,EAAE,GACvF,CAAC,CAAC5Y,CAAA,CAAoB4Y,KAAA;MACxB,CAAC,GAAGza,CAAA,CAAqBiE,CAAA,CAAkBwW,KAAA,EAAkC,KAAK,CAAC,EAAE,GACnF,CAAC,CAACxW,CAAA,CAAkBwW;IACtB;EACJ;EC/CAiZ,EAAA,GAAeC,CAACjxB,CAAA,EAAmC1C,CAAA,KAA0C;IAC3F,MAAMC,CAAA,GAAiB4f,EAAA,CAASI,CAAA,CAAMvd,CAAM,CAAC;MACvCrB,CAAA,GAAwBwe,EAAA,CAASI,CAAA,CAAMjgB,CAAU,CAAC;MAKlDyB,CAAA,GAA4Bwe,CAAA,CAAM,MAAM,CAAC5e,CAAA,CAAsBoZ,KAAK;IAE1E+F,EAAA,CAAU,MAAM;MACd,MAAM7e,CAAA,GAAW0oB,EAAA,CACfhmB,QAAA,CAASoR,IAAA,EACTxV,CAAA,CAAewa,KAAA,IAAShZ,CAAA,CAA0BgZ,KAAA;MAG9CI,EAAA,EAAC5a,CAAA,EAAgBwB,CAAyB,GAAG,CAAC,CAACI,CAAA,EAAUoC,CAAO,MAAM;QAC1EtC,CAAA,CAAS8Y,KAAA,GAAQ5Y,CAAA,IAAYoC,CAAA;MAAA,CAC9B;IAAA,CACF;EACH;EClBM2vB,EAAA,GAAa;EAEJC,EAAA,GAAA/V,EAAA,CAAkB,MAAM;IAC/B,MAAApb,CAAA,GAASgY,CAAA,CAAgC,EAAE;IA+B1C;MAACoZ,MAAA,EAAApxB,CAAA;MAAQmwB,IAAA,EA1BHA,CAAA,GAAI,CAACxxB,CAAA,EAAII,CAAG,MAAqE;QACtF,MAAAE,CAAA,GAAiB;UAACoyB,GAAA,EAAKH;QAAA;QACzB,OAAOvyB,CAAA,IAAO,WACTd,MAAA,CAAAC,MAAA,CAAOmB,CAAA,EAASF,CAAA,EAAK;UAC1BgU,IAAA,EAAMpU,CAAA;UACNoZ,KAAA,GAAOhZ,CAAA,oBAAAA,CAAA,CAAKgZ,KAAA,KAAS;QAAA,CACN,IAEVla,MAAA,CAAAC,MAAA,CAAOmB,CAAA,EAASN,CAAA,EAAI;UAACoZ,KAAA,EAAOpZ,CAAA,CAAGoZ,KAAA,IAAS;QAAA,CAAqB;QAEtE,MAAM5Y,CAAA,GAAOmyB,MAAA;QAEb,OAAAtxB,CAAA,CAAO+X,KAAA,CAAMpJ,IAAA,CAAK;UAAC,GAAG1P,CAAA;UAASyhB,IAAA,EAAAvhB;QAAA,CAAK,GAE7BA,CAAA;MAAA;MAYa6P,IAAA,EANRrQ,CAAA,IAAiB;QACvB,MAAAI,CAAA,GAAMiB,CAAA,CAAO+X,KAAA,CAAM8X,SAAA,CAAW5wB,CAAA,IAAOA,CAAA,CAAGyhB,IAAA,KAAS/hB,CAAI;QACvDI,CAAA,KAAQ,MACLiB,CAAA,CAAA+X,KAAA,CAAMuS,MAAA,CAAOvrB,CAAA,EAAK,CAAC;MAAA;IAAA;EAI9B,CAAC;EAAAwyB,EAAA;EAAAC,EAAA;EAAAC,EAAA;EAAAC,EAAA,kBAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCkED,MAAMhzB,CAAA,GAAQqB,CAAA;QAkCRjB,CAAA,GAAOxB,CAAA;QAwBP0B,CAAA,GAAoB0qB,CAAA,CAAc,MAAMhrB,CAAA,CAAMizB,UAAU;QACxDzyB,CAAA,GAAY6Y,CAAA,CAAI/Y,CAAA,CAAkB8Y,KAAK;QACvCxW,CAAA,GAAoByW,CAAA,CAAI/Y,CAAA,CAAkB8Y,KAAK;MACrDqI,EAAA,CAAY,MAAM;QACXrhB,CAAA,sBAAqBI,CAAA,CAAU4Y,KAAK;MAAA,CAC1C,GAEDI,EAAA,CAAMlZ,CAAA,EAAmB,MAAM;QACzBA,CAAA,CAAkB8Y,KAAA,KAAU5Y,CAAA,CAAU4Y,KAAA,KAC1C9Y,CAAA,CAAkB8Y,KAAA,GAAQ8Z,EAAA,CAAK,IAAIC,EAAA,CAAK,IAAIC,KAAA,CAAM,mBAAmB,CAAC;MAAA,CACvE;MAED,MAAMtoB,CAAA,GAAa8iB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,SAAS;QAE5CljB,CAAA,GAAeigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMqzB,KAAK;QAC9CroB,CAAA,GAAgBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMszB,MAAM;QAChDroB,CAAA,GAAiB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMuzB,OAAO;QAClDroB,CAAA,GAAgB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMwzB,MAAM;QAChDzqB,CAAA,GAAgBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMyzB,MAAM;QAChD5nB,CAAA,GAAgBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAM0zB,MAAM;QAChD5nB,CAAA,GAAqBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAM2zB,WAAW;QAC1D5nB,CAAA,GAAgBif,CAAA,CAAc,MAAMhrB,CAAA,CAAM4zB,MAAM;QAChD3nB,CAAA,GAAkB+e,CAAA,CAAc,MAAMhrB,CAAA,CAAM6zB,QAAQ;QACpD3nB,CAAA,GAAgB8e,CAAA,CAAc,MAAMhrB,CAAA,CAAM6Q,MAAM;QAChD1E,CAAA,GAAoB6e,CAAA,CAAc,MAAMhrB,CAAA,CAAM8zB,UAAU;QACxDznB,CAAA,GAAiB2e,CAAA,CAAc,MAAMhrB,CAAA,CAAM+zB,OAAO;QAClDxnB,CAAA,GAAwBye,CAAA,CAAc,MAAMhrB,CAAA,CAAMg0B,cAAc;QAChEjmB,CAAA,GAASid,CAAA,CAAc,MAAMhrB,CAAA,CAAM+vB,IAAI;QAEvC/hB,CAAA,GAASqL,CAAA,CAAI,EAAK;QAElBpL,CAAA,GAAUoL,CAAA,CAAwB,IAAI;QACtCnL,CAAA,GAAgBmL,CAAA,CAAwB,IAAI;QAC5ClL,CAAA,GAAQkL,CAAA,CAAwB,IAAI;QACpCjL,CAAA,GAAUiL,CAAA,CAAwB,IAAI;QACtChL,CAAA,GAAcgL,CAAA,CAAwB,IAAI;QAE1C/K,CAAA,GAAiB4K,CAAA,CAAS,MAC9BlZ,CAAA,CAAMi0B,KAAA,GAAQjY,EAAA,CAAahc,CAAA,CAAMi0B,KAAA,EAAOvZ,EAAgB,IAAI;QAGxDnM,CAAA,GAAmB2K,CAAA,CAAS,MAChClZ,CAAA,CAAMk0B,OAAA,GAAUlY,EAAA,CAAahc,CAAA,CAAMk0B,OAAA,EAASxZ,EAAgB,IAAI;QAE5DlM,CAAA,GAAkBoQ,CAAA,CAAM,MAAM5e,CAAA,CAAMqL,SAAA,CAAU8oB,UAAA,CAAW,MAAM,CAAC;QAChE1lB,EAAA,GAAeiR,EAAA,CAAY,MAAM1f,CAAA,CAAMmR,MAAA,IAAUod,GAAG;QAEpD5f,EAAA,GAAWuK,CAAA,CAA+B,MAC9ClZ,CAAA,CAAM6M,QAAA,KAAa,cAAc7M,CAAA,CAAM6M,QAAA,KAAa,aAAa,SAAY7M,CAAA,CAAM6M,QAAA;QAE/EoD,EAAA,GAAeiJ,CAAA,CAAmC,MACtDlZ,CAAA,CAAM6M,QAAA,KAAa,cAAc7M,CAAA,CAAM6M,QAAA,KAAa,aAAa7M,CAAA,CAAM6M,QAAA,GAAW;QAG9EunB,EAAA,GAAa/a,CAAA,CAAmB,EAAE;QAClCgb,EAAA,GAAqBnb,CAAA,CAAuB,MAAM;UAClD,IAAAlZ,CAAA,CAAMs0B,kBAAA,KAAuB,QAC/B,OAAOt0B,CAAA,CAAMs0B,kBAAA;UAET,MAAAC,CAAA,GAAMv0B,CAAA,CAAMmR,MAAA,KAAW,OAAO1C,EAAA,CAAa2K,KAAA,GAAQ/M,CAAA,CAAe+M,KAAA,GAAQ,IAAI;YAC9Eob,EAAA,GAAoB,CAACtjB,EAAA,CAAiBqjB,CAAG,CAAC;UAChD,OAAIxrB,CAAA,CAAcqQ,KAAA,KAAU,MAAS,CAAC5K,CAAA,CAAgB4K,KAAA,IAChDob,EAAA,CAAAxkB,IAAA,CACFP,EAAA,CAAK;YACH5C,QAAA,EAAU8B,EAAA,CAASyK,KAAA;YACnBtM,YAAA,EAAcmD,EAAA,CAAamJ,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B;UAAA,CAChB,IAGDjmB,CAAA,CAAgB4K,KAAA,IACdob,EAAA,CAAAxkB,IAAA,CACFjB,EAAA,CAAc;YACZG,SAAA,EAAYlP,CAAA,CAAMqL,SAAA,CAAU3I,KAAA,CAAM,GAAG,EAAE,CAAC,KAAmB;YAC3DmK,QAAA,EAAU8B,EAAA,CAASyK,KAAA;YACnBtM,YAAA,EAAcmD,EAAA,CAAamJ,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B;UAAA,CAChB,IAGDxpB,CAAA,CAAemO,KAAA,KAAU,MACvBob,EAAA,CAAAxkB,IAAA,CACFoB,EAAA,CAAM;YACJvE,QAAA,EAAU8B,EAAA,CAASyK,KAAA;YACnBtM,YAAA,EAAcmD,EAAA,CAAamJ,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B;UAAA,CAChB,IAGD1oB,CAAA,CAAcqN,KAAA,KAAU,MACtBob,EAAA,CAAAxkB,IAAA,CACFI,EAAA,CAAe;YACbvD,QAAA,EAAU8B,EAAA,CAASyK,KAAA;YACnBtM,YAAA,EAAcmD,EAAA,CAAamJ,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B;UAAA,CAChB,IAGDvoB,CAAA,CAAckN,KAAA,KAAU,MACtBob,EAAA,CAAAxkB,IAAA,CAAKY,EAAA,EAAkB,GAEzB4jB,EAAA,CAAAxkB,IAAA,CAAK2I,EAAA,CAAgB;YAACxL,OAAA,EAASgB,CAAA;YAAOlB,OAAA,EAAS;UAAG,EAAC,GACnD/B,CAAA,CAAckO,KAAA,KAAU,MACtBob,EAAA,CAAAxkB,IAAA,CACFuB,EAAA,CAAe;YACb1E,QAAA,EAAU8B,EAAA,CAASyK,KAAA;YACnBtM,YAAA,EAAcmD,EAAA,CAAamJ,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B,eAAA;YACfhjB,MAAM;cAACC,cAAA,EAAAgjB,EAAA;cAAgB/iB,eAAA,EAAAgjB;YAAA,GAAkB;cACvCP,EAAA,CAAWhb,KAAA,GAAQ;gBACjBwb,SAAA,EAAWD,EAAA,GAAkB,GAAGA,EAAe,OAAO;gBACtDE,QAAA,EAAUH,EAAA,GAAiB,GAAGA,EAAc,OAAO;cAAA;YAEvD;UAAA,CACD,IAGEF,EAAA;QAAA,CACR;QAEKM,EAAA,GAAelW,CAAA,CAAM,MACzBpQ,CAAA,CAAgB4K,KAAA,GAAQ,SAAapZ,CAAA,CAAMqL,SAAA;QAGvC;UAACyO,cAAA,EAAAib,EAAA;UAAgBtoB,cAAA,EAAAuoB,EAAA;UAAgB3pB,SAAA,EAAA4pB,EAAA;UAAWlb,MAAA,EAAAmb;QAAA,IAAUlc,EAAA,CAAY9K,CAAA,EAAeD,CAAA,EAAS;UAC9F5C,SAAA,EAAWypB,EAAA;UACXvpB,UAAA,EAAY8oB,EAAA;UACZ/oB,QAAA,EAAUsT,CAAA,CAAM,MAAM5e,CAAA,CAAMsL,QAAQ;UACpC2N,oBAAA,EAAsBA,CAAA,GAAIsb,CAAA,KACR3c,EAAA,CAAW,GAAG2c,CAAA,EAAM;YAACrc,cAAA,EAAgBjM,CAAA,CAAgBmN;UAAA,CAAM;QAG7E,CACD;QAEK+b,CAAA,GAAa9b,CAAA,CAAmB;UAAChD,QAAA,EAAU;QAAW;MAE5DmD,EAAA,CAAMwb,EAAA,EAAgB,MAAM;;QAQtB,IAPAjpB,CAAA,CAAcqN,KAAA,KAAU,QACtBmb,CAAA,GAAAS,EAAA,CAAe5b,KAAA,CAAM/I,IAAA,KAArB,QAAAkkB,CAAA,CAA2BhkB,eAAA,GAC7BvC,CAAA,CAAOoL,KAAA,GAAQ,KAEfpL,CAAA,CAAOoL,KAAA,GAAQ,KAGf4b,EAAA,CAAe5b,KAAA,CAAM1K,KAAA,EAAO;UAC9B,MAAM;YAAC5F,CAAA,EAAA0rB,EAAA;YAAGzrB,CAAA,EAAA2rB;UAAC,IAAIM,EAAA,CAAe5b,KAAA,CAAM1K,KAAA;UACpCymB,CAAA,CAAW/b,KAAA,GAAQ;YACjB/C,QAAA,EAAU;YACVjN,GAAA,EAAKsrB,EAAA,GAAI,GAAGA,EAAC,OAAO;YACpBzrB,IAAA,EAAMurB,EAAA,GAAI,GAAGA,EAAC,OAAO;UAAA;QAEzB;MAAA,CACD;MAEK,MAAAY,CAAA,GAAkBlc,CAAA,CAAS,MAAM;UAC/B,MAAAqb,CAAA,GAAOloB,CAAA,CAAe+M,KAAA,GAAQ,YAAY;UACzC,QACLmb,CAAA,EACA,KAAKA,CAAI,IACT;YACE,CAAC,KAAKA,CAAI,IAAIv0B,CAAA,CAAMgsB,OAAO,EAAE,GAAGhsB,CAAA,CAAMgsB,OAAA,KAAY;YAClDwF,IAAA,EAAMhxB,CAAA,CAAU4Y,KAAA,IAAS,CAACpL,CAAA,CAAOoL,KAAA;YAChC,WAAY,CAAC5Y,CAAA,CAAU4Y,KAAA;YACxBic,IAAA,EAAM,CAACxpB,CAAA,CAAcuN,KAAA;YACpB,UAAW,CAAC5Y,CAAA,CAAU4Y,KAAA,IAASvN,CAAA,CAAcuN,KAAA;YAC9C,CAAC,GAAGpZ,CAAA,CAAMs1B,WAAW,EAAE,GAAGt1B,CAAA,CAAMs1B,WAAA,KAAgB;YAChD,CAAC,MAAMf,CAAI,IAAIgB,EAAA,CAA0BN,EAAA,CAAU7b,KAAK,CAAC,EAAE,GAAG6b,EAAA,CAAU7b,KAAA,KAAU;UACpF;QACF,CACD;QAEK;UAACsP,SAAA,EAAA8M;QAAA,IAAatN,EAAA,CAAkBja,CAAO;QACvC;UAACya,SAAA,EAAW+M;QAAgB,IAAIvN,EAAA,CAAkB9Z,CAAO;QAEzDsnB,CAAA,GAAUnB,CAAA,IAAa;UAC3B,MAAMC,EAAA,GAAQD,CAAA,IAAK,IAAInB,KAAA,CAAM,OAAO;UACpC5yB,CAAA,CAAU4Y,KAAA,GAAQ+Z,EAAA,CAAKqB,EAAK,IAAItB,EAAA,CAAK;QAAA;QAGjCyC,EAAA,GAAwBC,CAC5BrB,CAAA,EACAC,EAAA,GAAoC,OAEpC,IAAIz0B,EAAA,CAAmBw0B,CAAA,EAAM;UAC3Bh1B,UAAA,EAAY;UACZO,MAAA,EAAQmO,CAAA,CAAQmL,KAAA,IAAS;UACzBvZ,aAAA,EAAe;UACfI,OAAA,EAAS;UACT,GAAGu0B,EAAA;UACH70B,WAAA,EAAamL,CAAA,CAAWsO;QAAA,CACzB;MAEC,IAAAyc,EAAA;MACJ,MAAM3C,EAAA,GAAO1B,CAAA,KAAM;UACjB,MAAM+C,CAAA,GAAQoB,EAAA,CAAsB,QAAQ;YAACp2B,UAAA,EAAY;UAAA,CAAK;UAE9D,IADAa,CAAA,CAAK,QAAQm0B,CAAK,GACdA,CAAA,CAAM/0B,gBAAA,EAAkB;YAC1BY,CAAA,CAAK,gBAAgB;YACrB;UACF;UACAwC,CAAA,CAAkBwW,KAAA,GAAQ,IAC1BgG,EAAA,CAAS,MAAM;;YACN8V,CAAA,IACOW,EAAA,GAAAre,UAAA,CACZ,MAAM;cACG0d,CAAA,IACP10B,CAAA,CAAU4Y,KAAA,GAAQ,IAClBgG,EAAA,CAAS,MAAM;gBACRhf,CAAA,UAASu1B,EAAA,CAAsB,OAAO,CAAC;cAAA,CAC7C;YACH,GACA,OAAO31B,CAAA,CAAM81B,KAAA,IAAU,WAAW91B,CAAA,CAAM81B,KAAA,KAAQtB,EAAA,GAAAx0B,CAAA,CAAM81B,KAAA,KAAN,gBAAAtB,EAAA,CAAahD,IAAA,KAAQ;UACvE,CACD;QAAA;QAGG2B,EAAA,GAAQoB,CAAA,IAAa;;UACzB,MAAMC,EAAA,GAAQmB,EAAA,CAAsB,QAAQ;YAACp2B,UAAA,EAAY;UAAA,CAAK;UAE9D,IADAa,CAAA,CAAK,QAAQo0B,EAAK,GACdA,EAAA,CAAMh1B,gBAAA,EAAkB;YAC1BY,CAAA,CAAK,gBAAgB;YACrB;UACF;UACIy1B,EAAA,KACF1e,YAAA,CAAa0e,EAAW,GACVA,EAAA;UAEV,MAAAnB,EAAA,GAAQ,OAAO10B,CAAA,CAAM81B,KAAA,IAAU,WAAW91B,CAAA,CAAM81B,KAAA,KAAQnB,EAAA,GAAA30B,CAAA,CAAM81B,KAAA,KAAN,gBAAAnB,EAAA,CAAatkB,IAAA,KAAQ;UACnFmH,UAAA,CAAW,MAAM;;YACf,CACE+c,CAAA,oBAAAA,CAAA,CAAG/M,IAAA,MAAS,YACZ+M,CAAA,oBAAAA,CAAA,CAAG/M,IAAA,MAAS,gBACX+M,CAAA,oBAAAA,CAAA,CAAG/M,IAAA,MAAS,uBAAuBxc,CAAA,CAAcoO,KAAA,IACjD,CAAC7M,CAAA,CAAsB6M,KAAA,IACtBoc,CAAA,CAAUpc,KAAA,IACVqc,CAAA,CAAiBrc,KAAA,IACjB,GAAC2c,EAAA,GAAA9nB,CAAA,CAAQmL,KAAA,KAAR,QAAA2c,EAAA,CAAelV,QAAA,CAAS7d,QAAA,oBAAAA,QAAA,CAAU0B,aAAA,MACnC,GAACsxB,EAAA,GAAA5nB,CAAA,CAAQgL,KAAA,KAAR,QAAA4c,EAAA,CAAenV,QAAA,CAAS7d,QAAA,oBAAAA,QAAA,CAAU0B,aAAA,MACpC6H,CAAA,CAAsB6M,KAAA,IAASqc,CAAA,CAAiBrc,KAAA,IAEjD5Y,CAAA,CAAU4Y,KAAA,GAAQ,IAClBgG,EAAA,CAAS,MAAM;cACb5H,UAAA,CACE,MAAM;gBACJ5U,CAAA,CAAkBwW,KAAA,GAAQ;cAC5B,GACAnL,CAAA,CAAQmL,KAAA,GAAQhS,EAAA,CAAmB6G,CAAA,CAAQmL,KAAK,IAAI,MAEjDhZ,CAAA,WAAUu1B,EAAA,CAAsB,QAAQ,CAAC;YAAA,CAC/C,KAEDne,UAAA,CACE,MAAM;cACJ2b,EAAA,CAAKoB,CAAC;YACR,GACAG,EAAA,GAAQ,KAAK,KAAKA,EAAA;UAAA,GAGrBA,EAAK;QAAA;MAGG/1B,CAAA;QAAA0R,IAAA,EACX8iB,EAAA;QACA3B,IAAA,EAAA0B,EAAA;QACA7C,MAAA,EAAAqF;MAAA,CACD;MAEK,MAAAO,EAAA,GACJ1B,CAAA,IAG4B;UACtB,MAAAC,EAAA,GAAU5b,CAAA,CAAM2b,CAAM;UAC5B,IAAKC,EAAA,EACD;YAAA,WAAOA,EAAA,IAAY,UAAU;cACzB,MAAAE,EAAA,GAAY1xB,QAAA,CAASkD,cAAA,CAAesuB,EAAO;cACjD,OAAOE,EAAA,IAAwB;YACjC;YACA,OAAKF,EAAA,CAAiD9b,GAAA,GAC5C8b,EAAA,CAAiD9b,GAAA,GAEpD8b,EAAA;UAAA;QAAA;QAGH0B,EAAA,GAAOxL,CAAA,KAAM;;UAGjB,IAAI1qB,CAAA,CAAMF,MAAA,EAAQ;YACV,MAAA00B,EAAA,GAAOyB,EAAA,CAAWj2B,CAAA,CAAMF,MAAM;YAChC00B,EAAA,GACFpmB,CAAA,CAAQgL,KAAA,GAAQob,EAAA,GAGRxvB,OAAA,CAAAirB,IAAA,CAAK,4BAA4BjwB,CAAA,CAAMF,MAAM;UACvD,OAEQsO,CAAA,CAAAgL,KAAA,IAAQmb,CAAA,GAAAlmB,CAAA,CAAY+K,KAAA,KAAZ,gBAAAmb,CAAA,CAAmB4B,kBAAA;UAErC,IAAIn2B,CAAA,CAAMkK,SAAA,EAAW;YACb,MAAAsqB,EAAA,GAAOyB,EAAA,CAAWj2B,CAAA,CAAMkK,SAAS;YACnCsqB,EAAA,GACFtmB,CAAA,CAAckL,KAAA,GAAQob,EAAA,GAGdxvB,OAAA,CAAAirB,IAAA,CAAK,+BAA+BjwB,CAAA,CAAMkK,SAAS;UAC7D,OAEAgE,CAAA,CAAckL,KAAA,GAAQhL,CAAA,CAAQgL,KAAA;UAEhC,IAAI,GAAChL,CAAA,CAAQgL,KAAA,IAASpO,CAAA,CAAcoO,KAAA,KAG/BtV,EAAA,EAEL;YAAA,IADQsK,CAAA,CAAAgL,KAAA,CAAM3V,gBAAA,CAAiB,aAAa0vB,EAAI,GAC5CpoB,CAAA,CAAaqO,KAAA,EAAO;cACdhL,CAAA,CAAAgL,KAAA,CAAM3V,gBAAA,CAAiB,SAASiyB,CAAM;cAC9C;YACF;YACQtnB,CAAA,CAAAgL,KAAA,CAAM3V,gBAAA,CAAiB,gBAAgByvB,EAAI,GAC3C9kB,CAAA,CAAAgL,KAAA,CAAM3V,gBAAA,CAAiB,gBAAgB0vB,EAAI,GAC3C/kB,CAAA,CAAAgL,KAAA,CAAM3V,gBAAA,CAAiB,SAASyvB,EAAI,GACpC9kB,CAAA,CAAAgL,KAAA,CAAM3V,gBAAA,CAAiB,QAAQ0vB,EAAI;UAAA;QAAA;QAGvCiD,EAAA,GAASC,CAAA,KAAM;UACfjoB,CAAA,CAAQgL,KAAA,KACFhL,CAAA,CAAAgL,KAAA,CAAM1V,mBAAA,CAAoB,aAAayvB,EAAI,GAC3C/kB,CAAA,CAAAgL,KAAA,CAAM1V,mBAAA,CAAoB,SAASgyB,CAAM,GACzCtnB,CAAA,CAAAgL,KAAA,CAAM1V,mBAAA,CAAoB,gBAAgBwvB,EAAI,GAC9C9kB,CAAA,CAAAgL,KAAA,CAAM1V,mBAAA,CAAoB,gBAAgByvB,EAAI,GAC9C/kB,CAAA,CAAAgL,KAAA,CAAM1V,mBAAA,CAAoB,SAASwvB,EAAI,GACvC9kB,CAAA,CAAAgL,KAAA,CAAM1V,mBAAA,CAAoB,QAAQyvB,EAAI;QAChD;MAGF,OAAA7S,EAAA,CACErS,CAAA,EACA,MAAM;QACAzN,CAAA,CAAU4Y,KAAA,IAASrO,CAAA,CAAaqO,KAAA,IAAS,CAACtN,CAAA,CAAmBsN,KAAA,IAAS,CAACpO,CAAA,CAAcoO,KAAA,IAClF+Z,EAAA,KAAIC,KAAA,CAAM,cAAc,CAAC;MAClC,GACA;QAAC7S,MAAA,EAAQ,CAACnS,CAAO;MAAC,IAGdoL,EAAA,EAAC,MAAMxZ,CAAA,CAAMqzB,KAAA,EAAO,MAAMrzB,CAAA,CAAMF,MAAA,EAAQ,MAAME,CAAA,CAAMkK,SAAS,GAAG,MAAM;QACnEksB,EAAA,IACFF,EAAA;MAAA,CAEN,GAED/W,EAAA,CAAU+W,EAAI,GAEdI,EAAA,CAAgBF,EAAM,IAAA7B,CAAA,EAAAC,EAAA,MAAA+B,CAAA,IAAAC,CAAA,CAAAC,EAAA,S;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECrfTC,EAAA,GAA2BC,CAAC;IACvCvtB,GAAA,EAAA/H,CAAA;IACAkI,GAAA,EAAA5K,CAAA;IACA2K,KAAA,EAAA1K,CAAA;IACAg4B,WAAA,EAAA52B,CAAA;IACA62B,QAAA,EAAAz2B;EACF,MAMiB;IACf,MAAME,CAAA,GAAYe,CAAA,GAAM,QAAQzC,CAAA,GAAQ,SAASD,CAAA,GAAM,UAAU;MAC3D6B,CAAA,GAAQJ,CAAA,GAAW,QAAQJ,CAAA,GAAc,OAAO;IACtD,OAAO,GAAGM,CAAS,GAAGE,CAAA,GAAQ,IAAIA,CAAK,KAAK,EAAE;EAChD;EAEa+0B,EAAA,GAA6Bl0B,CAAA,IAAiC;IACzE,MAAM,CAAC1C,CAAU,IAAI0C,CAAA,CAAUqB,KAAA,CAAM,GAAG;IACxC,QAAQ/D,CAAA;MACN,KAAK;QACI;MACT,KAAK;QACI;MACT;QACS,OAAAA,CAAA;IACX;EACF;EAEam4B,EAAA,GAAuBz1B,CAAA,IAClC,OAAOA,CAAA,IAAW,YAAYA,CAAA,CAAO01B,MAAA,KAAW;EAErCC,EAAA,GAAiBC,CAC5B51B,CAAA,EACA1C,CAAA,KACuC;IAEvC,IAAI,CADam4B,EAAA,CAAoBz1B,CAAM,GAC5B,OAAO;IAEhB,MAAArB,CAAA,GACJ,OAAOqB,CAAA,GAAW,OACjB,OAAOA,CAAA,IAAW,YAAY,CAACA,CAAA,CAAO4yB,KAAA,IAAS,CAAC5yB,CAAA,CAAO6yB,OAAA;MACpD9zB,CAAA,GAAQzB,CAAA,CAAGyG,YAAA,CAAa,OAAO,KAAKzG,CAAA,CAAGyG,YAAA,CAAa,qBAAqB;IAC/E,OAAIpF,CAAA,GACEI,CAAA,IACFzB,CAAA,CAAG8H,eAAA,CAAgB,OAAO,GACvB9H,CAAA,CAAA2H,YAAA,CAAa,uBAAuBlG,CAAK,GAErC;MACL8zB,OAAA,EAASlY,EAAA,CAAa5b,CAAA,EAAOsa,EAAgB;IAAA,KAG1C,KAEL,OAAOrZ,CAAA,IAAW,WACb;MACL6yB,OAAA,EAASlY,EAAA,CAAa3a,CAAA,EAAQqZ,EAAgB;IAAA,IAG3C;MACLuZ,KAAA,EAAO5yB,CAAA,YAAAA,CAAA,CAAQ4yB,KAAA,GAAQjY,EAAA,CAAa3a,CAAA,oBAAAA,CAAA,CAAQ4yB,KAAA,EAAOvZ,EAAgB,IAAI;MACvEwZ,OAAA,EAAS7yB,CAAA,YAAAA,CAAA,CAAQ6yB,OAAA,GAAUlY,EAAA,CAAa3a,CAAA,oBAAAA,CAAA,CAAQ6yB,OAAA,EAASxZ,EAAgB,IAAI;IAAA;EAEjF;EAEawc,EAAA,GAAwBC,CAAC91B,CAAA,EAA2B1C,CAAA,MAAqB;IACpFmB,MAAA,EAAQnB,CAAA;IACRs0B,UAAA,EAAY5xB,CAAA,CAAQ+1B,SAAA,CAAU5F,IAAA;IAC9B3gB,MAAA,EAAQxP,CAAA,CAAQ+1B,SAAA,CAAUvmB,MAAA;IAC1BwiB,KAAA,EAAOhyB,CAAA,CAAQ+1B,SAAA,CAAU/D,KAAA;IACzBQ,QAAA,EAAUxyB,CAAA,CAAQ+1B,SAAA,CAAUvD,QAAA;IAC5BC,UAAA,EAAYzyB,CAAA,CAAQ+1B,SAAA,CAAUtD,UAAA;IAC9BzoB,SAAA,EAAWhK,CAAA,CAAQ+1B,SAAA,CAAUnuB,IAAA,GACzB,SACA5H,CAAA,CAAQ+1B,SAAA,CAAUluB,KAAA,GAClB,UACA7H,CAAA,CAAQ+1B,SAAA,CAAUjuB,MAAA,GAClB,WACA9H,CAAA,CAAQ+1B,SAAA,CAAUhuB,GAAA,GAClB,QACA;IACJ2mB,IAAA,EAAM;IACN,IAAI,OAAO1uB,CAAA,CAAQ+X,KAAA,IAAU,WAAW/X,CAAA,CAAQ+X,KAAA,GAAQ,CAAC;IACzD6a,KAAA,EAAO;IACPC,OAAA,EAAS;EACX;EAQamD,EAAA,GAAO3M,CAACrpB,CAAA,EAAuB1C,CAAA,KAA8B;;IAClE,MAAAC,CAAA,GAAMoE,QAAA,CAASkiB,aAAA,CAAc,MAAM;IACrCvmB,CAAA,CAAQy4B,SAAA,CAAUhjB,IAAA,GAAepR,QAAA,CAAAoR,IAAA,CAAK+Q,WAAA,CAAYvmB,CAAG,IAChDD,CAAA,CAAQy4B,SAAA,CAAUE,KAAA,GAAOj2B,CAAA,CAAG8jB,WAAA,CAAYvmB,CAAG,KAC/CoB,CAAA,GAAAqB,CAAA,CAAG6F,UAAA,KAAH,QAAAlH,CAAA,CAAeu3B,YAAA,CAAa34B,CAAA,EAAKyC,CAAA,CAAGm2B,WAAA,GACzCn2B,CAAA,CAAGo2B,MAAA,GAASC,EAAA,CAAU;MAACC,MAAA,EAAQA,CAAA;;QAAM,OAAAC,EAAA,CAAE7E,EAAA,EAAU;UAAC,KAAG3yB,CAAA,GAAAiB,CAAA,CAAGw2B,QAAA,KAAH,gBAAAz3B,CAAA,CAAagZ,KAAA;QAAM;MAAA;IAAE,IACvE/X,CAAA,CAAAo2B,MAAA,CAAOK,KAAA,CAAMl5B,CAAG,GACnByC,CAAA,CAAG02B,UAAA,GAAan5B,CAAA;EAClB;EAEao5B,EAAA,GAAU32B,CAAA,IAA0B;;IAC/C,MAAM1C,CAAA,GAAM0C,CAAA,CAAG02B,UAAA;IACf,CAAAn5B,CAAA,GAAAyC,CAAA,CAAGo2B,MAAA,KAAH,QAAA74B,CAAA,CAAWq5B,OAAA,IACX,OAAO52B,CAAA,CAAGo2B,MAAA,EACV,OAAOp2B,CAAA,CAAGw2B,QAAA,EACVrgB,UAAA,CAAW,MAAM;MACf7Y,CAAA,YAAAA,CAAA,CAAK0d,MAAA;IAAA,GACJ,CAAC,GACJ,OAAOhb,CAAA,CAAG02B,UAAA;EACZ;ECpHAG,EAAA,GAAeC,CACb92B,CAAA,EACA1C,CAAA,EACAC,CAAA,KAEAD,CAAA,CAAYwJ,MAAA,CAAO,CAAC,MAAM,MAAM,MAAM,MAAM,KAAK,CAAC,EAAExF,MAAA,CAAO,CAAC3C,CAAA,EAAOI,CAAA,MACjEJ,CAAA,CACGqB,CAAA,GAAsB,GAAGA,CAAM,GAAGjB,CAAA,CAAW+B,MAAA,CAAO,CAAC,EAAEJ,WAAA,CAAgB,IAAA3B,CAAA,CAAWgC,KAAA,CAAM,CAAC,CAAC,KAAjFhC,CACZ,IAAIxB,CAAA,EACGoB,CAAA,GACN,eAAAd,MAAA,CAAOk5B,MAAA,CAAO,IAAI,CAAC;ECjBTC,EAAA,GAAAC,CACbj3B,CAAA,EACA1C,CAAA,EACAC,CAAA,EACAoB,CAAA,GAAcpB,CAAA,KAEdM,MAAA,CAAOkd,IAAA,CAAKzd,CAAG,EAAEgE,MAAA,CAAO,CAACvC,CAAA,EAAeE,CAAA,MACjCe,CAAA,CAAMf,CAAI,KAEXF,CAAA,CAAA4P,IAAA,CACF,CAAChQ,CAAA,EAAaM,CAAA,CAAKwB,OAAA,CAAQlD,CAAA,EAAY,EAAE,GAAGyC,CAAA,CAAMf,CAAI,CAAC,EACpDmL,MAAA,CAAQjL,CAAA,IAAMA,CAAA,IAAK,OAAOA,CAAA,IAAM,SAAS,EACzCmH,IAAA,CAAK,GAAG,EACRf,WAAA,CAAY,IAGVxG,CAAA,GACN,EAAE;ECnBPm4B,EAAA,GAAgBl3B,CAAA,IACd,OAAOA,CAAA,IAAU,WACbW,EAAA,CAAUX,CAAK,IACfA,CAAA,CAAMsuB,KAAA,KAAU,SAChBtuB,CAAA,CAAMsuB,KAAA,GACN,OAAOtuB,CAAA,CAAM0f,GAAA,IAAQ,WACrB/e,EAAA,CAAUX,CAAA,CAAM0f,GAAG,IACnB1f,CAAA,CAAM0f,GAAA;ECVZ+M,EAAA,GAAe0K,CAACn3B,CAAA,GAAS,OACvB,WAAWgH,IAAA,CAAKowB,MAAA,CAAO,EAAEr3B,QAAA,CAAS,EAAEgB,KAAA,CAAM,GAAG,CAAC,CAAC,SAASf,CAAM;ECChEq3B,EAAA,GAAeC,CAACt3B,CAAA,EAAwB1C,CAAA,OACrC0C,CAAA,oBAAAA,CAAA,OAAY,IACVsB,MAAA,CAAO,CAAC/D,CAAA,EAAcoB,CAAA,MACjB,OAAOA,CAAA,CAAKwnB,IAAA,IAAS,WACjB5oB,CAAA,GAAAA,CAAA,CAAIuJ,MAAA,CAAOnI,CAAA,CAAK0gB,QAA4B,IAElD9hB,CAAA,CAAIoR,IAAA,CAAKhQ,CAAI,GAERpB,CAAA,GACN,EAAE,EACJ6M,MAAA,CAAQ7M,CAAA,IAAW;;IAAA,SAAAoB,CAAA,GAAApB,CAAA,CAAM4oB,IAAA,KAAN,gBAAAxnB,CAAA,CAA6C+wB,MAAA,MAAWpyB,CAAA;EAAA,CAAQ;ECT3Ei6B,EAAA,GAAYv3B,CAAA,IACvBA,CAAA,KAAQ,QAAQ,OAAOA,CAAA,IAAQ;EAKpBw3B,EAAA,GAAax3B,CAAA,IAA4B,oBAAoB8E,IAAA,CAAKvE,MAAA,CAAOP,CAAK,CAAC;ECP5FgqB,EAAA,GAAgBhqB,CAAA,IACd,CAAC,EAAEA,CAAA,CAAMy3B,IAAA,IAAQz3B,CAAA,CAAMd,EAAA;ECWZw4B,EAAA,GAIRpG,MAAA,CAAO,UAAU;EAGTqG,EAAA,GASRrG,MAAA,CAAO,MAAM;EAGLsG,EAAA,GAMRtG,MAAA,CAAO,UAAU;EAGTuG,EAAA,GAERvG,MAAA,CAAO,WAAW;EAGVwG,EAAA,GAYRxG,MAAA,CAAO,aAAa;EAGZyG,EAAA,GAIRzG,MAAA,CAAO,WAAW;EAGV0G,EAAA,GAaR1G,MAAA,CAAO,eAAe;EAEd2G,EAAA,GAYR3G,MAAA,CAAO,YAAY;EAGX4G,EAAA,GAOR5G,MAAA,CAAO,UAAU;EAET6G,EAAA,GAOR7G,MAAA,CAAO,UAAU;EAET8G,EAAA,GAGR9G,MAAA,CAAO,QAAQ;ECtHL+G,EAAA,GAAAC,CAACt4B,CAAA,EAAc1C,CAAA,GAAQ,IAAIC,CAAA,GAAgB,OAAc;IAEhE,MAAAoB,CAAA,GAAQ,CAACqB,CAAI;IACf,IAAAjB,CAAA;IACJ,SAASE,CAAA,GAAI,GAAGA,CAAA,GAAIN,CAAA,CAAMf,MAAA,IAAU,CAACmB,CAAA,EAAME,CAAA,IAAK;MACxC,MAAAE,CAAA,GAAOR,CAAA,CAAMM,CAAC;MACpBF,CAAA,GAAOxB,CAAA,CAAO4B,CAAI;IACpB;IAEA,OAAQJ,CAAA,IAAQ,OAAOA,CAAA,IAAS,aAAaA,CAAA,CAAKzB,CAAK,IAAIyB,CAAA;EAC7D;ECKaw5B,EAAA,GAAkBC,CAACx4B,CAAA,EAAe1C,CAAA,GAAe4vB,GAAA,KAAgB;IAC5E,MAAM3vB,CAAA,GAAU4I,MAAA,CAAOsyB,QAAA,CAASz4B,CAAA,EAAO,EAAE;IACzC,OAAOmG,MAAA,CAAOsY,KAAA,CAAMlhB,CAAO,IAAID,CAAA,GAAeC,CAAA;EAChD;EAUam7B,EAAA,GAAUC,CAAC34B,CAAA,EAAwB1C,CAAA,GAAe4vB,GAAA,KAAgB;IAC7E,MAAM3vB,CAAA,GAAQ4I,MAAA,CAAOiN,UAAA,CAAWpT,CAAA,CAAMD,QAAA,CAAU;IAChD,OAAOoG,MAAA,CAAOsY,KAAA,CAAMlhB,CAAK,IAAID,CAAA,GAAeC,CAAA;EAC9C;EC7Baq7B,EAAA,GAAOC,CAIlB74B,CAAA,EACA1C,CAAA,KAEAO,MAAA,CAAOkd,IAAA,CAAK/a,CAAU,EACnBoK,MAAA,CAAQ7M,CAAA,IAAQ,CAACD,CAAA,CAAY8L,GAAA,CAAKzK,CAAA,IAAOA,CAAA,CAAGoB,QAAA,CAAS,CAAC,EAAE2I,QAAA,CAASnL,CAAG,CAAC,EACrE+D,MAAA,CAAO,CAAC/D,CAAA,EAAQoB,CAAA,MAAS;IAAC,GAAGpB,CAAA;IAAQ,CAACoB,CAAG,GAAGqB,CAAA,CAAWrB,CAAG;EAAC,IAAI,EAAwB;EAM/EsrB,EAAA,GAAO6O,CAIlB94B,CAAA,EACA1C,CAAA,KAEA,CAAC,GAAGA,CAAW,EAAEgE,MAAA,CACf,CAAC/D,CAAA,EAAMoB,CAAA,MACApB,CAAA,CAAAoB,CAAI,IAAIqB,CAAA,CAAWrB,CAAI,GACrBpB,CAAA,GAET,CAAC,CACH;EASWw7B,EAAA,GAAM7jB,CAEjBlV,CAAA,EACA1C,CAAA,EACAC,CAAA,KACa;IACP,MAAAoB,CAAA,GAAWrB,CAAA,CAAK+D,KAAA,CAAM,SAAS;IAErC,IAAItC,CAAA,GAAeiB,CAAA;IACnB,WAAWf,CAAA,IAAON,CAAA,EAAU;MAE1B,IADII,CAAA,KAAY,QACZA,CAAA,KAAY,QAAkB,OAAAxB,CAAA;MAC9B0B,CAAA,CAAI4B,IAAA,OAAW,OACnB9B,CAAA,GAAUA,CAAA,CAAQE,CAAG;IACvB;IACA,OAAIF,CAAA,KAAY,SAAkBxB,CAAA,GAC3BwB,CAAA;EACT;ECxDAi6B,EAAA,GAAeC,CACbj5B,CAAA,EACA1C,CAAA,KACW;IACX,MAAM;QAAC47B,GAAA,EAAA37B,CAAA;QAAK,GAAGoB;MAAA,IAAUqB,CAAA;MACnBjB,CAAA,GAAmD;IACrDxB,CAAA,IACKD,CAAA,CAAAwZ,OAAA,CAAS3X,CAAA,IAAO;MACrBJ,CAAA,CAAWI,CAAE,IAAI5B,CAAA;IAAA,CAClB;IAEH,MAAM0B,CAAA,GAAiC;MAAC,GAAGF,CAAA;MAAY,GAAGJ;IAAM;IAE9D,OAAAd,MAAA,CAAO4jB,OAAA,CAAQxiB,CAAK,EAEjBmL,MAAA,CAAO,CAAC,CAACjL,CAAA,EAAMoC,CAAK,MAAM,CAAC,CAACA,CAAA,IAASjE,CAAA,CAAOoL,QAAA,CAASvJ,CAAY,CAAC,EAClEiK,GAAA,CAAI,CAAC,CAACjK,CAAI,MAAMA,CAAY;EAEnC;ECRag6B,EAAA,GAAiBC,CAACp5B,CAAA,EAAgB1C,CAAA,KAC7CA,CAAA,IAAS0C,CAAA,GAASY,EAAA,CAAWZ,CAAM,IAAI;EAAAq5B,EAAA;EAAAC,EAAA,kBAAA3H,CAAA;;;;;;;;;;;;;;;;;;;;;;MCAzC,MAAMp0B,CAAA,GAAQyC,CAAA;QAwBRjB,CAAA,GAAagqB,EAAA,CAAUxrB,CAAA,EAAO,cATvBD,CAAA,EAS2C;UAAC6E,OAAA,EAAS;QAAA,CAAK;QAEjElD,CAAA,GAAastB,EAAA,CAAM,MAAMhvB,CAAA,CAAMqvB,EAAA,EAAI,WAAW;QAE9CztB,CAAA,GAAewqB,CAAA,CAAc,MAAMpsB,CAAA,CAAM6a,KAAK;QAC9C7W,CAAA,GAAcooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMg8B,IAAI;QAE5C9vB,CAAA,GAAkBoO,CAAA,CAAS,OAAO;UACtC,mBAAmB1Y,CAAA,CAAa4Y;QAChC;MAEF,OAAAyhB,EAAA,CAAQzB,EAAA,EAAuB;QAC7B0B,QAAA,EAAUtc,EAAA,CAASpe,CAAU;QAC7Bw6B,IAAA,EAAMh4B,CAAA;QACNm4B,WAAA,EAAchwB,CAAA,IAAe;UAC3B3K,CAAA,CAAWgZ,KAAA,GAAQrO,CAAA;QACrB;MAAA,CACD,IAAAA,CAAA,EAAAC,CAAA,MAAAurB,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCbD,MAAMx2B,CAAA,GAAQqB,CAAA;QAwBRjB,CAAA,GAAOxB,CAAA;QAoCP0B,CAAA,GAAwBs1B,CAC5BznB,CAAA,EACAC,CAAA,GAAoC,OAEpC,IAAIrO,EAAA,CAAmBoO,CAAA,EAAM;UAC3B5O,UAAA,EAAY;UACZO,MAAA,EAAQ+L,CAAA,CAAQuN,KAAA,IAAS;UACzBvZ,aAAA,EAAe;UACfI,OAAA,EAAS;UACT,GAAGmO,CAAA;UACHzO,WAAA,EAAaoJ,CAAA,CAAWqQ;QAAA,CACzB;QAEG5Y,CAAA,GAAa4pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEZ,CAAA,GAAoBooB,CAAA,CAAcxqB,CAAU;QAC5CsK,CAAA,GAAgBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMqwB,MAAM;QAChDtlB,CAAA,GAAoBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMg7B,UAAU;QACxDhwB,CAAA,GAAeggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMi7B,KAAK;QAC9ChwB,CAAA,GAAiB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMk7B,OAAO;QAClDhwB,CAAA,GAAuB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMm7B,aAAa;QAE9DpyB,CAAA,GAAa6kB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,UAAU;QAE7CpiB,CAAA,GAAUwN,CAAA,CAAwB,IAAI;QACtCvN,CAAA,GAAeuN,CAAA,CAAI,EAAK;QACxBtN,CAAA,GAAOsN,CAAA,CAAIzW,CAAA,CAAkBwW,KAAK;QAElCnN,CAAA,GAAkBiN,CAAA,CAAS,OAAO;UACtCsY,IAAA,EAAQzlB,CAAA,CAAKqN,KAAA;UACb,mBAAmBpO,CAAA,CAAaoO,KAAA;UAChCgiB,UAAA,EAActvB,CAAA,CAAasN,KAAA;UAC3BiiB,OAAA,EAAWtvB,CAAA,CAAKqN,KAAA,IAAS,CAACxW,CAAA,CAAkBwW,KAAA;UAC5C,uBAAuBrO,CAAA,CAAkBqO;QACzC;QAEIlN,CAAA,GAAQovB,CAAA,KAAM;UAClB96B,CAAA,CAAW4Y,KAAA,GAAQ;QAAA;QAEfjN,CAAA,GAAOgN,CAAA,KAAM;UACjB3Y,CAAA,CAAW4Y,KAAA,GAAQ;QAAA;QAEf/M,CAAA,GAAWkvB,CAAA,KAAM;UACV/6B,CAAA,CAAA4Y,KAAA,GAAQ,CAACxW,CAAA,CAAkBwW,KAAA;QAAA;MAGpC,IAAA7M,CAAA;QACAwB,CAAA;QACAC,CAAA,GAAiB9C,CAAA,CAAqBkO,KAAA;MAE1C,MAAMnL,CAAA,GAASutB,CAAA,KAAM;UACnB,MAAMrtB,CAAA,GAAQ7N,CAAA,CAAsB,QAAQ;YAACf,UAAA,EAAY;UAAA,CAAK;UAE9D,IADAa,CAAA,CAAK,QAAQ+N,CAAK,GACdA,CAAA,CAAM3O,gBAAA,EAAkB;YAC1BY,CAAA,CAAK,gBAAgB;YACrB;UACF;UACA+W,YAAA,CAAapJ,CAAW,GACxBoJ,YAAA,CAAa5K,CAAa,GAC1BR,CAAA,CAAKqN,KAAA,GAAQ,IACT,CAAApL,CAAA,KACJlC,CAAA,CAAasN,KAAA,GAAQ,IACrBgG,EAAA,CAAS,MAAM;YACTvT,CAAA,CAAQuN,KAAA,KAAU,SAClBrO,CAAA,CAAkBqO,KAAA,GACpBvN,CAAA,CAAQuN,KAAA,CAAM6P,KAAA,CAAM1jB,KAAA,GAAQ,GAAGsG,CAAA,CAAQuN,KAAA,CAAMvD,WAAW,OAExDhK,CAAA,CAAQuN,KAAA,CAAM6P,KAAA,CAAM3jB,MAAA,GAAS,GAAGuG,CAAA,CAAQuN,KAAA,CAAMrD,YAAY,MAE5DxJ,CAAA,GAAgBiL,UAAA,CAAW,MAAM;cAC/B1L,CAAA,CAAasN,KAAA,GAAQ,IACrBhZ,CAAA,CAAK,OAAO,GACRyL,CAAA,CAAQuN,KAAA,KAAU,SACdvN,CAAA,CAAAuN,KAAA,CAAM6P,KAAA,CAAM3jB,MAAA,GAAS,IACrBuG,CAAA,CAAAuN,KAAA,CAAM6P,KAAA,CAAM1jB,KAAA,GAAQ;YAC3B,GAAA6B,EAAA,CAAmByE,CAAA,CAAQuN,KAAK,CAAC;UAAA,CACrC;QAAA;QAGGlL,CAAA,GAAOmC,CAAA,KAAM;UACjB,MAAMlC,CAAA,GAAQ7N,CAAA,CAAsB,QAAQ;YAACf,UAAA,EAAY;UAAA,CAAK;UAE9D,IADAa,CAAA,CAAK,QAAQ+N,CAAK,GACdA,CAAA,CAAM3O,gBAAA,EAAkB;YAC1BY,CAAA,CAAK,gBAAgB;YACrB;UACF;UAGA,IAFA+W,YAAA,CAAa5K,CAAa,GAC1B4K,YAAA,CAAapJ,CAAW,GACpBlC,CAAA,CAAQuN,KAAA,KAAU,MACtB;YAAA,IAAIpL,CAAA,EAAgB;cAClBjC,CAAA,CAAKqN,KAAA,GAAQ;cACb;YACF;YACItN,CAAA,CAAasN,KAAA,IACPvN,CAAA,CAAAuN,KAAA,CAAM6P,KAAA,CAAM3jB,MAAA,GAAS,IACrBuG,CAAA,CAAAuN,KAAA,CAAM6P,KAAA,CAAM1jB,KAAA,GAAQ,MAGxBwF,CAAA,CAAkBqO,KAAA,GACpBvN,CAAA,CAAQuN,KAAA,CAAM6P,KAAA,CAAM1jB,KAAA,GAAQ,GAAGsG,CAAA,CAAQuN,KAAA,CAAMvD,WAAW,OAExDhK,CAAA,CAAQuN,KAAA,CAAM6P,KAAA,CAAM3jB,MAAA,GAAS,GAAGuG,CAAA,CAAQuN,KAAA,CAAMrD,YAAY,MAI9DlK,CAAA,CAAQuN,KAAA,CAAMzE,YAAA,EACd7I,CAAA,CAAasN,KAAA,GAAQ,IACrBgG,EAAA,CAAS,MAAM;cACTvT,CAAA,CAAQuN,KAAA,KAAU,SACdvN,CAAA,CAAAuN,KAAA,CAAM6P,KAAA,CAAM3jB,MAAA,GAAS,IACrBuG,CAAA,CAAAuN,KAAA,CAAM6P,KAAA,CAAM1jB,KAAA,GAAQ,IAC5BwI,CAAA,GAAcyJ,UAAA,CAAW,MAAM;gBAC7BzL,CAAA,CAAKqN,KAAA,GAAQ,IACbtN,CAAA,CAAasN,KAAA,GAAQ,IACrBhZ,CAAA,CAAK,QAAQ;cACZ,GAAAgH,EAAA,CAAmByE,CAAA,CAAQuN,KAAK,CAAC;YAAA,CACrC;UAAA;QAAA;MAGH,OAAAI,EAAA,CAAMhZ,CAAA,EAAY,MAAM;QACJoC,CAAA,CAAAwW,KAAA,GAAQnL,CAAA,CAAO,IAAIC,CAAA,CAAK;MAAA,CAC3C,GAEDiR,EAAA,CAAU,MAAM;QACVtT,CAAA,CAAQuN,KAAA,KAAU,QAClB,CAACxW,CAAA,CAAkBwW,KAAA,IAAStO,CAAA,CAAcsO,KAAA,IAC5CgG,EAAA,CAAS,MAAM;UACb5e,CAAA,CAAW4Y,KAAA,GAAQ;QAAA,CACpB;MACH,CACD,GAEKI,EAAA,CAAAtO,CAAA,EAAuBiD,CAAA,IAAW;QACrBH,CAAA,GAAAG,CAAA;MAAA,CAClB,GAEGlD,CAAA,CAAemO,KAAA,KACApL,CAAA,OACjBxN,CAAA,CAAW4Y,KAAA,GAAQ,IACnBgG,EAAA,CAAS,MAAM;QACbpR,CAAA,GAAiB9C,CAAA,CAAqBkO,KAAA;MAAA,CACvC,IAGGI,EAAA,CAAAvO,CAAA,EAAiBkD,CAAA,IAAW;QACfH,CAAA,OACRG,CAAA,GAAAhC,CAAA,KAASD,CAAA,IAClBkT,EAAA,CAAS,MAAM;UACbpR,CAAA,GAAiB9C,CAAA,CAAqBkO,KAAA;QAAA,CACvC;MAAA,CACF,GAEgB6G,EAAA,CAAApU,CAAA,EAAS,aAAa,MAAM;QAChCrL,CAAA,CAAA4Y,KAAA,GAAQ,CAACxW,CAAA,CAAkBwW,KAAA;MAAA,CACvC,GAEYza,CAAA;QACX28B,KAAA,EAAApvB,CAAA;QACA+uB,KAAA,EAAOjwB,CAAA;QACPmO,IAAA,EAAAhN,CAAA;QACAkkB,MAAA,EAAQhkB,CAAA;QACR6uB,OAAA,EAAS1c,EAAA,CAASzS,CAAI;MAAA,CACvB,GAED8uB,EAAA,CAAQtB,EAAA,EAAsB;QAC5BtL,EAAA,EAAIllB,CAAA;QACJuyB,KAAA,EAAApvB,CAAA;QACAiN,IAAA,EAAAhN,CAAA;QACAkkB,MAAA,EAAQhkB,CAAA;QACR6uB,OAAA,EAAS1c,EAAA,CAASzS,CAAI;QACtBkvB,KAAA,EAAOjwB;MAAA,CACR,IAAAmD,CAAA,EAAAC,CAAA,MAAAmoB,CAAA,IAAAC,CAAA,CAAAC,EAAA,S;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpND,MAAM;UAACgF,KAAA,EAAO78B,CAAA;UAAc,GAAGoB;QAAA,IAAiB07B,EAAA,CAAS;QAEnDt7B,CAAA,GAAQiB,CAAA;QAyCRf,CAAA,GAAO3B,CAAA;QAiBP6B,CAAA,GAAa4pB,EAAA,CAAUhqB,CAAA,EAAO,cAAcE,CAAA,EAAM;UAACkD,OAAA,EAAS;QAAA,CAAK;QAEjEZ,CAAA,GAAa+4B,EAAA,CAAOvC,EAAA,EAAuB,IAAI;QAE/CtuB,CAAA,GAAa8iB,EAAA,CAAM,MAAMxtB,CAAA,CAAM6tB,EAAA,EAAI,gBAAgB;MAEzD,OAAA9O,EAAA,CAAU,MAAM;QACV3e,CAAA,CAAW4Y,KAAA,IAAS,EAACxW,CAAA,YAAAA,CAAA,CAAYg4B,IAAA,CAAKxhB,KAAA,MAC5BxW,CAAA,YAAAA,CAAA,CAAAm4B,WAAA,CAAYjwB,CAAA,CAAWsO,KAAA,IAEjC,CAAC5Y,CAAA,CAAW4Y,KAAA,KAASxW,CAAA,oBAAAA,CAAA,CAAYk4B,QAAA,CAAS1hB,KAAA,MAAUtO,CAAA,CAAWsO,KAAA,KACjE5Y,CAAA,CAAW4Y,KAAA,GAAQ;MACrB,CACD,GAEDI,EAAA,CACE,MAAM5W,CAAA,oBAAAA,CAAA,CAAYk4B,QAAA,CAAS1hB,KAAA,EAC3B,MACG5Y,CAAA,CAAW4Y,KAAA,IAAQxW,CAAA,oBAAAA,CAAA,CAAYk4B,QAAA,CAAS1hB,KAAA,MAAUtO,CAAA,CAAWsO,KAAA,IAAS,EAACxW,CAAA,YAAAA,CAAA,CAAYg4B,IAAA,CAAKxhB,KAAA,IAE7FI,EAAA,CAAMhZ,CAAA,EAAY,MAAM;QAClBA,CAAA,CAAW4Y,KAAA,IAAS,EAACxW,CAAA,YAAAA,CAAA,CAAYg4B,IAAA,CAAKxhB,KAAA,MAAmBxW,CAAA,YAAAA,CAAA,CAAAm4B,WAAA,CAAYjwB,CAAA,CAAWsO,KAAA;MAAK,CAC1F,IAAArO,CAAA,EAAAC,CAAA,MAAAurB,CAAA,IAAAC,CAAA,QAAAoF,CAAA;QAAAH,KAAA;MAAA,GAAA1wB,CAAA,CAAA8wB,YAAA;QAAAJ,KAAA,EAAA7iB,CAAA,CAAAha,CAAA;MAAA,K;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCnID,MAAMD,CAAA,GAAQ0C,CAAA;QAoBRzC,CAAA,GAAgBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMm9B,MAAM;QAChD97B,CAAA,GAAgBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAM+0B,MAAM;QAEhDtzB,CAAA,GAAiB8Y,CAAA,CAAS,MAAM;UACpC,MAAMtW,CAAA,GAAgB;cACpB7D,IAAA,EAAM;cACNg9B,gBAAA,EAAkB;cAClBC,YAAA,EAAc;cACdC,gBAAA,EAAkB;cAClBC,YAAA,EAAc;cACdC,cAAA,EAAgB;cAChBC,cAAA,EAAgB;YAAA;YAEZtxB,CAAA,GAAa;cACjB,GAAGlI,CAAA;cACHm5B,gBAAA,EAAkB;cAClBE,gBAAA,EAAkB;YAAA;UAEb,OAAAj8B,CAAA,CAAcoZ,KAAA,GAAQxW,CAAA,GAAgBkI,CAAA;QAAA,CAC9C;QAEKxK,CAAA,GAAiB4Y,CAAA,CAAS,OAAO;UAACmjB,IAAA,EAAM19B,CAAA,CAAM09B,IAAA;UAAMC,GAAA,EAAK;UAAM,GAAGl8B,CAAA,CAAegZ;QAAA,EAAO;QAExF5Y,CAAA,GAAgB0Y,CAAA,CAAS,MAC7Bva,CAAA,CAAM49B,UAAA,KAAe,SACjB;UAAA;UAAA;UAGE,GAAGj8B,CAAA,CAAe8Y,KAAA;UAClB,GAAGza,CAAA,CAAM49B;QAAA,IAEX39B,CAAA,CAAcwa,KAAA,GACd;UACE,GAAG9Y,CAAA,CAAe8Y,KAAA;UAClB0iB,MAAA,EAAQ;UACRU,iBAAA,EAAmBp8B,CAAA,CAAegZ,KAAA,CAAM2iB,gBAAA;UACxCU,aAAA,EAAer8B,CAAA,CAAegZ,KAAA,CAAM4iB;QAAA,IAEtC17B,CAAA,CAAe8Y,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;MCvDrB,MAAMxa,CAAA,GAAQyC,CAAA;QAaRrB,CAAA,GAAOrB,CAAA;QAIPyB,CAAA,GAAkB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCZ1D,MAAMlJ,CAAA,GAAQ0C,CAAA;QAmBRzC,CAAA,GAAQ89B,EAAA;QAKR18B,CAAA,GAAegrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMgd,KAAK;QAE9Cvb,CAAA,GAAkB8Y,CAAA,CAAS,MAAM,CACrC,WAAWva,CAAA,CAAM6oB,IAAI,IACrB;UACE,CAAC,WAAW7oB,CAAA,CAAM6oB,IAAI,KAAK,GAAGxnB,CAAA,CAAaoZ,KAAA;UAC3C,CAAC,QAAQza,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;QAC/C,EACD;QAEK1rB,CAAA,GAAese,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAY5G,CAAA,CAAM+wB,KAAK,CAAC;;;;;;;;;;;ECkCpDgN,EAAA,GAAqB;EAAAC,EAAA,kBAAA5J,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA/C3B,MAAMp0B,CAAA,GAAQyC,CAAA;QA2BRrB,CAAA,GAAOrB,CAAA;QAIPyB,CAAA,GAAQs7B,EAAA;QAERp7B,CAAA,GAAgB0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMm4B,MAAM;QAChDv2B,CAAA,GAAcwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMi+B,IAAI;MAG5B7R,CAAA,CAAc,MAAMpsB,CAAA,CAAMk+B,MAAM;MACtD,MAAMl6B,CAAA,GAAkBooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;MAGnCmjB,CAAA,CAAc,MAAMpsB,CAAA,CAAMkD,OAAO;MAClD,MAAAgJ,CAAA,GAAe6wB,EAAA,CAAOpC,EAAA,EAAsB,IAAI;QAChDxuB,CAAA,GAAa4wB,EAAA,CAAOlC,EAAA,EAAoB,IAAI;QAE5CzuB,CAAA,GAAWkU,EAAA;QAIXjU,CAAA,GAAMiO,CAAA,CAAS,MAAM;UACnB,MAAAjN,CAAA,GAAarN,CAAA,CAAMm+B,mBAAA,CACtBr6B,KAAA,CAAM,GAAG,EACT+H,GAAA,CAAK0B,CAAA,IAAMA,CAAA,CAAEhK,MAAA,CAAO,CAAC,EAAEJ,WAAA,CAAgB,IAAAoK,CAAA,CAAE/J,KAAA,CAAM,CAAC,CAAC,EACjDuF,IAAA,CAAK,EAAE;UAEV,OAAI,GADcqD,CAAA,oBAAAA,CAAA,CAAUgyB,UAAA,CAAWC,GAAA,CAAIC,SAAA,CAAUjxB,CAAA,OAAgB,WACnDrJ,CAAA,CAAgBwW,KAAA,IAAS,CAACxa,CAAA,CAAM2B,EAAA,GACzC,MAEF3B,CAAA,CAAMm+B,mBAAA;QAAA,CACd;QAEK7xB,CAAA,GAAegO,CAAA,CAAS,MAAM;UAClC,MAAMjN,CAAA,GAAa;UACnB,IAAIrN,CAAA,CAAMk6B,IAAA,EAAM,OAAOl6B,CAAA,CAAMk6B,IAAA;UAEzB,WAAOl6B,CAAA,CAAM2B,EAAA,IAAO,UAAU,OAAO3B,CAAA,CAAM2B,EAAA,IAAM0L,CAAA;UAE/C;YAAC1L,EAAA,EAAA2L;UAAM,IAAAtN,CAAA;UAET,IAAAsN,CAAA,KAAO,UAAa,UAAUA,CAAA,EAAI;YAC9B,MAAAC,CAAA,GAAOD,CAAA,CAAGixB,IAAA,IAAQ;cAClB9wB,CAAA,GAAQH,CAAA,CAAGkxB,KAAA,GACb,IAAIl+B,MAAA,CAAOkd,IAAA,CAAKlQ,CAAA,CAAGkxB,KAAK,EACrB3yB,GAAA,CAAKsD,CAAA;;gBAAM,UAAGA,CAAC,KAAIC,CAAA,GAAA9B,CAAA,CAAGkxB,KAAA,KAAH,gBAAApvB,CAAA,CAAWD,CAAA,CAAE;cAAA,CAAE,EAClCpG,IAAA,CAAK,GAAG,CAAC,KACZ;cACE4E,CAAA,GAAO,CAACL,CAAA,CAAGmxB,IAAA,IAAQnxB,CAAA,CAAGmxB,IAAA,CAAKl7B,MAAA,CAAO,CAAC,MAAM,MAAM+J,CAAA,CAAGmxB,IAAA,IAAQ,KAAK,IAAInxB,CAAA,CAAGmxB,IAAI;YAChF,OAAO,GAAGlxB,CAAI,GAAGE,CAAK,GAAGE,CAAI,MAAMN,CAAA;UACrC;UAGO,OAAAA,CAAA;QAAA,CACR;QAEKlD,CAAA,GAAkBmQ,CAAA,CAAS,OAAO;UACtC,CAAC,QAAQta,CAAA,CAAMotB,OAAO,EAAE,GAAGptB,CAAA,CAAMotB,OAAA,KAAY;UAC7C,CAAC,gBAAgBptB,CAAA,CAAM6mB,OAAO,EAAE,GAAG7mB,CAAA,CAAM6mB,OAAA,KAAY;UACrD,CAAC,gBAAgB7mB,CAAA,CAAM0+B,YAAY,QAAQ,GAAG1+B,CAAA,CAAM0+B,YAAA,KAAiB;UACrE,CAAC,kBAAkB1+B,CAAA,CAAM2+B,gBAAgB,EAAE,GAAG3+B,CAAA,CAAM2+B,gBAAA,KAAqB;UACzE,CAAC,eAAe3+B,CAAA,CAAM4+B,eAAe,EAAE,GAAG5+B,CAAA,CAAM4+B,eAAA,KAAoB;UACpE,CAAC,eAAe5+B,CAAA,CAAM6+B,oBAAoB,QAAQ,GAAG7+B,CAAA,CAAM6+B,oBAAA,KAAyB;UACpF,CAAC,0BAA0B7+B,CAAA,CAAM8+B,gBAAgB,EAAE,GAAG9+B,CAAA,CAAM8+B,gBAAA,KAAqB;UACjF,CAAC,0BAA0B9+B,CAAA,CAAM++B,qBAAqB,QAAQ,GAC5D/+B,CAAA,CAAM++B,qBAAA,KAA0B;UAClC,aAAan9B,CAAA,CAAY4Y,KAAA,KAAU;QACnC;QAEIvN,CAAA,GAAaqN,CAAA,CAAS,OAAO;UACjCuiB,KAAA,EAAS1yB,CAAA,CAAgBqQ,KAAA;UACzB7Y,EAAA,EAAM3B,CAAA,CAAM2B,EAAA;UACZu4B,IAAA,EAAQ5tB,CAAA,CAAakO,KAAA;UACrBtZ,MAAA,EAAUlB,CAAA,CAAMkB,MAAA;UAChB89B,GAAA,EAAOh/B,CAAA,CAAMkB,MAAA,KAAW,WAAWlB,CAAA,CAAMg/B,GAAA,IAAO,aAAa;UAC7DC,QAAA,EAAYj7B,CAAA,CAAgBwW,KAAA,GACxB,OACA,OAAOhZ,CAAA,CAAMy9B,QAAA,GAAa,MAC1B,OACAz9B,CAAA,CAAMy9B,QAAA;UACV,iBAAiBj7B,CAAA,CAAgBwW,KAAA,GAAQ,KAAO;QAChD;QAEItN,CAAA,GAAsBoN,CAAA,CAAS,OAAO;UAC1C,CAACyjB,EAAkB,GAAGr8B,CAAA,CAAc8Y,KAAA;UACpCvR,QAAA,EAAUjF,CAAA,CAAgBwW;QAC1B;QAEIrN,CAAA,GAAWE,CAAA,IAAwB;;UACvC,IAAIrJ,CAAA,CAAgBwW,KAAA,EAAO;YACzBnN,CAAA,CAAEvM,cAAA,CAAe,GACjBuM,CAAA,CAAE6xB,wBAAA,CAAyB;YAC3B;UACF;UAGG,GAAA5xB,CAAA,GAAApB,CAAA,oBAAAA,CAAA,CAAcmwB,KAAA,KAAd,gBAAA/uB,CAAA,CAAqBkN,KAAA,MAAU,MAAQrO,CAAA,KAAe,QACtDA,CAAA,KAAe,UAAQoB,CAAA,GAAApB,CAAA,CAAWgzB,SAAA,KAAX,gBAAA5xB,CAAA,CAAsBiN,KAAA,MAAU,SAExD/M,CAAA,GAAAvB,CAAA,oBAAAA,CAAA,CAAcwwB,KAAA,KAAd,QAAAjvB,CAAA,CAAA5K,IAAA,CAAAqJ,CAAA,IAGF9K,CAAA,CAAK,SAASiM,CAAC;QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCtHjB,MAAMrN,CAAA,GAAQyC,CAAA;QAqDRrB,CAAA,GAAOrB,CAAA;QAKPyB,CAAA,GAAegqB,EAAA,CAAUxrB,CAAA,EAAO,WAAWoB,CAAI;QAE/CM,CAAA,GAAgB0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMm4B,MAAM;QAChDv2B,CAAA,GAAkBwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QACpDjF,CAAA,GAAcooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMo/B,IAAI;QAC5ClzB,CAAA,GAAiBkgB,CAAA,CAAc,MAAMpsB,CAAA,CAAMq/B,OAAO;QAClDlzB,CAAA,GAAiBigB,CAAA,CAAc,MAAMpsB,CAAA,CAAMs/B,OAAO;QAClDlzB,CAAA,GAAiBggB,CAAA,CAAc,MAAMpsB,CAAA,CAAMu/B,OAAO;QAClDlzB,CAAA,GAAqB+f,CAAA,CAAc,MAAMpsB,CAAA,CAAMw/B,WAAW;QAE1D;UAAC7S,YAAA,EAAArgB,CAAA;UAAcsgB,iBAAA,EAAAziB;QAAA,IAAqBoiB,EAAA,CAAevsB,CAAA,EAAO,CAC9D,gBACA,sBACA,SACA,WACA,yBACA,aACD;QAEKiN,CAAA,GAAW+S,CAAA,CAAM,MAAM,OAAO9T,CAAA,CAAesO,KAAA,IAAU,SAAS;QAChEtN,CAAA,GAAW8S,CAAA,CACf,MAAMhgB,CAAA,CAAMy/B,GAAA,KAAQ,YAAYz/B,CAAA,CAAMk6B,IAAA,KAAS,UAAal6B,CAAA,CAAM2B,EAAA,KAAO;QAErEwL,CAAA,GAAU6S,CAAA,CAAM,MAAMhgB,CAAA,CAAM2B,EAAA,KAAO,MAAS;QAC5C0L,CAAA,GAAiB2S,CAAA,CAAM,MAAOhgB,CAAA,CAAMk6B,IAAA,KAAS,SAAY,KAAQ,CAAChtB,CAAA,CAASsN,KAAM;QAEjFlN,CAAA,GAAYgN,CAAA,CAAS,MAAOnN,CAAA,CAAQqN,KAAA,GAAQrQ,CAAA,CAAkBqQ,KAAA,GAAQ,EAAG;QAEzEjN,CAAA,GAAkB+M,CAAA,CAAS,MAAM,CACrC,CAAC,OAAOta,CAAA,CAAM4S,IAAI,EAAE,GACpB;UACE,CAAC,OAAO5S,CAAA,CAAMotB,OAAO,EAAE,GAAGptB,CAAA,CAAMotB,OAAA,KAAY;UAC5C+K,MAAA,EAAUz2B,CAAA,CAAc8Y,KAAA,IAAStO,CAAA,CAAesO,KAAA;UAChD,gBAAgBxW,CAAA,CAAYwW,KAAA;UAC5B,aAAarO,CAAA,CAAeqO,KAAA;UAC5BvR,QAAA,EAAYrH,CAAA,CAAgB4Y;QAC9B,EACD;QAEK/M,CAAA,GAAcuS,CAAA,CAAM,MAAO7S,CAAA,CAAQqN,KAAA,GAAQwjB,EAAA,GAAQh+B,CAAA,CAAMk6B,IAAA,GAAO,MAAMl6B,CAAA,CAAMy/B,GAAI;QAEhF9xB,CAAA,GAAWwB,CAAA,IAAwB;UACvC,IAAIvN,CAAA,CAAgB4Y,KAAA,EAAO;YACzBrL,CAAA,CAAErO,cAAA,CAAe,GACjBqO,CAAA,CAAEuwB,eAAA,CAAgB;YAClB;UACF;UACAt+B,CAAA,CAAK,SAAS+N,CAAC,GACXlC,CAAA,CAASuN,KAAA,KACEhZ,CAAA,CAAAgZ,KAAA,GAAQ,CAACtO,CAAA,CAAesO,KAAA;QACvC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC9HF,MAAMpZ,CAAA,GAAQqB,CAAA;QA+BRjB,CAAA,GAAOxB,CAAA;QAOP0B,CAAA,GAAQo8B,EAAA;QAORl8B,CAAA,GAAU6Y,CAAA,CAAwB,IAAI;QAEtCzW,CAAA,GAAawnB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAChD0K,CAAA,GAAaib,EAAA,CAAgBvlB,CAAO;QAEpCuK,CAAA,GAAqBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMu+B,WAAW;QAC1DvzB,CAAA,GAAcggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMq1B,IAAI;QAC5CpqB,CAAA,GAAmB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMsf,SAAS;QACtDpU,CAAA,GAAqB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMw+B,WAAW;QAC1Dz1B,CAAA,GAAsBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMy+B,YAAY;QAC5D5yB,CAAA,GAAiB6T,EAAA,CAAY,MAAM1f,CAAA,CAAM0+B,QAAQ;QAEjD5yB,CAAA,GAAe8S,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYlF,CAAA,CAAMg7B,KAAK,CAAC;QAEpDvvB,CAAA,GAAkB6S,CAAA,CAAM,MAAO,OAAOhc,CAAA,CAAWwW,KAAA,IAAU,YAAY,IAAIxW,CAAA,CAAWwW,KAAM;QAE5FnN,CAAA,GAAkBiN,CAAA,CAAS,OAAO;UACtC,CAAC,SAASlZ,CAAA,CAAMgsB,OAAO,EAAE,GAAGhsB,CAAA,CAAMgsB,OAAA,KAAY;UAC9C,qBAAqBjhB,CAAA,CAAmBqO;QACxC;QAEIlN,CAAA,GAAegN,CAAA,CAAS,MAAM,CAAClZ,CAAA,CAAM2+B,UAAA,EAAY;UAAC,oBAAoB7yB,CAAA,CAAasN;QAAM,EAAC;QAE1F;UACJmF,QAAA,EAAApS,CAAA;UACAsS,KAAA,EAAApS,CAAA;UACAmgB,OAAA,EAAAjgB,CAAA;UACAmS,MAAA,EAAA3Q,CAAA;UACA+O,IAAA,EAAA9O,CAAA;UACA2e,QAAA,EAAA1e,CAAA;UACAmL,KAAA,EAAOlL;QAAA,IACLme,EAAA,CAAatgB,CAAA,EAAiBF,CAAA,EAAgB;UAChDyT,SAAA,EAAW,OAAO1c,CAAA,CAAWwW,KAAA,IAAU,YAAYnO,CAAA,CAAiBmO;QAAA,CACrE;QAEKjL,CAAA,GAAiByQ,CAAA,CAAM,MAC3B,OAAOhc,CAAA,CAAWwW,KAAA,IAAU,YACxBxW,CAAA,CAAWwW,KAAA,GACXjN,CAAA,CAASiN,KAAA,IAAUlO,CAAA,CAAmBkO,KAAA,IAASnL,CAAA,CAASmL,KAAA;QAGxDhL,CAAA,GAAa8K,CAAA,CAAS,OAAO;UACjC8S,OAAA,EAASlgB,CAAA,CAAasN,KAAA,GAAQpZ,CAAA,CAAM4+B,YAAA,GAAe;UACnDnD,KAAA,EAAOvvB,CAAA,CAAakN;QACpB;MAEFqI,EAAA,CAAY,MAAM;QACXrhB,CAAA,oBAAmB8N,CAAA,CAAYkL,KAAK;MAAA,CAC1C;MAED,MAAM/K,CAAA,GAAOgC,CAAA,KAAM;UACjBjQ,CAAA,CAAK,OAAO,GAER,OAAOwC,CAAA,CAAWwW,KAAA,IAAU,YAC9BxW,CAAA,CAAWwW,KAAA,GAAQ,MAEnBxW,CAAA,CAAWwW,KAAA,GAAQ,GACdpL,CAAA,KAGP5N,CAAA,CAAK,QAAQ;QAAA;QAGTkO,CAAA,GAAeuwB,CAAA,KAAM;UACrB91B,CAAA,CAAoBqQ,KAAA,IAClB/M,CAAA;QAAA;MAGF,OAAAmN,EAAA,CAAA1O,CAAA,EAAayD,CAAA,IAAa;QAC9B,IAAIA,CAAA,EAAU;UACCD,CAAA;UACb;QACF;QACOP,CAAA;MAAA,CACR,GAEDuoB,EAAA,CAAgBtoB,CAAI,GAEPrP,CAAA;QACX8f,KAAA,EAAApS,CAAA;QACAmgB,OAAA,EAAAjgB,CAAA;QACAmS,MAAA,EAAA3Q,CAAA;QACA+O,IAAA,EAAA9O;MAAA,CACD,IAAAO,CAAA,EAAAC,CAAA,MAAA+nB,CAAA,IAAAztB,CAAA,CAAAg2B,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECmGYC,EAAA,GAAe19B,CAAA,IAA6C;IACjE,MAAA1C,CAAA,GAAY,OAAO0C,CAAA,IAAU,YAAYw3B,EAAA,CAAUx3B,CAAK,IAAI04B,EAAA,CAAQ14B,CAAA,EAAO,CAAC,IAAIA,CAAA;IACtF,OAAO,OAAO1C,CAAA,IAAc,WAAW,GAAGA,CAAS,OAAOA,CAAA,IAAa;EACzE;EAAAqgC,EAAA,kBAAAhM,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAvNA,MAAMp0B,CAAA,GAAQyC,CAAA;QA2ERrB,CAAA,GAAOrB,CAAA;QAKPyB,CAAA,GAAQs8B,EAAA;QAOR;UAACnR,YAAA,EAAAjrB,CAAA;UAAckrB,iBAAA,EAAAhrB;QAAiB,IAAI2qB,EAAA,CAAevsB,CAAK;QAExDgE,CAAA,GAAa+4B,EAAA,CAAOxC,EAAA,EAAyB,IAAI;QAEjDruB,CAAA,GAAQ,CAAC,MAAM,MAAM,IAAI;QACzBC,CAAA,GAAkB;QAClBC,CAAA,GAAwBD,CAAA,GAAkB;QAE1CE,CAAA,GAAoB+f,CAAA,CAAc,MAAMpsB,CAAA,CAAMqgC,UAAU;QACxD/zB,CAAA,GAAkB8f,CAAA,CAAc,MAAMpsB,CAAA,CAAMsgC,QAAQ;QACpDn2B,CAAA,GAAgBiiB,CAAA,CAAc,MAAMpsB,CAAA,CAAMmuB,MAAM;QAChDlhB,CAAA,GAAkBmf,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QACpDiE,CAAA,GAAgBkf,CAAA,CAAc,MAAMpsB,CAAA,CAAMugC,MAAM;QAChDpzB,CAAA,GAAiBif,CAAA,CAAc,MAAMpsB,CAAA,CAAMozB,OAAO;QAClD/lB,CAAA,GAAoB+e,CAAA,CAAc,MAAMpsB,CAAA,CAAMqzB,UAAU;QACxD/lB,CAAA,GAAuB8e,CAAA,CAAc,MAAMpsB,CAAA,CAAMszB,aAAa;QAC9D/lB,CAAA,GAAsB6e,CAAA,CAAc,MAAMpsB,CAAA,CAAMuzB,YAAY;QAC5D9lB,CAAA,GAAoB2e,CAAA,CAAc,MAAMpsB,CAAA,CAAMwzB,UAAU;QAExD7lB,CAAA,GAAiBqS,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYpF,CAAA,CAAMg/B,OAAO,CAAC;QACxDrxB,CAAA,GAAe6Q,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYpF,CAAA,CAAMi/B,KAAK,CAAC;QAEpDrxB,CAAA,GAAY4Q,CAAA,CAAM,MAAM,CAAC,CAAChgB,CAAA,CAAMygC,KAAA,IAASzgC,CAAA,CAAMygC,KAAA,KAAU,MAAMtxB,CAAA,CAAaqL,KAAK;QACjFnL,CAAA,GAAiB2Q,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAY4O,IAAA,CAAK4H,KAAA,KAAStN,CAAA,CAAcsN,KAAK;QAC1ElL,CAAA,GAAe0Q,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAY4O,IAAA,CAAK4H,KAAA,KAAS2lB,EAAA,CAAYngC,CAAA,CAAM4S,IAAI,CAAC;QAC5ErD,CAAA,GAAkByQ,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAYopB,OAAA,CAAQ5S,KAAA,KAASxa,CAAA,CAAMotB,OAAO;QACxE5d,CAAA,GAAkBwQ,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAYovB,OAAA,CAAQ5Y,KAAA,KAASrN,CAAA,CAAeqN,KAAK;QAC/E/K,CAAA,GAAqBuQ,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAYqvB,UAAA,CAAW7Y,KAAA,KAASnN,CAAA,CAAkBmN,KAAK;QACxF9K,CAAA,GAAwBsQ,CAAA,CAC5B,OAAMhc,CAAA,oBAAAA,CAAA,CAAYsvB,aAAA,CAAc9Y,KAAA,KAASlN,CAAA,CAAqBkN,KAAA;QAE1D7K,CAAA,GAAuBqQ,CAAA,CAC3B,OAAMhc,CAAA,oBAAAA,CAAA,CAAYuvB,YAAA,CAAa/Y,KAAA,KAASjN,CAAA,CAAoBiN,KAAA;QAExD5K,CAAA,GAAqBoQ,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAYwvB,UAAA,CAAWhZ,KAAA,KAAS/M,CAAA,CAAkB+M,KAAK;QAExF3K,EAAA,GAAuBqjB,EAAA,CAAwB,OAAO;UAC1DE,OAAA,EAAS5jB,CAAA,CAAgBgL,KAAA;UACzB6Y,UAAA,EAAY5jB,CAAA,CAAmB+K,KAAA;UAC/B8Y,aAAA,EAAe5jB,CAAA,CAAsB8K,KAAA;UACrC+Y,YAAA,EAAc5jB,CAAA,CAAqB6K,KAAA;UACnCgZ,UAAA,EAAY5jB,CAAA,CAAmB4K;QAC/B;QACIzK,EAAA,GAAeod,EAAA,CAAuB,OAAO;UACjDC,OAAA,EAASptB,CAAA,CAAM0gC,YAAA;UACfpT,SAAA,EAAWttB,CAAA,CAAM2gC,cAAA;UACjBtT,WAAA,EAAartB,CAAA,CAAM4gC;QACnB;QAEIvvB,EAAA,GAAY2O,CAAA,CAAM,MAAOhgB,CAAA,CAAMygC,KAAA,KAAU,KAAO,KAAKzgC,CAAA,CAAMygC,KAAM;QAEjEjL,EAAA,GAAsBxV,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAYqpB,WAAA,CAAY7S,KAAA,KAASxa,CAAA,CAAMqtB,WAAW;QACpFoI,EAAA,GAAoBzV,CAAA,CAAM,OAAMhc,CAAA,oBAAAA,CAAA,CAAYspB,SAAA,CAAU9S,KAAA,KAASxa,CAAA,CAAMstB,SAAS;QAE9E4I,EAAA,GAA4B/I,EAAA,CAAuB,OAAO;UAC9DG,SAAA,EAAWmI,EAAA,CAAkBjb,KAAA;UAC7B6S,WAAA,EAAamI,EAAA,CAAoBhb,KAAA;UACjC4S,OAAA,EAAS7d,CAAA,CAAgBiL;QACzB;QAEI2b,EAAA,GAAkB7b,CAAA,CAAS,MAAM,CACrC4b,EAAA,CAA0B1b,KAAA;QAAA;QAE1BnL,CAAA,CAAemL,KAAA,KAAU,KAAO,SAAY3K,EAAA,CAAqB2K,KAAA,EACjE;UACE,CAAC,YAAYxa,CAAA,CAAM4S,IAAI,EAAE,GAAG,CAAC,CAAC5S,CAAA,CAAM4S,IAAA,IAAQ1G,CAAA,CAAMhD,OAAA,CAAQi3B,EAAA,CAAYngC,CAAA,CAAM4S,IAAI,CAAC,MAAM;UACvF,CAAC,OAAOrD,CAAA,CAAgBiL,KAAK,EAAE,GAAGrQ,CAAA,CAAcqQ,KAAA,GAAQjL,CAAA,CAAgBiL,KAAA,KAAU,OAAO;UACzFimB,KAAA,EAAS,CAACt2B,CAAA,CAAcqQ,KAAA,IAASjL,CAAA,CAAgBiL,KAAA,KAAU,QAAQ7M,CAAA,CAAe6M,KAAA;UAClF+T,GAAA,EAAOpkB,CAAA,CAAcqQ,KAAA;UAAA;UAErB,aAAanL,CAAA,CAAemL,KAAA,KAAU;QACxC,EACD;QAEK4b,EAAA,GAAa9b,CAAA,CAAqB,MAAM;UACtC,MAAAwc,CAAA,GAAS92B,CAAA,CAAM6gC,WAAA,IAAe;UAK7B;YACLC,QAAA,GAJA50B,CAAA,CAAMhD,OAAA,CAAQoG,CAAA,CAAakL,KAAA,IAAS,IAAI,MAAM,KAC1C,QAAQlL,CAAA,CAAakL,KAAK,MAAMpO,CAAqB,MACrD,OAEkB;YACtB5B,GAAA,EAAK8B,CAAA,CAAgBkO,KAAA,GAAQsc,CAAA,GAAS;YACtCvsB,MAAA,EAAQ+B,CAAA,CAAgBkO,KAAA,GAAQ,KAAKsc,CAAA;YACrCzsB,IAAA,EAAMgC,CAAA,CAAkBmO,KAAA,GAAQsc,CAAA,GAAS;YACzCxsB,KAAA,EAAO+B,CAAA,CAAkBmO,KAAA,GAAQ,KAAKsc;UAAA;QACxC,CACD;QAEKT,EAAA,GAAgB/b,CAAA,CAAqB,MAAM;UAC/C,MAAMwc,CAAA,GACJ5qB,CAAA,CAAMhD,OAAA,CAAQoG,CAAA,CAAakL,KAAA,IAAS,IAAI,MAAM,KAC1C,QAAQlL,CAAA,CAAakL,KAAK,MAAMrO,CAAe,MAC/C;UACN,OAAO2qB,CAAA,GAAW;YAACgK,QAAA,EAAAhK;UAAQ,IAAI;QAAC,CACjC;QAEKR,CAAA,GAAchc,CAAA,CAAS,MAAM;;UAC3B,MAAAwc,CAAA,KAAeG,EAAA,GAAAjzB,CAAA,oBAAAA,CAAA,CAAY+8B,YAAA,KAAZ,gBAAA9J,EAAA,CAA0Bzc,KAAA,KAAS;YAElDuc,EAAA,GACJznB,CAAA,CAAakL,KAAA,IAASsc,CAAA,GAAe,QAAQxnB,CAAA,CAAakL,KAAK,OAAOsc,CAAY,MAAM;UAC1F,OAAOC,EAAA,GAAQ;YAACiK,UAAA,EAAYjK,EAAA;YAAOkK,WAAA,EAAalK;UAAA,IAAS;QAAC,CAC3D;QAEKR,CAAA,GAAcvW,CAAA,CAAM,MACxBte,CAAA,CAAa8Y,KAAA,GAAQwjB,EAAA,GAAQ7zB,CAAA,CAAcqQ,KAAA,GAAQ,WAAW;QAG1Dgc,CAAA,GAAgBlc,CAAA,CAAwB,OAAO;UACnD,GAAGgc,CAAA,CAAY9b,KAAA;UACf7T,KAAA,EAAO2I,CAAA,CAAakL,KAAA,IAAS;UAC7B9T,MAAA,EAAQ4I,CAAA,CAAakL,KAAA,IAAS;QAC9B;QAEIoc,CAAA,GAAWE,CAAA,IAAwB;UACnC,CAAC7pB,CAAA,CAAgBuN,KAAA,KAAU9Y,CAAA,CAAa8Y,KAAA,IAASrQ,CAAA,CAAcqQ,KAAA,KAAQpZ,CAAA,CAAK,SAAS01B,CAAC;QAAA;QAGtFD,CAAA,GAAcC,CAAA,IAAa;UAC/B11B,CAAA,CAAK,aAAa01B,CAAC;QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MChPrB,MAAM/2B,CAAA,GAAQ0C,CAAA;QAmCRzC,CAAA,GAAgBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMwgC,MAAM;QAChDn/B,CAAA,GAAiBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMqzB,OAAO;QAClD5xB,CAAA,GAAoB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMszB,UAAU;QACxD3xB,CAAA,GAAuB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMuzB,aAAa;QAC9D1xB,CAAA,GAAsBwqB,CAAA,CAAc,MAAMrsB,CAAA,CAAMwzB,YAAY;QAC5DvvB,CAAA,GAAoBooB,CAAA,CAAc,MAAMrsB,CAAA,CAAMyzB,UAAU;QACxDtnB,CAAA,GAAgB4U,EAAA,CAAY,MAAM/gB,CAAA,CAAMmhC,OAAO;QAE/C/0B,CAAA,GAAemO,CAAA,CAAS,MAAM6lB,EAAA,CAAYpgC,CAAA,CAAM6S,IAAI,CAAC;QACrDxG,CAAA,GAAe4T,CAAA,CAAM,MAAMvW,IAAA,CAAKC,GAAA,CAAID,IAAA,CAAKG,GAAA,CAAIsC,CAAA,CAAcsO,KAAA,EAAO,CAAC,GAAG,CAAC,IAAI,CAAC;QAE5EnO,CAAA,GAAeiO,CAAA,CAAqB,MAAM;UACxC,MAAAhO,CAAA,GAAQH,CAAA,CAAaqO,KAAA,GAAQ,QAAQrO,CAAA,CAAaqO,KAAK,MAAMpO,CAAA,CAAaoO,KAAK,MAAM;UAC3F,OAAOlO,CAAA,GAAQ;YAACoK,WAAA,EAAapK,CAAA;YAAO60B,YAAA,EAAc70B;UAAA,IAAS;QAAC,CAC7D;MAED,OAAA2vB,EAAA,CAAQ1B,EAAA,EAAyB;QAC/BwG,YAAA,EAAA30B,CAAA;QACAwG,IAAA,EAAMoN,CAAA,CAAM,MAAMjgB,CAAA,CAAM6S,IAAI;QAC5B2tB,MAAA,EAAQvgC,CAAA;QACRozB,OAAA,EAAShyB,CAAA;QACTiyB,UAAA,EAAY7xB,CAAA;QACZ8xB,aAAA,EAAe5xB,CAAA;QACf6xB,YAAA,EAAc3xB,CAAA;QACd4xB,UAAA,EAAYxvB,CAAA;QACZopB,OAAA,EAASpN,CAAA,CAAM,MAAMjgB,CAAA,CAAMqtB,OAAO;QAClCE,SAAA,EAAWtN,CAAA,CAAM,MAAMjgB,CAAA,CAAMutB,SAAS;QACtCD,WAAA,EAAarN,CAAA,CAAM,MAAMjgB,CAAA,CAAMstB,WAAW;MAAA,CAC3C,IAAA/gB,CAAA,EAAAnC,CAAA,MAAAwtB,CAAA,IAAAztB,CAAA,CAAAk3B,EAAA,CAAA90B,CAAA,CAAAmzB,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC9DD,MAAM1/B,CAAA,GAAQ0C,CAAA;QA8CRzC,CAAA,GAAcosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMq/B,IAAI;QAC5Ch+B,CAAA,GAAuBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMshC,aAAa;QAC9D7/B,CAAA,GAAsB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMuhC,YAAY;QAC5D5/B,CAAA,GAAgB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo4B,MAAM;QAChDv2B,CAAA,GAAkBwqB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkJ,QAAQ;QACpDjF,CAAA,GAA4BmpB,EAAA,CAAuBptB,CAAK;QAExD;UAAC4sB,YAAA,EAAAzgB,CAAA;UAAc0gB,iBAAA,EAAAzgB;QAAA,IAAqBogB,EAAA,CAAexsB,CAAA,EAAO,CAC9D,UACA,eACA,UACA,YACA,QACA,OACA,WACA,uBACA,UACA,MACA,WACA,gBACA,oBACA,mBACA,wBACA,oBACA,yBACA,OACD;QAEKqM,CAAA,GAAc4T,CAAA,CAAM,MAAO9T,CAAA,CAAasO,KAAA,GAAQwjB,EAAA,GAAQj+B,CAAA,CAAM0/B,GAAI;QAElEpzB,CAAA,GAAkBiO,CAAA,CAAS,MAAM,CACrCtW,CAAA,CAA0BwW,KAAA,EAC1B;UACE2d,MAAA,EAAUz2B,CAAA,CAAc8Y,KAAA;UACxBvR,QAAA,EAAYrH,CAAA,CAAgB4Y,KAAA;UAC5B,gBAAgBxa,CAAA,CAAYwa,KAAA;UAC5B,sDACEpZ,CAAA,CAAqBoZ,KAAA,IAAShZ,CAAA,CAAoBgZ,KAAA;UACpD,0CAA0ChZ,CAAA,CAAoBgZ,KAAA;UAC9D,wBAAwBtO,CAAA,CAAasO;QACvC,EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7ED,MAAMxa,CAAA,GAAQyC,CAAA;QAsCRrB,CAAA,GAAOrB,CAAA;QAIPyB,CAAA,GAAgB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMm4B,MAAM;QAChDz2B,CAAA,GAAkB0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QAEpDrH,CAAA,GAAkB0Y,CAAA,CAAS,OAAO;UACtC6d,MAAA,EAAQ32B,CAAA,CAAcgZ;QACtB;QAEIxW,CAAA,GAAcgc,CAAA,CAAM,MAAOxe,CAAA,CAAcgZ,KAAA,GAAQ,SAASwjB,EAAM;QAEhE9xB,CAAA,GAAsB8T,CAAA,CAAM,MAAOxe,CAAA,CAAcgZ,KAAA,GAAQxa,CAAA,CAAMuhC,WAAA,GAAc,MAAU;QAEvFp1B,CAAA,GAAoBmO,CAAA,CAAS,MACjCtW,CAAA,CAAYwW,KAAA,KAAU,SAClBkS,EAAA,CAAK1sB,CAAA,EAAO,CACV,UACA,eACA,UACA,YACA,QACA,OACA,WACA,uBACA,UACA,MACA,WACA,WACA,gBACA,oBACA,mBACA,wBACA,oBACA,yBACA,OACD,IACD,CAAC;QAGDoM,CAAA,GAAWC,CAAA,IAAwB;UACnC,IAAA3K,CAAA,CAAgB8Y,KAAA,IAAShZ,CAAA,CAAcgZ,KAAA,EAAO;YAChDnO,CAAA,CAAEvL,cAAA,CAAe,GACjBuL,CAAA,CAAE6yB,wBAAA,CAAyB;YAC3B;UACF;UACKx9B,CAAA,CAAgB8Y,KAAA,IAAOpZ,CAAA,CAAK,SAASiL,CAAC;QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7F7C,MAAMtM,CAAA,GAAQ0C,CAAA;QAgBRzC,CAAA,GAAa6sB,EAAA;QAEbzrB,CAAA,GAAwBkZ,CAAA,CAAiC,MAAM;UACnE,MAAM9Y,CAAA,GAAazB,CAAA,CAAM+sB,KAAA,KAAS9sB,CAAA,oBAAAA,CAAA,CAAY8sB,KAAA,KAAS;UACvD,IAAIprB,CAAA,GAAgB;UAcb,OAbOF,CAAA,CAAWqK,GAAA,CAAI,CAAC7H,CAAA,EAAMkI,CAAA,MAC9B,OAAOlI,CAAA,IAAS,aACXA,CAAA;YAACktB,IAAA,EAAMltB;UAAA,GACVkI,CAAA,GAAM1K,CAAA,CAAWnB,MAAA,GAAS,MAAG2D,CAAA,CAAKk2B,IAAA,GAAO,OAE3Cl2B,CAAA,CAAKm0B,MAAA,KAAwBz2B,CAAA,QAG7B,CAACsC,CAAA,CAAKm0B,MAAA,IAAU,CAACz2B,CAAA,KACdsC,CAAA,CAAAm0B,MAAA,GAASjsB,CAAA,GAAM,MAAM1K,CAAA,CAAWnB,MAAA,GAEhC2D,CAAA,CACR;QACM,CACR;;;;;;;;;;;;;;;;;;;;;;;;;;;MC3CD,MAAMjE,CAAA,GAAQ0C,CAAA;QAoBRzC,CAAA,GAAkBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMyhC,QAAQ;QAEpDpgC,CAAA,GAAkBkZ,CAAA,CAAS,OAAO;UACtC,aAAa,CAACta,CAAA,CAAgBwa,KAAA;UAC9B,CAAC,aAAaza,CAAA,CAAM6S,IAAI,EAAE,GAAG7S,CAAA,CAAM6S,IAAA,KAAS;UAC5C,sBAAsB5S,CAAA,CAAgBwa;QACtC;;;;;;;;;;;;;;;;;;;;;;;;;;;MC1BF,MAAMza,CAAA,GAAQ0C,CAAA;QAmBRzC,CAAA,GAAiBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM0hC,OAAO;QAElDrgC,CAAA,GAAkBkZ,CAAA,CAAS,OAAO;UACtC,2BAA2Bta,CAAA,CAAewa;QAC1C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MChBF,MAAMza,CAAA,GAAQ0C,CAAA;QAyBRzC,CAAA,GAAcosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMwvB,IAAI;QAC5CnuB,CAAA,GAAegrB,CAAA,CAAc,MAAMrsB,CAAA,CAAM2hC,KAAK;QAC9ClgC,CAAA,GAAe4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM4hC,KAAK;QAC9CjgC,CAAA,GAAgB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM6hC,MAAM;QAChDhgC,CAAA,GAAewqB,CAAA,CAAc,MAAMrsB,CAAA,CAAM8hC,KAAK;QAC9C79B,CAAA,GAAmBooB,CAAA,CAAc,MAAMrsB,CAAA,CAAM+hC,SAAS;QACtD51B,CAAA,GAAekgB,CAAA,CAAc,MAAMrsB,CAAA,CAAM2K,KAAK;QAC9CyB,CAAA,GAAaigB,CAAA,CAAc,MAAMrsB,CAAA,CAAM4K,GAAG;QAC1CyB,CAAA,GAAmBggB,CAAA,CAAc,MAAMrsB,CAAA,CAAMgiC,SAAS;QACtD11B,CAAA,GAAeyU,EAAA,CAAY,MAAM/gB,CAAA,CAAM2G,MAAA,IAAUipB,GAAG;QACpDrjB,CAAA,GAAcwU,EAAA,CAAY,MAAM/gB,CAAA,CAAM4G,KAAA,IAASgpB,GAAG;QAClDxlB,CAAA,GAAiBiiB,CAAA,CAAc,MAAMrsB,CAAA,CAAMqzB,OAAO;QAClDnmB,CAAA,GAAoBmf,CAAA,CAAc,MAAMrsB,CAAA,CAAMszB,UAAU;QACxDnmB,CAAA,GAAuBkf,CAAA,CAAc,MAAMrsB,CAAA,CAAMuzB,aAAa;QAC9DnmB,CAAA,GAAsBif,CAAA,CAAc,MAAMrsB,CAAA,CAAMwzB,YAAY;QAC5DlmB,CAAA,GAAoB+e,CAAA,CAAc,MAAMrsB,CAAA,CAAMyzB,UAAU;QAExDlmB,CAAA,GAAuB4lB,EAAA,CAAwB,OAAO;UAC1DE,OAAA,EAASjpB,CAAA,CAAeqQ,KAAA;UACxB6Y,UAAA,EAAYpmB,CAAA,CAAkBuN,KAAA;UAC9B8Y,aAAA,EAAepmB,CAAA,CAAqBsN,KAAA;UACpC+Y,YAAA,EAAcpmB,CAAA,CAAoBqN,KAAA;UAClCgZ,UAAA,EAAYnmB,CAAA,CAAkBmN;QAC9B;QAEIjN,CAAA,GAAiB+M,CAAA,CAAS,MAC9B,OAAOva,CAAA,CAAMiiC,MAAA,IAAW,WACpBjiC,CAAA,CAAMiiC,MAAA,CACHl+B,KAAA,CAAM,GAAG,EACT+I,MAAA,CAAQ0C,CAAA,IAAMA,CAAC,EACfxG,IAAA,CAAK,GAAG,IACXrG,KAAA,CAAMC,OAAA,CAAQ5C,CAAA,CAAMiiC,MAAM,IAC1BjiC,CAAA,CAAMiiC,MAAA,CAAOn1B,MAAA,CAAQ0C,CAAA,IAAMA,CAAC,EAAExG,IAAA,CAAK,GAAG,IACtC;QAGA0E,CAAA,GAAgB6M,CAAA,CAAS,MAC7B,OAAOva,CAAA,CAAMkiC,KAAA,IAAU,WACnBliC,CAAA,CAAMkiC,KAAA,CACHn+B,KAAA,CAAM,GAAG,EACT+I,MAAA,CAAQ0C,CAAA,IAAMA,CAAC,EACfxG,IAAA,CAAK,GAAG,IACXrG,KAAA,CAAMC,OAAA,CAAQ5C,CAAA,CAAMkiC,KAAK,IACzBliC,CAAA,CAAMkiC,KAAA,CAAMp1B,MAAA,CAAQ0C,CAAA,IAAMA,CAAC,EAAExG,IAAA,CAAK,GAAG,IACrC;QAGA4E,CAAA,GAAqB2M,CAAA,CAAkE,MAAM;UACjG,MAAM/K,CAAA,GAAQ3G,MAAA,CAAOsY,KAAA,CAAM5U,CAAA,CAAYkO,KAAK,IAAI,SAAYlO,CAAA,CAAYkO,KAAA;YAClEhL,CAAA,GAAS5G,MAAA,CAAOsY,KAAA,CAAM7U,CAAA,CAAamO,KAAK,IAAI,SAAYnO,CAAA,CAAamO,KAAA;UAC3E,OAAIpZ,CAAA,CAAaoZ,KAAA,GACXjL,CAAA,KAAU,UAAaC,CAAA,KAAW,SAC7B;YAAC9I,MAAA,EAAQ6I,CAAA;YAAO5I,KAAA,EAAA4I;UAAA,IAErBA,CAAA,KAAU,UAAaC,CAAA,KAAW,SAC7B;YAAC9I,MAAA,EAAA8I,CAAA;YAAQ7I,KAAA,EAAO6I;UAAA,IAElB;YAAC9I,MAAA,EAAQ;YAAGC,KAAA,EAAO;UAAC,IAEtB;YACLA,KAAA,EAAA4I,CAAA;YACA7I,MAAA,EAAA8I;UAAA;QACF,CACD;QAEKL,CAAA,GAAsB6Q,CAAA,CAAM,MAChC1Q,CAAA,CAAgB3B,CAAA,CAAmB6M,KAAA,CAAM7T,KAAA,EAAOgH,CAAA,CAAmB6M,KAAA,CAAM9T,MAAA,EAAQ3G,CAAA,CAAMmiC,UAAU;QAG7F9yB,CAAA,GAAY4Q,CAAA,CAAM,MACtB9T,CAAA,CAAasO,KAAA,GACT,gBACArO,CAAA,CAAWqO,KAAA,GACX,cACA9Y,CAAA,CAAc8Y,KAAA,GACd,YACA;QAGAnL,CAAA,GAAkBiL,CAAA,CAAS,MAAM,CACrChN,CAAA,CAAqBkN,KAAA,EACrB;UACE,iBAAiBpO,CAAA,CAAiBoO,KAAA;UAClC,aAAa5Y,CAAA,CAAa4Y,KAAA,IAASxW,CAAA,CAAiBwW,KAAA;UACpD,SAASxW,CAAA,CAAiBwW,KAAA;UAC1B,CAAC,GAAGpL,CAAA,CAAUoL,KAAK,EAAE,GAAGpL,CAAA,CAAUoL,KAAA,KAAU;UAC5C,WAAWhZ,CAAA,CAAagZ,KAAA,IAAS9Y,CAAA,CAAc8Y;QACjD,EACD;QAEKlL,CAAA,GAAkB6yB,CAAC5yB,CAAA,EAA2BC,CAAA,EAA4BC,CAAA,KAC9E,oCAAoC2yB,kBAAA,CAAmB,eAAe7yB,CAAK,aAAaC,CAAM,qDAAqDD,CAAK,IAAIC,CAAM;AAAA,mDACjHC,CAAK;AAAA,WAC7C,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7HZ,MAAM1P,CAAA,GAAQ0C,CAAA;QAmCRzC,CAAA,GAAgBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMwK,MAAM;QAChDnJ,CAAA,GAAagrB,CAAA,CAAc,MAAMrsB,CAAA,CAAM4K,GAAG;QAC1CnJ,CAAA,GAAe4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM2K,KAAK;QAC9ChJ,CAAA,GAAa0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMyK,GAAG;QAE1C5I,CAAA,GAAYoe,CAAA,CAAM,MACtBte,CAAA,CAAW8Y,KAAA,GACP,iBACApZ,CAAA,CAAWoZ,KAAA,GACX,mBACAxa,CAAA,CAAcwa,KAAA,GACd,oBACAhZ,CAAA,CAAagZ,KAAA,GACb,kBACA;QAGAxW,CAAA,GAAmBsW,CAAA,CAAS,MAAM+gB,EAAA,CAAKt7B,CAAA,EAAO,CAAC,UAAU,OAAO,OAAO,OAAO,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MChDtF,MAAMA,CAAA,GAAQ0C,CAAA;QAiBRzC,CAAA,GAA4BmtB,EAAA,CAAuBptB,CAAK;QAExDqB,CAAA,GAAkBkZ,CAAA,CAAS,MAAM,CACrCta,CAAA,CAA0Bwa,KAAA,EAC1B;UACE,CAAC,UAAUza,CAAA,CAAMsiC,aAAa,EAAE,GAAGtiC,CAAA,CAAMsiC,aAAA,KAAkB;QAC7D,EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7BD,MAAMtiC,CAAA,GAAQ0C,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCEd,MAAM1C,CAAA,GAAQ0C,CAAA;QAkBRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,QAAQva,CAAA,CAAMstB,WAAW,EAAE,GAAGttB,CAAA,CAAMstB,WAAA,KAAgB;QACrD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCAF,MAAMttB,CAAA,GAAQ0C,CAAA;QA8BRzC,CAAA,GAAQ89B,EAAA;QASR18B,CAAA,GAAiBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMuiC,OAAO;QAClD9gC,CAAA,GAA4B2rB,EAAA,CAAuBptB,CAAK;QAExD2B,CAAA,GAAese,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAY5G,CAAA,CAAMq1B,KAAK,CAAC;QACpDzzB,CAAA,GAAkBoe,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAY5G,CAAA,CAAMuiC,QAAQ,CAAC;QAE1Dv+B,CAAA,GAAkBsW,CAAA,CAAS,MAAM,CACrC9Y,CAAA,CAA0BgZ,KAAA,EAC1B;UACE,oBAAoBpZ,CAAA,CAAeoZ;QACrC,EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCtED,MAAMza,CAAA,GAAQ0C,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCgEd,MAAM1C,CAAA,GAAQ0C,CAAA;QA4FRzC,CAAA,GAAQ89B,EAAA;QAWR18B,CAAA,GAAmBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMyiC,SAAS;QACtDhhC,CAAA,GAAgB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM0iC,MAAM;QAChD/gC,CAAA,GAAkB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM2iC,QAAQ;QACpD9gC,CAAA,GAAgBwqB,CAAA,CAAc,MAAMrsB,CAAA,CAAM4iC,MAAM;QAEhD3+B,CAAA,GAAgBgc,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAY5G,CAAA,CAAM4iC,MAAM,CAAC;QACtD12B,CAAA,GAAgB8T,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAY5G,CAAA,CAAM6iC,MAAM,CAAC;QAEtD12B,CAAA,GAA4BghB,EAAA,CAAuBptB,CAAK;QAExDqM,CAAA,GAAkBkO,CAAA,CAAS,MAAM,CACrCnO,CAAA,CAA0BqO,KAAA,EAC1B;UACE,CAAC,QAAQza,CAAA,CAAM+iC,KAAK,EAAE,GAAG/iC,CAAA,CAAM+iC,KAAA,KAAU;UACzC,CAAC,UAAU/iC,CAAA,CAAMsiC,aAAa,EAAE,GAAGtiC,CAAA,CAAMsiC,aAAA,KAAkB;UAC3D,YAAY3gC,CAAA,CAAgB8Y,KAAA;UAC5B,oBAAoBhZ,CAAA,CAAcgZ;QACpC,EACD;QAEKnO,CAAA,GAAUiO,CAAA,CAAS,OAAO;UAC9ByoB,GAAA,EAAKhjC,CAAA,CAAMijC,MAAA;UACXC,GAAA,EAAKljC,CAAA,CAAMmjC,MAAA;UACXx8B,MAAA,EAAQ3G,CAAA,CAAMojC,SAAA;UACdx8B,KAAA,EAAO5G,CAAA,CAAMqjC,QAAA;UACb74B,MAAA,EAAQxK,CAAA,CAAMyiC,SAAA;UACd73B,GAAA,EAAK5K,CAAA,CAAM0iC,MAAA;UACX/3B,KAAA,EAAO3K,CAAA,CAAM2iC,QAAA;UACbl4B,GAAA,EAAKzK,CAAA,CAAMsjC;QACX;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCrMF,MAAMtjC,CAAA,GAAQ0C,CAAA;QAkBRzC,CAAA,GAAiBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMujC,OAAO;QAClDliC,CAAA,GAAcgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMwjC,IAAI;QAE5C/hC,CAAA,GAAgBwe,CAAA,CAAM,MAC1B5e,CAAA,CAAYoZ,KAAA,GAAQ,cAAcxa,CAAA,CAAewa,KAAA,GAAQ,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCgC5E,MAAMpZ,CAAA,GAAQqB,CAAA;QA8CRjB,CAAA,GAAOxB,CAAA;QAMP0B,CAAA,GAAQo8B,EAAA;QAKRl8B,CAAA,GAAaotB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,UAAU;QAE7CrrB,CAAA,GAAawnB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEsH,CAAA,GAAkBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMoiC,QAAQ;QACpDr3B,CAAA,GAAqBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMqiC,WAAW;QAC1Dr3B,CAAA,GAAsBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMy+B,YAAY;QAC5DxzB,CAAA,GAAc+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMq1B,IAAI;QAC5CnqB,CAAA,GAAkB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMsiC,QAAQ;QACpDv5B,CAAA,GAAoBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMuiC,UAAU;QACxD12B,CAAA,GAAiBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMwiC,OAAO;QAClD12B,CAAA,GAAgBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAMyiC,MAAM;QAChD12B,CAAA,GAAuB2T,EAAA,CAAY,MAAM1f,CAAA,CAAM0iC,cAAc;QAC7Dz2B,CAAA,GAAiByT,EAAA,CAAY,MAAM1f,CAAA,CAAM0+B,QAAQ;QACjDxyB,CAAA,GAAe8e,CAAA,CAAc,MAAMhrB,CAAA,CAAM2iC,IAAI;QAE7Cx2B,CAAA,GAAkBkN,CAAA,CAAI,EAAK;QAC3BhN,CAAA,GAAcgN,CAAA,CAAI,EAAK;QACvB9M,CAAA,GAAY8M,CAAA,CAAI,EAAI;QACpBtL,CAAA,GAAgBsL,CAAA,CAAwB,IAAI;QAC5CrL,CAAA,GAAUqL,CAAA,CAAwB,IAAI;QACtCpL,CAAA,GAAqBoL,CAAA,CAAIzW,CAAA,CAAWwW,KAAK;QAEzClL,CAAA,GAAa6X,EAAA,CAAgB/X,CAAO;QAOpCG,CAAA,GAAeyQ,CAAA,CACnB,MACE,+BAAgCrS,CAAA,CAAU6M,KAAA,GAAiB,SAAT,MAAe,kBAC9D7M,CAAA,CAAU6M,KAAA,GAAkB,QAAV,OACrB;QAEEhL,CAAA,GAAewQ,CAAA,CACnB,MAAM,sCAAsCrS,CAAA,CAAU6M,KAAA,GAAQ,UAAU,KAAK;QAGzE;UAACqF,KAAA,EAAApQ,CAAA;UAAOqQ,MAAA,EAAApQ;QAAA,IAAU+Q,EAAA,CACtB,MAAM;UACetU,CAAA,CAAAqO,KAAA,GAAQgb,EAAA,CAAK,IAAIC,EAAA,CAAK;QAC3C,GACApoB,CAAA,EACA;UAACqT,SAAA,EAAWpT,CAAA,CAAakN,KAAA,KAAU;QAAU;QAGzC7K,CAAA,GAAWqQ,CAAA,CACf,MACG1S,CAAA,CAAakN,KAAA,KAAU,MAAQ/M,CAAA,CAAY+M,KAAA,KAAU,MAASlN,CAAA,CAAakN,KAAA,KAAU;QAEpF5K,CAAA,GAAS0K,CAAA,CAAS,MAAMwf,EAAA,CAAgBp4B,CAAA,CAAM8+B,OAAA,EAAS,gBAAgB,CAAC;QACxE3wB,EAAA,GAAkByK,CAAA,CAAS,OAAO;UAAC,iBAAiBjO,CAAA,CAAYmO;QAAO;QAUvEzK,EAAA,GAAwB6mB,CAAA;;UAC5B,WAAIt1B,EAAA,CAAgBs1B,CAAA,EAAO;YACzB71B,WAAA,EAAaa,CAAA,CAAW4Y,KAAA;YACxB7Z,UAAA,EAAY;YACZO,MAAA,EAAQkO,CAAA,CAAQoL,KAAA;YAChB/Y,SAAA,EAAWkM,CAAA,CAAU6M,KAAA,GAAQ,UAAU;YACvCjZ,IAAA,EAAM8N,CAAA,CAAmBmL,KAAA;YACzB7Y,EAAA,EAAIqC,CAAA,CAAWwW,KAAA;YACfvZ,aAAA,IAAe41B,CAAA,GAAA1nB,CAAA,CAAcqL,KAAA,KAAd,gBAAAqc,CAAA,CAAqB/U,QAAA,CAAS9d,CAAA,CAAWwW,KAAA,MAAU;UAAA,CACnE;QAAA;QAEGnJ,EAAA,GAAaulB,CAAA,IAAwB;UACzC,IAAIrpB,CAAA,CAAgBiN,KAAA,KAAU,IAS1B;YAAA,IAPAlN,CAAA,CAAakN,KAAA,KAAU,OACzB/M,CAAA,CAAY+M,KAAA,GAAQ,KAElB7K,CAAA,CAAS6K,KAAA,KAAU,MACd9K,CAAA,IAET/B,CAAA,CAAU6M,KAAA,GAAQ,EAAAoc,CAAA,GAAQ5yB,CAAA,CAAWwW,KAAA,GACjCoc,CAAA,IAAShnB,CAAA,CAAO4K,KAAA,CAAMna,MAAA,EAAQ;cAChC,IAAI6M,CAAA,CAAcsN,KAAA,EAAO;cACzBxW,CAAA,CAAWwW,KAAA,GAAQ;cACnB;YACF;YACA,IAAIoc,CAAA,GAAQ,GAAG;cACb,IAAI1pB,CAAA,CAAcsN,KAAA,EAAO;cACdxW,CAAA,CAAAwW,KAAA,GAAQ5K,CAAA,CAAO4K,KAAA,CAAMna,MAAA,GAAS;cACzC;YACF;YACAgP,CAAA,CAAmBmL,KAAA,GAAQxW,CAAA,CAAWwW,KAAA,EACtCxW,CAAA,CAAWwW,KAAA,GAAQoc,CAAA;UAAA;QAAA;QAGfpB,EAAA,GAAOwO,CAAA,KAAY;UACb3yB,EAAA,CAAArN,CAAA,CAAWwW,KAAA,GAAQ,CAAC;QAAA;QAE1Bib,EAAA,GAAOwO,CAAA,KAAY;UACb5yB,EAAA,CAAArN,CAAA,CAAWwW,KAAA,GAAQ,CAAC;QAAA;QAG1B0b,EAAA,GAAaU,CAAA,IAAmB;UAChC1qB,CAAA,CAAgBsO,KAAA,KAAU,MAC3Boc,CAAA;QAAA;QAGCT,EAAA,GAAe8J,CAAA,KAAM;UACrB7zB,CAAA,CAAoBoO,KAAA,IAClB/K,CAAA;QAAA;QAEF2mB,EAAA,GAAe8N,CAAA,KAAM;UACpBv0B,CAAA,CAAS6K,KAAA,IACP9K,CAAA;QAAA;QAGH;UAAC4b,OAAA,EAAA+K;QAAA,IAAW5L,EAAA,CAASrb,CAAA,EAAS;UAClCxK,OAAA,EAAS;UACTgmB,aAAA,EAAe;YACT3d,CAAA,CAAeuN,KAAA,KAAU,MACvB/K,CAAA;UACR;UACAkb,WAAA,EAAa;YACX,IAAI1d,CAAA,CAAeuN,KAAA,KAAU,IAAM;YACnC,MAAMoc,CAAA,GAAeuN,CAAA,KAAM;cACrBx0B,CAAA,CAAS6K,KAAA,KAAU,MAChB9K,CAAA;YAAA;YAEL,IAAA2mB,EAAA,CAAQ7b,KAAA,IAASrN,CAAA,CAAqBqN,KAAA,EAAO;cAC1Cib,EAAA,IACQmB,CAAA;cACb;YACF;YACIP,EAAA,CAAQ7b,KAAA,IAAS,CAACrN,CAAA,CAAqBqN,KAAA,KACpCgb,EAAA,IACQoB,CAAA;UAEjB;QAAA,CACD;QAEKN,CAAA,GAAgB8N,CAAA,KAAM;UACrB5iC,CAAA,UAASuO,EAAA,CAAqB,OAAO,CAAC,GAC3CxC,CAAA,CAAgBiN,KAAA,GAAQ;QAAA;QAEpB+b,CAAA,GAAe8N,CAAA,KAAM;UACpB7iC,CAAA,SAAQuO,EAAA,CAAqB,MAAM,CAAC,GACzCxC,CAAA,CAAgBiN,KAAA,GAAQ;QAAA;QAKpBgc,CAAA,GAAgBI,CAAA,IAAgB;UAChC5yB,CAAA,CAAWwW,KAAA,KAAU,KACpBoc,CAAA,CAAAjQ,SAAA,CAAUC,GAAA,CAAI,eAAe;QAClC;MAGF,OAAAxE,EAAA,CACE,aACA,MAAM;QACJ8T,EAAA,CAAUV,EAAI;MAChB,GACA;QAACt0B,MAAA,EAAQkO;MAAO,IAElBgT,EAAA,CACE,cACA,MAAM;QACJ8T,EAAA,CAAUT,EAAI;MAChB,GACA;QAACv0B,MAAA,EAAQkO;MAAO,IAGlBwL,EAAA,CAAMtN,CAAA,EAAc,MAAM;QACxBG,CAAA,CAAY+M,KAAA,GAAQ;MAAA,CACrB,GAEKI,EAAA,CAAAtL,CAAA,EAAasnB,CAAA,IAAa;QAC9B,IAAIA,CAAA,EAAU;UACCT,EAAA;UACb;QACF;QACaC,EAAA;MAAA,CACd,GAEYr2B,CAAA;QACXkkC,IAAA,EAAAxO,EAAA;QACA5V,KAAA,EAAApQ,CAAA;QACAu0B,IAAA,EAAAxO,EAAA;QACA1V,MAAA,EAAApQ;MAAA,CACD,GAEDusB,EAAA,CAAQ9B,EAAA,EAAsB;QAC5BmK,UAAA,EAAYtkB,CAAA,CAAM,MAAM5e,CAAA,CAAMkjC,UAAU;QACxC39B,KAAA,EAAOqZ,CAAA,CAAM,MAAM5e,CAAA,CAAMgiC,QAAQ;QACjC18B,MAAA,EAAQsZ,CAAA,CAAM,MAAM5e,CAAA,CAAM+hC,SAAS;MAAA,CACpC,IAAAvM,CAAA,EAAAC,CAAA,MAAAc,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC/QD,MAAM73B,CAAA,GAAQ0C,CAAA;QA2CRzC,CAAA,GAAQ89B,EAAA;QAWR18B,CAAA,GAAa27B,EAAA,CAAO5C,EAAA,EAAsB,IAAI;QAE9C34B,CAAA,GAAUwe,CAAA,CAAM,MAAMjgB,CAAA,CAAMmxB,IAAA,IAAQnxB,CAAA,CAAMwkC,QAAA,IAAY,CAAC39B,EAAA,CAAY5G,CAAA,CAAMkxB,IAAI,CAAC;QAC9ExvB,CAAA,GAAase,CAAA,CAAM,MAAMjgB,CAAA,CAAMykC,OAAA,IAAWzkC,CAAA,CAAM0kC,WAAA,IAAe,CAAC79B,EAAA,CAAY5G,CAAA,CAAMwkC,OAAO,CAAC;QAC1F5iC,CAAA,GAAaoe,CAAA,CAAM,MAAMxe,CAAA,CAAQgZ,KAAA,IAAS9Y,CAAA,CAAW8Y,KAAA,IAAS,CAAC5T,EAAA,CAAY5G,CAAA,CAAMwgC,OAAO,CAAC;QAEzFx8B,CAAA,GAAgBsW,CAAA,CAAwB,OAAO;UACnDgqB,UAAA,EAAY,GACVvkC,CAAA,CAAMukC,UAAA,KAAcljC,CAAA,oBAAAA,CAAA,CAAYkjC,UAAA,CAAW9pB,KAAA,KAAS,oBACtD;QACA;QAEItO,CAAA,GAAyBoO,CAAA,CAAS,OAAO;UAC7C,UAAUva,CAAA,CAAM2kC,gBAAA,KAAqB;UACrC,CAAC,KAAK3kC,CAAA,CAAM2kC,gBAAgB,QAAQ,GAAG3kC,CAAA,CAAM2kC,gBAAA,KAAqB;QAClE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC1GIC,EAAA,GAAgBrL,EAAA,CAAmB,IAAI,IAAI;IAAC1Q,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;IAAG43B,OAAA,EAAS;EAAM;EAC5FoE,EAAA,GAAmBtL,EAAA,CAAmB,UAAU,CAAC,EAAE,GAAG;IAAC1Q,IAAA,EAAM,CAAC5lB,MAAA,EAAQ4F,MAAM;IAAG43B,OAAA,EAAS;EAAK;EAC7FqE,EAAA,GAAkBvL,EAAA,CAAmB,SAAS,CAAC,EAAE,GAAG;IAAC1Q,IAAA,EAAM,CAAC5lB,MAAA,EAAQ4F,MAAM;IAAG43B,OAAA,EAAS;EAAK;EAEjGsE,EAAA,GAAe1Q,CAAA,CAAgB;IAC7Bj0B,IAAA,EAAM;IACN4kC,KAAA,EAAOzkC,MAAA;IAGP0kC,KAAA,EAAO;MACL/oB,GAAA,EAAK;QAAC2M,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;MAAA;MACrEyE,IAAA,EAAM;QAACrc,IAAA,EAAM,CAAC5lB,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAI;MAAA;MAC5C,GAAGmE,EAAA;MACHpyB,MAAA,EAAQ;QAACqW,IAAA,EAAM,CAAC5lB,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAI;MAC9C,GAAGoE,EAAA;MACHM,KAAA,EAAO;QAACtc,IAAA,EAAM,CAAC5lB,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAI;MAC7C,GAAGqE,EAAA;MACHM,SAAA,EAAW;QAACvc,IAAA,EAAM5lB,MAAA;QAAgDw9B,OAAA,EAAS;MAAI;MAC/Ef,GAAA,EAAK;QAAC7W,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAK;IACpC;IACA4E,MAAM3iC,CAAA,EAAO;MACX,MAAM1C,CAAA,GAAa,CACjB;UAACu1B,OAAA,EAASqP,EAAA;UAAeU,UAAA,EAAY;UAAQC,WAAA,EAAa;QAAK,GAC/D;UAAChQ,OAAA,EAASsP,EAAA;UAAkBS,UAAA,EAAY;QAAQ,GAChD;UAAC/P,OAAA,EAASuP,EAAA;UAAiBQ,UAAA,EAAY;QAAO;QAG1CrlC,CAAA,GAAaosB,CAAA,CAAc,MAAM3pB,CAAA,CAAMwZ,GAAG;QAE1C7a,CAAA,GAAYkZ,CAAA,CAAS,MACzBva,CAAA,CAAWyhB,OAAA,CAAS9f,CAAA,IAAO+3B,EAAA,CAAWh3B,CAAA,EAAOf,CAAA,CAAG4zB,OAAA,EAAS5zB,CAAA,CAAG2jC,UAAA,EAAY3jC,CAAA,CAAG4jC,WAAW,CAAC;MAclF;QACLC,eAAA,EAZsBjrB,CAAA,CAAS,MAAM,CACrClZ,CAAA,CAAUoZ,KAAA,EACV;UACEyB,GAAA,EAAKjc,CAAA,CAAWwa,KAAA,IAAU,CAACpZ,CAAA,CAAUoZ,KAAA,CAAMzU,IAAA,CAAMrE,CAAA,IAAM,QAAQ6F,IAAA,CAAK7F,CAAC,CAAC,KAAK,CAACe,CAAA,CAAMwiC,IAAA;UAClF,CAAC,OAAOxiC,CAAA,CAAMwiC,IAAI,EAAE,GAAG,CAAC,CAACxiC,CAAA,CAAMwiC,IAAA;UAC/B,CAAC,UAAUxiC,CAAA,CAAM8P,MAAM,EAAE,GAAG,CAAC,CAAC9P,CAAA,CAAM8P,MAAA;UACpC,CAAC,SAAS9P,CAAA,CAAMyiC,KAAK,EAAE,GAAG,CAAC,CAACziC,CAAA,CAAMyiC,KAAA;UAClC,CAAC,cAAcziC,CAAA,CAAM0iC,SAAS,EAAE,GAAG,CAAC,CAAC1iC,CAAA,CAAM0iC;QAC7C,EACD;MAGC;IAEJ;EACF,CAAC;AA3D4B,SAAAK,GAAA/iC,CAAA,EAAE1C,CAAA,EAAeC,CAAA,EAAAoB,CAAA,EAAAI,CAAA,EAAAE,CAAA;;IAClCm7B,KAAA,EAAA4I,CAAA,CAAAhjC,CAAA,CAAA8iC,eAAA;EAAA;IAAA/E,OAAA,EAAAkF,CAAA,Q;;;;;;;;;;;;;;;;;;;;;;;MCUZ,MAAM3lC,CAAA,GAAQ0C,CAAA;QAeRzC,CAAA,GAAkB8gB,EAAA,CAAY,MAAM/gB,CAAA,CAAM4lC,OAAA,IAAWhW,GAAA,EAAK;UAAC5O,MAAA,EAAQ;QAAA,CAAW;QAC9E3f,CAAA,GAAkB0f,EAAA,CAAY,MAAM/gB,CAAA,CAAM6lC,OAAA,IAAWjW,GAAA,EAAK;UAAC5O,MAAA,EAAQ;QAAA,CAAW;QAC9Evf,CAAA,GAAgB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM8hC,KAAK;QAE/CngC,CAAA,GAAkB4Y,CAAA,CAAS,OAAO;UACtCkT,SAAA,EAAWhsB,CAAA,CAAcgZ,KAAA,KAAU;UAClC,mBAAoBhZ,CAAA,CAAcgZ,KAAA,KAAU;UAC7C,CAAC,aAAahZ,CAAA,CAAcgZ,KAAK,EAAE,GAAG,OAAOhZ,CAAA,CAAcgZ,KAAA,IAAU;UACrE,CAAC,MAAMxa,CAAA,CAAgBwa,KAAK,EAAE,GAAG,CAAC5R,MAAA,CAAOsY,KAAA,CAAMlhB,CAAA,CAAgBwa,KAAK;UACpE,CAAC,MAAMpZ,CAAA,CAAgBoZ,KAAK,EAAE,GAAG,CAAC5R,MAAA,CAAOsY,KAAA,CAAM9f,CAAA,CAAgBoZ,KAAK;QACpE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC0CF,MAAMpZ,CAAA,GAAQqB,CAAA;QAuCRjB,CAAA,GAAOxB,CAAA;QAqBP0B,CAAA,GAAastB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,UAAU;QAE7CztB,CAAA,GAAa4pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEZ,CAAA,GAAoBooB,CAAA,CAAcxqB,CAAU;QAC5CsK,CAAA,GAAgBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMykC,MAAM;QAChD15B,CAAA,GAAiBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM0kC,OAAO;QAClD15B,CAAA,GAAeggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMi7B,KAAK;QAC9ChwB,CAAA,GAAmB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM2kC,SAAS;QACtDz5B,CAAA,GAAgB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMwgC,MAAM;QAChDz3B,CAAA,GAAaiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMuJ,GAAG;QAC1CsC,CAAA,GAAemf,CAAA,CAAc,MAAMhrB,CAAA,CAAM0C,KAAK;QAC9CoJ,CAAA,GAAiBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAM4kC,OAAO;QAClD74B,CAAA,GAAgBif,CAAA,CAAc,MAAMhrB,CAAA,CAAMyzB,MAAM;QAChDxnB,CAAA,GAAiB+e,CAAA,CAAc,MAAMhrB,CAAA,CAAMuzB,OAAO;QAClDrnB,CAAA,GAAgB8e,CAAA,CAAc,MAAMhrB,CAAA,CAAMwzB,MAAM;QAChDrnB,CAAA,GAAc6e,CAAA,CAAc,MAAMhrB,CAAA,CAAMmuB,IAAI;QAC5C9hB,CAAA,GAAuB2e,CAAA,CAAc,MAAMhrB,CAAA,CAAM6kC,aAAa;QAE9Dt4B,CAAA,GAAiBqS,CAAA,CAAM,MAC3B,OAAO5e,CAAA,CAAMmR,MAAA,IAAW,YAAY,OAAOnR,CAAA,CAAMmR,MAAA,IAAW,WAAWnR,CAAA,CAAMmR,MAAA,GAASod,GAAA;QAElFxgB,CAAA,GAAiB2R,EAAA,CAAYnT,CAAc;QAE3CyB,CAAA,GAAWqL,CAAA,CAAwB,IAAI;QACvCpL,CAAA,GAASoL,CAAA,CAAwB,IAAI;QACrCnL,CAAA,GAAcmL,CAAA,CAAwB,IAAI;QAC1ClL,CAAA,GAAUkL,CAAA,CAAwB,IAAI;QAEtCjL,CAAA,GAAW8K,CAAA,CAA+B,MAC9ClZ,CAAA,CAAM6M,QAAA,KAAa,cAAc7M,CAAA,CAAM6M,QAAA,KAAa,aAAa,SAAY7M,CAAA,CAAM6M,QAAA;QAE/EwB,CAAA,GAAe6K,CAAA,CAAmC,MACtDlZ,CAAA,CAAM6M,QAAA,KAAa,cAAc7M,CAAA,CAAM6M,QAAA,KAAa,aAAa7M,CAAA,CAAM6M,QAAA,GAAW;QAG9EyB,CAAA,GAAqBsQ,CAAA,CAAM,MAAQ/S,CAAA,CAAauN,KAAA,GAA4BnL,CAAA,CAAOmL,KAAA,GAA3BlL,CAAA,CAAYkL,KAAqB;MAE/F4H,EAAA,CACE,UACA,MAAM;QACJxgB,CAAA,CAAW4Y,KAAA,GAAQ,CAACxW,CAAA;MACtB,GACA;QAAC9C,MAAA,EAAQwO;MAAkB,IAE7B0S,EAAA,CACE,UACA,MAAM;QACJxgB,CAAA,CAAW4Y,KAAA,GAAQ,CAACxW,CAAA;MACtB,GACA;QAAC9C,MAAA,EAAQkO;MAAQ;MAGb,MAAAO,CAAA,GAASu2B,CAACtP,CAAA,EAAUC,CAAA,KAAc;;QAElC,IADJD,CAAA,CAAE91B,cAAA,CAAe,GACb,CAACkD,CAAA,CAAkBwW,KAAA,EAAO;UACvB+b,CAAA,IACL/V,EAAA,CAAS,MAAM7Q,CAAA,CAAOinB,CAAA,EAAGC,CAAC,CAAC;UAC3B;QACF;QACA,MAAMC,CAAA,IAAOC,EAAA,GAAA3nB,CAAA,CAASoL,KAAA,KAAT,gBAAAuc,EAAA,CAAgB7vB,gBAAA,CAAiB;QAC9C,IAAK4vB,CAAA,EACL,KAAIG,EAAA,GAAA7nB,CAAA,CAASoL,KAAA,KAAT,QAAAyc,EAAA,CAAgBhV,QAAA,CAAS7d,QAAA,CAAS0B,aAAA,GAAgB;UACpD,MAAMuxB,EAAA,GAASjoB,CAAA,CAASoL,KAAA,CAAMzT,aAAA,CAAc,sBAAsB;YAC5DuwB,EAAA,GAAQ50B,KAAA,CAAME,SAAA,CAAUsG,OAAA,CAAQrG,IAAA,CAAKi0B,CAAA,EAAMO,EAAM,IAAIR,CAAA;UACvDS,EAAA,IAAS,KAAKA,EAAA,IAAQR,CAAA,oBAAAA,CAAA,CAAMz2B,MAAA,OAASi0B,EAAA,GAAAwC,CAAA,CAAKQ,EAAK,MAAV,QAAAhD,EAAA,CAA6BnuB,KAAA;QAAM,OAE1E,CAAAouB,EAAA,GAAAuC,CAAA,CAAKD,CAAA,KAAM,KAAKC,CAAA,CAAKz2B,MAAA,GAAS,IAAI,CAAC,MAAnC,QAAAk0B,EAAA,CAAsDpuB,KAAA;MAC1D;MAGUic,EAAA,YAAYwU,CAAA,IAAMjnB,CAAA,CAAOinB,CAAA,EAAG,EAAE,GAAG;QAAC11B,MAAA,EAAQwO;MAAmB,IAC7D0S,EAAA,cAAcwU,CAAA,IAAMjnB,CAAA,CAAOinB,CAAA,EAAG,CAAC,GAAG;QAAC11B,MAAA,EAAQwO;MAAA,CAAmB,GAC9D0S,EAAA,YAAYwU,CAAA,IAAMjnB,CAAA,CAAOinB,CAAA,EAAG,EAAE,GAAG;QAAC11B,MAAA,EAAQkO;MAAS,IACnDgT,EAAA,cAAcwU,CAAA,IAAMjnB,CAAA,CAAOinB,CAAA,EAAG,CAAC,GAAG;QAAC11B,MAAA,EAAQkO;MAAA,CAAS;MAEhE,MAAMQ,CAAA,GAAoB0K,CAAA,CAAS,MACjCwd,EAAA,CAAyB;UACvBttB,GAAA,EAAK0B,CAAA,CAAcsO,KAAA;UACnB9P,KAAA,EAAO2B,CAAA,CAAiBmO,KAAA;UACxB7P,GAAA,EAAKwB,CAAA,CAAeqO,KAAA;UACpBwd,WAAA,EAAa1rB,CAAA,CAAckO,KAAA;UAC3Byd,QAAA,EAAU9tB,CAAA,CAAWqQ;QAAA,CACtB;QAEG3K,EAAA,GAAa4K,CAAA,CAAmB,EAAE;QAClC1K,EAAA,GAAqBuK,CAAA,CAAuB,MAAM;UAClD,IAAAlZ,CAAA,CAAMs0B,kBAAA,KAAuB,QAC/B,OAAOt0B,CAAA,CAAMs0B,kBAAA;UAET,MAAAkB,CAAA,GACJ,OAAOx1B,CAAA,CAAMmR,MAAA,IAAW,YAAY,OAAOnR,CAAA,CAAMmR,MAAA,IAAW,WACxDpD,CAAA,CAAeqL,KAAA,GACfpZ,CAAA,CAAMmR,MAAA;YACNskB,CAAA,GAAoB,CAACvkB,EAAA,CAAiBskB,CAAW,CAAC;UACpD,OAAAzpB,CAAA,CAAcqN,KAAA,KAAU,MACtBqc,CAAA,CAAAzlB,IAAA,CACFP,EAAA,CAAK;YACH5C,QAAA,EAAUuB,CAAA,CAASgL,KAAA;YACnBtM,YAAA,EAAcuB,CAAA,CAAa+K,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B;UAAA,CAChB,IAGDxoB,CAAA,CAAemN,KAAA,KAAU,MACvBqc,CAAA,CAAAzlB,IAAA,CACFoB,EAAA,CAAM;YACJvE,QAAA,EAAUuB,CAAA,CAASgL,KAAA;YACnBtM,YAAA,EAAcuB,CAAA,CAAa+K,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B;UAAA,CAChB,IAGDvoB,CAAA,CAAckN,KAAA,KAAU,MACtBqc,CAAA,CAAAzlB,IAAA,CACFuB,EAAA,CAAe;YACb1E,QAAA,EAAUuB,CAAA,CAASgL,KAAA;YACnBtM,YAAA,EAAcuB,CAAA,CAAa+K,KAAA;YAC3BnM,OAAA,EAASjN,CAAA,CAAMy0B,eAAA;YACfhjB,MAAM;cAACC,cAAA,EAAAgkB,CAAA;cAAgB/jB,eAAA,EAAAgkB;YAAA,GAAkB;cACvClnB,EAAA,CAAW2K,KAAA,GAAQ;gBACjBwb,SAAA,EAAWe,EAAA,GAAkB,GAAGA,EAAe,OAAO;gBACtDd,QAAA,EAAUa,CAAA,GAAiB,GAAGA,CAAc,OAAO;cAAA;YAEvD;UAAA,CACD,IAGED,CAAA;QAAA,CACR;QACK;UAAC1b,MAAA,EAAA9J,EAAA;UAAQ6J,cAAA,EAAAsa;QAAA,IAAkBpb,EAAA,CAAY1K,CAAA,EAAoBN,CAAA,EAAU;UACzE3C,SAAA,EAAWmD,CAAA;UACXjD,UAAA,EAAYoD,EAAA;UACZrD,QAAA,EAAUsT,CAAA,CAAM,MAAM5e,CAAA,CAAMsL,QAAQ;UACpC2N,oBAAA,EAAsBrB;QAAA,CACvB;QAEKyc,EAAA,GAAkBnb,CAAA,CAAS,OAAO;UACtCurB,MAAA,EAAU35B,CAAA,CAAcsO,KAAA;UACxBsrB,OAAA,EAAW35B,CAAA,CAAeqO,KAAA;UAC1BurB,SAAA,EAAa15B,CAAA,CAAiBmO,KAAA;UAC9B,mBAAmBpZ,CAAA,CAAM6M,QAAA,KAAa,uBAAuB,CAAC7B,CAAA,CAAaoO;QAC3E;QAEI0b,EAAA,GAAgB5b,CAAA,CAAS,MAAM,CACnCrN,CAAA,CAAauN,KAAA,GAAQpZ,CAAA,CAAM+kC,UAAA,GAAa/kC,CAAA,CAAMglC,WAAA,EAC9C;UACE,YAAYh6B,CAAA,CAAaoO,KAAA;UACzB,mBAAmB,CAACvN,CAAA,CAAauN,KAAA;UACjC,4BAA4BtN,CAAA,CAAesN,KAAA,IAAS,CAACvN,CAAA,CAAauN,KAAA;UAClEoY,IAAA,EAAQ3lB,CAAA,CAAauN,KAAA,GAAQ,SAAYxW,CAAA,CAAkBwW;QAC7D,EACD;QAEK2b,EAAA,GAAgBkQ,CAAA,KAAM;UACnB7P,CAAA;QAAA;QAGHJ,EAAA,GAAgBQ,CAAA,IAAsB;UAC1C3pB,CAAA,CAAauN,KAAA,GAAQhZ,CAAA,CAAK,SAASo1B,CAAK,IAAIT,EAAA;QAAc;MAG5DzU,EAAA,CACEtS,CAAA,EACA,MAAM;QACApL,CAAA,CAAkBwW,KAAA,KAAUpZ,CAAA,CAAM+9B,SAAA,KAAc,MAAQ/9B,CAAA,CAAM+9B,SAAA,KAAc,cACvE3I,CAAA;MAEX,GACA;QAAC7U,MAAA,EAAQ,CAACtS,CAAA,EAAQC,CAAW;MAAC;MAEhC,MAAM+mB,EAAA,GAAgBiQ,CAAA,KAAM;UACtBtiC,CAAA,CAAkBwW,KAAA,KAAUpZ,CAAA,CAAM+9B,SAAA,KAAc,MAAQ/9B,CAAA,CAAM+9B,SAAA,KAAc,aACvE3I,CAAA;QACT;QAGIF,CAAA,GAAQoG,CAAA,KAAM;UAClB96B,CAAA,CAAW4Y,KAAA,IAASgc,CAAA;QAAO;QAEvBD,CAAA,GAAOhc,CAAA,KAAM;UACjB3Y,CAAA,CAAW4Y,KAAA,IAASgc,CAAA;QAAO;QAEvBA,CAAA,GAAS/E,CAAA,KAAM;;UACnBjwB,CAAA,CAAK,QAAQ;UACb,MAAMo1B,CAAA,GAAoB5yB,CAAA,CAAkBwW,KAAA;YACtCqc,CAAA,GAAI,IAAI11B,EAAA,CAAmBy1B,CAAA,GAAoB,SAAS,MAAM;UAEpE,IADoBp1B,CAAA,CAApBo1B,CAAA,GAAyB,SAAkB,QAAVC,CAAC,GAC9BA,CAAA,CAAEj2B,gBAAA,EAAkB;YACFY,CAAA,CAApBo1B,CAAA,GAAyB,mBAAyB,gBAAT;YACzC;UACF;UACAh1B,CAAA,CAAW4Y,KAAA,GAAQ,CAACoc,CAAA,EACAp1B,CAAA,CAApBo1B,CAAA,GAAyB,WAAiB,OAAT,IACjCE,CAAA,GAAAvnB,CAAA,CAAQiL,KAAA,KAAR,QAAAsc,CAAA,CAAe3R,aAAA,CAAc,IAAIqP,KAAA,CAAM,WAAW;QAAC;MAGrD,OAAA5Z,EAAA,CAAM5W,CAAA,EAAmB,MAAM;QACtBqN,EAAA;MAAA,CACR,GAEYtR,CAAA;QACX28B,KAAA,EAAApG,CAAA;QACA/b,IAAA,EAAAgc,CAAA;QACA9E,MAAA,EAAA+E;MAAA,CACD,GAEDyF,EAAA,CAAQrB,EAAA,EAAsB;QAC5BvL,EAAA,EAAI3tB,CAAA;QACJ6Y,IAAA,EAAAgc,CAAA;QACAmG,KAAA,EAAApG,CAAA;QACA7E,MAAA,EAAA+E,CAAA;QACA8F,OAAA,EAASt4B,CAAA;QACTq4B,KAAA,EAAOjwB;MAAA,CACR,IAAAwqB,CAAA,EAAAC,CAAA,MAAAc,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MChUD,MAAM73B,CAAA,GAAQ0C,CAAA;QA0BRzC,CAAA,GAAWggB,CAAA,CAAM,MAAOjgB,CAAA,CAAMsvB,EAAA,GAAK,GAAGtvB,CAAA,CAAMsvB,EAAE,qBAAqB,MAAU;QAC7EjuB,CAAA,GAAa4e,CAAA,CAAM,MAAOjgB,CAAA,CAAMwmC,SAAA,KAAc,WAAW,SAAY,SAAU;QAE/E/kC,CAAA,GAAkB8Y,CAAA,CAAS,MAAM,CACrCva,CAAA,CAAMymC,WAAA,EACN;UACE,CAAC,QAAQzmC,CAAA,CAAM0mC,aAAa,EAAE,GAAG1mC,CAAA,CAAM0mC,aAAA,KAAkB;QAC3D,EACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MClCD,MAAMzmC,CAAA,GAAQyC,CAAA;QAoCRrB,CAAA,GAAOrB,CAAA;QAIP;UAAC88B,KAAA,EAAOr7B,CAAA;UAAc,GAAGE;QAAA,IAASo7B,EAAA,CAAS;QAE3Cl7B,CAAA,GAAgBwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMm4B,MAAM;QAChDn0B,CAAA,GAAkBooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QAOpD;UAAC0jB,YAAA,EAAAzgB,CAAA;UAAc0gB,iBAAA,EAAAzgB;QAAiB,IAAIogB,EAAA,CAAevsB,CAAK;QAExDoM,CAAA,GAAkBkO,CAAA,CAAS,MAAM,CACrCta,CAAA,CAAM0mC,SAAA,EACN;UACEvO,MAAA,EAAQv2B,CAAA,CAAc4Y,KAAA;UACtBvR,QAAA,EAAUjF,CAAA,CAAgBwW,KAAA;UAC1B,CAAC,QAAQxa,CAAA,CAAMotB,OAAO,EAAE,GAAGptB,CAAA,CAAMotB,OAAA,KAAY;QAC/C,EACD;QAEK/gB,CAAA,GAAc2T,CAAA,CAAM,MAAO9T,CAAA,CAAasO,KAAA,GAAQwjB,EAAA,GAAQh+B,CAAA,CAAMk6B,IAAA,GAAO,MAAM,QAAS;QAEpF5tB,CAAA,GAAeywB,EAAA,CAAOpC,EAAA,EAAsB,IAAI;QAChDxwB,CAAA,GAAe4yB,EAAA,CAAOnC,EAAA,EAAsB,IAAI;QAChD3tB,CAAA,GAAa8vB,EAAA,CAAOlC,EAAA,EAAoB,IAAI;QAG5C3tB,CAAA,GAAWC,CAAA,IAAwB;;UACvC/L,CAAA,CAAK,SAAS+L,CAAC,GACXF,CAAA,KAAe,UAAQI,CAAA,GAAAJ,CAAA,oBAAAA,CAAA,CAAYkyB,SAAA,KAAZ,gBAAA9xB,CAAA,CAAuBmN,KAAA,MAAU,QAC1DlN,CAAA,GAAAhB,CAAA,oBAAAA,CAAA,CAAcowB,KAAA,KAAd,QAAApvB,CAAA,CAAAzK,IAAA,CAAAyJ,CAAA,KAEFiB,CAAA,GAAApD,CAAA,oBAAAA,CAAA,CAAcuyB,KAAA,KAAd,QAAAnvB,CAAA,CAAA1K,IAAA,CAAAsH,CAAA;QAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MClFxB,MAAMnK,CAAA,GAAQyC,CAAA;QAiBRrB,CAAA,GAAOrB,CAAA;QAIPyB,CAAA,GAAgB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMm4B,MAAM;QAChDz2B,CAAA,GAAkB0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QAOpDrH,CAAA,GAAkB0Y,CAAA,CAAS,MAAM,CACrCta,CAAA,CAAM2mC,WAAA,EACN;UACE,CAAC3mC,CAAA,CAAM4mC,WAAW,GAAGplC,CAAA,CAAcgZ,KAAA;UACnCvR,QAAA,EAAUvH,CAAA,CAAgB8Y,KAAA;UAC1B,CAAC,QAAQxa,CAAA,CAAMotB,OAAO,EAAE,GAAGptB,CAAA,CAAMotB,OAAA,KAAY;QAC/C,EACD;QAEKppB,CAAA,GAAWkI,CAAA,IAAkB;UACjC9K,CAAA,CAAK,SAAS8K,CAAC;QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC9CjB,MAAM9K,CAAA,GAAQqB,CAAA;QAORjB,CAAA,GAAOxB,CAAA;QAIP0B,CAAA,GAAU+Y,CAAA,CAA4B,IAAI;QAE1C7Y,CAAA,GAAkBwqB,CAAA,CAAc,MAAMhrB,CAAA,CAAMmK,QAAQ;QACpDvH,CAAA,GAAoBooB,CAAA,CAAc,MAAMhrB,CAAA,CAAMylC,UAAU;QACxD36B,CAAA,GAAmBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMytB,SAAS;QAOtD1iB,CAAA,GAAkBmO,CAAA,CAAS,OAAO;UACtC,iBAAiB1Y,CAAA,CAAgB4Y,KAAA;UACjC,iBAAiBtO,CAAA,CAAiBsO;QAClC;QAEIpO,CAAA,GAAaC,CAAA,IAAa;UAC9B7K,CAAA,CAAK,UAAU6K,CAAC;QAAA;MAGL,OAAAtM,CAAA;QACXwO,OAAA,EAAA7M;MAAA,CACD,IAAA2K,CAAA,EAAAC,CAAA,MAAAqrB,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC9BD,MAAM73B,CAAA,GAAQ0C,CAAA;QAgBRzC,CAAA,GAAmBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM+mC,SAAS;QACtD1lC,CAAA,GAAegrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMmnB,KAAK;QAC9C1lB,CAAA,GAAiB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo1B,OAAO;QAElDzzB,CAAA,GAAese,CAAA,CAAM,MAAMhgB,CAAA,CAAiBwa,KAAA,KAAU,MAAQpZ,CAAA,CAAaoZ,KAAA,KAAU,EAAK;QAE1F5Y,CAAA,GAAkB0Y,CAAA,CAAS,OAAO;UACtC,WAAW5Y,CAAA,CAAa8Y,KAAA;UACxB,oBAAoB,CAAChZ,CAAA,CAAegZ,KAAA;UACpC,mBAAmBhZ,CAAA,CAAegZ;QAClC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCjCF,MAAMza,CAAA,GAAQ0C,CAAA;QAsBRzC,CAAA,GAAgBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkS,MAAM;QAEhD7Q,CAAA,GAAkBkZ,CAAA,CAAS,OAAO;UACtC,CAAC,QAAQva,CAAA,CAAMstB,WAAW,EAAE,GAAGttB,CAAA,CAAMstB,WAAA,KAAgB;UACrD,aAAa,CAACrtB,CAAA,CAAcwa;QAC5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpBF,MAAMza,CAAA,GAAQ0C,CAAA;QAgBRzC,CAAA,GAAmBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM+mC,SAAS;QACtD1lC,CAAA,GAAegrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMmnB,KAAK;QAC9C1lB,CAAA,GAAiB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo1B,OAAO;QAElDzzB,CAAA,GAAese,CAAA,CAAM,MAAMhgB,CAAA,CAAiBwa,KAAA,KAAU,MAAQpZ,CAAA,CAAaoZ,KAAA,KAAU,EAAI;QAEzF5Y,CAAA,GAAkB0Y,CAAA,CAAS,OAAO;UACtC,WAAW5Y,CAAA,CAAa8Y,KAAA;UACxB,kBAAkB,CAAChZ,CAAA,CAAegZ,KAAA;UAClC,iBAAiBhZ,CAAA,CAAegZ;QAChC;;;;;;;;;;;;;ECpCFusB,EAAA,GAAe3S,CAAA,CAAgB;IAC7Bj0B,IAAA,EAAM;IACN4kC,KAAA,EAAOzkC,MAAA;IAGP0kC,KAAA,EAAO;MACLvF,GAAA,EAAK;QACH7W,IAAA,EAAM5lB,MAAA;QACNw9B,OAAA,EAAS;MACX;MACA7+B,EAAA,EAAI;QACFinB,IAAA,EAAM,CAAC5lB,MAAA,EAAQ1C,MAAM;QACrBkgC,OAAA,EAAS;MACX;MACAwG,IAAA,EAAM;QACJpe,IAAA,EAAM9b,OAAA;QACN0zB,OAAA,EAAS;MACX;IACF;IACA4E,MAAM3iC,CAAA,EAAO;MAACsiC,KAAA,EAAAhlC,CAAA;MAAOknC,KAAA,EAAAjnC;IAAA,GAAQ;MAC3B,OAAO,MACL;;QAAA,OAAAyC,CAAA,CAAMukC,IAAA,IACF5lC,CAAA,GAAArB,CAAA,CAAMygC,OAAA,KAAN,gBAAAp/B,CAAA,CAAAyB,IAAA,CAAA9C,CAAA,IACA0C,CAAA,CAAMg9B,GAAA,KAAQ,aACdzG,EAAA,CAAEkO,EAAA,EAAU;UAACvlC,EAAA,EAAIc,CAAA,CAAMd;QAAA,GAAK,EAACH,CAAA,GAAAzB,CAAA,CAAMygC,OAAA,KAAN,gBAAAh/B,CAAA,CAAAqB,IAAA,CAAA9C,CAAA,CAAiB,CAAC,IAC/Ci5B,EAAA,CAAEv2B,CAAA,CAAMg9B,GAAA,EAAK;UAAC,GAAGz/B;QAAA,GAAQ,EAAC0B,CAAA,GAAA3B,CAAA,CAAMygC,OAAA,KAAN,gBAAA9+B,CAAA,CAAAmB,IAAA,CAAA9C,CAAA,CAAiB,CAAC;MAAA;IACpD;EACF,CAAC;EAAAonC,EAAA;EAAAC,EAAA;EAAAC,EAAA,kBAAAjT,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCID,MAAMhzB,CAAA,GAAQqB,CAAA;QA+CRjB,CAAA,GAAOxB,CAAA;QAMP0B,CAAA,GAAQo8B,EAAA;QAKRl8B,CAAA,GAAa4pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEZ,CAAA,GAAagrB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,YAAY;QAE/CnjB,CAAA,GAAuBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkmC,aAAa;QAC9Dn7B,CAAA,GAAmBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkuB,SAAS;QACtDljB,CAAA,GAAeggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM8sB,KAAK;QAC9C7hB,CAAA,GAAgB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM+sB,MAAM;QAChD7hB,CAAA,GAAqB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMmmC,WAAW;QAC1Dp9B,CAAA,GAAgBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMgtB,MAAM;QAChDnhB,CAAA,GAAkBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDiE,CAAA,GAAgBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAM6Q,MAAM;QAChD9E,CAAA,GAAkBif,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDthB,CAAA,GAAe+e,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAE9C5Z,CAAA,GAAayvB,EAAA,CAAOtC,EAAA,EAAkB,IAAI;QAE1CltB,CAAA,GAAQkN,CAAA,CAAwB,IAAI;QAEpC;UAACgN,OAAA,EAAAha;QAAA,IAAW6Z,EAAA,CAAS/Z,CAAA,EAAO;UAChCqY,YAAA,EAAczZ,CAAA,CAAiBqO;QAAA,CAChC;QAEK7M,CAAA,GAAiBqS,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYlF,CAAA,CAAM8+B,OAAO,CAAC;QAExDrxB,CAAA,GAAamL,CAAA,CAAS;UAC1B3C,GAAA,EAAKA,CAAA,MAAMrK,CAAA,oBAAAA,CAAA,CAAY+mB,UAAA,CAAW7Z,KAAA,KAAS5Y,CAAA,CAAW4Y,KAAA;UACtD5C,GAAA,EAAMlI,CAAA,IAAW;YACf,IAAIA,CAAA,KAAW,QACf;cAAA,IAAIpC,CAAA,KAAe,QAAQ5K,KAAA,CAAMC,OAAA,CAAQ+M,CAAM,GAAG;gBAIhDpC,CAAA,CAAW+mB,UAAA,CAAW7Z,KAAA,GAAQ9K,CAAA;gBAC9B;cACF;cACA9N,CAAA,CAAW4Y,KAAA,GAAQ9K,CAAA;YAAA;UACrB;QAAA,CACD;QAEKN,CAAA,GAAmB4Q,CAAA,CACvB,MACE,CAAC,EAAE5e,CAAA,CAAMjB,IAAA,KAAQmN,CAAA,oBAAAA,CAAA,CAAYnN,IAAA,CAAKqa,KAAA,OACjCrN,CAAA,CAAgBqN,KAAA,KAASlN,CAAA,oBAAAA,CAAA,CAAYqhB,QAAA,CAASnU,KAAA;QAG7CnL,CAAA,GAAgB2Q,CAAA,CAAM,MAAM1T,CAAA,CAAmBkO,KAAA,MAAUlN,CAAA,oBAAAA,CAAA,CAAYwhB,OAAA,CAAQtU,KAAA,KAAS,GAAM;QAE5FlL,CAAA,GAAgBgL,CAAA,CAAS,OAAO;UACpC4T,KAAA,EAAO9hB,CAAA,CAAaoO,KAAA,MAAUlN,CAAA,oBAAAA,CAAA,CAAY4gB,KAAA,CAAM1T,KAAA,KAAS;UACzD2T,MAAA,EAAQ9hB,CAAA,CAAcmO,KAAA,MAAUlN,CAAA,oBAAAA,CAAA,CAAYwhB,OAAA,CAAQtU,KAAA,KAAS;UAC7DvI,MAAA,EAAQ/E,CAAA,CAAcsN,KAAA,MAAUlN,CAAA,oBAAAA,CAAA,CAAY2E,MAAA,CAAOuI,KAAA,KAAS;UAC5D4T,MAAA,EAAQjkB,CAAA,CAAcqQ,KAAA,MAAUlN,CAAA,oBAAAA,CAAA,CAAY8gB,MAAA,CAAO5T,KAAA,KAAS;UAC5D0M,KAAA,EAAO7Z,CAAA,CAAamN,KAAA,KAASlN,CAAA,oBAAAA,CAAA,CAAY4Z,KAAA,CAAM1M,KAAA;UAC/C5H,IAAA,EAAMxR,CAAA,CAAMwR,IAAA,KAAQtF,CAAA,oBAAAA,CAAA,CAAYsF,IAAA,CAAK4H,KAAA,KAAS;UAAA;UAC9CgU,aAAA,EAAeptB,CAAA,CAAMotB,aAAA,KAAiBlhB,CAAA,oBAAAA,CAAA,CAAYkhB,aAAA,CAAchU,KAAA,KAAS;UAAA;QACzE;QACIjL,CAAA,GAAkB0e,EAAA,CAAW3e,CAAa;QAC1CE,CAAA,GAAe6e,EAAA,CAAgB/e,CAAa;QAC5CG,CAAA,GAAe6e,EAAA,CAAgBhf,CAAa;MAErC,OAAAvP,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACV/Z,CAAA,CAAQ+M,KAAA,GAAQ;QAClB;QACAjM,OAAA,EAAShB,CAAA;QACTpH,KAAA,EAAOA,CAAA,KAAM;UACXsH,CAAA,CAAQ+M,KAAA,GAAQ;QAClB;MAAA,CACD,IAAA9K,CAAA,EAAAC,CAAA,MAAAgoB,CAAA,IAAAztB,CAAA,CAAA68B,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC5ID,MAAM3lC,CAAA,GAAQqB,CAAA;QAiDRjB,CAAA,GAAOxB,CAAA;QAaP0B,CAAA,GAAa8pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAEhDI,CAAA,GAAaotB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,UAAU;QAC7CrrB,CAAA,GAAegrB,EAAA,CAAM,MAAM5tB,CAAA,CAAMjB,IAAA,EAAM,UAAU;QACjD+L,CAAA,GAAmBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkuB,SAAS;QACtDnjB,CAAA,GAAiBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM0tB,OAAO;QAClD1iB,CAAA,GAAkBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDoD,CAAA,GAAe+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM8sB,KAAK;QAC9C5hB,CAAA,GAAkB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDxkB,CAAA,GAAiBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAM2tB,OAAO;QAClD9hB,CAAA,GAAemf,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAC9Cha,CAAA,GAAkBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAMomC,QAAQ;QACpDr6B,CAAA,GAAmBif,CAAA,CAAc,MAAMhrB,CAAA,CAAMytB,SAAS;QAEtDxhB,CAAA,GAAUoN,CAAA,CAAwB,IAAI;QAEtC;UAACgN,OAAA,EAAAna;QAAA,IAAWga,EAAA,CAASja,CAAA,EAAS;UAClCuY,YAAA,EAAc1Z,CAAA,CAAiBsO;QAAA,CAChC;MAEDyhB,EAAA,CAAQxB,EAAA,EAAkB;QACxBpG,UAAA,EAAA3yB,CAAA;QACA0sB,MAAA,EAAQlhB,CAAA;QACRshB,aAAA,EAAexO,CAAA,CAAM,MAAM5e,CAAA,CAAMotB,aAAa;QAC9CiZ,IAAA,EAAMznB,CAAA,CAAM,MAAM5e,CAAA,CAAMqmC,IAAI;QAC5BtnC,IAAA,EAAM6D,CAAA;QACNkjB,KAAA,EAAOja,CAAA;QACPihB,KAAA,EAAO7hB,CAAA;QACPuG,IAAA,EAAMoN,CAAA,CAAM,MAAM5e,CAAA,CAAMwR,IAAI;QAC5BX,MAAA,EAAQ+N,CAAA,CAAM,MAAM,CAAC7V,CAAA,CAAeqQ,KAAK;QACzCmU,QAAA,EAAUriB,CAAA;QACVwiB,OAAA,EAAS3iB,CAAA;QACTlD,QAAA,EAAUmD;MAAA,CACX,GAEKwO,EAAA,CAAAlZ,CAAA,EAAa0N,CAAA,IAAa;QAC9B5N,CAAA,CAAK,SAAS4N,CAAQ,GACtBoR,EAAA,CAAS,MAAM;UACbhf,CAAA,CAAK,UAAU4N,CAAQ;QAAA,CACxB;MAAA,CACF;MAED,MAAM7B,CAAA,GAAmB+M,CAAA,CAAS,MAChClZ,CAAA,CAAM6N,OAAA,CAAQpD,GAAA,CAAI,CAACuD,CAAA,EAAIC,CAAA,KACrB,OAAOD,CAAA,IAAO,YAAY,OAAOA,CAAA,IAAO,WACpC;UACE41B,KAAA,EAAO;YACLxqB,KAAA,EAAOpL,CAAA;YACPnG,QAAA,EAAUmD,CAAA,CAAgBoO;UAC5B;UACA0W,IAAA,EAAM9hB,CAAA,CAAG5M,QAAA,CAAS;UAClB2uB,IAAA,EAAM;UACNhO,IAAA,EAAM4Q,MAAA,CAAO,0BAA0B1kB,CAAG,EAAE;QAAA,IAE9C;UACE21B,KAAA,EAAO;YACLxqB,KAAA,EAAOpL,CAAA,CAAGhO,CAAA,CAAMsvB,UAAU;YAC1BznB,QAAA,EAAUmG,CAAA,CAAGhO,CAAA,CAAMyvB,aAAa;YAChC,IAAIzhB,CAAA,CAAG41B,KAAA,GAAQ51B,CAAA,CAAG41B,KAAA,GAAQ,CAAC;UAC7B;UACA9T,IAAA,EAAM9hB,CAAA,CAAGhO,CAAA,CAAMuvB,SAAS;UACxBQ,IAAA,EAAM/hB,CAAA,CAAGhO,CAAA,CAAMwvB,SAAS;UACxBzN,IAAA,EAAM4Q,MAAA,CAAO,0BAA0B1kB,CAAG,EAAE;QAC9C,CACN;QAGI5B,CAAA,GAAgB6M,CAAA,CAAS,OAAO;UACpCqU,QAAA,EAAUriB,CAAA,CAAgBkO,KAAA;UAC1BkU,WAAA,EAAattB,CAAA,CAAMstB,WAAA;UACnBxH,KAAA,EAAOja,CAAA,CAAauN,KAAA;UACpBqU,SAAA,EAAW1hB,CAAA,CAAiBqN,KAAA;UAC5BsU,OAAA,EAAS3iB,CAAA,CAAeqO,KAAA;UACxBuU,OAAA,EAAS5kB,CAAA,CAAeqQ,KAAA;UACxB5H,IAAA,EAAMxR,CAAA,CAAMwR;QACZ;QACIjF,CAAA,GAAgB8gB,EAAA,CAAahhB,CAAa;QAC1C0B,CAAA,GAAkByf,EAAA,CAAgBnhB,CAAa;MAExC,OAAA1N,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACVla,CAAA,CAAQkN,KAAA,GAAQ;QAClB;QACArU,KAAA,EAAOA,CAAA,KAAM;UACXmH,CAAA,CAAQkN,KAAA,GAAQ;QAClB;MAAA,CACD,IAAApL,CAAA,EAAAC,CAAA,MAAAsoB,CAAA,IAAAC,CAAA,QAAAoF,CAAA,CAAAhjB,CAAA,CAAArM,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCzID,MAAMvM,CAAA,GAAQ08B,EAAA;QAKRt8B,CAAA,GAAQiB,CAAA;QA0CRf,CAAA,GAAO1B,CAAA;QAKP4B,CAAA,GAAa4pB,EAAA,CAAUhqB,CAAA,EAAO,cAAcE,CAAI;QAChDsC,CAAA,GAAagrB,EAAA,CAAM,MAAMxtB,CAAA,CAAM6tB,EAAE;QAEjCnjB,CAAA,GAAmBkgB,CAAA,CAAc,MAAM5qB,CAAA,CAAM8tB,SAAS;QACtDnjB,CAAA,GAAmBigB,CAAA,CAAc,MAAM5qB,CAAA,CAAMkmC,SAAS;QACtDt7B,CAAA,GAAkBggB,CAAA,CAAc,MAAM5qB,CAAA,CAAMyH,QAAQ;QACpDoD,CAAA,GAAkB+f,CAAA,CAAc,MAAM5qB,CAAA,CAAMmmC,QAAQ;QACpDr7B,CAAA,GAAgB8f,CAAA,CAAc,MAAM5qB,CAAA,CAAMomC,MAAM;MAG5Bxb,CAAA,CAAc,MAAM5qB,CAAA,CAAMqmC,UAAU;MAC9D,MAAM19B,CAAA,GAAkBiiB,CAAA,CAAc,MAAM5qB,CAAA,CAAMmtB,QAAQ;QACpD1hB,CAAA,GAAemf,CAAA,CAAc,MAAM5qB,CAAA,CAAM0lB,KAAK;QAC9Cha,CAAA,GAAkBkf,CAAA,CAAc,MAAM5qB,CAAA,CAAMogB,OAAO;QAEnDzU,CAAA,GAAa6gB,EAAA,CAAc/gB,CAAY;QAEvCI,CAAA,GAAQoN,CAAA,CAA6B,IAAI;QAEzC;UAACgN,OAAA,EAAAna;QAAW,IAAAga,EAAA,CAASja,CAAA,EAAO;UAACuY,YAAA,EAAc1Z,CAAA,CAAiBsO;QAAA,CAAM;QAElEjN,CAAA,GAAeyS,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYxF,CAAA,CAAM2vB,KAAQ,CAAC;QACvDtjB,CAAA,GAAiBuS,CAAA,CAAM,MAC3B,OAAOxe,CAAA,CAAMsmC,MAAA,IAAW,WAAWtmC,CAAA,CAAMsmC,MAAA,GAAStmC,CAAA,CAAMsmC,MAAA,CAAO/+B,IAAA,CAAK,GAAG;QAGnE4E,CAAA,GAAkB2M,CAAA,CAAS,MAAM,CACrCnN,CAAA,CAAWqN,KAAA,EACX;UACE,CAAC,gBAAgBhZ,CAAA,CAAMoR,IAAI,EAAE,GAAGpR,CAAA,CAAMoR,IAAA,KAAS;QACjD,EACD;QAEKzD,CAAA,GAAYG,CAAA,IAAa;;UAC7B,MAAMC,CAAA,KACJC,CAAA,GAAAnC,CAAA,CAAMmN,KAAA,KAAN,gBAAAhL,CAAA,CAAau4B,KAAA,MAAU,UAAQt4B,CAAA,GAAApC,CAAA,CAAMmN,KAAA,KAAN,gBAAA/K,CAAA,CAAas4B,KAAA,MAAU,SAAY,OAAO,CAAC,GAAG16B,CAAA,CAAMmN,KAAA,CAAMutB,KAAK;UACrFnmC,CAAA,CAAA4Y,KAAA,GAAQjL,CAAA,KAAU,OAAO,OAAOlD,CAAA,CAAgBmO,KAAA,KAAU,KAAOjL,CAAA,GAAQA,CAAA,CAAM,CAAC,GAC3F7N,CAAA,CAAK,UAAU4N,CAAC;QAAA;QAGZF,CAAA,GAAUE,CAAA,IAAa;UACvBhD,CAAA,CAAckO,KAAA,KAAU,MAC1BlL,CAAA,CAAExO,cAAA,CAAe;QACnB;QAMIuO,CAAA,GAAQ3B,CAAA,KAAM;UAClB9L,CAAA,CAAW4Y,KAAA,GAAQ;QAAA;MAGf,OAAAI,EAAA,CAAAhZ,CAAA,EAAa0N,CAAA,IAAa;QAC1BA,CAAA,KAAa,QAAQjC,CAAA,CAAMmN,KAAA,KAAU,SACvCnN,CAAA,CAAMmN,KAAA,CAAMA,KAAA,GAAQ;MACtB,CACD,GAEYza,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACVla,CAAA,CAAQkN,KAAA,GAAQ;QAClB;QACAjM,OAAA,EAASlB,CAAA;QACTlH,KAAA,EAAOA,CAAA,KAAM;UACXmH,CAAA,CAAQkN,KAAA,GAAQ;QAClB;QACA9M,KAAA,EAAA2B;MAAA,CACD,IAAAC,CAAA,EAAAC,CAAA,MAAAooB,CAAA,IAAAC,CAAA,CAAAC,EAAA,S;;;;;;;;;;;;;;;;;;;;;;;;;;ECrIKmQ,EAAA,GAAS,CAAC,SAAS,UAAU,UAAU;EAEvCC,EAAA,GAAiBD,EAAA,CAAOn8B,GAAA,CAAKpJ,CAAA,IAAM,GAAGA,CAAC,kBAAkB,EAAEsG,IAAA;EAG3Dm/B,EAAA,GAA8B,CAAC,GAAGF,EAAA,EAAQ,KAAK,UAAU,OAAO;EAEzDG,EAAA,GAAkB;EAClBC,EAAA,GAA6B;EAC7BC,EAAA,GAA2B;EAC3BC,EAAA,GAAwB;EACxBC,EAAA,GAAoB;EAEjCC,EAAA,GAAepU,CAAA,CAAgB;IAC7BqU,UAAA,EAAY;MAACC,IAAA,EAAAC,EAAA;MAAMC,oBAAA,EAAAC,EAAA;MAAsBC,QAAA,EAAAC,EAAA;MAAUC,SAAA,EAAAC,EAAA;MAAWC,kBAAA,EAAAC;IAAkB;IAChFnE,KAAA,EAAO;MACLtW,WAAA,EAAa;QAAC9F,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA4Bw9B,OAAA,EAAS;MAAS;MAClF4I,WAAA,EAAa;QAACxgB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACjE6I,aAAA,EAAe;QAACzgB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACnE8I,aAAA,EAAe;QAAC1gB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACnE+I,aAAA,EAAe;QAAC3gB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACnEgJ,aAAA,EAAe;QAAC5gB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACnEiJ,WAAA,EAAa;QAAC7gB,IAAA,EAAM,CAAC5lB,MAAM;QAAGw9B,OAAA,EAAS;MAAS;MAChDv3B,QAAA,EAAU;QAAC2f,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;MAC1EkJ,gBAAA,EAAkB;QAAC9gB,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAW;MACrDnR,EAAA,EAAI;QAACzG,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAS;MACrCmJ,eAAA,EAAiB;QAAC/gB,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAS;MAClDzP,KAAA,EAAO;QAACnI,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAS;MACxCoJ,UAAA,EAAY;QAAChhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MAChEqJ,YAAA,EAAc;QAACjhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MAClEsJ,YAAA,EAAc;QAAClhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MAClEuJ,YAAA,EAAc;QAACnhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MAClEwJ,YAAA,EAAc;QAACphB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MAClEyJ,UAAA,EAAY;QAACrhB,IAAA,EAAM,CAAClmB,KAAA,EAAOpC,MAAA,EAAQ0C,MAAM;QAAGw9B,OAAA,EAAS;MAAS;MAC9D0J,SAAA,EAAW;QAACthB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MAC/D2J,WAAA,EAAa;QAACvhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACjE4J,WAAA,EAAa;QAACxhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACjE6J,WAAA,EAAa;QAACzhB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACjE8J,WAAA,EAAa;QAAC1hB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAA,EAAQ4F,MAAM;QAAG43B,OAAA,EAAS;MAAS;MACjE+J,QAAA,EAAU;QAAC3hB,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAS;MAC3CgK,SAAA,EAAW;QAAC5hB,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAS;MAC5CiK,WAAA,EAAa;QAAC7hB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;MAC7EtZ,KAAA,EAAO;QAAC0B,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAAkCw9B,OAAA,EAAS;MAAI;MAC7ErL,OAAA,EAAS;QAACvM,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;MACzEkK,aAAA,EAAe;QAAC9hB,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAS;MAChD3R,SAAA,EAAW;QAACjG,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;MAC3Ej1B,QAAA,EAAU;QAACqd,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;IAC5E;IACA4E,MAAM3iC,CAAA,EAAO;MACX,MAAM1C,CAAA,GAAkBqsB,CAAA,CAAc,MAAM3pB,CAAA,CAAMwG,QAAQ;QACpDjJ,CAAA,GAAqBosB,CAAA,CAAc,MAAM3pB,CAAA,CAAMgoC,WAAW;QAC1DrpC,CAAA,GAAegrB,CAAA,CAAc,MAAM3pB,CAAA,CAAMykB,KAAK;QAC9C1lB,CAAA,GAAiB4qB,CAAA,CAAc,MAAM3pB,CAAA,CAAM0yB,OAAO;QAClDzzB,CAAA,GAAmB0qB,CAAA,CAAc,MAAM3pB,CAAA,CAAMosB,SAAS;QACtDjtB,CAAA,GAAkBwqB,CAAA,CAAc,MAAM3pB,CAAA,CAAM8I,QAAQ;QAEpDvH,CAAA,GAAiC;QACjCkI,CAAA,GAAc,CAAC,MAAM,MAAM,MAAM,MAAM,IAAI;QAG3CC,CAAA,GAAkBw+B,CAACl9B,CAAA,EAAYE,CAAA,KACnCzB,CAAA,CAAYnI,MAAA,CAAO,CAACoL,CAAA,EAAkBC,CAAA,KAAe;UAC7C,MAAAC,CAAA,GAASusB,EAAA,CAAexsB,CAAA,KAAe,OAAO,KAAKA,CAAA,EAAY,GAAGzB,CAAM,OAAO;YAC/E2B,CAAA,GAAoB7B,CAAA,CAAM4B,CAAM,KAAK;UAC3C,OAAIC,CAAA,KACFF,CAAA,KAAe,OACXD,CAAA,CAAOiC,IAAA,CAAK,QAAQ9B,CAAS,EAAE,IAC/BH,CAAA,CAAOiC,IAAA,CAAK,QAAQhC,CAAU,IAAIE,CAAS,EAAE,IAG5CH,CAAA;QACT,GAAG,EAAE;QAGD/C,CAAA,GAAcw+B,CAACn9B,CAAA,EAAYE,CAAA;QAAA;QAE/BzB,CAAA,CAAYnI,MAAA,CAAO,CAACoL,CAAA,EAAaC,CAAA,KAAuB;UAChD,MAAAC,CAAA,GAASusB,EAAA,CAAexsB,CAAA,KAAe,OAAO,KAAKA,CAAA,EAAY,GAAGzB,CAAM,MAAM;UAChF,IAAA2B,CAAA,GAAY7B,CAAA,CAAM4B,CAAM;UAGhB,OAAAC,CAAA,GAAAA,CAAA,KAAc,KAAK,KAAOA,CAAA,IAAa,IAE7C,OAAOA,CAAA,IAAc,aAAcA,CAAA,KAAc,WAEzCA,CAAA,GAAA0rB,EAAA,CAAgB1rB,CAAA,EAAW,CAAC,GAE5BA,CAAA,GAAAA,CAAA,GAAY,IAAIA,CAAA,GAAY,KAMtCA,CAAA,KAGEF,CAAA,KAAe,OACjBD,CAAA,CAAO,OAAOG,CAAA,IAAc,YAAY,QAAQ,MAAM,IAAIA,CAAA,GAE1DH,CAAA,CAAOC,CAAA,KAAe,OAAOE,CAAA,IAAc,YAAY,QAAQ,OAAO,IAAIA,CAAA,GAGvEH,CAAA;QACT,GAAG,EAAE;QAED9C,CAAA,GAAUoO,CAAA,CAAwB,IAAI;QAKtCnO,CAAA,GAAwBu+B,CAACp9B,CAAA,EAAyBE,CAAA,GAA0B,SAAS;UACzF,IAAIzI,EAAA,IAAczC,CAAA,CAAM8nC,QAAA,IAAYl+B,CAAA,CAAQmO,KAAA,KAAU,MAAM;YAEpD,MAAArL,CAAA,GAAStI,EAAA,CAAO,IAAIjD,EAAA,CAAUnB,CAAA,CAAM8nC,QAAQ,CAAC,IAAIl+B,CAAA,CAAQmO,KAAK;YACpE,IAAIrL,CAAA,EAAQ;cACV,MAAMC,CAAA,GAAO;gBACPC,CAAA,IAAU5B,CAAA,IAAY,IAAI3J,KAAA,CAAM7B,EAAc;gBAC9CqN,CAAA,IAAU3B,CAAA,IAAY,IAAI7J,KAAA,CAAM7B,EAAc;gBAI9CsN,CAAA,IAAOpI,EAAA,CAAQgI,CAAA,EAAQC,CAAI,KAAK,IACnCtL,KAAA,CAAM7B,EAAc,EACpB4K,MAAA,CAAQ2C,CAAA,IAAO,CAACF,CAAA,CAAOnE,QAAA,CAASqE,CAAE,CAAC,EACnCjG,MAAA,CAAO8F,CAAM,EACbxC,MAAA,CAAO,CAAC2C,CAAA,EAAIC,CAAA,EAAOC,CAAA,KAAQA,CAAA,CAAIxG,OAAA,CAAQsG,CAAE,MAAMC,CAAK,EACpD5C,MAAA,CAAQ2C,CAAA,IAAMA,CAAC,EACfzG,IAAA,CAAK,GAAG,EACRzF,IAAA;cAECiM,CAAA,GACM/H,EAAA,CAAA2H,CAAA,EAAQC,CAAA,EAAMG,CAAG,IAEzB5H,EAAA,CAAWwH,CAAA,EAAQC,CAAI;YAE3B;UACF;QAAA;QAGIjF,CAAA,GAAkBmQ,CAAA,CAAS,MAAMlO,CAAA,CAAY3J,CAAA,EAAO,SAAS,CAAC;QAC9DwK,CAAA,GAAoBqN,CAAA,CAAS,MAAMnO,CAAA,CAAgB1J,CAAA,EAAO,OAAO,CAAC;QAClEyK,CAAA,GAAgBoN,CAAA,CAAS,MAAMlO,CAAA,CAAY3J,CAAA,EAAO,OAAO,CAAC;QAC1D0K,CAAA,GAAemN,CAAA,CACnB;QAAA;QAAA;QAGEha,MAAA,CAAOkd,IAAA,CAAKrT,CAAA,CAAgBqQ,KAAK,EAAEna,MAAA,GAAS,KAAKC,MAAA,CAAOkd,IAAA,CAAKtQ,CAAA,CAAcsN,KAAK,EAAEna,MAAA,GAAS;QAGzFgN,CAAA,GAAa2gB,EAAA,CAAc5sB,CAAY;QAEvCkM,CAAA,GAAsB+e,EAAA,CAAe,MAAM5pB,CAAA,CAAMisB,WAAA,EAAattB,CAAY;MAEhF,OAAAwZ,EAAA,CACE,MAAM5W,CAAA,EACN,CAACyJ,CAAA,EAAyBE,CAAA,KAA4B;QAChDF,CAAA,KAAaE,CAAA,IACfrB,CAAA,CAAsBmB,CAAA,EAAUE,CAAQ;MAE5C,IAGF4S,EAAA,CAAU,MAAM;QACdC,EAAA,CAAS,MAAM;UAGblU,CAAA,CAAsBtI,CAAe;QAAA,CACtC;MAAA,CACF,GAoBM;QACL8mC,eAAA,EAAA/qC,CAAA;QACAgrC,kBAAA,EAAA/qC,CAAA;QACAgrC,YAAA,EAAA5pC,CAAA;QACA6pC,cAAA,EAAAzpC,CAAA;QACA0pC,gBAAA,EAAAxpC,CAAA;QACAypC,eAAA,EAAAvpC,CAAA;QACAwpC,eAAA,EAAApnC,CAAA;QACAksB,mBAAA,EAAA5iB,CAAA;QACA+9B,eAAA,EAAAlhC,CAAA;QACAmhC,YAAA,EAAAn+B,CAAA;QACAo+B,iBAAA,EAAAt+B,CAAA;QACAu+B,aAAA,EAAAt+B,CAAA;QACAu+B,aAAA,EA/BqBh+B,CAAA,IAAsB;UAEvC,IAAAhL,CAAA,CAAM8nC,QAAA,IAAYl+B,CAAA,CAAQmO,KAAA,KAAU,MAAM;UAExC;cAACtZ,MAAA,EAAAyM;YAAU,IAAAF,CAAA;YACX0B,CAAA,GAAUxB,CAAA,GAAUA,CAAA,CAAuBxE,OAAA,GAAU;UAIvD,IAAA++B,EAAA,CAA4Bh/B,OAAA,CAAQiG,CAAO,MAAM,IAAI;UAGzD,MAAMC,CAAA,GAASpI,EAAA,CAAUihC,EAAA,EAAgB57B,CAAA,CAAQmO,KAAK,EAAE3N,MAAA,CAAOpG,EAAS;UACpE2I,CAAA,CAAO/O,MAAA,KAAW,KACP4F,EAAA,CAAAmJ,CAAA,CAAO,CAAC,CAAC;QACxB;QAiBAs8B,UAAA,EAAAr+B;MAAA;IAEJ;IACA0rB,OAAA,EAAS;MACP,MAAMt2B,CAAA,GAAQ,KAAKkpC,MAAA;QACb5rC,CAAA,GAAQ,KAAK6rC,MAAA;QAEb5rC,CAAA,GAAKgvB,EAAA;QACL5tB,CAAA,GAAa,CAACqB,CAAA,CAAM8nC,QAAA;MAG1B,IAAI/oC,CAAA,GAAc;MAClB,MAAME,CAAA,GAAeo5B,EAAA,CAAcqN,EAAA,EAAiB,CAAI,GAAApoC,CAAK,KAAK0C,CAAA,CAAMsuB,KAAA;QAClEnvB,CAAA,GAAUF,CAAA,GAAewtB,EAAA,CAAM,YAAY,IAAI;MAEjD,IAAAxtB,CAAA,IAAgB,KAAK4pC,YAAA,EAAc;QAC/B,MAAA79B,CAAA,GAA+BrM,CAAA,GAAa,WAAW;QAC7D,IAAI,KAAK2pC,kBAAA,EACHrpC,CAAA,KACOF,CAAA,GAAAw3B,EAAA,CACPvrB,CAAA,EACA;UACEovB,KAAA,EAAO;UACPxN,EAAA,EAAIztB,CAAA;UACJiqC,GAAA,EAAKppC,CAAA,CAAM8nC,QAAA,IAAY;QACzB,GACA7oC,CAAA,IAGA,KAAK4pC,YAAA,GACE9pC,CAAA,GAAAw3B,EAAA,CAAE2P,EAAA,EAAM,KAAK6C,aAAA,EAAe;UAAChL,OAAA,EAASA,CAAA,KAAMh/B;QAAA,CAAO,IAE5DA,CAAA,GAASw3B,EAAA,CAAE,OAAO,CAAI,IAACx3B,CAAM,CAAC,OAE3B;UACL,MAAMmM,CAAA,GAAc;YAClBm+B,OAAA,EAAS1qC,CAAA,GAAa,KAAKqqC,aAAA,GAAgB;YAC3C,IAAI,KAAKH,YAAA,GAAe,KAAKE,aAAA,GAAgB,CAAC;YAC9C/L,GAAA,EAAK,KAAK6L,YAAA,GAAe79B,CAAA,GAAW;YACpC4hB,EAAA,EAAIztB,CAAA;YACJiqC,GAAA,EAAKppC,CAAA,CAAM8nC,QAAA,IAAY;YACvBwB,QAAA,EAAU3qC,CAAA,GAAa,OAAO;YAC9By7B,KAAA,EAAO,CACL,KAAKyO,YAAA,GAAe,mBAAmB,cACvC;cACE,oBAAoBlqC,CAAA;cACpB,kBAAkB,KAAKkqC,YAAA,IAAgBlqC,CAAA;cACvC,QAAQ,CAAC,KAAKkqC,YAAA,IAAgBlqC,CAAA;cAC9B,WAAW,CAAC,KAAKkqC,YAAA,IAAgB,CAAClqC,CAAA;cAClC,CAAC,kBAAkBqB,CAAA,CAAM+nC,SAAS,EAAE,GAAG,CAAC,CAAC/nC,CAAA,CAAM+nC;YACjD,GACA,KAAKe,iBAAA,EACL9oC,CAAA,CAAMwnC,UAAA;UACR;UAEE,KAAKqB,YAAA,GACP9pC,CAAA,GAASw3B,EAAA,CAAE2P,EAAA,EAAMh7B,CAAA,EAAa;YAAC6yB,OAAA,EAASA,CAAA,KAAM9+B;UAAA,CAAa,IAElDF,CAAA,GAAAw3B,EAAA,CAAEvrB,CAAA,EAAUE,CAAA,EAAajM,CAAY;QAElD;MACF;MAEA,IAAIsC,CAAA,GAAmB;MACvB,MAAMkI,CAAA,GACJ4uB,EAAA,CAAcsN,EAAA,EAA4B,CAAI,GAAAroC,CAAK,KAAK,KAAK4pC,eAAA;QACzDx9B,CAAA,GAAoBD,CAAA,GAAyBgjB,EAAA,CAAM,uBAAuB,IAAI;MAEhFhjB,CAAA,KACiBlI,CAAA,GAAAg1B,EAAA,CACjB6P,EAAA,EACA;QACEmD,QAAA,EAAUvpC,CAAA,CAAMinC,gBAAA;QAChBra,EAAA,EAAIljB,CAAA;QACJ+a,KAAA,EAAO,KAAK8jB,YAAA;QACZ7V,OAAA,EAAS,KAAK8V;MAChB,GACA;QAACzK,OAAA,EAASA,CAAA,KAAMt0B;MAAsB;MAI1C,IAAIE,CAAA,GAAiB;MACrB,MAAMC,CAAA,GACJyuB,EAAA,CAAcuN,EAAA,EAA0B,CAAI,GAAAtoC,CAAK,KAAK,KAAK2qC,aAAA;QACvDp+B,CAAA,GAAkBD,CAAA,GAAuB6iB,EAAA,CAAM,qBAAqB,IAAI;MAE1E7iB,CAAA,KACeD,CAAA,GAAA4sB,EAAA,CACfmQ,EAAA,EACA;QACE6C,QAAA,EAAUvpC,CAAA,CAAMinC,gBAAA;QAChBra,EAAA,EAAI/iB,CAAA;QACJ4a,KAAA,EAAO,KAAK8jB,YAAA;QACZ7V,OAAA,EAAS,KAAK8V;MAChB,GACA;QAACzK,OAAA,EAASA,CAAA,KAAMn0B;MAAoB;MAAA;MAAA;MAKxC,IAAIlC,CAAA,GAAe;MACnB,MAAM8C,CAAA,GAAqB6tB,EAAA,CAAcwN,EAAA,EAAuB,CAAI,GAAAvoC,CAAK,KAAK,KAAK0pC,WAAA;QAC7Ev8B,CAAA,GAAgBD,CAAA,GAAqBiiB,EAAA,CAAM,kBAAkB,IAAI;MACnEjiB,CAAA,KACa9C,CAAA,GAAA6uB,EAAA,CACbiQ,EAAA,EACA;QACE5Z,EAAA,EAAIniB;MACN,GACA;QAACszB,OAAA,EAASA,CAAA,KAAMvzB;MAAkB;MAQhC,MAAAE,CAAA,GAAmB,KAAKi+B,eAAA,GAC5B,CACEl+B,CAAA,EACA,KAAK89B,YAAA,KAAiB,KAAQ7+B,CAAA,GAAoB,MAClD,KAAK6+B,YAAA,KAAiB,KAAO1+B,CAAA,GAAkB,MAE9CO,MAAA,CAAQY,CAAA,IAAMA,CAAC,EACf1E,IAAA,CAAK,GAAG,KAAK;QAEZsE,CAAA,GAAgB,CACpBytB,EAAA,CAAcyN,EAAA,EAAmB;UAAC6C,eAAA,EAAAj+B,CAAA;UAAiB8+B,aAAA,EAAA/+B,CAAA;UAAemiB,EAAA,EAAArvB,CAAA;UAAIksC,OAAA,EAAAtqC;QAAA,GAAU7B,CAAK,KAAK,IAC1FiE,CAAA,EACAoI,CAAA,EACAjC,CAAA;MAEE,CAAC,KAAKmhC,YAAA,IAAgB,KAAKH,eAAA,IAAiB99B,CAAA,CAAc+D,IAAA,CAAK5P,CAAM;MAEzE,IAAI8L,CAAA,GAAW0rB,EAAA,CACb,OACA;QACEmT,GAAA,EAAK;QACLtP,KAAA,EAAO,CACL;UACE,iBAAiB,CAAC,KAAKyO,YAAA,IAAgB,KAAKH;QAC9C;MAEJ,GACA99B,CAAA;MAEE,KAAKi+B,YAAA,KACPh+B,CAAA,GAAW0rB,EAAA,CAAE2P,EAAA,EAAM;QAACwD,GAAA,EAAK;QAAW,GAAG,KAAKd;MAAkB;QAAC7K,OAAA,EAASA,CAAA,KAAMnzB;MAAc;MAO9F,MAAME,CAAA,GAAW;QACfsvB,KAAA,EAAS,CACP,KAAK6O,UAAA,EACL;UACE,iBAAiB,KAAKR;QACxB,EACF;QACA7b,EAAA,EAAML,EAAA,CAAM,MAAMvsB,CAAA,CAAM4sB,EAAE,EAAE7U,KAAA;QAC5BvR,QAAA,EAAY7H,CAAA,GAAa,KAAK0pC,eAAA,GAAkB;QAChDsB,IAAA,EAAQhrC,CAAA,GAAa,OAAO;QAC5B,gBAAgB,KAAK8uB,mBAAA;QAAA;QAAA;QAGrB,mBAAmB9uB,CAAA,IAAc,KAAKkqC,YAAA,GAAe1pC,CAAA,GAAU;MAAA;MAG7D,YAAK0pC,YAAA,IAAgB,CAAClqC,CAAA,GACjB43B,EAAA,CAAE+P,EAAA,EAAUx7B,CAAA,EAAU;QAACizB,OAAA,EAASA,CAAA,KAAM,CAACh/B,CAAA,EAAQ8L,CAAQ;MAAA,CAAE,IAG3D0rB,EAAA,CACL53B,CAAA,GAAa,aAAa,OAC1BmM,CAAA,EACA,KAAK+9B,YAAA,IAAgBlqC,CAAA,GACjB,CAAC43B,EAAA,CAAE+P,EAAA,EAAU,MAAM;QAACvI,OAAA,EAASA,CAAA,KAAM,CAACh/B,CAAA,EAAQ8L,CAAQ;MAAE,EAAC,IACvD,KAAKg+B,YAAA,IAAgB,CAAC,KAAKH,eAAA,GAC3B,CAAC3pC,CAAA,EAAQ8L,CAAQ,IACjB,CAACA,CAAQ;IAEjB;EACF,CAAC;EAAA++B,EAAA;EAAAC,EAAA,kBAAAlY,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC5XD,MAAMhzB,CAAA,GAAQqB,CAAA;QA0CRjB,CAAA,GAAOxB,CAAA;QAUP;UAACgwB,KAAA,EAAAtuB,CAAA;UAAOuuB,UAAA,EAAAruB,CAAA;UAAYsuB,mBAAA,EAAAlsB,CAAA;UAAqBmsB,OAAA,EAAAjkB,CAAA;UAASkkB,QAAA,EAAAjkB,CAAA;UAAUkkB,MAAA,EAAAjkB,CAAA;UAAQjG,KAAA,EAAAkG,CAAA;UAAOmb,IAAA,EAAAlb;QAAI,IACnF6iB,EAAA,CAAa/tB,CAAA,EAAOI,CAAI;QAEpB2I,CAAA,GAAkBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDgE,CAAA,GAAkBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDzhB,CAAA,GAAkBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAMmrC,QAAQ;QACpDp/B,CAAA,GAAmBif,CAAA,CAAc,MAAMhrB,CAAA,CAAMorC,SAAS;QACtDn/B,CAAA,GAAe+e,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAE9C5Z,CAAA,GAAa0gB,EAAA,CAAc3gB,CAAY;QAEvCE,CAAA,GAAgBkN,CAAA,CAAI,EAAK;QAEzBhN,CAAA,GAAkB6M,CAAA,CAAS,MAAM;UAC/B,MAAA3M,CAAA,GAAUvM,CAAA,CAAMwnB,IAAA,KAAS;YACzBzZ,CAAA,GAAU/N,CAAA,CAAMwnB,IAAA,KAAS;UACxB,QACLtb,CAAA,CAAWkN,KAAA,EACX;YACE,4BAA4BjN,CAAA,CAAciN,KAAA;YAC1C,cAAc7M,CAAA;YACd,gBAAgBwB,CAAA,IAAY,CAAC/N,CAAA,CAAMorC,SAAA,IAAa,CAAC7+B,CAAA;YACjD,sBAAsBwB,CAAA;YACtB,0BAA0B/N,CAAA,CAAMorC,SAAA,IAAa,CAAC7+B,CAAA,IAAW,CAACwB,CAAA;YAC1D,CAAC,gBAAgB/N,CAAA,CAAMwR,IAAI,EAAE,GAAG,CAAC,CAACxR,CAAA,CAAMwR;UAC1C;QACF,CACD;MAEY,OAAA7S,CAAA;QACXynB,IAAA,EAAAlb,CAAA;QACAiC,OAAA,EAAS7M,CAAA;QACTyE,KAAA,EAAAkG;MAAA,CACD,IAAAsB,CAAA,EAAAwB,CAAA,MAAAwoB,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC/ED,MAAMx2B,CAAA,GAAQqB,CAAA;QAyCRjB,CAAA,GAAOxB,CAAA;QAMP0B,CAAA,GAAQo8B,EAAA;QAKRl8B,CAAA,GAAa4pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEZ,CAAA,GAAagrB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,YAAY;QAE/CnjB,CAAA,GAAmBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkuB,SAAS;QACtDnjB,CAAA,GAAeigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM8sB,KAAK;QAC9C9hB,CAAA,GAAgBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM+sB,MAAM;QAChD9hB,CAAA,GAAqB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMmmC,WAAW;QAC1Dj7B,CAAA,GAAkB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDkB,CAAA,GAAgBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6Q,MAAM;QAChDhF,CAAA,GAAkBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDzhB,CAAA,GAAekf,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAE9C/Z,CAAA,GAAa4vB,EAAA,CAAOrC,EAAA,EAAe,IAAI;QAEvCrtB,CAAA,GAAQoN,CAAA,CAAwB,IAAI;QAEpC;UAACgN,OAAA,EAAAna;QAAA,IAAWga,EAAA,CAASja,CAAA,EAAO;UAChCuY,YAAA,EAAc1Z,CAAA,CAAiBsO;QAAA,CAChC;QAEKjN,CAAA,GAAiByS,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYlF,CAAA,CAAM8+B,OAAO,CAAC;QAExD/yB,CAAA,GAAa6M,CAAA,CAAS;UAC1B3C,GAAA,EAAKA,CAAA,MAAMxK,CAAA,oBAAAA,CAAA,CAAYknB,UAAA,CAAW7Z,KAAA,KAAS5Y,CAAA,CAAW4Y,KAAA;UACtD5C,GAAA,EAAMpI,CAAA,IAAa;YACjB,IAAIA,CAAA,KAAa,QACjB;cAAA,IAAIrC,CAAA,KAAe,MAAM;gBACvBA,CAAA,CAAWknB,UAAA,CAAW7Z,KAAA,GAAQhL,CAAA;gBAC9B;cACF;cACA5N,CAAA,CAAW4Y,KAAA,GAAQhL,CAAA;YAAA;UACrB;QAAA,CACD;QAEK7B,CAAA,GAAmBqS,CAAA,CACvB,MACE,CAAC,EAAE5e,CAAA,CAAMjB,IAAA,KAAQgN,CAAA,oBAAAA,CAAA,CAAYhN,IAAA,CAAKqa,KAAA,OACjCvN,CAAA,CAAgBuN,KAAA,KAASrN,CAAA,oBAAAA,CAAA,CAAYwhB,QAAA,CAASnU,KAAA;QAG7CrL,CAAA,GAAgB6Q,CAAA,CAAM,MAAM3T,CAAA,CAAmBmO,KAAA,MAAUrN,CAAA,oBAAAA,CAAA,CAAY2hB,OAAA,CAAQtU,KAAA,KAAS,GAAM;QAE5FpL,CAAA,GAAgBkL,CAAA,CAAS,OAAO;UACpC4T,KAAA,EAAO/hB,CAAA,CAAaqO,KAAA,MAAUrN,CAAA,oBAAAA,CAAA,CAAY+gB,KAAA,CAAM1T,KAAA,KAAS;UACzD2T,MAAA,EAAQ/hB,CAAA,CAAcoO,KAAA,MAAUrN,CAAA,oBAAAA,CAAA,CAAY2hB,OAAA,CAAQtU,KAAA,KAAS;UAC7DvI,MAAA,EAAQ9H,CAAA,CAAcqQ,KAAA,MAAUrN,CAAA,oBAAAA,CAAA,CAAY8E,MAAA,CAAOuI,KAAA,KAAS;UAC5D0M,KAAA,EAAOha,CAAA,CAAasN,KAAA,KAASrN,CAAA,oBAAAA,CAAA,CAAY+Z,KAAA,CAAM1M,KAAA;UAC/C5H,IAAA,EAAMxR,CAAA,CAAMwR,IAAA,KAAQzF,CAAA,oBAAAA,CAAA,CAAYyF,IAAA,CAAK4H,KAAA,KAAS;UAAA;UAC9CgU,aAAA,EAAeptB,CAAA,CAAMotB,aAAA,KAAiBrhB,CAAA,oBAAAA,CAAA,CAAYqhB,aAAA,CAAchU,KAAA,KAAS;UAAA;QACzE;QACInL,CAAA,GAAkB4e,EAAA,CAAW7e,CAAa;QAC1CE,CAAA,GAAe+e,EAAA,CAAgBjf,CAAa;QAC5CG,CAAA,GAAe+e,EAAA,CAAgBlf,CAAa;MAErC,OAAArP,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACVla,CAAA,CAAQkN,KAAA,GAAQ;QAClB;QACAjM,OAAA,EAASlB,CAAA;QACTlH,KAAA,EAAOA,CAAA,KAAM;UACXmH,CAAA,CAAQkN,KAAA,GAAQ;QAClB;MAAA,CACD,IAAAhL,CAAA,EAAAC,CAAA,MAAAkoB,CAAA,IAAAztB,CAAA,CAAA68B,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7HD,MAAM3lC,CAAA,GAAQqB,CAAA;QA+CRjB,CAAA,GAAOxB,CAAA;QAaP0B,CAAA,GAAa8pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAEhDI,CAAA,GAAaotB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,OAAO;QAC1CrrB,CAAA,GAAegrB,EAAA,CAAM,MAAM5tB,CAAA,CAAMjB,IAAA,EAAM,UAAU;QAEjD+L,CAAA,GAAmBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkuB,SAAS;QACtDnjB,CAAA,GAAiBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM0tB,OAAO;QAClD1iB,CAAA,GAAkBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDoD,CAAA,GAAe+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM8sB,KAAK;QAC9C5hB,CAAA,GAAkB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDxkB,CAAA,GAAiBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAM2tB,OAAO;QAClD9hB,CAAA,GAAemf,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAC9Cha,CAAA,GAAmBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAMytB,SAAS;QAEtD1hB,CAAA,GAAUsN,CAAA,CAAwB,IAAI;QAEtC;UAACgN,OAAA,EAAApa;QAAA,IAAWia,EAAA,CAASna,CAAA,EAAS;UAClCyY,YAAA,EAAc1Z,CAAA,CAAiBsO;QAAA,CAChC;MAEDyhB,EAAA,CAAQvB,EAAA,EAAe;QACrBrG,UAAA,EAAA3yB,CAAA;QACA8sB,aAAA,EAAexO,CAAA,CAAM,MAAM5e,CAAA,CAAMotB,aAAa;QAC9CiZ,IAAA,EAAMznB,CAAA,CAAM,MAAM5e,CAAA,CAAMqmC,IAAI;QAC5BtnC,IAAA,EAAM6D,CAAA;QACN8qB,OAAA,EAAS3iB,CAAA;QACT+a,KAAA,EAAOja,CAAA;QACPihB,KAAA,EAAO7hB,CAAA;QACPuG,IAAA,EAAMoN,CAAA,CAAM,MAAM5e,CAAA,CAAMwR,IAAI;QAC5BX,MAAA,EAAQ+N,CAAA,CAAM,MAAM,CAAC7V,CAAA,CAAeqQ,KAAK;QACzCmU,QAAA,EAAUriB,CAAA;QACVrD,QAAA,EAAUmD;MAAA,CACX,GAEKwO,EAAA,CAAAlZ,CAAA,EAAayN,CAAA,IAAa;QAC9B3N,CAAA,CAAK,SAAS2N,CAAQ,GACtBqR,EAAA,CAAS,MAAM;UACbhf,CAAA,CAAK,UAAU2N,CAAQ;QAAA,CACxB;MAAA,CACF;MAED,MAAM7B,CAAA,GAAmBgN,CAAA,CAAS,MAChClZ,CAAA,CAAM6N,OAAA,CAAQpD,GAAA,CAAI,CAACsD,CAAA,EAAIC,CAAA,KACrB,OAAOD,CAAA,IAAO,YAAY,OAAOA,CAAA,IAAO,WACpC;UACE61B,KAAA,EAAO;YACLxqB,KAAA,EAAOrL,CAAA;YACPlG,QAAA,EAAUmD,CAAA,CAAgBoO;UAC5B;UACA0W,IAAA,EAAM/hB,CAAA,CAAG3M,QAAA,CAAS;UAClB2uB,IAAA,EAAM;UACNhO,IAAA,EAAM4Q,MAAA,CAAO,uBAAuB3kB,CAAG,EAAE;QAAA,IAE3C;UACE41B,KAAA,EAAO;YACLxqB,KAAA,EAAOrL,CAAA,CAAG/N,CAAA,CAAMsvB,UAAU;YAC1BznB,QAAA,EAAUkG,CAAA,CAAG/N,CAAA,CAAMyvB,aAAa;YAChC,IAAI1hB,CAAA,CAAG61B,KAAA,GAAQ71B,CAAA,CAAG61B,KAAA,GAAQ,CAAC;UAC7B;UACA9T,IAAA,EAAM/hB,CAAA,CAAG/N,CAAA,CAAMuvB,SAAS;UACxBQ,IAAA,EAAMhiB,CAAA,CAAG/N,CAAA,CAAMwvB,SAAS;UACxBzN,IAAA,EAAM4Q,MAAA,CAAO,uBAAuB3kB,CAAG,EAAE;QAC3C,CACN;QAGI7B,CAAA,GAAgB+M,CAAA,CAAS,OAAO;UACpCqU,QAAA,EAAUriB,CAAA,CAAgBkO,KAAA;UAC1BkU,WAAA,EAAattB,CAAA,CAAMstB,WAAA;UACnBxH,KAAA,EAAOja,CAAA,CAAauN,KAAA;UACpBqU,SAAA,EAAW3hB,CAAA,CAAiBsN,KAAA;UAC5BsU,OAAA,EAAS3iB,CAAA,CAAeqO,KAAA;UACxBuU,OAAA,EAAS5kB,CAAA,CAAeqQ,KAAA;UACxB5H,IAAA,EAAMxR,CAAA,CAAMwR;QACZ;QACInF,CAAA,GAAgBghB,EAAA,CAAalhB,CAAa;QAC1CI,CAAA,GAAkBihB,EAAA,CAAgBrhB,CAAa;MAExC,OAAAxN,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACVna,CAAA,CAAQmN,KAAA,GAAQ;QAClB;QACArU,KAAA,EAAOA,CAAA,KAAM;UACXkH,CAAA,CAAQmN,KAAA,GAAQ;QAClB;MAAA,CACD,IAAArL,CAAA,EAAAC,CAAA,MAAAuoB,CAAA,IAAAC,CAAA,QAAAoF,CAAA,CAAAhjB,CAAA,CAAAvM,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCnKD,MAAM1N,CAAA,GAAQ0C,CAAA;QAiBRzC,CAAA,GAAkBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkJ,QAAQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCH1D,MAAMlJ,CAAA,GAAQ0C,CAAA;QA2BRzC,CAAA,GAAcsa,CAAA,CAAS;QAAA;QAE3B2W,EAAA,CAAiBlxB,CAAA,CAAMkP,OAAA,EAAkB,0BAA0BlP,CAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCH1E,MAAMqB,CAAA,GAAQqB,CAAA;QA+CRjB,CAAA,GAAOxB,CAAA;QAaP0B,CAAA,GAAa8pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAEhDI,CAAA,GAAaotB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,OAAO;QAE1CrrB,CAAA,GAAmBooB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkuB,SAAS;QACtDpjB,CAAA,GAAkBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDkD,CAAA,GAAkBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMumC,QAAQ;QACpDv7B,CAAA,GAAeggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM8sB,KAAK;QAC9C7hB,CAAA,GAAkB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDriB,CAAA,GAAe8f,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAC9C/c,CAAA,GAAmB2W,EAAA,CAAY,MAAM1f,CAAA,CAAMqrC,UAAU;QAErDx/B,CAAA,GAAa+gB,EAAA,CAAc1hB,CAAY;QAEvCY,CAAA,GAAQuN,CAAA,CAAwB,IAAI;QAEpC;UAACgN,OAAA,EAAAta;QAAA,IAAWma,EAAA,CAASpa,CAAA,EAAO;UAChC0Y,YAAA,EAAc5hB,CAAA,CAAiBwW;QAAA,CAChC;QAEKnN,CAAA,GAAkBiN,CAAA,CAAS,MAAM,CACrCrN,CAAA,CAAWuN,KAAA,EACX;UACE,gBAAgBpO,CAAA,CAAaoO,KAAA;UAC7B,CAAC,gBAAgBpZ,CAAA,CAAMwR,IAAI,EAAE,GAAGxR,CAAA,CAAMwR,IAAA,KAAS,QAAQxG,CAAA,CAAaoO,KAAA;UACpE,eAAe,CAACpO,CAAA,CAAaoO,KAAA;UAC7B,CAAC,eAAepZ,CAAA,CAAMwR,IAAI,EAAE,GAAGxR,CAAA,CAAMwR,IAAA,KAAS,QAAQ,CAACxG,CAAA,CAAaoO;QACtE,EACD;QAEKlN,CAAA,GAAqB0S,CAAA,CAAM,MAC/B7V,CAAA,CAAiBqQ,KAAA,IAASpO,CAAA,CAAaoO,KAAA,GAAQrQ,CAAA,CAAiBqQ,KAAA,GAAQ;QAGpEjN,CAAA,GAAsB8e,EAAA,CAAe,MAAMjrB,CAAA,CAAMstB,WAAA,EAAapiB,CAAY;QAM1EmB,CAAA,GAAc6M,CAAA,CAAS,MAAM2W,EAAA,CAAiB7vB,CAAA,CAAM6N,OAAA,EAAkB,eAAe7N,CAAK,CAAC;QAC3FuM,CAAA,GAAa2M,CAAA,CAAS;UAC1B3C,GAAA,EAAKA,CAAA,KAAMjW,CAAA,CAAW8Y,KAAA;UAAA;UAEtB5C,GAAA,EAAMzI,CAAA,IAAkB;YACtB3N,CAAA,CAAK,SAAS2N,CAAQ,GACtBzN,CAAA,CAAW8Y,KAAA,GAAQrL,CAAA,EACnBqR,EAAA,CAAS,MAAM;cACbhf,CAAA,CAAK,UAAU2N,CAAQ;YAAA,CACxB;UACH;QAAA,CACD;MAEY,OAAApP,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACVra,CAAA,CAAQqN,KAAA,GAAQ;QAClB;QACAjM,OAAA,EAASrB,CAAA;QACT/G,KAAA,EAAOA,CAAA,KAAM;UACXgH,CAAA,CAAQqN,KAAA,GAAQ;QAClB;MAAA,CACD,IAAArL,CAAA,EAAAC,CAAA,KAAAs9B,EAAA,EAAA/U,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECvKK+U,EAAA,GAAY,CAChB,MACA,MACA,OACA,MACA,MACA,MACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,KACF,CAAE9gC,GAAA,CAAKpJ,CAAA,IAAWA,CAAA,CAAOuF,WAAA,CAAa;EAMzB4kC,EAAA,GAAenqC,CAAA,IAAmB;IAEvC,MAAA1C,CAAA,GAAQwC,EAAA,CAASE,CAAM,EAAEuF,WAAA,CAAc,EAAA9E,OAAA,CAAQd,EAAA,EAAsB,EAAE,EAAE0B,KAAA,CAAM,GAAG;MAClF9D,CAAA,GAAUD,CAAA,CAAMyD,KAAA,CAAM,GAAG,CAAC,EAAEuF,IAAA,CAAK,GAAG;MACpC,CAAC3H,CAAO,IAAIrB,CAAA;IAClB,OAAO4sC,EAAA,CAAUxhC,QAAA,CAASnL,CAAO,KAAK2sC,EAAA,CAAUxhC,QAAA,CAAS/J,CAAO;EAClE;ECvBayrC,EAAA,GACXpqC,CAAA,IAEI2C,EAAA,GACK40B,EAAA,CAASv3B,CAAO,IAAIA,CAAA,GAAU;IAACmf,OAAA,EAAS,CAAC,CAACnf,CAAA,IAAW;EAAA,IAGvD,CAAC,EAAEu3B,EAAA,CAASv3B,CAAO,IAAIA,CAAA,CAAQmf,OAAA,GAAUnf,CAAA;EAOrCqqC,EAAA,GAAUC,CACrBtqC,CAAA,EACA1C,CAAA,EACAC,CAAA,EACAoB,CAAA,KACG;IACCqB,CAAA,IAAMA,CAAA,CAAGoC,gBAAA,IACXpC,CAAA,CAAGoC,gBAAA,CAAiB9E,CAAA,EAAWC,CAAA,EAAS6sC,EAAA,CAAkBzrC,CAAO,CAAC;EAEtE;EAMa4rC,EAAA,GAAWC,CACtBxqC,CAAA,EACA1C,CAAA,EACAC,CAAA,EACAoB,CAAA,KACG;IACCqB,CAAA,IAAMA,CAAA,CAAGqC,mBAAA,IACRrC,CAAA,CAAAqC,mBAAA,CAAoB/E,CAAA,EAAWC,CAAA,EAASoB,CAAO;EAEtD;EAOa8rC,EAAA,GAAaC,CAAC1qC,CAAA,EAAa1C,CAAA,KAA6C;IAEnF,CADe0C,CAAA,GAAKqqC,EAAA,GAAUE,EAAA,EACvB,GAAGjtC,CAAW;EACvB;EAMaqtC,EAAA,GAAYC,CACvB5qC,CAAA,EACA;IAAC3B,cAAA,EAAAf,CAAA,GAAiB;IAAMutC,WAAA,EAAAttC,CAAA,GAAc;IAAMutC,oBAAA,EAAAnsC,CAAA,GAAuB;EAAS,WACzE;IACCrB,CAAA,IACF0C,CAAA,CAAM3B,cAAA,CAAe,GAEnBd,CAAA,IACFyC,CAAA,CAAMi9B,eAAA,CAAgB,GAEpBt+B,CAAA,IACFqB,CAAA,CAAMy8B,wBAAA,CAAyB;EAEnC;ECxEasO,EAAA,GAAY;EACZC,EAAA,GAAW;EAGXC,EAAA,GAAY;EAEZC,EAAA,GAAgB;EAChBC,EAAA,GAAc;EAGdC,EAAA,GAAU;EAAAC,EAAA;EAAAC,EAAA;EAAAC,EAAA;EC6iBjBC,EAAA,GAAgB;IACpBvkC,GAAA,EAAK;IACLE,GAAA,EAAK;IACLskC,IAAA,EAAM;IACNC,WAAA,EAAa;IACbC,cAAA,EAAgB;IAChBC,eAAA,EAAiB;IACjBC,gBAAA,EAAkB;EACpB;EAAAC,EAAA,kBAAAna,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA7eA,MAAMp0B,CAAA,GAAY,CAAC6tC,EAAA,EAASL,EAAA,EAAWE,EAAA,EAAWD,EAAA,EAAUG,EAAA,EAAaD,EAAa;QAEhFvsC,CAAA,GAAQqB,CAAA;QA2DRjB,CAAA,GAAOzB,CAAA;QAYP2B,CAAA,GAAa8pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAGjEhD,CAAA,GAAU6Y,CAAA,CAAwB,IAAI;QAEtC;UAACgN,OAAA,EAAAzjB;QAAA,IAAWsjB,EAAA,CAAS1lB,CAAO;QAE5BsK,CAAA,GAAa8iB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,YAAY;QAE/CljB,CAAA,GAAkBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDmD,CAAA,GAAgBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6Q,MAAM;QAChD5F,CAAA,GAAkB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMmrC,QAAQ;QACpDjgC,CAAA,GAAkB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMogC,QAAQ;QACpDr3B,CAAA,GAAkBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpD1hB,CAAA,GAAcmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMotC,IAAI;QAC5CthC,CAAA,GAAekf,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAE9C/Z,CAAA,GAAkBmN,CAAA,CAAS,OAAO;UACtCrR,QAAA,EAAYkD,CAAA,CAAgBqO,KAAA;UAC5B+xB,QAAA,EAAYlgC,CAAA,CAAgBmO,KAAA;UAC5BrU,KAAA,EAASnC,CAAA,CAAQwW,KAAA;UACjB,iBAAiBpO,CAAA,CAAcoO,KAAA,IAASlO,CAAA,CAAgBkO,KAAA;UACxD,UAAU,CAACpO,CAAA,CAAcoO,KAAA,IAAS,CAAClO,CAAA,CAAgBkO,KAAA;UACnD,uBAAuB,CAAClO,CAAA,CAAgBkO,KAAA;UACxC,eAAelO,CAAA,CAAgBkO,KAAA;UAC/B,CAAC,gBAAgBpZ,CAAA,CAAMwR,IAAI,EAAE,GAAGxR,CAAA,CAAMwR,IAAA,KAAS;QAC/C;QAEIvF,CAAA,GAAsBiN,CAAA,CAAS,OAAO;UAC1C,UAAUhO,CAAA,CAAgBkO,KAAA;UAC1B,qBAAqB,CAAClO,CAAA,CAAgBkO,KAAA;UACtC,sBAAsBlO,CAAA,CAAgBkO,KAAA;UACtC,cAAclO,CAAA,CAAgBkO,KAAA;UAC9B,iBAAiBlO,CAAA,CAAgBkO,KAAA;UACjC,gBAAgB,CAAClO,CAAA,CAAgBkO,KAAA;UACjC,cAAc,CAAClO,CAAA,CAAgBkO;QAC/B;MAGE,IAAAlN,CAAA;QACAC,CAAA;QACAE,CAAA,GAAc;MAMlB,MAAME,CAAA,GAAamT,EAAA,CAAY,MAAM1f,CAAA,CAAM8sC,IAAI;QACzC/+B,CAAA,GAAe6Q,CAAA,CAAM,MACzBpX,MAAA,CAAOsY,KAAA,CAAMvT,CAAA,CAAW6M,KAAK,IAAIyzB,EAAA,CAAcC,IAAA,GAAOvgC,CAAA,CAAW6M,KAAA;QAG7DpL,CAAA,GAAY0R,EAAA,CAAY,MAAM1f,CAAA,CAAMsI,GAAG;QACvC2F,CAAA,GAAc2Q,CAAA,CAAM,MACxBpX,MAAA,CAAOsY,KAAA,CAAM9R,CAAA,CAAUoL,KAAK,IAAIyzB,EAAA,CAAcvkC,GAAA,GAAM0F,CAAA,CAAUoL,KAAA;QAG1DlL,CAAA,GAAYwR,EAAA,CAAY,MAAM1f,CAAA,CAAMwI,GAAG;QACvC2F,CAAA,GAAcyQ,CAAA,CAAM,MAAM;UAC9B,MAAMqX,EAAA,GAAOloB,CAAA,CAAaqL,KAAA;YACpB8c,EAAA,GAAMjoB,CAAA,CAAYmL,KAAA;UACxB,OAAO/Q,IAAA,CAAKO,KAAA,EAAOsF,CAAA,CAAUkL,KAAA,GAAQ8c,EAAA,IAAOD,EAAI,IAAIA,EAAA,GAAOC,EAAA;QAAA,CAC5D;QAEK9nB,CAAA,GAAoBsR,EAAA,CAAY,MAAM1f,CAAA,CAAM+sC,WAAA,EAAa;UAC7DltB,SAAA,EAAW;UACXF,MAAA,EAAQ;QAAA,CACT;QACKtR,CAAA,GAAgBuQ,CAAA,CAAM,MAC1BxQ,CAAA,CAAkBgL,KAAA,GAAQ,IAAIhL,CAAA,CAAkBgL,KAAA,GAAQyzB,EAAA,CAAcE,WAAA;QAGlEz+B,CAAA,GAAuBoR,EAAA,CAAY,MAAM1f,CAAA,CAAMgtC,cAAA,EAAgB;UACnEntB,SAAA,EAAW;UACXF,MAAA,EAAQ;QAAA,CACT;QACKpR,CAAA,GAAmBqQ,CAAA,CAAM,MAC7BtQ,CAAA,CAAqB8K,KAAA,GAAQ,IAAI9K,CAAA,CAAqB8K,KAAA,GAAQyzB,EAAA,CAAcG,cAAA;QAGxEx+B,CAAA,GAAwBkR,EAAA,CAAY,MAAM1f,CAAA,CAAMitC,eAAA,EAAiB;UACrEptB,SAAA,EAAW;UACXF,MAAA,EAAQ;QAAA,CACT;QACKlR,EAAA,GAAoBmQ,CAAA,CAAM,MAC9BvW,IAAA,CAAKG,GAAA,CACHhB,MAAA,CAAOsY,KAAA,CAAMtR,CAAA,CAAsB4K,KAAK,IACpCyzB,EAAA,CAAcI,eAAA,GACdz+B,CAAA,CAAsB4K,KAAA,EAC1B,CACF;QAGIzK,EAAA,GAA6B+Q,EAAA,CAAY,MAAM1f,CAAA,CAAMqtC,oBAAA,EAAsB;UAC/ExtB,SAAA,EAAW;UACXF,MAAA,EAAQ;QAAA,CACT;QACK1P,EAAA,GAAyB2O,CAAA,CAAM,MACnCvW,IAAA,CAAKG,GAAA,CACHhB,MAAA,CAAOsY,KAAA,CAAMnR,EAAA,CAA2ByK,KAAK,IACzCyzB,EAAA,CAAcK,gBAAA,GACdv+B,EAAA,CAA2ByK,KAAA,EAC/B,CACF;QAGIgb,EAAA,GAAoBxV,CAAA,CAAM,MAAM;UACpC,MAAMqX,EAAA,GAAOloB,CAAA,CAAaqL,KAAA;UAC1B,OAAO/Q,IAAA,CAAKO,KAAA,CAAMqtB,EAAI,MAAMA,EAAA,GAAO,KAAKA,EAAA,CAAK70B,QAAA,CAAS,EAAEsB,KAAA,CAAM,GAAG,EAAE,CAAC,KAAK,IAAIzD,MAAA;QAAA,CAC9E;QAEKo1B,EAAA,GAAqBzV,CAAA,CAAM,MAAMvW,IAAA,CAAKilC,GAAA,CAAI,IAAIlZ,EAAA,CAAkBhb,KAAA,IAAS,CAAC,CAAC;QAE3E0b,EAAA,GAAelW,CAAA,CAAM,MACzBte,CAAA,CAAW8Y,KAAA,KAAU,OAAO,KAAK9Y,CAAA,CAAW8Y,KAAA,CAAMm0B,OAAA,CAAQnZ,EAAA,CAAkBhb,KAAK;QAG7E2b,EAAA,GAAiB7b,CAAA,CAAS,MAAM;UAE9B,MAAA+c,EAAA,GAAU,CAACj2B,CAAA,CAAMwtC,MAAM;UAEtB,OADI,IAAIC,IAAA,CAAKC,YAAA,CAAazX,EAAO,EAC9B0X,eAAA,CAAkB,EAAAH,MAAA;QAAA,CAC7B;QAEKxY,EAAA,GAAc9b,CAAA,CAAS;QAAA;QAE3BsyB,EAAA,CAAYzW,EAAA,CAAe3b,KAAK;QAG5B6b,EAAA,GAAmB2Y,CAAA,KACvB,IAAIH,IAAA,CAAKC,YAAA,CAAa3Y,EAAA,CAAe3b,KAAA,EAAO;UAC1C6P,KAAA,EAAO;UACP4kB,WAAA,EAAa;UACbC,oBAAA,EAAsB;UACtBC,qBAAA,EAAuB3Z,EAAA,CAAkBhb,KAAA;UACzC40B,qBAAA,EAAuB5Z,EAAA,CAAkBhb,KAAA;UACzC60B,QAAA,EAAU;QACX,GAAEC,MAAA;QAEChZ,CAAA,GAAoBtW,CAAA,CAAM,MAAM5e,CAAA,CAAMmuC,WAAA,IAAelZ,EAAA,EAAkB;QAEvEE,CAAA,GAAac,EAAA,IAAsB;UAGnC;YAAC7c,KAAA,EAAA8c;UAAS,IAAA51B,CAAA;UACd,IAAI,CAACyK,CAAA,CAAgBqO,KAAA,IAAS8c,EAAA,KAAU,MAAM;YACtC,MAAAE,EAAA,GAAOroB,CAAA,CAAaqL,KAAA,GAAQ6c,EAAA;cAC5B1B,CAAA,GAAMtmB,CAAA,CAAYmL,KAAA;cAClBob,EAAA,GAAMrmB,CAAA,CAAYiL,KAAA;cAClBsb,EAAA,GAAaL,EAAA,CAAmBjb,KAAA;cAChC;gBAACg0B,IAAA,EAAAzY;cAAQ,IAAA30B,CAAA;YAEfk2B,EAAA,GAAQ7tB,IAAA,CAAKK,KAAA,EAAOwtB,EAAA,GAAQ3B,CAAA,IAAO6B,EAAI,IAAIA,EAAA,GAAO7B,CAAA,GAAM6B,EAAA,EAExDF,EAAA,GAAQ7tB,IAAA,CAAKK,KAAA,CAAMwtB,EAAA,GAAQxB,EAAU,IAAIA,EAAA,EAE9Bp0B,CAAA,CAAA8Y,KAAA,GAAQ8c,EAAA,GAAQ1B,EAAA,GAAOG,EAAA,GAAOJ,CAAA,GAAMC,EAAA,GAAO0B,EAAA,GAAQ3B,CAAA,GAAOI,EAAA,GAAOH,EAAA,GAAMD,CAAA,GAAO2B,EAAA;UAC3F;QAAA;QAGId,CAAA,GAASgZ,CAACnY,EAAA,GAAa,MAAM;UAC7B,IAAA31B,CAAA,CAAW8Y,KAAA,KAAU,MAAM;YAC7B9Y,CAAA,CAAW8Y,KAAA,GAAQnL,CAAA,CAAYmL,KAAA;YAC/B;UACF;UACA+b,CAAA,CAAU,IAAKc,EAAU;QAAA;QAGrBT,CAAA,GAAW6Y,CAACpY,EAAA,GAAa,MAAM;UAC/B,IAAA31B,CAAA,CAAW8Y,KAAA,KAAU,MAAM;YAC7B9Y,CAAA,CAAW8Y,KAAA,GAAQvN,CAAA,CAAYuN,KAAA,GAAQjL,CAAA,CAAYiL,KAAA,GAAQnL,CAAA,CAAYmL,KAAA;YACvE;UACF;UACA+b,CAAA,CAAU,KAAKc,EAAU;QAAA;MAG3BjV,EAAA,CACEpiB,CAAA,EACCq3B,EAAA,IAAU;QACT,MAAM;UAACnb,IAAA,EAAAob,EAAA;UAAMoY,MAAA,EAAAlY,EAAA;UAAQmY,OAAA,EAAAha,CAAA;UAASia,OAAA,EAAAha;QAAA,IAAWyB,EAAA;QAEzC,IAAI,EAAAlrB,CAAA,CAAgBqO,KAAA,IAASnO,CAAA,CAAgBmO,KAAA,IAASgd,EAAA,IAAU7B,CAAA,IAAWC,EAAA,MAG3EwX,EAAA,CAAU/V,EAAA,EAAO;UAACiW,WAAA,EAAa;QAAM,IACjC,CAAA7/B,CAAA,GAMJ;UAAA,IADY6mB,EAAA,IACR,CAACuZ,EAAA,EAASL,EAAS,EAAEriC,QAAA,CAASmsB,EAAI,GAAG;YAIvC,IADc7pB,CAAA,OACV6pB,EAAA,KAASuW,EAAA,EAAS;cACpBhX,CAAA,CAAiBQ,EAAA,EAAOb,CAAM;cAC9B;YACF;YACIc,EAAA,KAASkW,EAAA,IACX3W,CAAA,CAAiBQ,EAAA,EAAOT,CAAQ;YAElC;UACF;UAEA,IAAIU,EAAA,KAASsW,EAAA,EAAa;YACxBpX,CAAA,CAAOnlB,EAAA,CAAuBmJ,KAAK;YACnC;UACF;UACA,IAAI8c,EAAA,KAASqW,EAAA,EAAe;YAC1B/W,CAAA,CAASvlB,EAAA,CAAuBmJ,KAAK;YACrC;UACF;UACA,IAAI8c,EAAA,KAASoW,EAAA,EAAW;YACtBhsC,CAAA,CAAW8Y,KAAA,GAAQnL,CAAA,CAAYmL,KAAA;YAC/B;UACF;UACI8c,EAAA,KAASmW,EAAA,KACX/rC,CAAA,CAAW8Y,KAAA,GAAQjL,CAAA,CAAYiL,KAAA;QAAA;MAEnC,GACA;QAACtZ,MAAA,EAAQU,CAAA;QAASygB,SAAA,EAAW;MAAS,IAGxCD,EAAA,CACEpiB,CAAA,EACCq3B,EAAA,IAAyB;QAGxB,MAAM;UAACqY,MAAA,EAAApY,EAAA;UAAQqY,OAAA,EAAAnY,EAAA;UAASoY,OAAA,EAAAja;QAAA,IAAW0B,EAAA;QAE/BlrB,CAAA,CAAgBqO,KAAA,IAASnO,CAAA,CAAgBmO,KAAA,IAAS8c,EAAA,IAAUE,EAAA,IAAW7B,CAAA,KAE3EyX,EAAA,CAAU/V,EAAA,EAAO;UAACiW,WAAA,EAAa;QAAM,IACzBhZ,EAAA,IACE7mB,CAAA,OACTjM,CAAA,WAAUE,CAAA,CAAW8Y,KAAK;MACjC,GACA;QAACtZ,MAAA,EAAQU,CAAA;QAASygB,SAAA,EAAW;MAAO;MAIhC,MAAAwU,CAAA,GAAmBgZ,CAACxY,EAAA,EAAcC,EAAA,KAAoC;UAC1E,MAAM;YAAC1O,IAAA,EAAA4O;UAAA,IAAQH,EAAA,IAAS;UAExB,IAAI,CAAClrB,CAAA,CAAgBqO,KAAA,IAAS,CAACnO,CAAA,CAAgBmO,KAAA,EAAO;YAChD,IAAAsc,CAAA,CAAaO,EAAK,KAEhBG,EAAA,KAAS,eAAeH,EAAA,CAAMlJ,MAAA,EAAQ;YAEhCmG,EAAA,IAEZgD,EAAA,CAAQ,CAAC;YACT,MAAM3B,CAAA,GAAY9lB,EAAA,CAAkB2K,KAAA;cAC9Bob,EAAA,GAAavkB,EAAA,CAAuBmJ,KAAA;cACpCsb,EAAA,GAAQrmB,CAAA,CAAc+K,KAAA;cACtBub,EAAA,GAAWpmB,CAAA,CAAiB6K,KAAA;YAGlClN,CAAA,GAAmBsL,UAAA,CAAW,MAAM;cAClC,IAAIue,EAAA,GAAQ;cACZ5pB,CAAA,GAAoBsT,WAAA,CAAY,MAAM;gBAK5ByW,EAAA,CAAAH,EAAA,GAAQxB,CAAA,GAAY,IAAIC,EAAU,GAC1CuB,EAAA;cAAA,GACCpB,EAAQ;YAAA,GACVD,EAAK;UACV;QAAA;QAGIgB,CAAA,GAAgBO,EAAA,IACpBA,EAAA,CAAIzO,IAAA,KAAS,aAAayO,EAAA,CAAIzO,IAAA,KAAS;QAEnCmO,EAAA,GAA4BM,EAAA,IAAiB;UAG7CP,CAAA,CAAaO,EAAK,KAChBA,EAAA,CAAMzO,IAAA,KAAS,aAAayO,EAAA,CAAMlJ,MAAA,KAMxCif,EAAA,CAAU/V,EAAA,EAAO;YAACiW,WAAA,EAAa;UAAM,IACzBhZ,EAAA,IACZ2C,EAAA,CAAW,EAAK,GAEXz1B,CAAA,WAAUE,CAAA,CAAW8Y,KAAK;QAAA;QAG3Byc,EAAA,GAAcI,EAAA,IAAgB;UAG9B;YACF6V,EAAA,CAAW7V,EAAA,EAAI,CAACjzB,QAAA,CAASoR,IAAA,EAAM,WAAWuhB,EAAA,EAAW,EAAK,CAAC,GAC3DmW,EAAA,CAAW7V,EAAA,EAAI,CAACjzB,QAAA,CAASoR,IAAA,EAAM,YAAYuhB,EAAA,EAAW,EAAK,CAAC;UAAA,QACtD,CAER;QAAA;QAEIzC,EAAA,GAAcwb,CAAA,KAAM;UACxBv3B,YAAA,CAAajL,CAAgB,GAC7BsT,aAAA,CAAcrT,CAAiB,GACZD,CAAA,WACCC,CAAA;QAAA;QAGhBgnB,EAAA,GAAUja,CAAA,CAAS,MAAM;UAC7B,MAAM+c,EAAA,GAAoB;cACxB0Y,GAAA,EAAK;gBACHC,KAAA,EAAO;gBACPrpC,KAAA,EAAO;gBACPD,MAAA,EAAQ;gBACRupC,IAAA,EAAM;gBACNpT,KAAA,EAAO;gBACPqT,OAAA,EAAS;cACX;cACA3R,IAAA,EAAM;gBACJpyB,CAAA,EAAG;cACL;YAAA;YAGImrB,EAAA,GAAoB;cACxByY,GAAA,EAAK;gBACHC,KAAA,EAAO;gBACPrpC,KAAA,EAAO;gBACPD,MAAA,EAAQ;gBACRupC,IAAA,EAAM;gBACNpT,KAAA,EAAO;gBACPqT,OAAA,EAAS;cACX;cACA3R,IAAA,EAAM;gBAACpyB,CAAA,EAAG;cAA2D;YAAA;YAGjEqrB,EAAA,GAAoB;cACxBqF,KAAA,EAAS,CAAC;gBAAC,QAAQ,CAACvwB,CAAA,CAAgBkO;cAAQ,UAAO,UAAU,YAAY,WAAW;cACpFykB,QAAA,EAAY;cACZrW,IAAA,EAAQ;cACR3f,QAAA,EAAYkD,CAAA,CAAgBqO,KAAA,IAASnO,CAAA,CAAgBmO,KAAA;cACrD,iBAAiBrO,CAAA,CAAgBqO,KAAA,IAASnO,CAAA,CAAgBmO,KAAA,GAAQ,KAAO;cACzE,iBAAiBtO,CAAA,CAAWsO;YAAA;YAGxBmb,CAAA,GAAiB;cACrB,eAAe;cACfwa,KAAA,EAASnsC,CAAA,CAAQwW,KAAA,GAAQ,MAAM;YAAA;YAG3Bob,EAAA,GAAUwa,CAACjZ,EAAA,EAAcC,EAAA,KAA2C;cACpE,CAACjrB,CAAA,CAAgBqO,KAAA,IAAS,CAACnO,CAAA,CAAgBmO,KAAA,KAC7C4yB,EAAA,CAAUjW,EAAA,EAAO;gBAACmW,WAAA,EAAa;cAAM,IACrCrW,EAAA,CAAW,EAAI,GAGfjzB,CAAA,CAAQwW,KAAA,GAAQ,IAChBqc,CAAA,CAAiBM,EAAA,EAAOC,EAAO;YACjC;YAGItB,EAAA,GAAiB;cACrB3H,MAAA,EAAQ;gBACN,GAAGqJ,EAAA;gBACH,cAAcp2B,CAAA,CAAMivC,cAAA,IAAkB;gBACtC,qBAAqB;cACvB;cACAN,GAAA,EAAK;gBACH,GAAGpa,CAAA;gBACH,GAAG0B,EAAA,CAAkB0Y;cACvB;cACAxR,IAAA,EAAM;gBACJ,GAAGlH,EAAA,CAAkBkH;cACvB;cACA+R,IAAA,EAAM;gBACJnwC,IAAA,EAAM;cACR;cACAiwC,OAAA,EAAUjZ,EAAA,IAAavB,EAAA,CAAQuB,EAAA,EAAGX,CAAM;YAAA;YAGpCT,EAAA,GAAiB;cACrB5H,MAAA,EAAQ;gBACN,GAAGqJ,EAAA;gBACH,cAAcp2B,CAAA,CAAMmvC,cAAA,IAAkB;gBACtC,qBAAqB;cACvB;cACAR,GAAA,EAAK;gBACH,GAAGpa,CAAA;gBACH,GAAG2B,EAAA,CAAkByY;cACvB;cACAxR,IAAA,EAAM;gBACJ,GAAGjH,EAAA,CAAkBiH;cACvB;cACA+R,IAAA,EAAM;gBACJnwC,IAAA,EAAM;cACR;cACAiwC,OAAA,EAAUjZ,EAAA,IAAavB,EAAA,CAAQuB,EAAA,EAAGP,CAAQ;YAAA;UAGrC;YACLpsB,GAAA,EAAK;cACH,IAAI8B,CAAA,CAAgBkO,KAAA,GAAQsb,EAAA,GAAiBC,EAAA;YAC/C;YACAxrB,MAAA,EAAQ;cACN,IAAK+B,CAAA,CAAgBkO,KAAA,GAAyBub,EAAA,GAAjBD,EAAA;YAC/B;UAAA;QACF,CACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCxhBD,MAAM91B,CAAA,GAAQyC,CAAA;QAuBRrB,CAAA,GAAOrB,CAAA;QAIPyB,CAAA,GAAQs8B,EAAA;QAKRp8B,CAAA,GAAastB,EAAA,CAAM,MAAMhvB,CAAA,CAAMqvB,EAAE;QAEjCztB,CAAA,GAAkBwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QACpDjF,CAAA,GAAkBooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMwwC,QAAQ;QACpDtkC,CAAA,GAAckgB,CAAA,CAAc,MAAMpsB,CAAA,CAAMo/B,IAAI;QAE5CjzB,CAAA,GAAUmO,CAAA,CACd;;UAAQ,WAAAhO,CAAA,GAAA9K,CAAA,CAAMg/B,OAAA,KAAN,gBAAAl0B,CAAA,CAAAzJ,IAAA,CAAArB,CAAA,EAAgB,IAAI,GAAGsgB,QAAA,KAAY,IAAItf,QAAA,CAAS,KAAKxC,CAAA,CAAMq1B,KAAA,KAAU;QAAA;QAEzEjpB,CAAA,GAAa4T,CAAA,CAAM,MAAM,GAAGte,CAAA,CAAW8Y,KAAK,YAAY;QAExDnO,CAAA,GAAkBiO,CAAA,CAAS,OAAO;UACtC,CAAC,WAAWta,CAAA,CAAMotB,OAAO,EAAE,GAAGptB,CAAA,CAAMotB,OAAA,KAAY;UAChD,gBAAgBlhB,CAAA,CAAYsO,KAAA;UAC5BvR,QAAA,EAAYrH,CAAA,CAAgB4Y;QAC5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCuDF,MAAMpZ,CAAA,GAAQqB,CAAA;QAqERjB,CAAA,GAAOxB,CAAA;QA0BP0B,CAAA,GAAa8pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAEhDI,CAAA,GAAaotB,EAAA;QAEbhrB,CAAA,GAAqBooB,CAAA,CAAc,MAAMhrB,CAAA,CAAMqvC,WAAW;QAC1DvkC,CAAA,GAAmBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMkuB,SAAS;QACtDnjB,CAAA,GAAkBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDmD,CAAA,GAAsBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMsvC,YAAY;QAC5DrkC,CAAA,GAAsB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMuvC,YAAY;QAC5DrkC,CAAA,GAAqB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAMwvC,WAAW;QAC1DzmC,CAAA,GAAwBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMyvC,cAAc;QAChE5jC,CAAA,GAAkBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDzhB,CAAA,GAAekf,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAC9C/Z,CAAA,GAAkBif,CAAA,CAAc,MAAMhrB,CAAA,CAAM0vC,QAAQ;QACpDzjC,CAAA,GAAcyT,EAAA,CAAY,MAAM1f,CAAA,CAAM2vC,KAAA,IAASphB,GAAG;QAElDriB,CAAA,GAAa0gB,EAAA,CAAc9gB,CAAY;QAEvCK,CAAA,GAAQkN,CAAA,CAA6B,IAAI;QAEzC;UAACgN,OAAA,EAAAha;QAAA,IAAW6Z,EAAA,CAAS/Z,CAAA,EAAO;UAChCqY,YAAA,EAAc1Z,CAAA,CAAiBsO;QAAA,CAChC;QAEK7M,CAAA,GAAWqS,CAAA,CAAM,MAAM5e,CAAA,CAAM4vC,OAAA,IAAW,GAAGpvC,CAAA,CAAW4Y,KAAK,SAAS;QACpErL,CAAA,GAAOsL,CAAA,CAAc/Y,CAAA,CAAW8Y,KAAK;QACrCpL,CAAA,GAAaqL,CAAA,CAAY,EAAE;QAC3BpL,CAAA,GAAuBoL,CAAA,CAAa/Y,CAAA,CAAW8Y,KAAA,CAAMna,MAAA,GAAS,CAAC;QAC/DiP,CAAA,GAAiBmL,CAAA,CAAY,EAAE;QAC/BlL,CAAA,GAAYkL,CAAA,CAAc,EAAE;QAC5BjL,CAAA,GAAciL,CAAA,CAAc,EAAE;QAC9BhL,CAAA,GAAgBgL,CAAA,CAAc,EAAE;QAEhC/K,CAAA,GAAkB4K,CAAA,CAAS,MAAM,CACrChN,CAAA,CAAWkN,KAAA,EACX;UACE,CAAC,gBAAgBpZ,CAAA,CAAMwR,IAAI,EAAE,GAAGxR,CAAA,CAAMwR,IAAA,KAAS;UAC/C3J,QAAA,EAAUkD,CAAA,CAAgBqO,KAAA;UAC1BrU,KAAA,EAAOsH,CAAA,CAAQ+M;QACjB,EACD;QAEK7K,CAAA,GAAc2K,CAAA,CAAS,MAAMnL,CAAA,CAAKqL,KAAA,CAAMrP,QAAA,CAASiE,CAAA,CAAWoL,KAAK,CAAC;QAClE5K,CAAA,GAAY0K,CAAA,CAAS,MACzBlL,CAAA,CAAWoL,KAAA,KAAU,KAAK,KAAQ,CAACpZ,CAAA,CAAM6vC,YAAA,CAAa7hC,CAAA,CAAWoL,KAAK;QAElE3K,EAAA,GAAiBmQ,CAAA,CAAM,MAAM7Q,CAAA,CAAKqL,KAAA,CAAMna,MAAA,KAAWgN,CAAA,CAAYmN,KAAK;QACpEzK,EAAA,GAAmBiQ,CAAA,CAAM,MAAM,CAACpQ,CAAA,CAAU4K,KAAA,IAAS,CAAC7K,CAAA,CAAY6K,KAAK;QAErEnJ,EAAA,GAAYiJ,CAAA,CAAS,OAAO;UAChC42B,aAAA,EAAe9vC,CAAA,CAAM8vC,aAAA;UACrBC,gBAAA,EAAkB/vC,CAAA,CAAM+vC,gBAAA;UACxBC,MAAA,EAAA5a,CAAA;UACA6a,gBAAA,EAAkBthC,EAAA,CAAiByK,KAAA;UACnCvR,QAAA,EAAUkD,CAAA,CAAgBqO,KAAA;UAC1B82B,gBAAA,EAAkBlwC,CAAA,CAAMkwC,gBAAA;UACxBC,aAAA,EAAe9hC,CAAA,CAAc+K,KAAA;UAC7BitB,IAAA,EAAMrmC,CAAA,CAAMqmC,IAAA;UACZ+J,UAAA,EAAY;YACV,GAAGpwC,CAAA,CAAMowC,UAAA;YACTvoC,QAAA,EAAUkD,CAAA,CAAgBqO,KAAA;YAC1BitB,IAAA,EAAMrmC,CAAA,CAAMqmC,IAAA;YACZpY,EAAA,EAAI1hB,CAAA;YACJ6M,KAAA,EAAOpL;UACT;UACAqiC,aAAA,EAAe;YACbzhB,KAAA,EAAOmG,EAAA;YACPub,OAAA,EAASrb,EAAA;YACTsb,MAAA,EAAQvb;UACV;UACA4a,OAAA,EAASrjC,CAAA;UACTikC,SAAA,EAAWxwC,CAAA,CAAMwwC,SAAA;UACjBC,cAAA,EAAgBzwC,CAAA,CAAMywC,cAAA;UACtBC,WAAA,EAAatiC,CAAA,CAAYgL,KAAA;UACzBu3B,WAAA,EAAapiC,CAAA,CAAY6K,KAAA;UACzBw3B,SAAA,EAAWpiC,CAAA,CAAU4K,KAAA;UACrBy3B,cAAA,EAAgBpiC,EAAA,CAAe2K,KAAA;UAC/B03B,aAAA,EAAe9wC,CAAA,CAAM8wC,aAAA;UACrBnB,KAAA,EAAO1jC,CAAA,CAAYmN,KAAA;UACnBo2B,WAAA,EAAatkC,CAAA,CAAmBkO,KAAA;UAChC23B,WAAA,EAAa/wC,CAAA,CAAM+wC,WAAA;UACnBC,SAAA,EAAAxb,CAAA;UACAjI,QAAA,EAAU1hB,CAAA,CAAgBuN,KAAA;UAC1B63B,SAAA,EAAWjxC,CAAA,CAAMixC,SAAA;UACjBz/B,IAAA,EAAMxR,CAAA,CAAMwR,IAAA;UACZsU,KAAA,EAAOha,CAAA,CAAasN,KAAA;UACpB83B,QAAA,EAAUlxC,CAAA,CAAMkxC,QAAA;UAChBxB,QAAA,EAAU3jC,CAAA,CAAgBqN,KAAA;UAC1B+3B,cAAA,EAAgBnxC,CAAA,CAAMmxC,cAAA;UACtBC,UAAA,EAAYpxC,CAAA,CAAMoxC,UAAA;UAClBC,IAAA,EAAMtjC,CAAA,CAAKqL;QACX;MAEII,EAAA,CAAAlZ,CAAA,EAAam1B,CAAA,IAAW;QAC5B1nB,CAAA,CAAKqL,KAAA,GAAQqc,CAAA;MAAA,CACd;MAEK,MAAArB,EAAA,GAAaqB,CAAA,IAAwB;UACzC,IAAI1qB,CAAA,CAAgBqO,KAAA,EAAO;YACVqc,CAAA,CAAE31B,MAAA,CACVsmB,IAAA,CAAK;YACZ;UACF;UAEAhmB,CAAA,CAAK,WAAWq1B,CAAC;QAAA;QAGbpB,EAAA,GAAWoB,CAAA,IAAwB;UACnC1qB,CAAA,CAAgBqO,KAAA,IAASnO,CAAA,CAAoBmO,KAAA,KAIjD/M,CAAA,CAAQ+M,KAAA,GAAQ,IAChBhZ,CAAA,CAAK,SAASq1B,CAAC;QAAA;QAGXX,EAAA,GAAUW,CAAA,IAAwB;UACtCppB,CAAA,CAAQ+M,KAAA,GAAQ,IAChBhZ,CAAA,CAAK,QAAQq1B,CAAC;QAAA;QAGVV,EAAA,GAAWU,CAAA,IAA4B;;UAC3C,MAAMC,CAAA,GAAQ,OAAOD,CAAA,IAAM,WAAWA,CAAA,GAAKA,CAAA,CAAE31B,MAAA,CAA4BsZ,KAAA;UAIrE,IAFJnL,CAAA,CAAqBmL,KAAA,GAAQ,KAEzBuc,EAAA,GAAA31B,CAAA,CAAMixC,SAAA,KAAN,QAAAtb,EAAA,CAAiB5rB,QAAA,CAAS2rB,CAAA,CAAMvzB,MAAA,CAAO,CAAC,MAAMuzB,CAAA,CAAMz2B,MAAA,GAAS,GAAG;YAC9DkN,CAAA,CAAMiN,KAAA,KACRjN,CAAA,CAAMiN,KAAA,CAAMA,KAAA,GAAQ;YAEtB;UACF;UAII,IAFJpL,CAAA,CAAWoL,KAAA,GAAQsc,CAAA,GAEfG,EAAA,GAAA71B,CAAA,CAAMixC,SAAA,KAAN,QAAApb,EAAA,CAAiB9rB,QAAA,CAAS2rB,CAAA,CAAMvzB,MAAA,CAAOuzB,CAAA,CAAMz2B,MAAA,GAAS,CAAC,IAAI;YAC7Dm2B,CAAA,CAAOM,CAAA,CAAMtzB,KAAA,CAAM,GAAGszB,CAAA,CAAMz2B,MAAA,GAAS,CAAC,CAAC;YACvC;UACF;UAEUkP,CAAA,CAAAiL,KAAA,GAAQpZ,CAAA,CAAM6vC,YAAA,CAAana,CAAK,KAAK,CAACnnB,CAAA,CAAY6K,KAAA,GAAQ,CAACsc,CAAK,IAAI,IAClEtnB,CAAA,CAAAgL,KAAA,GAAQpZ,CAAA,CAAM6vC,YAAA,CAAana,CAAK,IAAI,EAAC,GAAI,CAACA,CAAK,GAC3DrnB,CAAA,CAAc+K,KAAA,GAAQ7K,CAAA,CAAY6K,KAAA,GAAQ,CAACsc,CAAK,IAAI,IAEpDt1B,CAAA,CAAK,aAAa+N,CAAA,CAAUiL,KAAA,EAAOhL,CAAA,CAAYgL,KAAA,EAAO/K,CAAA,CAAc+K,KAAK;QAAA;QAGrE4b,EAAA,GAAYS,CAAA,IAAmB;UAC/B7yB,CAAA,CAAmBwW,KAAA,KACrB2b,EAAA,CAAQU,CAAC,GAEJlnB,CAAA,CAAY6K,KAAA,IACfgc,CAAA,CAAOpnB,CAAA,CAAWoL,KAAK;QAE3B;QAGI6b,EAAA,GAAaQ,CAAA,IAA2B;UAC5C,IAAIA,CAAA,CAAE1U,GAAA,KAAQ,WAAW,CAAC/V,CAAA,CAAoBoO,KAAA,EAAO;YACnDgc,CAAA,CAAOpnB,CAAA,CAAWoL,KAAK;YACvB;UACF;UAEA,CACGqc,CAAA,CAAE1U,GAAA,KAAQ,eAAe0U,CAAA,CAAE1U,GAAA,KAAQ,aACpChY,CAAA,CAAsBqQ,KAAA,IACtBpL,CAAA,CAAWoL,KAAA,KAAU,MACrBnL,CAAA,CAAqBmL,KAAA,IACrBrL,CAAA,CAAKqL,KAAA,CAAMna,MAAA,GAAS,IAEpBu2B,CAAA,CAAUznB,CAAA,CAAKqL,KAAA,CAAMrL,CAAA,CAAKqL,KAAA,CAAMna,MAAA,GAAS,CAAC,CAAC,IAE3CgP,CAAA,CAAqBmL,KAAA,GAAQ;QAC/B;MAGF4H,EAAA,CAAYiU,EAAA,EAAW;QAACn1B,MAAA,EAAQqM;MAAM;MAEhC,MAAA+oB,CAAA,GAAYhc,CAAA,CAAS,MAAM;UAC3B,IAAClZ,CAAA,CAAMixC,SAAA,EAIJ,cAAOjxC,CAAA,CAAMixC,SAAA,IAAc,WAAWjxC,CAAA,CAAMixC,SAAA,GAAYjxC,CAAA,CAAMixC,SAAA,CAAUtpC,IAAA,CAAK,EAAE;QAAA,CACvF;QAEKwtB,CAAA,GAAkBjc,CAAA,CAAS,MAAM;UACjC,IAACgc,CAAA,CAAU9b,KAAA,EAIf,OAAO,IAAIqB,MAAA,CAAO,IAAInY,EAAA,CAAkB4yB,CAAA,CAAU9b,KAAK,CAAC,IAAI;QAAA,CAC7D;QAEKgc,CAAA,GAAUK,CAAA,IAAuB;UAC9BA,CAAA,IAAAA,CAAA,IAAOznB,CAAA,CAAWoL,KAAA,EAAOlX,IAAA,CAAK;UAErC,MAAMwzB,CAAA,GAAUP,CAAA,CAAgB/b,KAAA,GAC5Bqc,CAAA,CAAI/yB,KAAA,CAAMyyB,CAAA,CAAgB/b,KAAK,EAAE3O,GAAA,CAAKyoB,EAAA,IAAMA,EAAA,CAAEhxB,IAAA,EAAM,IACpD,CAACuzB,CAAG;YACFE,EAAA,GAAsB;UAE5B,WAAWzC,EAAA,IAAUwC,CAAA,EACf,MAAAxC,EAAA,KAAW,MAAM3kB,CAAA,CAAY6K,KAAA,IAAS,CAACpZ,CAAA,CAAM6vC,YAAA,CAAa3c,EAAM,IAIhE;YAAA,IAAAjnB,CAAA,CAAYmN,KAAA,IAAS3K,EAAA,CAAe2K,KAAA,EACtC;YAGFuc,EAAA,CAAU3lB,IAAA,CAAKkjB,EAAM;UAAA;UAGvB,MAAM2C,EAAA,GAAW,CAAC,GAAGv1B,CAAA,CAAW8Y,KAAA,EAAO,GAAGuc,EAAS;UACnD3nB,CAAA,CAAWoL,KAAA,GAAQ,IACnBnL,CAAA,CAAqBmL,KAAA,GAAQ,IAC7B9Y,CAAA,CAAW8Y,KAAA,GAAQyc,EAAA,EACnBz1B,CAAA,CAAK,SAASy1B,EAAQ,GACtBxpB,CAAA,CAAQ+M,KAAA,GAAQ;QAAA;QAGZoc,CAAA,GAAaC,CAAA,IAAuB;UACxC,MAAMC,CAAA,GAAW3nB,CAAA,CAAKqL,KAAA,CAAMtR,OAAA,EAAQ2tB,CAAA,oBAAAA,CAAA,CAAKr0B,QAAA,OAAc,EAAE;UACzD8M,CAAA,CAAekL,KAAA,GAAQrL,CAAA,CAAKqL,KAAA,CAAMuS,MAAA,CAAO+J,CAAA,EAAU,CAAC,EAAEt0B,QAAA,IACtDd,CAAA,CAAW8Y,KAAA,GAAQrL,CAAA,CAAKqL,KAAA;QAAA;MAIb,OAAAza,CAAA;QACXynB,IAAA,EAAMA,CAAA,KAAM;UACV/Z,CAAA,CAAQ+M,KAAA,GAAQ;QAClB;QACAjM,OAAA,EAAShB,CAAA;QACTpH,KAAA,EAAOA,CAAA,KAAM;UACXsH,CAAA,CAAQ+M,KAAA,GAAQ;QAClB;MAAA,CACD,IAAAqc,CAAA,EAAAC,CAAA,MAAAa,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MClbD,MAAMx2B,CAAA,GAAQqB,CAAA;QAuCRjB,CAAA,GAAOxB,CAAA;QAUP;UAACgwB,KAAA,EAAAtuB,CAAA;UAAOuuB,UAAA,EAAAruB,CAAA;UAAYsuB,mBAAA,EAAAlsB,CAAA;UAAqBmsB,OAAA,EAAAjkB,CAAA;UAASkkB,QAAA,EAAAjkB,CAAA;UAAUkkB,MAAA,EAAAjkB,CAAA;UAAQjG,KAAA,EAAAkG,CAAA;UAAOmb,IAAA,EAAAlb;QAAI,IACnF6iB,EAAA,CAAa/tB,CAAA,EAAOI,CAAI;QAEpB2I,CAAA,GAAkBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDgE,CAAA,GAAkBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMutB,QAAQ;QACpDzhB,CAAA,GAAkBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAMmrC,QAAQ;QACpDp/B,CAAA,GAAmBif,CAAA,CAAc,MAAMhrB,CAAA,CAAMorC,SAAS;QACtDn/B,CAAA,GAAkB+e,CAAA,CAAc,MAAMhrB,CAAA,CAAMsxC,QAAQ;QACpDplC,CAAA,GAAe8e,CAAA,CAAc,MAAMhrB,CAAA,CAAM8lB,KAAK;QAE9C3Z,CAAA,GAAaygB,EAAA,CAAc1gB,CAAY;QAEvCG,CAAA,GAAkB6M,CAAA,CAAS,MAAM,CACrC/M,CAAA,CAAWiN,KAAA,EACX;UACE,gBAAgB,CAACpZ,CAAA,CAAMorC,SAAA;UACvB,0BAA0BprC,CAAA,CAAMorC,SAAA;UAChC,CAAC,gBAAgBprC,CAAA,CAAMwR,IAAI,EAAE,GAAG,CAAC,CAACxR,CAAA,CAAMwR;QAC1C,EACD;QAEKjF,CAAA,GAAiB2M,CAAA,CAAwB,OAAO;UACpDq4B,MAAA,EAAQtlC,CAAA,CAAgBmN,KAAA,GAAQ,SAAS;QACzC;MAEW,OAAAza,CAAA;QACXynB,IAAA,EAAAlb,CAAA;QACAiC,OAAA,EAAS7M,CAAA;QACTyE,KAAA,EAAAkG;MAAA,CACD,IAAA8C,CAAA,EAAAC,CAAA,MAAAuoB,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpFD,MAAM73B,CAAA,GAAQ0C,CAAA;QA8BRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,eAAeva,CAAA,CAAM6S,IAAI,EAAE,GAAG7S,CAAA,CAAM6S,IAAA,KAAS;QAC9C;QACIxR,CAAA,GAAY4e,CAAA,CAAM,MAAM,CAAC,CAACjgB,CAAA,CAAMm+B,MAAA,IAAU,CAAC,CAACn+B,CAAA,CAAM6yC,UAAU;QAC5DpxC,CAAA,GAAawe,CAAA,CAAM,MAAM,CAAC,CAACjgB,CAAA,CAAM8yC,OAAA,IAAW,CAAC,CAAC9yC,CAAA,CAAM+yC,WAAW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC9CrE,MAAM/yC,CAAA,GAAQ0C,CAAA;QASRzC,CAAA,GAAgBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMgzC,MAAM;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCTtD,MAAMhzC,CAAA,GAAQ0C,CAAA;QAoBRzC,CAAA,GAAeosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM8a,KAAK;QAC9CzZ,CAAA,GAAkBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMizC,QAAQ;QACpDxxC,CAAA,GAAqB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMq8B,UAAU;QAEzD16B,CAAA,GAAkB4Y,CAAA,CAAS,MAAM;UACrC,MAAMtW,CAAA,GAAahE,CAAA,CAAawa,KAAA,GAAQ,KAAQhZ,CAAA,CAAmBgZ,KAAA;UAC5D;YACL,oBAAoBxa,CAAA,CAAawa,KAAA;YACjC,yBAAyBxW,CAAA,KAAe;YACxC,CAAC,yBAAyBA,CAAU,EAAE,GAAG,OAAOA,CAAA,IAAe;YAC/D,uBAAuB5C,CAAA,CAAgBoZ;UAAA;QACzC,CACD;QACK5Y,CAAA,GAAcoe,CAAA,CAAM,MAAO5e,CAAA,CAAgBoZ,KAAA,KAAU,KAAO,OAAOza,CAAA,CAAM0/B,GAAI;MAEnF,OAAAxD,EAAA,CAAQ3B,EAAA,EAAuB;QAC7B0Y,QAAA,EAAU5xC;MAAA,CACX,IAAA4C,CAAA,EAAAkI,CAAA,MAAAyrB,CAAA,IAAAztB,CAAA,CAAAk3B,EAAA,CAAAx/B,CAAA,CAAA4Y,KAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC1BD,MAAMza,CAAA,GAAQ0C,CAAA;QA2CRzC,CAAA,GAAQ88B,EAAA;QAER17B,CAAA,GAAa27B,EAAA,CAAOzC,EAAA,EAAuB,IAAI;QAE/C94B,CAAA,GAAgB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkzC,MAAM;QAChDvxC,CAAA,GAAgB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo4B,MAAM;QAChDv2B,CAAA,GAAgBwqB,CAAA,CAAc,MAAMrsB,CAAA,CAAMouB,MAAM;QAChDnqB,CAAA,GAAkBooB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkJ,QAAQ;QAEpD;UAAC0jB,YAAA,EAAAzgB;QAAA,IAAgBqgB,EAAA,CAAexsB,CAAK;QAErCoM,CAAA,GAAS6T,CAAA,CAAM,MAAM,CAACpe,CAAA,CAAc4Y,KAAA,IAAStO,CAAA,CAAasO,KAAK;QAC/DpO,CAAA,GAAc4T,CAAA,CAAM,MACxB5e,CAAA,YAAAA,CAAA,CAAY4xC,QAAA,CAASx4B,KAAA,GACjB,OACA5Y,CAAA,CAAc4Y,KAAA,GACd,WACCrO,CAAA,CAAOqO,KAAA,GAERwjB,EAAA,GADAj+B,CAAA,CAAM0/B,GACN;QAGApzB,CAAA,GAAWiO,CAAA,CACf,MACE9Y,CAAA,CAAcgZ,KAAA,IACdrO,CAAA,CAAOqO,KAAA,IACP5Y,CAAA,CAAc4Y,KAAA,IACd,CAAC,KAAK,eAAe,UAAU,QAAQ,EAAErP,QAAA,CAASpL,CAAA,CAAM0/B,GAAG;QAGzDnzB,CAAA,GAAkBgO,CAAA,CAAS,OAAO;UACtC,CAAC,mBAAmBva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY,QAAQrtB,CAAA,CAAMqtB,OAAA,KAAY;UAClF,0BAA0B/gB,CAAA,CAASmO,KAAA;UACnC2d,MAAA,EAAUz2B,CAAA,CAAc8Y,KAAA;UACxBvR,QAAA,EAAYjF,CAAA,CAAgBwW;QAC5B;QAEIrQ,CAAA,GAAgBmQ,CAAA,CAAS,MAAM;UACnC,MAAMrN,CAAA,GAAa;UACnB,OAAIrL,CAAA,CAAc4Y,KAAA,MACZ,CAACxa,CAAA,IAAS,CAACA,CAAA,CAAM4oB,IAAA,MAEnB3b,CAAA,CAAW2b,IAAA,GAAO,WAEhB5kB,CAAA,CAAgBwW,KAAA,KAElBvN,CAAA,CAAWhE,QAAA,GAAW,MAGnBgE,CAAA;QAAA,CACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC/ED,MAAMjN,CAAA,GAAQyC,CAAA;QAgDRrB,CAAA,GAAOrB,CAAA;QAaPyB,CAAA,GAAiB;UAACgJ,GAAA,EAAK;UAAGH,IAAA,EAAM;UAAGE,MAAA,EAAQ;UAAGD,KAAA,EAAO;QAAA;QAErD5I,CAAA,GAAe0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMkzC,KAAK;QAC9CtxC,CAAA,GAAmBwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMmzC,SAAS;QACtDnvC,CAAA,GAAkBooB,CAAA,CAAc,MAAMpsB,CAAA,CAAMozC,QAAQ;QACpDlnC,CAAA,GAAgBkgB,CAAA,CAAc,MAAMpsB,CAAA,CAAM6jC,MAAM;QAChD13B,CAAA,GAAcigB,CAAA,CAAc,MAAMpsB,CAAA,CAAM4yB,IAAI;QAC5CxmB,CAAA,GAAsBggB,CAAA,CAAc,MAAMpsB,CAAA,CAAMqzC,YAAY;QAC5DhnC,CAAA,GAAiB+f,CAAA,CAAc,MAAMpsB,CAAA,CAAMozB,OAAO;QAClD9mB,CAAA,GAAoB8f,CAAA,CAAc,MAAMpsB,CAAA,CAAMqzB,UAAU;QACxDlpB,CAAA,GAAuBiiB,CAAA,CAAc,MAAMpsB,CAAA,CAAMszB,aAAa;QAC9DrmB,CAAA,GAAsBmf,CAAA,CAAc,MAAMpsB,CAAA,CAAMuzB,YAAY;QAC5DrmB,CAAA,GAAoBkf,CAAA,CAAc,MAAMpsB,CAAA,CAAMwzB,UAAU;QAExDrmB,CAAA,GAAuB+lB,EAAA,CAAwB,OAAO;UAC1DE,OAAA,EAAS/mB,CAAA,CAAemO,KAAA;UACxB6Y,UAAA,EAAY/mB,CAAA,CAAkBkO,KAAA;UAC9B8Y,aAAA,EAAenpB,CAAA,CAAqBqQ,KAAA;UACpC+Y,YAAA,EAActmB,CAAA,CAAoBuN,KAAA;UAClCgZ,UAAA,EAAYtmB,CAAA,CAAkBsN;QAC9B;QAEInN,CAAA,GAAkB2S,CAAA,CAAM,MAC5BhgB,CAAA,CAAMotB,OAAA,KAAY,QAAQ,CAACptB,CAAA,CAAMszC,OAAA,GAAU,MAAMtzC,CAAA,CAAMotB,OAAO,KAAK;QAG/D9f,CAAA,GAAmB0S,CAAA,CAAM,MAAO7T,CAAA,CAAYqO,KAAA,GAAQ,KAAO,IAAK;QAEhEjN,CAAA,GAAe+M,CAAA,CAAS,OAAO;UACnCsO,IAAA,EAAM5oB,CAAA,CAAMuzC,WAAA;UACZnmB,OAAA,EAASptB,CAAA,CAAMwzC,cAAA;UACfz2B,KAAA,EAAO3Q,CAAA,CAAoBoO;QAC3B;QAEI/M,CAAA,GAAgB6M,CAAA,CAAS,OAAO;UACpC,GAAG9Y,CAAA;UACHiyC,MAAA,EAAQzzC,CAAA,CAAMyzC,MAAA,IAAU;QACxB;QAEI9lC,CAAA,GAAiB2M,CAAA,CAAS,OAAO;UACrC,qBAAqB,CAACpO,CAAA,CAAcsO,KAAA,IAAS,CAAC9Y,CAAA,CAAa8Y,KAAA;UAC3D,kBAAkBtO,CAAA,CAAcsO,KAAA,IAAS9Y,CAAA,CAAa8Y;QACtD;QAEIrL,CAAA,GAAcmL,CAAA,CAAS,MAAM,CAACjN,CAAA,CAAgBmN,KAAA,EAAOrN,CAAA,CAAqBqN,KAAK,CAAC;QAEhFpL,CAAA,GAAakL,CAAA,CAAS,OAAO;UACjC,GAAG9Y,CAAA;UACHqlB,OAAA,EAAS7mB,CAAA,CAAM6mB,OAAA;UACf6sB,eAAA,EAAiB1zC,CAAA,CAAMszC,OAAA,IAAW;UAClC9+B,cAAA,EAAgBxU,CAAA,CAAMwnB,IAAA,GAAO,QAAQxnB,CAAA,CAAMwnB,IAAI,MAAM;QACrD;QAEInY,CAAA,GAAoBiL,CAAA,CAAS,MACjCtW,CAAA,CAAgBwW,KAAA,GACZhZ,CAAA,GACA;UACEgJ,GAAA,EAAK;UACLH,IAAA,EAAM;UACNgK,SAAA,EAAW;QACb;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EC6WAs/B,EAAA,GAA2B;EAAAC,EAAA,kBAAAxf,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAjYjC,MAAMhzB,CAAA,GAAQqB,CAAA;QAiHRjB,CAAA,GAAOxB,CAAA;QAqBP0B,CAAA,GAAQo8B,EAAA;QAmBRl8B,CAAA,GAAaotB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,OAAO;QAE1CrrB,CAAA,GAAawnB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEsH,CAAA,GAAckgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMyyC,IAAI;QAC5C1nC,CAAA,GAAcigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMmuB,IAAI;QAC5CnjB,CAAA,GAAwBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM0yC,cAAc;QAChEznC,CAAA,GAAkB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM2yC,QAAQ;QACpDznC,CAAA,GAAsB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAM4yC,YAAY;QAC5D7pC,CAAA,GAAoBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6yC,UAAU;QACxDhnC,CAAA,GAAoBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAM8yC,UAAU;QACxDhnC,CAAA,GAAyBkf,CAAA,CAAc,MAAMhrB,CAAA,CAAM+yC,eAAe;QAClEhnC,CAAA,GAAoBif,CAAA,CAAcpoB,CAAU;QAC5CqJ,CAAA,GAA2B+e,CAAA,CAAc,MAAMhrB,CAAA,CAAMgzC,iBAAiB;QACtE9mC,CAAA,GAAsB8e,CAAA,CAAc,MAAMhrB,CAAA,CAAMizC,YAAY;QAC5D9mC,CAAA,GAAgB6e,CAAA,CAAc,MAAMhrB,CAAA,CAAM0zB,MAAM;QAChDrnB,CAAA,GAAmB2e,CAAA,CAAc,MAAMhrB,CAAA,CAAMkzC,SAAS;QACtD3mC,CAAA,GAAoBye,CAAA,CAAc,MAAMhrB,CAAA,CAAMmzC,UAAU;QACxDplC,CAAA,GAAgBid,CAAA,CAAc,MAAMhrB,CAAA,CAAMozC,MAAM;QAChDplC,CAAA,GAAoBgd,CAAA,CAAc,MAAMhrB,CAAA,CAAMqzC,UAAU;QACxDplC,CAAA,GAAqB+c,CAAA,CAAc,MAAMhrB,CAAA,CAAMszC,WAAW;QAC1DplC,CAAA,GAA0B8c,CAAA,CAAc,MAAMhrB,CAAA,CAAMuzC,gBAAgB;QACpEplC,CAAA,GAAuB6c,CAAA,CAAc,MAAMhrB,CAAA,CAAMwzC,aAAa;QAC9DplC,CAAA,GAAqB4c,CAAA,CAAc,MAAMhrB,CAAA,CAAMyzC,UAAU;QAEzDplC,CAAA,GAAUgL,CAAA,CAAwB,IAAI;QACtC/K,CAAA,GAAW+K,CAAA,CAAwB,IAAI;QACvC9K,CAAA,GAAe8K,CAAA,CAAwB,IAAI;QAC3C7K,CAAA,GAAc6K,CAAA,CAAwB,IAAI;QAC1C5K,EAAA,GAAW4K,CAAA,CAAItN,CAAA,CAAkBqN,KAAK;QACtCzK,EAAA,GAAoB0K,CAAA,CAAI,EAAK;MAEnC2H,EAAA,CACE,UACA,MAAM;QACJuT,CAAA,CAAK,KAAK;MACZ,GACA;QAACz0B,MAAA,EAAQuO;MAAO,IAElBgkB,EAAA,CAAkBtmB,CAAA,EAAmBoC,CAAoB;MACzD,MAAM;UAACkY,OAAA,EAASpW;QAAA,IAAciW,EAAA,CAAS7X,CAAA,EAAS;UAC9CmW,YAAA,EAAczY,CAAA,CAAkBqN,KAAA,IAASpZ,CAAA,CAAM0zC,eAAA,KAAoB;QAAA,CACpE;QACK;UAACrtB,OAAA,EAAS+N;QAAA,IAAiBlO,EAAA,CAAS5X,CAAA,EAAU;UAClDkW,YAAA,EAAczY,CAAA,CAAkBqN,KAAA,IAASpZ,CAAA,CAAM0zC,eAAA,KAAoB;QAAA,CACpE;QACK;UAACrtB,OAAA,EAASgO;QAAA,IAAqBnO,EAAA,CAAS3X,CAAA,EAAc;UAC1DiW,YAAA,EAAczY,CAAA,CAAkBqN,KAAA,IAASpZ,CAAA,CAAM0zC,eAAA,KAAoB;QAAA,CACpE;QACK;UAACrtB,OAAA,EAASyO;QAAA,IAAoB5O,EAAA,CAAS1X,CAAA,EAAa;UACxDgW,YAAA,EAAczY,CAAA,CAAkBqN,KAAA,IAASpZ,CAAA,CAAM0zC,eAAA,KAAoB;QAAA,CACpE;QAEK3e,EAAA,GAAe7b,CAAA,CAAS,MAAM,CAClClZ,CAAA,CAAM2zC,UAAA,EACN;UACEte,IAAA,EAAM,CAAClpB,CAAA,CAAciN,KAAA;UACrBoY,IAAA,EAAM/iB,EAAA,CAAS2K;QACjB,EACD;QAEK4b,EAAA,GAAcpW,CAAA,CAClB,MACE7T,CAAA,CAAYqO,KAAA,KAAU,MACrBrO,CAAA,CAAYqO,KAAA,KAAU,MAAQzK,EAAA,CAAkByK,KAAA,KAAU,MAC1DrO,CAAA,CAAYqO,KAAA,KAAU,MAAQrN,CAAA,CAAkBqN,KAAA,KAAU;QAGzD6b,EAAA,GAA0BrW,CAAA,CAAM,MACpC5e,CAAA,CAAM4zC,eAAA,KAAoB,SACtB5zC,CAAA,CAAM4zC,eAAA,GACN1oC,CAAA,CAAoBkO,KAAA,GACpB,gBACA;QAGA8b,CAAA,GAAqBtW,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYlF,CAAA,CAAM,cAAc,CAAC,CAAC;QAEpE60B,CAAA,GAAqBjc,CAAA,CAAS,MAAM,CACxClZ,CAAA,CAAM6zC,WAAA,EACN;UACE,oBAAoBzlC,CAAA,CAAmBgL,KAAA,KAAU;UACjD,CAAC,oBAAoBhL,CAAA,CAAmBgL,KAAK,OAAO,GAClD,OAAOhL,CAAA,CAAmBgL,KAAA,IAAU;UACtC,CAAC,SAASpZ,CAAA,CAAMwR,IAAI,EAAE,GAAGxR,CAAA,CAAMwR,IAAA,KAAS;UACxC,yBAAyBvG,CAAA,CAAgBmO,KAAA;UACzC,2BAA2BpL,CAAA,CAAkBoL;QAC/C,EACD;QAEKgc,CAAA,GAAwBrJ,EAAA,CAAuB,OAAO;UAC1DG,SAAA,EAAWlsB,CAAA,CAAM8zC,aAAA;UACjB7nB,WAAA,EAAajsB,CAAA,CAAM+zC,eAAA;UACnB/nB,OAAA,EAAShsB,CAAA,CAAMg0C;QACf;QAEIxe,CAAA,GAActc,CAAA,CAAS,MAAM,CAAClZ,CAAA,CAAMi0C,SAAA,EAAW7e,CAAA,CAAsBhc,KAAK,CAAC;QAE3Eqc,CAAA,GAA0B1J,EAAA,CAAuB,OAAO;UAC5DG,SAAA,EAAWlsB,CAAA,CAAMk0C,eAAA;UACjBjoB,WAAA,EAAajsB,CAAA,CAAMm0C,iBAAA;UACnBnoB,OAAA,EAAShsB,CAAA,CAAMqlC;QACf;QAEI3P,CAAA,GAAgBxc,CAAA,CAAS,MAAM,CACnClZ,CAAA,CAAMolC,WAAA,EACN3P,CAAA,CAAwBrc,KAAA,EACxB;UACE,CAAC,UAAUpZ,CAAA,CAAMo0C,mBAAmB,EAAE,GAAGp0C,CAAA,CAAMo0C,mBAAA,KAAwB;QACzE,EACD;QAEKze,EAAA,GAAmBzc,CAAA,CAAS,OAAO;UACvC8S,OAAA,EAASkJ,CAAA,CAAmB9b,KAAA,GAAQpZ,CAAA,CAAMq0C,kBAAA,GAAqB;UAC/D5Y,KAAA,EAAOz7B,CAAA,CAAMs0C;QACb;QAEIze,EAAA,GAA0B9J,EAAA,CAAuB,OAAO;UAC5DG,SAAA,EAAWlsB,CAAA,CAAMu0C,eAAA;UACjBtoB,WAAA,EAAajsB,CAAA,CAAMw0C,iBAAA;UACnBxoB,OAAA,EAAShsB,CAAA,CAAMy0C;QACf;QAEIvhB,EAAA,GAAgBha,CAAA,CAAS,MAAM,CACnClZ,CAAA,CAAM00C,WAAA,EACN7e,EAAA,CAAwBzc,KAAA,EACxB;UACE,CAAC,UAAUpZ,CAAA,CAAM20C,mBAAmB,EAAE,GAAG30C,CAAA,CAAM20C,mBAAA,KAAwB;QACzE,EACD;QAEKxhB,EAAA,GAAeja,CAAA,CAAS,MAAM,CAClClZ,CAAA,CAAM40C,UAAA,EACN;UACG,mBAAoB3mC,CAAA,CAAmBmL;QAC1C,EACD;QACK6c,EAAA,GAAgBrX,CAAA,CAAM,MAAM5T,CAAA,CAAsBoO,KAAA,IAAStO,CAAA,CAAYsO,KAAK;QAC5E8c,EAAA,GAAYtX,CAAA,CAAM,MAAMrS,CAAA,CAAkB6M,KAAA,IAAStO,CAAA,CAAYsO,KAAK;QAEpEgd,EAAA,GAAwBR,CAC5Bif,EAAA,EACAC,EAAA,GAAoC,OAEpC,IAAI/0C,EAAA,CAAmB80C,EAAA,EAAM;UAC3Bt1C,UAAA,EAAY;UACZO,MAAA,EAAQuO,CAAA,CAAQ+K,KAAA,IAAS;UACzBvZ,aAAA,EAAe;UACfI,OAAA,EAAS;UACT,GAAG60C,EAAA;UACHn1C,WAAA,EAAaa,CAAA,CAAW4Y;QAAA,CACzB;MAEGI,EAAA,CAAAzN,CAAA,EAAmB,CAAC8oC,EAAA,EAAUC,EAAA,KAAa;QAC3CD,EAAA,KAAaC,EAAA,KACbD,EAAA,KAAa,KACRrgB,EAAA,KAEFD,CAAA;MACP,CACD;MAEK,MAAAA,CAAA,GAAOlkB,CAACwkC,EAAA,GAAU,OAAO;UAC7B,IACGA,EAAA,KAAY,cAAc5oC,CAAA,CAAyBmN,KAAA,IACnDy7B,EAAA,KAAY,SAAS3oC,CAAA,CAAoBkN,KAAA,EAC1C;YACAhZ,CAAA,CAAK,gBAAgB;YACrB;UACF;UAEM,MAAA00C,EAAA,GAAQ1e,EAAA,CAAsB,QAAQ;YAAC72B,UAAA,EAAYs1C,EAAA,KAAY;YAAI50C,OAAA,EAAA40C;UAAA,CAAQ;UAajF,IAXIA,EAAA,KAAY,QACdz0C,CAAA,CAAKy0C,EAAA,EAASC,EAAK,GAEjBD,EAAA,KAAY,YACdz0C,CAAA,CAAKy0C,EAAA,EAASC,EAAK,GAEjBD,EAAA,KAAY,WACdz0C,CAAA,CAAKy0C,EAAA,EAASC,EAAK,GAErB10C,CAAA,CAAK,QAAQ00C,EAAK,GAEdA,EAAA,CAAMt1C,gBAAA,EAAkB;YAC1BY,CAAA,CAAK,gBAAgB,GAChBwC,CAAA,CAAWwW,KAAA,KAAOxW,CAAA,CAAWwW,KAAA,GAAQ;YAC1C;UACF;UACIxW,CAAA,CAAWwW,KAAA,KAAOxW,CAAA,CAAWwW,KAAA,GAAQ;QAAA;QAKrCob,EAAA,GAASugB,CAAA,KAAM;UACnB,MAAMF,EAAA,GAAQze,EAAA,CAAsB,QAAQ;YAAC72B,UAAA,EAAY;UAAA,CAAK;UAE9D,IADAa,CAAA,CAAK,QAAQy0C,EAAK,GACdA,EAAA,CAAMr1C,gBAAA,EAAkB;YACtBoD,CAAA,CAAWwW,KAAA,KAAOxW,CAAA,CAAWwW,KAAA,GAAQ,KACzChZ,CAAA,CAAK,gBAAgB;YACrB;UACF;UACKwC,CAAA,CAAWwW,KAAA,KAAOxW,CAAA,CAAWwW,KAAA,GAAQ;QAAA;QAGtCsb,EAAA,GAAgBsgB,CAAA,KAAM;UACtB3oC,CAAA,CAAiB+M,KAAA,KAAU,OAC/BpZ,CAAA,CAAM0zC,eAAA,KAAoB,OACrBtf,EAAA,CAAchb,KAAA,GAAQ,KACvBpZ,CAAA,CAAM0zC,eAAA,KAAoB,UACzB5e,EAAA,CAAiB1b,KAAA,GAAQ,KAC1BpZ,CAAA,CAAM0zC,eAAA,KAAoB,WACzBrf,EAAA,CAAkBjb,KAAA,GAAQ,KAC1BnJ,EAAA,CAAWmJ,KAAA,GAAQ;QAAA;QAGpBub,EAAA,GAAgBsgB,CAAA,KAAMzgB,EAAA;QACtBuB,EAAA,GAAemf,CAAA,KAAM;UACzBzmC,EAAA,CAAS2K,KAAA,GAAQ,IACHsb,EAAA,IACTt0B,CAAA,UAASg2B,EAAA,CAAsB,OAAO,CAAC,GACxCrrB,CAAA,CAAYqO,KAAA,KAAU,OAAMzK,EAAA,CAAkByK,KAAA,GAAQ;QAAA;QAEtD4c,EAAA,GAAUmf,CAAA,KAAM;UACpB1mC,EAAA,CAAS2K,KAAA,GAAQ;QAAA;QAEbg8B,EAAA,GAAenS,CAAA,KAAM;UACpB7iC,CAAA,WAAUg2B,EAAA,CAAsB,QAAQ,CAAC,GAC1CrrB,CAAA,CAAYqO,KAAA,KAAU,OAAMzK,EAAA,CAAkByK,KAAA,GAAQ;QAAA;QAGtD;UAAC6X,cAAA,EAAAokB,EAAA;UAAgBjkB,gBAAA,EAAAkkB;QAAgB,IAAIxkB,EAAA,CAAgBriB,EAAQ;QAE7D8mC,EAAA,GAAiBr8B,CAAA,CAAwB,OAAO;UAAA;UAAA;UAAA;UAAA;UAKpD,WAAWzK,EAAA,CAAS2K,KAAA,GAChBm5B,EAAA,IAA4B+C,EAAA,CAAiBl8B,KAAA,GAAQi8B,EAAA,CAAej8B,KAAA,IACpEm5B;QACJ;MAEetyB,EAAA,CAAA5R,CAAA,EAAS,aAAa,MAAM;QACzBtC,CAAA,CAAAqN,KAAA,GAAQmb,CAAA,CAAK,IAAIC,EAAA,CAAO;MAAA,CAC3C;MAED,MAAMghB,EAAA,GAA+B/rB,EAAA,CAAS;QAC5CgsB,MAAA,EAAQA,CAAA,KAAM;UACZlhB,CAAA,CAAK,QAAQ;QACf;QACA+G,KAAA,EAAOA,CAAA,KAAM;UACX/G,CAAA,CAAK,OAAO;QACd;QACAlkB,IAAA,EAAAkkB,CAAA;QACAmhB,EAAA,EAAIA,CAAA,KAAM;UACRnhB,CAAA,CAAK,IAAI;QACX;QACA2G,OAAA,EAASnvB;MAAA,CACV;MAEY,OAAApN,CAAA;QACX0R,IAAA,EAAAkkB,CAAA;QACAtG,EAAA,EAAIztB,CAAA;QACJgxB,IAAA,EAAMgD;MAAA,CACP,IAAAqgB,EAAA,EAAAC,EAAA,MAAAve,CAAA,IAAAztB,CAAA,CAAAg9B,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCjiBD,MAAMnnC,CAAA,GAAQ0C,CAAA;QAgCRzC,CAAA,GAAoBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMg3C,UAAU;QACxD31C,CAAA,GAAcgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkwC,IAAI;QAC5CzuC,CAAA,GAAmB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMi3C,SAAS;QACtDt1C,CAAA,GAAe0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMk3C,KAAK;QAC9Cr1C,CAAA,GAAewqB,CAAA,CAAc,MAAMrsB,CAAA,CAAMgd,KAAK;QAC9C/Y,CAAA,GAAcooB,CAAA,CAAc,MAAMrsB,CAAA,CAAMm3C,IAAI;QAC5ChrC,CAAA,GAAkBkgB,CAAA,CAAc,MAAMrsB,CAAA,CAAMyhC,QAAQ;QACpDr1B,CAAA,GAAY8f,EAAA,CAAa,MAAMlsB,CAAA,CAAM+iC,KAAK;QAC1C12B,CAAA,GAAmBggB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo3C,SAAS;QAEtD9qC,CAAA,GAAkBiO,CAAA,CAAS,OAAO;UACtC,YAAYtW,CAAA,CAAYwW,KAAA;UACxB,aAAa9Y,CAAA,CAAa8Y,KAAA,IAAS,CAACxW,CAAA,CAAYwW,KAAA;UAChD,oBAAoB,CAACtO,CAAA,CAAgBsO,KAAA,IAASxa,CAAA,CAAkBwa,KAAA,IAASxW,CAAA,CAAYwW,KAAA;UACrF,qBACE,CAACtO,CAAA,CAAgBsO,KAAA,IAASxa,CAAA,CAAkBwa,KAAA,IAAS9Y,CAAA,CAAa8Y,KAAA,IAAS,CAACxW,CAAA,CAAYwW,KAAA;UAC1F,eAAetO,CAAA,CAAgBsO,KAAA;UAC/B,YAAY,CAACtO,CAAA,CAAgBsO,KAAA,IAASpZ,CAAA,CAAYoZ,KAAA;UAClD,iBAAiB,CAACtO,CAAA,CAAgBsO,KAAA,IAAShZ,CAAA,CAAiBgZ,KAAA;UAC5D,CAACrO,CAAA,CAAUqO,KAAK,GAAG,CAACtO,CAAA,CAAgBsO,KAAA,IAASza,CAAA,CAAM+iC,KAAA,KAAU;UAC7D/lB,KAAA,EAASnb,CAAA,CAAa4Y,KAAA;UACtB,iBAAiBpO,CAAA,CAAiBoO;QAClC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCvBF,MAAMxa,CAAA,GAAOD,CAAA;QASPqB,CAAA,GAAaI,CAAA,IAAa;UAC9BxB,CAAA,CAAK,UAAUwB,CAAC;QAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCzBlB,MAAMxB,CAAA,GAAQyC,CAAA;QAmCRrB,CAAA,GAAOrB,CAAA;QAIPyB,CAAA,GAAkB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QAEpDvH,CAAA,GAAoB4Y,CAAA,CAAS,MACjCoS,EAAA,CAAK1sB,CAAA,EAAO,CACV,UACA,eACA,UACA,YACA,QACA,QACA,WACA,gBACA,OACA,WACA,uBACA,UACA,MACA,mBACA,wBACA,oBACA,yBACA,oBACA,UACD;MAEH,OAAA0B,CAAA,CAAkB8Y,KAAA,CAAMosB,WAAA,GAAAhlC,CAAA,EAAAoC,CAAA,MAAA2zB,CAAA,IAAAC,CAAA,OAAAwf,EAAA,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCxDxB,MAAMh2C,CAAA,GAAQqB,CAAA;QAwCRjB,CAAA,GAAOxB,CAAA;QAoBP0B,CAAA,GAAW+Y,CAAA,CAA2C,IAAI;QAE1D7Y,CAAA,GAAQ86B,CAAA,KAAM;;UAClB,CAAAvwB,CAAA,GAAAzK,CAAA,CAAS8Y,KAAA,KAAT,QAAArO,CAAA,CAAgBuwB,KAAA;QAAM;QAElB14B,CAAA,GAAOuW,CAAA,KAAM;;UACjB,CAAApO,CAAA,GAAAzK,CAAA,CAAS8Y,KAAA,KAAT,QAAArO,CAAA,CAAgBoO,IAAA;QAAK;MAMV,OAAAxa,CAAA;QACX28B,KAAA,EAAA96B,CAAA;QACA2Y,IAAA,EAAAvW,CAAA;QACAytB,MAAA,EAPaA,CAAA,KAAM;;UACnB,CAAAtlB,CAAA,GAAAzK,CAAA,CAAS8Y,KAAA,KAAT,QAAArO,CAAA,CAAgBslB,MAAA;QAAO;MAMvB,CACD,IAAAtlB,CAAA,EAAAC,CAAA,MAAAurB,CAAA,IAAAC,CAAA,OAAAyf,EAAA,G;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MChGD,MAAMt3C,CAAA,GAAQ0C,CAAA;QA4BRzC,CAAA,GAAmBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMytB,SAAS;QACtDpsB,CAAA,GAAmBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo/B,SAAS;QACtD39B,CAAA,GAAe4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMu3C,KAAK;QAC9C51C,CAAA,GAAuB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMw3C,UAAU;QAE3D31C,CAAA,GAAeoe,CAAA,CAAM,MAAOjgB,CAAA,CAAM0/B,GAAA,KAAQ,QAAQ,SAAY,YAAa;QAE3Ez7B,CAAA,GAAiBupB,EAAA,CAAoBvtB,CAAgB;QAErDkM,CAAA,GAAkBoO,CAAA,CAAS,OAAO;UACtC,WAAW9Y,CAAA,CAAagZ,KAAA;UACxB,CAAC,UAAUza,CAAA,CAAMy3C,MAAM,EAAE,GAAGz3C,CAAA,CAAMy3C,MAAA,KAAW;UAC7C,CAAC,MAAMz3C,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;UAC3C,CAAC,SAASrtB,CAAA,CAAMmzC,KAAK,EAAE,GAAGnzC,CAAA,CAAMmzC,KAAA,KAAU;UAC1C,iBAAiBxxC,CAAA,CAAqB8Y,KAAA,KAAU;UAChD,CAAC,iBAAiB9Y,CAAA,CAAqB8Y,KAAK,EAAE,GAAG,OAAO9Y,CAAA,CAAqB8Y,KAAA,IAAU;QACvF;MAEF,OAAAyhB,EAAA,CAAQpB,EAAA,EAAoB;QAC1B4E,GAAA,EAAKzf,CAAA,CAAM,MAAMjgB,CAAA,CAAM0/B,GAAG;QAC1BN,SAAA,EAAW/9B;MAAA,CACZ,IAAA+K,CAAA,EAAAC,CAAA,MAAAurB,CAAA,IAAAztB,CAAA,CAAAk3B,EAAA,CAAAj1B,CAAA,CAAAszB,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC/CD,MAAM1/B,CAAA,GAAQ0C,CAAA;QAiCR;UAACkqB,YAAA,EAAA3sB,CAAA;UAAc4sB,iBAAA,EAAAxrB;QAAA,IAAqBmrB,EAAA,CAAexsB,CAAA,EAAO,CAC9D,UACA,eACA,UACA,YACA,QACA,OACA,WACA,uBACA,UACA,MACA,WACA,WACA,gBACA,oBACA,mBACA,wBACA,oBACA,yBACA,OACD;QAEKyB,CAAA,GAAcwe,CAAA,CAAM,MAAOhgB,CAAA,CAAawa,KAAA,GAAQwjB,EAAA,GAAQj+B,CAAA,CAAM0/B,GAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7DxE,MAAM1/B,CAAA,GAAQ0C,CAAA;QAsBRzC,CAAA,GAAcosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMkwC,IAAI;QAC5C7uC,CAAA,GAAmBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMi3C,SAAS;QACtDx1C,CAAA,GAAe4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMgd,KAAK;QAC9Crb,CAAA,GAAYuqB,EAAA,CAAa,MAAMlsB,CAAA,CAAM+iC,KAAK;QAE1ClhC,CAAA,GAAkB0Y,CAAA,CAAS,OAAO;UACtC,YAAYta,CAAA,CAAYwa,KAAA;UACxB,iBAAiBpZ,CAAA,CAAiBoZ,KAAA;UAClC,CAAC9Y,CAAA,CAAU8Y,KAAK,GAAGza,CAAA,CAAM+iC,KAAA,KAAU;UACnC/lB,KAAA,EAASvb,CAAA,CAAagZ;QACtB;;;;;;ECzCIi9B,EAAA,GAAWC,CAACj1C,CAAA,EAAiB1C,CAAA,KAAwB0C,CAAA,CAAGiF,YAAA,CAAa,iBAAiB3H,CAAK;EAClF43C,EAAA;IACbC,QAAQn1C,CAAA,EAAI1C,CAAA,EAAiC;MAClC03C,EAAA,CAAAh1C,CAAA,EAAI1C,CAAA,CAAQya,KAAK;IAC5B;IACAq9B,QAAQp1C,CAAA,EAAI1C,CAAA,EAAiC;MAClC03C,EAAA,CAAAh1C,CAAA,EAAI1C,CAAA,CAAQya,KAAK;IAC5B;EACF;ECNMs9B,EAAA,GAAaC,CAACt1C,CAAA,EAA8C1C,CAAA,KAAoB;IACpF,MAAM;QAACy4B,SAAA,EAAAx4B,CAAA;QAAWg4C,GAAA,EAAA52C,CAAA;QAAKoZ,KAAA,EAAAhZ;MAAA,IAASiB,CAAA;MAE1Bf,CAAA,GAAUpB,MAAA,CAAOkd,IAAA,CAAKxd,CAAA,IAAa,CAAE;MAGrC4B,CAAA,GAAa,OAAOJ,CAAA,IAAU,WAAWA,CAAA,CAAMsC,KAAA,CAAM7B,EAAc,IAAIT,CAAA;IAG7E,IAAIsG,EAAA,CAAM/H,CAAA,CAAGoJ,OAAA,EAAS,GAAG,GAAG;MAC1B,MAAMnF,CAAA,GAAOmD,EAAA,CAAQpH,CAAA,EAAI,MAAM,KAAK;MAChCoC,EAAA,CAAWoF,IAAA,CAAKvD,CAAI,KACtBtC,CAAA,CAAQ0P,IAAA,CAAKpN,CAAA,CAAKd,OAAA,CAAQhB,EAAA,EAAS,EAAE,CAAC;IAE1C;IAKA,OAAAQ,KAAA,CAAME,SAAA,CAAU2G,MAAA,CACbsJ,KAAA,CAAM,IAAI,CAACzR,CAAA,EAAKQ,CAAU,CAAC,EAC3B2X,OAAA,CAASvV,CAAA,IAAM,OAAOA,CAAA,IAAM,YAAYtC,CAAA,CAAQ0P,IAAA,CAAKpN,CAAC,CAAC,GAGnDtC,CAAA,CAAQmL,MAAA,CAAO,CAAC7I,CAAA,EAAGkI,CAAA,EAAOC,CAAA,KAAQnI,CAAA,IAAKmI,CAAA,CAAIjD,OAAA,CAAQlF,CAAC,MAAMkI,CAAK;EACxE;EAEM+rC,EAAA,GAASxmB,CAAChvB,CAAA,EAAqB1C,CAAA,KAAoB;IAC7C0C,CAAA,CAAA8W,OAAA,CAASvZ,CAAA,IAAa;MACxB,MAAAoB,CAAA,GAASgD,QAAA,CAASkD,cAAA,CAAetH,CAAQ;MAE3CoB,CAAA,KAAW,QACbA,CAAA,CAAO+jB,aAAA,CAAc,IAAIqP,KAAA,CAAM,WAAW,CAAC;IAC7C,CACD,GACD5b,UAAA,CAAW,MAAMs/B,EAAA,CAAgBz1C,CAAA,EAAW1C,CAAE,GAAG,EAAE;EACrD;EAEMm4C,EAAA,GAAkBC,CAAC11C,CAAA,EAAqB1C,CAAA,KAAoB;IAChE,IAAIC,CAAA,GAAU;IACJyC,CAAA,CAAA8W,OAAA,CAASnY,CAAA,IAAa;MACxB,MAAAI,CAAA,GAAS4C,QAAA,CAASkD,cAAA,CAAelG,CAAQ;MAE3CI,CAAA,YAAAA,CAAA,CAAQmlB,SAAA,CAAU1E,QAAA,CAAS,YACnBjiB,CAAA,QAERwB,CAAA,YAAAA,CAAA,CAAQmlB,SAAA,CAAU1E,QAAA,CAAS,eACnBjiB,CAAA;IACZ,CACD,GACDD,CAAA,CAAG2H,YAAA,CAAa,iBAAiB1H,CAAA,GAAU,SAAS,OAAO,GAC3DD,CAAA,CAAG4mB,SAAA,CAAUlJ,MAAA,CAAOzd,CAAA,GAAU,cAAc,eAAe,GAC3DD,CAAA,CAAG4mB,SAAA,CAAUC,GAAA,CAAI5mB,CAAA,GAAU,kBAAkB,WAAW;EAC1D;EAEMo4C,EAAA,GAAeC,CAAC51C,CAAA,EAAgB1C,CAAA,KAA6D;IAE7F,IAAAA,CAAA,CAAQya,KAAA,KAAU,UAAala,MAAA,CAAOkd,IAAA,CAAKzd,CAAA,CAAQy4B,SAAA,IAAa,EAAE,EAAEn4B,MAAA,KAAW,GAAG;IAChF,MAAAL,CAAA,GAAU83C,EAAA,CAAW/3C,CAAA,EAAgD0C,CAAE;IAGzEA,CAAA,CAAG61C,QAAA,IACF71C,CAAA,CAAAqC,mBAAA,CAAoB,SAASrC,CAAA,CAAG61C,QAAQ,GAE7C71C,CAAA,CAAG61C,QAAA,GAAW,MAAML,EAAA,CAAOj4C,CAAA,EAASyC,CAAE,GACnCA,CAAA,CAAAoC,gBAAA,CAAiB,SAASpC,CAAA,CAAG61C,QAAQ,GAGxC71C,CAAA,CAAGiF,YAAA,CAAa,iBAAiB1H,CAAA,CAAQ+I,IAAA,CAAK,GAAG,CAAC,GAClDmvC,EAAA,CAAgBl4C,CAAA,EAASyC,CAAE;EAC7B;EAMe81C,EAAA;IACbX,OAAA,EAASQ,EAAA;IACTP,OAAA,EAASO,EAAA;IACTI,UAAU/1C,CAAA,EAAsB;MAC3BA,CAAA,CAAAqC,mBAAA,CAAoB,SAASrC,CAAA,CAAG61C,QAAQ,GAC3C71C,CAAA,CAAGoF,eAAA,CAAgB,eAAe,GAClCpF,CAAA,CAAGoF,eAAA,CAAgB,eAAe;IACpC;EACF;EC9Ee4wC,EAAA;IACbb,QAAQn1C,CAAA,EAAI1C,CAAA,EAAS;MAEnB,IAAI,CADam4B,EAAA,CAAoBn4B,CAAA,CAAQya,KAAK,GACnC;MAEf,MAAMpZ,CAAA,GAAOg3B,EAAA,CAAer4B,CAAA,CAAQya,KAAA,EAAO/X,CAAE;MAEzC,CAACrB,CAAA,CAAKk0B,OAAA,IAAW,CAACl0B,CAAA,CAAKi0B,KAAA,KAE3B5yB,CAAA,CAAGw2B,QAAA,GAAWxe,CAAA,CAAI;QAChB,GAAG6d,EAAA,CAAsBv4B,CAAA,EAAS0C,CAAE;QACpC,GAAGrB;MAAA,CACJ,GACDq3B,EAAA,CAAKh2B,CAAA,EAAI1C,CAAO;IAClB;IACA83C,QAAQp1C,CAAA,EAAI1C,CAAA,EAAS;MAEnB,IAAI,CADam4B,EAAA,CAAoBn4B,CAAA,CAAQya,KAAK,GACnC;MAEf,MAAMpZ,CAAA,GAAOg3B,EAAA,CAAer4B,CAAA,CAAQya,KAAA,EAAO/X,CAAE;MAE7C,IAAI,GAACrB,CAAA,CAAKk0B,OAAA,IAAW,CAACl0B,CAAA,CAAKi0B,KAAA,GAEvB;QAAA,KAAC5yB,CAAA,CAAGw2B,QAAA,EAAU;UAIhBx2B,CAAA,CAAGw2B,QAAA,GAAWxe,CAAA,CAAI;YAChB,GAAG6d,EAAA,CAAsBv4B,CAAA,EAAS0C,CAAE;YACpC,GAAGrB;UAAA,CACJ,GACDq3B,EAAA,CAAKh2B,CAAA,EAAI1C,CAAO;UAChB;QACF;QACA0C,CAAA,CAAGw2B,QAAA,CAASze,KAAA,GAAQ;UAClB,GAAG8d,EAAA,CAAsBv4B,CAAA,EAAS0C,CAAE;UACpC,GAAGrB;QAAA;MAAA;IAEP;IACAs3C,cAAcj2C,CAAA,EAAI;MAChB22B,EAAA,CAAO32B,CAAE;IACX;EACF;EC1Cek2C,EAAA;IACbf,QAAQn1C,CAAA,EAAI1C,CAAA,EAAS;MACb,MAAAC,CAAA,GAAWk4B,EAAA,CAAoBn4B,CAAA,CAAQya,KAAK;MAClD,IAAI,CAACxa,CAAA,EAAU;MAEf,MAAMoB,CAAA,GAAOg3B,EAAA,CAAer4B,CAAA,CAAQya,KAAA,EAAO/X,CAAE;MAEzC,CAACrB,CAAA,CAAKk0B,OAAA,IAAW,CAACl0B,CAAA,CAAKi0B,KAAA,KAE3B5yB,CAAA,CAAGw2B,QAAA,GAAWxe,CAAA,CAAI;QAChB2a,cAAA,EAAgB;QAChB,GAAGkD,EAAA,CAAsBv4B,CAAA,EAAS0C,CAAE;QACpC4yB,KAAA,EAAOj0B,CAAA,CAAKi0B,KAAA,IAASj0B,CAAA,CAAKk0B,OAAA,IAAW;QACrCH,OAAA,EAASn1B;MAAA,CACV,GACDy4B,EAAA,CAAKh2B,CAAA,EAAI1C,CAAO;IAClB;IACA83C,QAAQp1C,CAAA,EAAI1C,CAAA,EAAS;MACb,MAAAC,CAAA,GAAWk4B,EAAA,CAAoBn4B,CAAA,CAAQya,KAAK;MAClD,IAAI,CAACxa,CAAA,EAAU;MAEf,MAAMoB,CAAA,GAAOg3B,EAAA,CAAer4B,CAAA,CAAQya,KAAA,EAAO/X,CAAE;MAE7C,IAAI,GAACrB,CAAA,CAAKk0B,OAAA,IAAW,CAACl0B,CAAA,CAAKi0B,KAAA,GAEvB;QAAA,KAAC5yB,CAAA,CAAGw2B,QAAA,EAAU;UAIhBx2B,CAAA,CAAGw2B,QAAA,GAAWxe,CAAA,CAAI;YAChB2a,cAAA,EAAgB;YAChB,GAAGkD,EAAA,CAAsBv4B,CAAA,EAAS0C,CAAE;YACpC4yB,KAAA,EAAOj0B,CAAA,CAAKi0B,KAAA,IAASj0B,CAAA,CAAKk0B,OAAA,IAAW;YACrCH,OAAA,EAASn1B;UAAA,CACV,GACDy4B,EAAA,CAAKh2B,CAAA,EAAI1C,CAAO;UAChB;QACF;QACA0C,CAAA,CAAGw2B,QAAA,CAASze,KAAA,GAAQ;UAClB4a,cAAA,EAAgB;UAChB,GAAGkD,EAAA,CAAsBv4B,CAAA,EAAS0C,CAAE;UACpC4yB,KAAA,EAAOj0B,CAAA,CAAKi0B,KAAA,IAASj0B,CAAA,CAAKk0B,OAAA,IAAW;UACrCH,OAAA,EAASn1B;QAAA;MAAA;IAEb;IACA04C,cAAcj2C,CAAA,EAAI;MAChB22B,EAAA,CAAO32B,CAAE;IACX;EACF;EAAAm2C,EAAA,kBAAAt4C,MAAA,CAAAu4C,MAAA,gBAAAv4C,MAAA,CAAAw4C,cAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpCA,MAAM94C,CAAA,GAAQyC,CAAA;QAaRrB,CAAA,GAAOrB,CAAA;QAUPyB,CAAA,GAAkB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QAEpDvH,CAAA,GAAkB4Y,CAAA,CAAS,OAAO;UACtCrR,QAAA,EAAUzH,CAAA,CAAgBgZ;QAC1B;QAEI5Y,CAAA,GAAWoC,CAAA,IAAwB;UAClCxC,CAAA,CAAgBgZ,KAAA,IACnBpZ,CAAA,CAAK,SAAS4C,CAAC;QACjB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCuCF,MAAM5C,CAAA,GAAQqB,CAAA;QAsDRjB,CAAA,GAAOxB,CAAA;QAYP0B,CAAA,GAAQo8B,EAAA;QA+BRl8B,CAAA,GAAa4pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAEjEZ,CAAA,GAAoBooB,CAAA,CAAcxqB,CAAU;QAC5CsK,CAAA,GAAuBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMwzC,aAAa;QAC9DzoC,CAAA,GAAkBigB,CAAA,CAAc,MAAMhrB,CAAA,CAAM23C,QAAQ;QACpD3sC,CAAA,GAAuBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM43C,aAAa;QAC9D3sC,CAAA,GAAkB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM63C,QAAQ;QACpD3sC,CAAA,GAAiB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAM83C,OAAO;QAClD/uC,CAAA,GAA2BiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMgzC,iBAAiB;QACtEnnC,CAAA,GAAsBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMizC,YAAY;QAC5DnnC,CAAA,GAAckf,CAAA,CAAc,MAAMhrB,CAAA,CAAMmuB,IAAI;QAC5CpiB,CAAA,GAA0Bif,CAAA,CAAc,MAAMhrB,CAAA,CAAMuzC,gBAAgB;QAEpEtnC,CAAA,GAAa2hB,EAAA,CAAM,MAAM5tB,CAAA,CAAMiuB,EAAA,EAAI,WAAW;MACpDoE,EAAA,CAAkBzvB,CAAA,EAAmBkI,CAAoB;MAEnD,MAAAoB,CAAA,GAAUmN,CAAA,CAAwB,IAAI;MAE5C2H,EAAA,CACE,UACA,MAAM;QACJzS,CAAA,CAAK,KAAK;MACZ,GACA;QAACzO,MAAA,EAAQoM;MAAO;MAGlB,MAAM;UAACma,OAAA,EAAAla;QAAA,IAAW+Z,EAAA,CAASha,CAAA,EAAS;UAClCsY,YAAA,EAAc5hB,CAAA,CAAkBwW,KAAA,IAASlO,CAAA,CAAekO,KAAA,KAAU;QAAA,CACnE;QAEK/M,CAAA,GAAWgN,CAAA,CAAIzW,CAAA,CAAkBwW,KAAK;QACtC7M,CAAA,GAAoB8M,CAAA,CAAI,EAAK;QAE7BtL,CAAA,GAAe6Q,CAAA,CAAM,MAAM7T,CAAA,CAAgBqO,KAAA,KAAU,MAAQxW,CAAA,CAAkBwW,KAAA,KAAU,EAAI;QAE7FpL,CAAA,GAAc4Q,CAAA,CAClB,MACE9S,CAAA,CAAYsN,KAAA,KAAU,MACrBtN,CAAA,CAAYsN,KAAA,KAAU,MAAQ7M,CAAA,CAAkB6M,KAAA,KAAU,MAC1DtN,CAAA,CAAYsN,KAAA,KAAU,MAAQxW,CAAA,CAAkBwW,KAAA,KAAU;QAGzDnL,CAAA,GAAqB2Q,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYlF,CAAA,CAAM,cAAc,CAAC,CAAC;QACpE4N,CAAA,GAAqBgL,CAAA,CAAS,MAAM,CACxC;UAAC,cAAc,CAACjL,CAAA,CAAmBmL;QAAK,GACxCpZ,CAAA,CAAMs0C,gBAAA,CACP;QACKnmC,CAAA,GAAmB+K,CAAA,CAAS,OAAO;UACvC8S,OAAA,EAAS/d,CAAA,CAAmBmL,KAAA,GAAQpZ,CAAA,CAAMq0C,kBAAA,GAAqB;UAC/D5Y,KAAA,EAAOvtB,CAAA,CAAmBkL;QAC1B;QAEIhL,CAAA,GAAgBwQ,CAAA,CAAM,MAAM,CAACpZ,EAAA,CAAYlF,CAAA,CAAMmhC,MAAM,CAAC;QACtDpzB,CAAA,GAAkB6K,CAAA,CAAS,MAAM;QAAA;QAErC;QAAA;QACA,aAAalZ,CAAA,CAAMqL,SAAS,IAC5B;UACEmmB,IAAA,EAAM5uB,CAAA,CAAkBwW,KAAA,IAAS/M,CAAA,CAAS+M,KAAA,KAAU;QACtD,EACD;QAEK9K,CAAA,GAAwBsnB,CAC5Bd,EAAA,EACAC,EAAA,GAAoC,OAEpC,IAAIh1B,EAAA,CAAmB+0B,EAAA,EAAM;UAC3Bv1B,UAAA,EAAY;UACZO,MAAA,EAAQoM,CAAA,CAAQkN,KAAA,IAAS;UACzBvZ,aAAA,EAAe;UACfI,OAAA,EAAS;UACT,GAAG80B,EAAA;UACHp1B,WAAA,EAAasM,CAAA,CAAWmN;QAAA,CACzB;QAEG7K,CAAA,GAAO8B,CAACykB,EAAA,GAAU,OAAO;UAC7B,IACGA,EAAA,KAAY,cAAc/rB,CAAA,CAAyBqQ,KAAA,IACnD0b,EAAA,KAAY,SAASjpB,CAAA,CAAoBuN,KAAA,EAC1C;YACAhZ,CAAA,CAAK,gBAAgB;YACrB;UACF;UAEM,MAAA20B,EAAA,GAAQzmB,CAAA,CAAsB,QAAQ;YAAC/O,UAAA,EAAYu1B,EAAA,KAAY;YAAI70B,OAAA,EAAA60B;UAAA,CAAQ;UAUjF,IARIA,EAAA,KAAY,WACd10B,CAAA,CAAK00B,EAAA,EAASC,EAAK,GAEjBD,EAAA,KAAY,SACd10B,CAAA,CAAK00B,EAAA,EAASC,EAAK,GAErB30B,CAAA,CAAK,QAAQ20B,EAAK,GAEdA,EAAA,CAAMv1B,gBAAA,EAAkB;YAC1BY,CAAA,CAAK,gBAAgB;YACrB;UACF;UAEAI,CAAA,CAAW4Y,KAAA,GAAQ;QAAA;QAGf5K,CAAA,GAAOgjB,CAAA,KAAM;UACjB,MAAMsD,EAAA,GAAQxmB,CAAA,CAAsB,QAAQ;YAAC/O,UAAA,EAAY;UAAA,CAAK;UAE9D,IADAa,CAAA,CAAK,QAAQ00B,EAAK,GACdA,EAAA,CAAMt1B,gBAAA,EAAkB;YAC1BgB,CAAA,CAAW4Y,KAAA,GAAQ,IACnBhZ,CAAA,CAAK,gBAAgB;YACrB;UACF;UACAI,CAAA,CAAW4Y,KAAA,GAAQ;QAAA;QAGf3K,EAAA,GAAQ1J,CAAA,KAAM;UAClBqa,EAAA,CAAS,MAAM;YACTlU,CAAA,CAAekO,KAAA,KAAU,OAC3BjN,CAAA,CAAQiN,KAAA,GAAQ;UAClB,CACD;QAAA;QAGGzK,EAAA,GAAgBopC,CAAA,KAAMvpC,CAAA;QACtByB,EAAA,GAAe+nC,CAAA,KAAM;UACzB3rC,CAAA,CAAS+M,KAAA,GAAQ,IACX3K,EAAA,IACDrO,CAAA,UAASkO,CAAA,CAAsB,OAAO,CAAC,GACxCxC,CAAA,CAAYsN,KAAA,KAAU,OAAM7M,CAAA,CAAkB6M,KAAA,GAAQ;QAAA;QAEtDgb,EAAA,GAAU+gB,CAAA,KAAM;UACpB9oC,CAAA,CAAS+M,KAAA,GAAQ;QAAA;QAEbib,EAAA,GAAe4jB,CAAA,KAAM;UACpB73C,CAAA,WAAUkO,CAAA,CAAsB,QAAQ,CAAC,GAC1CxC,CAAA,CAAYsN,KAAA,KAAU,OAAM7M,CAAA,CAAkB6M,KAAA,GAAQ;QAAA;MAE3C,OAAA6G,EAAA,CAAA/T,CAAA,EAAS,aAAa,MAAM;QACzBtJ,CAAA,CAAAwW,KAAA,GAAQ7K,CAAA,CAAK,IAAIC,CAAA,CAAK;MAAA,CACzC,GAEY7P,CAAA;QACX0R,IAAA,EAAA9B,CAAA;QACAijB,IAAA,EAAAhjB;MAAA,CACD,IAAAsmB,EAAA,EAAAC,EAAA,MAAAwB,CAAA,IAAAztB,CAAA,CAAAg9B,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECkIKoS,EAAA,GAAmB;EACnBC,EAAA,GAAqB;EAAAC,EAAA,kBAAAplB,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA7U3B,MAAMhzB,CAAA,GAAQqB,CAAA;QAmERjB,CAAA,GAAOzB,CAAA;QAKP2B,CAAA,GAAa8pB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAEhDI,CAAA,GAAkBwqB,CAAA,CAAc,MAAMhrB,CAAA,CAAM6H,QAAQ;QACpDjF,CAAA,GAAqBooB,CAAA,CAAc,MAAMhrB,CAAA,CAAMq4C,WAAW;QAC1DvtC,CAAA,GAAsBkgB,CAAA,CAAc,MAAMhrB,CAAA,CAAMs4C,YAAY;QAC5DvtC,CAAA,GAA4BigB,CAAA,CAAc,MAAMhrB,CAAA,CAAMu4C,kBAAkB;QACxEvtC,CAAA,GAAoBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAMw4C,UAAU;QACxDvtC,CAAA,GAAe+f,CAAA,CAAc,MAAMhrB,CAAA,CAAM61C,KAAK;QAE9C3qC,CAAA,GAAgBwU,EAAA,CAAY,MAAM1f,CAAA,CAAMy4C,OAAA,EAAS;UAAC54B,SAAA,EAAW;UAAMF,MAAA,EAAQ;QAAA,CAAW;QACtF5W,CAAA,GAAkB2W,EAAA,CAAY,MAAM1f,CAAA,CAAM04C,SAAA,EAAW;UAAC74B,SAAA,EAAW;UAAMF,MAAA,EAAQ;QAAA,CAAW;QAC1F9T,CAAA,GAAmB6T,EAAA,CAAYpf,CAAA,EAAY;UAACuf,SAAA,EAAW;UAAMF,MAAA,EAAQ;QAAA,CAAW;QAEhF7T,CAAA,GAAmB8S,CAAA,CAAM,MAAMvW,IAAA,CAAKG,GAAA,CAAI0C,CAAA,CAAckO,KAAA,IAAS8+B,EAAA,EAAkB,CAAC,CAAC;QACnFnsC,CAAA,GAAqB6S,CAAA,CAAM,MAAMvW,IAAA,CAAKG,GAAA,CAAIO,CAAA,CAAgBqQ,KAAA,IAAS++B,EAAA,EAAoB,CAAC,CAAC;QAEzFlsC,CAAA,GAAgB2S,CAAA,CAAM,MAAMvW,IAAA,CAAKkkB,IAAA,CAAKxgB,CAAA,CAAmBqN,KAAA,GAAQtN,CAAA,CAAiBsN,KAAK,CAAC;QACxFlN,CAAA,GAAe0S,CAAA,CAAM,MAAM5e,CAAA,CAAM0hC,KAAA,KAAU,MAAM;QAEjDv1B,CAAA,GAAeyS,CAAA,CAAM,MAAO5e,CAAA,CAAM0hC,KAAA,KAAU,SAAS,UAAU1hC,CAAA,CAAM0hC,KAAM;QAE3Er1B,CAAA,GAAYwe,EAAA,CAAa1e,CAAY;QAErCI,CAAA,GAAgB4oB,CAAA,IAAuBA,CAAA,KAAetpB,CAAA,CAAiBuN,KAAA;QACvErL,CAAA,GAAeonB,CAAA,IAAiB30B,CAAA,CAAgB4Y,KAAA,GAAQ,OAAO7M,CAAA,CAAa4oB,CAAG,IAAI,MAAM;QAEzFnnB,CAAA,GAAiBmnB,CAAA,IACrB30B,CAAA,CAAgB4Y,KAAA,IAChB7M,CAAA,CAAa4oB,CAAG,KAChBtpB,CAAA,CAAiBuN,KAAA,GAAQ;QAAA;QAEzB+b,CAAA,GAAM,KACNA,CAAA,GAAMlpB,CAAA,CAAcmN,KAAA;QAEhBnL,CAAA,GAAgBiL,CAAA,CAAS,MAAMlL,CAAA,CAAc,CAAC,CAAC;QAC/CE,CAAA,GAAegL,CAAA,CAAS,MAAMlL,CAAA,CAAcnC,CAAA,CAAiBuN,KAAA,GAAQ,CAAC,CAAC;QACvEjL,CAAA,GAAe+K,CAAA,CAAS,MAAMlL,CAAA,CAAc/B,CAAA,CAAcmN,KAAK,CAAC;QAChEhL,CAAA,GAAe8K,CAAA,CAAS,MAAMlL,CAAA,CAAcnC,CAAA,CAAiBuN,KAAA,GAAQ,CAAC,CAAC;QAEvE/K,CAAA,GAAoBsqC,CAACxjB,CAAA,EAAcC,CAAA,MAA0B;UACjEzc,EAAA,EAAI;YACF8iB,KAAA,EAAO,CACL,aACA;cACE5zB,QAAA,EAAYstB,CAAA;cACZ,aAAajpB,CAAA,CAAakN,KAAA;cAC1B,UAAUlN,CAAA,CAAakN,KAAA,IAAS,CAAC+b;YACnC,GACAC,CAAA;UAEJ;UACArI,MAAA,EAAQ;YACN1pB,EAAA,EAAM8xB,CAAA,GAAM,SAAS;YACrBsG,KAAA,EAAS,CAAC,aAAa;cAAC,eAAe,CAACtG,CAAA,IAAOjpB,CAAA,CAAakN;YAAA,CAAM;YAClE,cAAcpZ,CAAA,CAAM44C,cAAA;YACpB,iBAAiB54C,CAAA,CAAM64C,YAAA,IAAgB;YACvC,iBAAiB1jB,CAAA,GAAM,KAAO;YAC9B6V,IAAA,EAAQ;YACRxjB,IAAA,EAAQ2N,CAAA,GAAM,SAAY;YAC1B0I,QAAA,EAAY1I,CAAA,GAAM,SAAY;UAChC;QAAA;QAGI7mB,CAAA,GAAmB4K,CAAA,CAAS,MAAM7K,CAAA,CAAkBJ,CAAA,CAAcmL,KAAA,EAAOpZ,CAAA,CAAM84C,UAAU,CAAC;QAC1FvqC,CAAA,GAAkB2K,CAAA,CAAS,MAAM7K,CAAA,CAAkBH,CAAA,CAAakL,KAAA,EAAOpZ,CAAA,CAAM+4C,SAAS,CAAC;QACvFvqC,CAAA,GAAkB0K,CAAA,CAAS,MAAM7K,CAAA,CAAkBD,CAAA,CAAagL,KAAA,EAAOpZ,CAAA,CAAMg5C,SAAS,CAAC;QACvFvqC,EAAA,GAAqByK,CAAA,CAAS,MAAM7K,CAAA,CAAkBF,CAAA,CAAaiL,KAAA,EAAOpZ,CAAA,CAAMi5C,SAAS,CAAC;QAE1FtqC,EAAA,GAAgBuK,CAAA,CAAS,OAAO;UACpCP,EAAA,EAAI;YACF8iB,KAAA,EAAO,CACL,aACA,YACA,qBACAvvB,CAAA,CAAakN,KAAA,GAAQ,cAAc,IACnCpZ,CAAA,CAAMk5C,aAAA,CACR;YACAlO,IAAA,EAAM;UACR;UACApvB,IAAA,EAAM;YACJ6f,KAAA,EAAO,CAAC,WAAW;UACrB;QACA;QAEIxrB,EAAA,GAAyBiJ,CAAA,CAAS,MAAM,CAC5C7M,CAAA,CAAU+M,KAAA,EACV;UACE,CAAC,cAAcpZ,CAAA,CAAMwR,IAAI,EAAE,GAAGxR,CAAA,CAAMwR,IAAA,KAAS;UAC7C,sBAAsBvG,CAAA,CAAamO;QACrC,EACD;QAEKgb,EAAA,GAAclb,CAAA,CAAS,MAAM;UAC7B,IAAAic,CAAA;UAGJ,OAF0BlpB,CAAA,CAAcmN,KAAA,GAAQvN,CAAA,CAAiBuN,KAAA,GAEjD,IAAIpZ,CAAA,CAAM2vC,KAAA,IAAS3vC,CAAA,CAAM2vC,KAAA,GAAQ,IAChCxa,CAAA,GAAAlpB,CAAA,CAAcmN,KAAA,GAAQ0b,EAAA,CAAc1b,KAAA,GAAQ,IAG3D+b,CAAA,GAAetpB,CAAA,CAAiBuN,KAAA,GAAQ/Q,IAAA,CAAKO,KAAA,CAAMksB,EAAA,CAAc1b,KAAA,GAAQ,CAAC,GAGxE+b,CAAA,GAAe,IACFA,CAAA,OACNA,CAAA,GAAelpB,CAAA,CAAcmN,KAAA,GAAQ0b,EAAA,CAAc1b,KAAA,KAC7C+b,CAAA,GAAAlpB,CAAA,CAAcmN,KAAA,GAAQ0b,EAAA,CAAc1b,KAAA,GAAQ,IAQzDpZ,CAAA,CAAM2vC,KAAA,IAAS,KACb3kC,CAAA,CAAkBoO,KAAA,IAASnN,CAAA,CAAcmN,KAAA,KAAU+b,CAAA,GAAeL,EAAA,CAAc1b,KAAA,GAAQ,MAC1F+b,CAAA,GAAe9sB,IAAA,CAAKG,GAAA,CAAI2sB,CAAA,GAAe,GAAG,CAAC,IAGxCA,CAAA;QAAA,CACR;QAEKd,EAAA,GAAgBnb,CAAA,CAAS,MAAM;UAC7B,MAAAic,CAAA,GAAYlpB,CAAA,CAAcmN,KAAA,GAAQvN,CAAA,CAAiBuN,KAAA;UACzD,IAAIgc,CAAA,GAAY;UAEhB,OAAID,CAAA,GAAY,IAAIn1B,CAAA,CAAM2vC,KAAA,IAAS3vC,CAAA,CAAM2vC,KAAA,GAAQ,IAC3C3vC,CAAA,CAAM2vC,KAAA,GAAQ,MACJva,CAAA,SAGVp1B,CAAA,CAAM2vC,KAAA,GAAQ,MAChBva,CAAA,GAAY,CAAC,EAAE,CAACtqB,CAAA,CAAoBsO,KAAA,IAASxW,CAAA,CAAmBwW,KAAA,IAGhEgb,EAAA,CAAYhb,KAAA,IAAS,MACXgc,CAAA,QAGVA,CAAA,IAAaxyB,CAAA,CAAmBwW,KAAA,IAASgb,EAAA,CAAYhb,KAAA,GAAQ,MACnDgc,CAAA,QAGPA,CAAA;QAAA,CACR;QAGKN,EAAA,GAAgB5b,CAAA,CAAS,MAAM;UACnC,IAAIic,CAAA,GAAYn1B,CAAA,CAAM2vC,KAAA;UAElB,OAAA1jC,CAAA,CAAcmN,KAAA,IAASpZ,CAAA,CAAM2vC,KAAA,GAC/Bxa,CAAA,GAAIlpB,CAAA,CAAcmN,KAAA,GACTvN,CAAA,CAAiBuN,KAAA,GAAQpZ,CAAA,CAAM2vC,KAAA,GAAQ,KAAK3vC,CAAA,CAAM2vC,KAAA,GAAQ,MAC/D,CAAC7kC,CAAA,CAAoBsO,KAAA,IAASpO,CAAA,CAAkBoO,KAAA,MAClD+b,CAAA,GAAIn1B,CAAA,CAAM2vC,KAAA,IAAS/sC,CAAA,CAAmBwW,KAAA,GAAQ,IAAI,KAEpD+b,CAAA,GAAI9sB,IAAA,CAAKC,GAAA,CAAI6sB,CAAA,EAAGn1B,CAAA,CAAM2vC,KAAK,KAE3B1jC,CAAA,CAAcmN,KAAA,GAAQvN,CAAA,CAAiBuN,KAAA,GAAQ,IAAIpZ,CAAA,CAAM2vC,KAAA,IACzD3vC,CAAA,CAAM2vC,KAAA,GAAQ,KAEV,CAAC7kC,CAAA,CAAoBsO,KAAA,IAASxW,CAAA,CAAmBwW,KAAA,MACnD+b,CAAA,GAAIn1B,CAAA,CAAM2vC,KAAA,IAAS3kC,CAAA,CAAkBoO,KAAA,GAAQ,IAAI,MAI/CpZ,CAAA,CAAM2vC,KAAA,GAAQ,MAChBxa,CAAA,GAAIn1B,CAAA,CAAM2vC,KAAA,IAAS7kC,CAAA,CAAoBsO,KAAA,GAAQ,IAAI,KAIhD+b,CAAA;QAAA,CACR;QAEKJ,EAAA,GAAe7b,CAAA,CAAS,MAAM;UAC5B,MAAAic,CAAA,GAAsBlpB,CAAA,CAAcmN,KAAA,GAAQ0b,EAAA,CAAc1b,KAAA;UAEhE,IAAIgc,CAAA,GAAY;UAEZvpB,CAAA,CAAiBuN,KAAA,GAAQpZ,CAAA,CAAM2vC,KAAA,GAAQ,KAAK3vC,CAAA,CAAM2vC,KAAA,GAAQ,KACxD,CAAC7kC,CAAA,CAAoBsO,KAAA,IAASpO,CAAA,CAAkBoO,KAAA,MACtCgc,CAAA,SAGVp1B,CAAA,CAAM2vC,KAAA,GAAQ,MAChBva,CAAA,GAAY,CAAC,EAAE,CAACtqB,CAAA,CAAoBsO,KAAA,IAASpO,CAAA,CAAkBoO,KAAA,IAG/Dgb,EAAA,CAAYhb,KAAA,GAAQ+b,CAAA,KACVC,CAAA;UAEd,MAAMI,CAAA,GAAiBpB,EAAA,CAAYhb,KAAA,GAAQ0b,EAAA,CAAc1b,KAAA,GAAQ;UAEjE,OAAIgc,CAAA,IAAapqB,CAAA,CAAkBoO,KAAA,IAASoc,CAAA,GAAiBvpB,CAAA,CAAcmN,KAAA,GAAQ,MACrEgc,CAAA,QAGPA,CAAA;QAAA,CACR;QAEKJ,EAAA,GAAa9b,CAAA,CAAS,OAAO;UACjCigC,QAAA,EAAUrtC,CAAA,CAAiBsN,KAAA;UAC3Bs/B,SAAA,EAAW3vC,CAAA,CAAgBqQ,KAAA;UAC3BggC,aAAA,EAAentC,CAAA,CAAcmN;QAC7B;QAEI6b,EAAA,GAAYokB,CAAClkB,CAAA,EAAmBC,CAAA,KAAuB;UAC3D,IAAIA,CAAA,KAAevpB,CAAA,CAAiBuN,KAAA,EAAO;UAErC,MAAAoc,CAAA,GAAa,IAAI/2B,EAAA,CAAQ,cAAc;YAC3Cc,UAAA,EAAY;YACZO,MAAA,EAAQq1B,CAAA,CAAMr1B;UAAA,CACf;UACIM,CAAA,eAAco1B,CAAA,EAAYJ,CAAU,GAErC,CAAAI,CAAA,CAAWh2B,gBAAA,KAEfc,CAAA,CAAW8Y,KAAA,GAAQgc,CAAA;QAAA;MAWf5b,EAAA,CAAA3N,CAAA,EAAmBspB,CAAA,IAAa;QAKpC,MAAMK,CAAA,IAJsB,CAACC,CAAA,EAAeC,CAAA,KAA0B;UACpE,MAAMC,EAAA,GAAOF,CAAA,IAAS;UACtB,OAAOE,EAAA,GAAOD,CAAA,GAAgBA,CAAA,GAAgBC,EAAA,GAAO,IAAI,IAAIA,EAAA;QAAA,GAEnBR,CAAA,EAAUlpB,CAAA,CAAcmN,KAAK;QACrEoc,CAAA,KAAoBl1B,CAAA,CAAW8Y,KAAA,KACnC9Y,CAAA,CAAW8Y,KAAA,GAAQoc,CAAA;MAAA,CACpB,GAEKhc,EAAA,CAAAwb,EAAA,EAAY,CAACG,CAAA,EAAUC,CAAA,KAAa;QACxC,CAAIA,CAAA,CAAS+jB,QAAA,KAAahkB,CAAA,CAASgkB,QAAA,IAAY/jB,CAAA,CAASsjB,SAAA,KAAcvjB,CAAA,CAASujB,SAAA,IAI7EtjB,CAAA,CAASgkB,aAAA,KAAkBjkB,CAAA,CAASikB,aAAA,IACpCvtC,CAAA,CAAiBuN,KAAA,GAAQgc,CAAA,CAASgkB,aAAA,MAIlC94C,CAAA,CAAW8Y,KAAA,GAAQ;MACrB,CACD;MAED,MAAM8b,CAAA,GAAQhc,CAAA,CAAS,MACrB5X,KAAA,CAAMnB,IAAA,CAAK;QAAClB,MAAA,EAAQ61B,EAAA,CAAc1b;MAAK,GAAG,CAAC+b,CAAA,EAAGC,CAAA,MAAW;QACvDzS,MAAA,EAAQyR,EAAA,CAAYhb,KAAA,GAAQgc;MAAA,EAC5B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCrbJ,MAAMz2B,CAAA,GAAQ0C,CAAA;QAqBRzC,CAAA,GAAcggB,CAAA,CAAM,MACxBjgB,CAAA,CAAM4G,KAAA,KAAU,SACZ,SACA,OAAO5G,CAAA,CAAM4G,KAAA,IAAU,WACvB5G,CAAA,CAAM4G,KAAA,CAAMnE,QAAA,KACZzC,CAAA,CAAM4G,KAAA,CAAMzD,OAAA,CAAQ,KAAK,EAAE;QAG3B9B,CAAA,GAAa4e,CAAA,CAAM,MACvBjgB,CAAA,CAAMklC,IAAA,KAAS,SACX,SACA,OAAOllC,CAAA,CAAMklC,IAAA,IAAS,WACtBllC,CAAA,CAAMklC,IAAA,CAAKziC,QAAA,KACXzC,CAAA,CAAMklC,IAAA;QAGNzjC,CAAA,GAAkB8Y,CAAA,CAAS,OAAO;UACtC,CAAC,OAAOlZ,CAAA,CAAWoZ,KAAK,EAAE,GAAGpZ,CAAA,CAAWoZ,KAAA,KAAU,UAAaxa,CAAA,CAAYwa,KAAA,KAAU;UACrF,CAAC,MAAMza,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;UAC3C,CAAC,eAAertB,CAAA,CAAM6S,IAAI,EAAE,GAAG7S,CAAA,CAAM6S,IAAA,KAAS;QAC9C;QAEIlR,CAAA,GAAiB4Y,CAAA,CAAS,OAAO;UACrC,CAAC,eAAeva,CAAA,CAAM26C,SAAS,EAAE,GAAG36C,CAAA,CAAM26C,SAAA,KAAc;QACxD;QAEI94C,CAAA,GAAgB0Y,CAAA,CAAwB,OAAO;UACnD3T,KAAA,EAAO3G,CAAA,CAAYwa,KAAA,KAAU,SAAY,SAAY,GAAGxa,CAAA,CAAYwa,KAAK;QACzE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpDF,MAAMza,CAAA,GAAQ0C,CAAA;QAiBRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,OAAOva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;QAC5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCoBF,MAAMrtB,CAAA,GAAQ0C,CAAA;QAwDRzC,CAAA,GAAkBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM46C,QAAQ;QACpDv5C,CAAA,GAAkBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMk5C,QAAQ;QACpDz3C,CAAA,GAAkB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM66C,QAAQ;QACpDl5C,CAAA,GAAe0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM86C,KAAK;QAE9Cj5C,CAAA,GAAe0Y,CAAA,CAAS,OAAO;UACnCogC,SAAA,EAAW36C,CAAA,CAAM26C,SAAA;UACjB9nC,IAAA,EAAM7S,CAAA,CAAM6S,IAAA;UACZwa,OAAA,EAASrtB,CAAA,CAAMqtB;QACf;QAEIppB,CAAA,GAAkBgc,CAAA,CAAM,MAAQhgB,CAAA,CAAgBwa,KAAA,GAA6BsgC,EAAA,GAArBC,EAAkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCvGhG,MAAMh7C,CAAA,GAAQ0C,CAAA;QA0BRzC,CAAA,GAAoBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMi7C,UAAU;QACxD55C,CAAA,GAAoBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAMk7C,UAAU;QACxDz5C,CAAA,GAAkB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMm7C,QAAQ;QACpDx5C,CAAA,GAAc0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMqmB,IAAI;QAC5CxkB,CAAA,GAAewqB,CAAA,CAAc,MAAMrsB,CAAA,CAAMo7C,KAAK;QAC9Cn3C,CAAA,GAAeooB,CAAA,CAAc,MAAMrsB,CAAA,CAAMgd,KAAK;QAC9C7Q,CAAA,GAAiBkgB,CAAA,CAAc,MAAMrsB,CAAA,CAAMq7C,OAAO;QAClDjvC,CAAA,GAAsBigB,CAAA,CAAc,MAAMrsB,CAAA,CAAMs7C,YAAY;QAC5DjvC,CAAA,GAAwBggB,CAAA,CAAc,MAAMrsB,CAAA,CAAMu7C,cAAc;QAChEjvC,CAAA,GAAqB+f,CAAA,CAAc,MAAMrsB,CAAA,CAAMw7C,UAAU;QACzDjvC,CAAA,GAAkB8f,CAAA,CAAc,MAAMrsB,CAAA,CAAMgvB,OAAO;QAEnD5kB,CAAA,GAAkBmQ,CAAA,CAAS,MAAM,CACrCva,CAAA,CAAMy7C,UAAA,EACN,SACA,WACA;UACE,kBAAkBh6C,CAAA,CAAgBgZ,KAAA;UAClC,oBAAoBpZ,CAAA,CAAkBoZ,KAAA;UACtC,CAAC,UAAUza,CAAA,CAAMsiC,aAAa,EAAE,GAAGtiC,CAAA,CAAMsiC,aAAA,KAAkB;UAC3D,eAAeriC,CAAA,CAAkBwa,KAAA;UACjC,cAAc9Y,CAAA,CAAY8Y,KAAA;UAC1B,eAAe5Y,CAAA,CAAa4Y,KAAA;UAC5B,mBAAmBlO,CAAA,CAAgBkO,KAAA,KAAU;UAC7C,CAAC,mBAAmBlO,CAAA,CAAgBkO,KAAK,EAAE,GAAG,OAAOlO,CAAA,CAAgBkO,KAAA,IAAU;UAC/E,iBAAiBtO,CAAA,CAAesO,KAAA;UAChC,YAAYxW,CAAA,CAAawW,KAAA;UACzB,CAAC,SAASza,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;UAC9C,yBAAyBhhB,CAAA,CAAsBoO;QACjD,EACD;QAEKvN,CAAA,GAAoBqN,CAAA,CAAS,OAAO;UACxC,oBAAoBjO,CAAA,CAAmBmO,KAAA,KAAU;UACjD,CAAC,oBAAoBnO,CAAA,CAAmBmO,KAAK,EAAE,GAAG,OAAOnO,CAAA,CAAmBmO,KAAA,IAAU;UACtF,yBAAyBrO,CAAA,CAAoBqO;QAC7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC3BF,MAAMza,CAAA,GAAQ0C,CAAA;QAoDRzC,CAAA,GAAkB8gB,EAAA,CAAY,MAAM/gB,CAAA,CAAMujC,OAAO;QACjDliC,CAAA,GAAe0f,EAAA,CAAY,MAAM/gB,CAAA,CAAM07C,IAAI;QAC3Cj6C,CAAA,GAAwBwe,CAAA,CAAM,MAAMjgB,CAAA,CAAM27C,aAAA,IAAiB/rB,GAAG;QAC9DjuB,CAAA,GAAwBse,CAAA,CAAM,MAAMjgB,CAAA,CAAM47C,aAAA,IAAiBhsB,GAAG;QAC9D/tB,CAAA,GAAsBkf,EAAA,CAAYtf,CAAqB;QACvDwC,CAAA,GAAsB8c,EAAA,CAAYpf,CAAqB;QAEvDwK,CAAA,GAAgB8T,CAAA,CAAM,MAAMhgB,CAAA,CAAgBwa,KAAA,IAAS,CAAC;QACtDrO,CAAA,GAAa6T,CAAA,CAAM,MAAM5e,CAAA,CAAaoZ,KAAA,IAAS,CAAC;QAEhDpO,CAAA,GAA8B4T,CAAA,CAAM,MACxCjgB,CAAA,CAAM27C,aAAA,KAAkB,SAAYxvC,CAAA,CAAcsO,KAAA,GAAQ5Y,CAAA,CAAoB4Y,KAAA;QAE1EnO,CAAA,GAA8B2T,CAAA,CAAM,MACxCjgB,CAAA,CAAM47C,aAAA,KAAkB,SAAYzvC,CAAA,CAAcsO,KAAA,GAAQxW,CAAA,CAAoBwW,KAAA;QAG1ElO,CAAA,GAAoB8f,CAAA,CAAc,MAAMrsB,CAAA,CAAMm0C,UAAU;QACxD/pC,CAAA,GAAoBiiB,CAAA,CAAc,MAAMrsB,CAAA,CAAM67C,UAAU;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpH9D,MAAM77C,CAAA,GAAQ0C,CAAA;QAgBRzC,CAAA,GAAiBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAMw/B,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCFxD,MAAMx/B,CAAA,GAAQ0C,CAAA;QAoBRzC,CAAA,GAAa+8B,EAAA,CAAO1C,EAAA,EAAsB,IAAI;QAE9Cj5B,CAAA,GAAkBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAM87C,QAAQ;QACpDr6C,CAAA,GAAsB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAM+7C,YAAY;QAC5Dp6C,CAAA,GAAmB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMg8C,SAAS;QACtDn6C,CAAA,GAAiBwqB,CAAA,CAAc,MAAMrsB,CAAA,CAAMq7C,OAAO;QAClDp3C,CAAA,GAA4BmpB,EAAA,CAAuBptB,CAAK;QAExDmM,CAAA,GAAkBoO,CAAA,CAAS,MAAM,CACrCtW,CAAA,CAA0BwW,KAAA,EAC1B;UACE,yBAAyBpZ,CAAA,CAAgBoZ,KAAA,KAASxa,CAAA,oBAAAA,CAAA,CAAY67C,QAAA,CAASrhC,KAAA;UACvE,wBACE5Y,CAAA,CAAe4Y,KAAA,KACfxa,CAAA,oBAAAA,CAAA,CAAYo7C,OAAA,CAAQ5gC,KAAA,KACpBpZ,CAAA,CAAgBoZ,KAAA,KAChBxa,CAAA,oBAAAA,CAAA,CAAY67C,QAAA,CAASrhC,KAAA;QACzB,EACD;QAEKrO,CAAA,GAAkB2U,EAAA,CAAY,MAAM/gB,CAAA,CAAMi8C,SAAS;QACnD5vC,CAAA,GAAc0U,EAAA,CAAY,MAAM/gB,CAAA,CAAMya,KAAK;QAC3CnO,CAAA,GAAYyU,EAAA,CAAY,MAAM/gB,CAAA,CAAM6J,GAAA,IAAO+lB,GAAG;QAC9CrjB,CAAA,GAAkBwU,EAAA,CAAY,OAAM9gB,CAAA,oBAAAA,CAAA,CAAY4J,GAAA,CAAI4Q,KAAA,KAASmV,GAAG;QAEhExlB,CAAA,GAAgBmQ,CAAA,CAAS,MAC7Bva,CAAA,CAAMk8C,SAAA,KAAc,SAChBl8C,CAAA,CAAMk8C,SAAA,GACNv6C,CAAA,CAAiB8Y,KAAA,IAASxa,CAAA,YAAAA,CAAA,CAAY+7C,SAAA,CAAUvhC,KAAA,GAChDpO,CAAA,CAAYoO,KAAA,CAAMm0B,OAAA,CAAQxiC,CAAA,CAAgBqO,KAAK,IAC/ChZ,CAAA,CAAoBgZ,KAAA,IAASxa,CAAA,YAAAA,CAAA,CAAY87C,YAAA,CAAathC,KAAA,IACpDpO,CAAA,CAAYoO,KAAA,GAAQ,OAAQnO,CAAA,CAAUmO,KAAA,IAAS,MAAMm0B,OAAA,CAAQxiC,CAAA,CAAgBqO,KAAK,IACpFza,CAAA,CAAMgxB,KAAA,KAAU,SAChBhxB,CAAA,CAAMgxB,KAAA,GACN;QAGA9jB,CAAA,GAAgBqN,CAAA,CAAS,MAC7BhO,CAAA,CAAgBkO,KAAA,GACZ,GAAIpO,CAAA,CAAYoO,KAAA,GAAQ,MAAOlO,CAAA,CAAgBkO,KAAK,MACpDnO,CAAA,CAAUmO,KAAA,GACV,GAAIpO,CAAA,CAAYoO,KAAA,GAAQ,MAAOnO,CAAA,CAAUmO,KAAK,MAC9C,OAAOza,CAAA,CAAMya,KAAA,IAAU,WACvBza,CAAA,CAAMya,KAAA,GACN,GAAGza,CAAA,CAAMya,KAAK;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7DpB,MAAMza,CAAA,GAAQ0C,CAAA;QA4BRzC,CAAA,GAAkBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM87C,QAAQ;QACpDz6C,CAAA,GAAsBgrB,CAAA,CAAc,MAAMrsB,CAAA,CAAM+7C,YAAY;QAC5Dt6C,CAAA,GAAmB4qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMg8C,SAAS;QACtDr6C,CAAA,GAAiB0qB,CAAA,CAAc,MAAMrsB,CAAA,CAAMq7C,OAAO;MAExD,OAAAnf,EAAA,CAAQ5B,EAAA,EAAsB;QAC5BwhB,QAAA,EAAU77C,CAAA;QACV4J,GAAA,EAAKoW,CAAA,CAAM,MAAMjgB,CAAA,CAAM6J,GAAG;QAC1BkyC,YAAA,EAAc16C,CAAA;QACd26C,SAAA,EAAWv6C,CAAA;QACX45C,OAAA,EAAS15C;MAAA,CACV,IAAAE,CAAA,EAAAoC,CAAA,MAAA2zB,CAAA,IAAAC,CAAA;;;;;;;;;;;;;;;;;;;EChDKskB,EAAA,GAAe5iB,EAAA,CAAmB,QAAQ,CAAC,EAAE,GAAG;IAAC1Q,IAAA,EAAM,CAAC5lB,MAAA,EAAQ4F,MAAM;IAAG43B,OAAA,EAAS;EAAK;EAE7F2b,EAAA,GAAe/nB,CAAA,CAAgB;IAC7Bj0B,IAAA,EAAM;IACN4kC,KAAA,EAAOzkC,MAAA;IAGP0kC,KAAA,EAAO;MACLvF,GAAA,EAAK;QAAC7W,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAK;MAClCmF,OAAA,EAAS;QAAC/c,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAI;MACrCoF,OAAA,EAAS;QAAChd,IAAA,EAAM5lB,MAAA;QAAQw9B,OAAA,EAAS;MAAI;MACrC4b,SAAA,EAAW;QAACxzB,IAAA,EAAM,CAAC9b,OAAA,EAAS9J,MAAM;QAA2Bw9B,OAAA,EAAS;MAAK;MAC3E6b,MAAA,EAAQ;QAACzzB,IAAA,EAAM5lB,MAAA;QAAuCw9B,OAAA,EAAS;MAAI;MACnE8b,MAAA,EAAQ;QAAC1zB,IAAA,EAAM5lB,MAAA;QAA6Cw9B,OAAA,EAAS;MAAI;MACzE+b,YAAA,EAAc;QAAC3zB,IAAA,EAAM5lB,MAAA;QAAsCw9B,OAAA,EAAS;MAAI;MACxE,GAAG0b;IACL;IACA9W,MAAM3iC,CAAA,EAAO;MACX,MAAM1C,CAAA,GAAmBqsB,CAAA,CAAc,MAAM3pB,CAAA,CAAM25C,SAAS;QACtDp8C,CAAA,GAAYisB,EAAA,CAAa,MAAMxpB,CAAA,CAAM65C,MAAM;QAE3Cl7C,CAAA,GAAiBkZ,CAAA,CAAS,MAAMmf,EAAA,CAAWh3B,CAAA,EAAOy5C,EAAA,EAAc,QAAQ,UAAU,CAAC;MAclF;QACL3W,eAAA,EAbsBjrB,CAAA,CAAS,MAAM,CACrClZ,CAAA,CAAeoZ,KAAA,EACf;UACE,CAAC,MAAM/X,CAAA,CAAMkjC,OAAO,EAAE,GAAGljC,CAAA,CAAMkjC,OAAA,KAAY;UAC3C,CAAC,MAAMljC,CAAA,CAAMmjC,OAAO,EAAE,GAAGnjC,CAAA,CAAMmjC,OAAA,KAAY;UAC3C,OAAO7lC,CAAA,CAAiBya,KAAA;UACxB,CAAC,eAAe/X,CAAA,CAAM45C,MAAM,EAAE,GAAG55C,CAAA,CAAM45C,MAAA,KAAW;UAClD,CAACr8C,CAAA,CAAUwa,KAAK,GAAG/X,CAAA,CAAM65C,MAAA,KAAW;UACpC,CAAC,iBAAiB75C,CAAA,CAAM85C,YAAY,EAAE,GAAG95C,CAAA,CAAM85C,YAAA,KAAiB;QAClE,EACD;MAGC;IAEJ;EACF,CAAC;AAvD2B,SAAAC,GAAA/5C,CAAA,EAAA1C,CAAA,EAAeC,CAAA,EAAeoB,CAAA,EAAAI,CAAA,EAAAE,CAAA;;IAC9Cm7B,KAAA,EAAA4I,CAAA,SAAAhjC,CAAA,CAAA8iC,eAAA;EAAA;IAAA/E,OAAA,EAAAkF,CAAA,Q;;;;;;;;;;;;;MCQZ,MAAM3lC,CAAA,GAAQ0C,CAAA;QAcRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,SAASva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;QAC9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCNF,MAAMrtB,CAAA,GAAQ0C,CAAA;QAsBRzC,CAAA,GAAsBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM08C,YAAY;QAE5Dr7C,CAAA,GAAkBkZ,CAAA,CAAS,OAAO;UACtC,CAAC,SAASva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;UAC9C,yBAAyBptB,CAAA,CAAoBwa,KAAA;UAC7C,yBAAyBxa,CAAA,CAAoBwa,KAAA,IAASza,CAAA,CAAMqtB,OAAA,KAAY;QACxE;QAEI5rB,CAAA,GAAQwe,CAAA,CAAM,MAAOjgB,CAAA,CAAM28C,OAAA,GAAU,YAAY38C,CAAA,CAAM48C,OAAA,GAAU,YAAY,KAAM;;;;;;;;;;;;;;;;;;;;MCxCzF,MAAM58C,CAAA,GAAQ0C,CAAA;QAcRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,SAASva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;QAC9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCNF,MAAMrtB,CAAA,GAAQ0C,CAAA;QAsBRzC,CAAA,GAAsBosB,CAAA,CAAc,MAAMrsB,CAAA,CAAM08C,YAAY;QAE5Dr7C,CAAA,GAAkBkZ,CAAA,CAAS,OAAO;UACtC,CAAC,SAASva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;UAC9C,yBAAyBptB,CAAA,CAAoBwa,KAAA;UAC7C,yBAAyBxa,CAAA,CAAoBwa,KAAA,IAASza,CAAA,CAAMqtB,OAAA,KAAY;QACxE;QAEI5rB,CAAA,GAAQwe,CAAA,CAAM,MAAOjgB,CAAA,CAAM28C,OAAA,GAAU,YAAY38C,CAAA,CAAM48C,OAAA,GAAU,YAAY,KAAM;;;;;;;;;;;;;;;;;;;;MCxCzF,MAAM58C,CAAA,GAAQ0C,CAAA;QAcRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,SAASva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;QAC9C;;;;;;;;;;;;;;MChBF,MAAMrtB,CAAA,GAAQ0C,CAAA;QAcRzC,CAAA,GAAkBsa,CAAA,CAAS,OAAO;UACtC,CAAC,SAASva,CAAA,CAAMqtB,OAAO,EAAE,GAAGrtB,CAAA,CAAMqtB,OAAA,KAAY;QAC9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCgLF,MAAMptB,CAAA,GAAQyC,CAAA;QAgDRrB,CAAA,GAAOrB,CAAA;QAaPyB,CAAA,GAAmB4qB,CAAA,CAAc,MAAMpsB,CAAA,CAAM48C,SAAS;QACtDl7C,CAAA,GAAsB0qB,CAAA,CAAc,MAAMpsB,CAAA,CAAM68C,YAAY;QAC5Dj7C,CAAA,GAAmBwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAM88C,SAAS;QACtD94C,CAAA,GAAkBooB,CAAA,CAAc,MAAMpsB,CAAA,CAAM+uB,OAAO;QAEnD7iB,CAAA,GAAuBoO,CAAA,CAAS,MAAM,CAC1Cta,CAAA,CAAMw7C,UAAA,EACN;UACE,CAAC,SAASx7C,CAAA,CAAM8iC,KAAK,EAAE,GAAG9iC,CAAA,CAAM8iC,KAAA,KAAU;QAC5C,EACD;QAEK32B,CAAA,GAAiBmO,CAAA,CAA6B,MAC9C,CAACta,CAAA,CAAM+8C,MAAA,CAAO18C,MAAA,IAAUL,CAAA,CAAM8sB,KAAA,CAAMzsB,MAAA,GAC/BC,MAAA,CAAOkd,IAAA,CAAKxd,CAAA,CAAM8sB,KAAA,CAAM,CAAC,CAAC,EAAEjhB,GAAA,CAAKwB,CAAA,IAAM;UACtC,MAAAC,CAAA,GAAQrK,EAAA,CAAUoK,CAAC;UAClB;YACL8U,GAAA,EAAK9U,CAAA;YACL0jB,KAAA,EAAAzjB,CAAA;YACA0vC,MAAA,EAAQh5C,CAAA,CAAgBwW,KAAA,KAAU,KAAO;cAAC,cAAclN;YAAS;UAAA;QACnE,CACD,IAGItN,CAAA,CAAM+8C,MAAA,CAAOlxC,GAAA,CAAKwB,CAAA,IAAM;UACzB,WAAOA,CAAA,IAAM,UAAU;YACnB,MAAAC,CAAA,GAAQrK,EAAA,CAAUoK,CAAC;YAClB;cACL8U,GAAA,EAAK9U,CAAA;cACL0jB,KAAA,EAAAzjB,CAAA;cACA0vC,MAAA,EAAQh5C,CAAA,CAAgBwW,KAAA,KAAU,KAAO;gBAAC,cAAclN;cAAS;YAAA;UAErE;UACO;YACL,GAAGD,CAAA;YACH2vC,MAAA,EACEh5C,CAAA,CAAgBwW,KAAA,KAAU,KAAO;cAAC,cAAcvX,EAAA,CAAUoK,CAAA,CAAE8U,GAAG;cAAG,GAAG9U,CAAA,CAAE2vC;YAAA,IAAU3vC,CAAA,CAAE2vC;UAAA;QACvF,CAED,CACF;QACK5wC,CAAA,GAAsB4T,CAAA,CAAM,MAAM7T,CAAA,CAAeqO,KAAA,CAAMna,MAAM;QAE7DgM,CAAA,GAAa4wC,CACjB5vC,CAAA,EACAC,CAAA,EACAC,CAAA,KACG;UACG,MAAAE,CAAA,GAAM+tB,EAAA,CAAInuB,CAAA,EAAMC,CAAQ;UACvB,OAAAC,CAAA,IAAa,OAAOA,CAAA,IAAc,aAAaA,CAAA,CAAUE,CAAA,EAAKH,CAAA,EAAUD,CAAI,IAAII,CAAA;QAAA;QAGnFnB,CAAA,GAAgB4wC,CAAC7vC,CAAA,EAAmBC,CAAA,EAAmBC,CAAA,GAAW,OAAU;UAChF,MAAME,CAAA,GAAW,OAAOJ,CAAA,IAAU,WAAWA,CAAA,GAAQA,CAAA,CAAM8U,GAAA;UAC3D/gB,CAAA,CAAK,gBAAgBqM,CAAA,EAAUJ,CAAA,EAAOC,CAAA,EAAOC,CAAQ;QAAA;QAGjDpD,CAAA,GAAoBkD,CAAA,IAAkB;UACvCA,CAAA,CAAA8vC,YAAA,GAAe,CAAC9vC,CAAA,CAAG8vC,YAAA;QAAA;QAGlBlwC,CAAA,GAAyBI,CAAA,IAA4B,CACzDA,CAAA,CAAMwvB,KAAA,EACNxvB,CAAA,CAAM+vC,OAAA,EACN;UACE,yBAAyB/vC,CAAA,CAAMovC;QACjC,GACAz8C,CAAA,CAAMq9C,gBAAA,GACF,OAAOr9C,CAAA,CAAMq9C,gBAAA,IAAqB,aAChCr9C,CAAA,CAAMq9C,gBAAA,CAAiBhwC,CAAK,IAC5BrN,CAAA,CAAMq9C,gBAAA,GACR;QAGAnwC,CAAA,GAAqBowC,CAACjwC,CAAA,EAAyBC,CAAA,KAAkB;;UAAA,QACrED,CAAA,CAAMwvB,KAAA,EACNxvB,CAAA,CAAMkwC,OAAA,GACNhwC,CAAA,GAAAD,CAAA,CAAGkwC,aAAA,KAAH,QAAAjwC,CAAA,CAAmBF,CAAA,CAAM8U,GAAA,IAAO,SAAS7U,CAAA,CAAGkwC,aAAA,CAAcnwC,CAAA,CAAM8U,GAAG,CAAC,KAAK,MACzE;YACE,yBAAyB9U,CAAA,CAAMovC;UACjC;QAAA;QAGItvC,CAAA,GAAgBswC,CAACpwC,CAAA,EAAiBC,CAAA,KACtCtN,CAAA,CAAM09C,YAAA,GACF,OAAO19C,CAAA,CAAM09C,YAAA,IAAiB,aAC5B19C,CAAA,CAAM09C,YAAA,CAAarwC,CAAA,EAAMC,CAAI,IAC7BtN,CAAA,CAAM09C,YAAA,GACR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC7PN,MAAMt8C,CAAA,GAAQqB,CAAA;QAuHRjB,CAAA,GAAOxB,CAAA;QAsBP0B,CAAA,GAAc8pB,EAAA,CAAUpqB,CAAA,EAAO,UAAUI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAC9DhD,CAAA,GAAY4pB,EAAA,CAAUpqB,CAAA,EAAO,QAAQI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAC1DZ,CAAA,GAAgBwnB,EAAA,CAAUpqB,CAAA,EAAO,YAAYI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAClEsH,CAAA,GAAqBsf,EAAA,CAAUpqB,CAAA,EAAO,iBAAiBI,CAAA,EAAM;UAACoD,OAAA,EAAS;QAAA,CAAK;QAE5EuH,CAAA,GAAqBmO,CAAA,CAAS;UAClC3C,GAAA,EAAKA,CAAA,KAAU,mBAAA0D,GAAA,CAAI,CAAC,GAAGnP,CAAA,CAAmBsO,KAAK,CAAC;UAChD5C,GAAA,EAAM0e,CAAA,IAAQ;YACOpqB,CAAA,CAAAsO,KAAA,GAAQ,CAAC,GAAG8b,CAAG;UACpC;QAAA,CACD;QAKKlqB,CAAA,GAA4B;UAChCwa,GAAA,EAAM0P,CAAA,IAAoB;YACxB,MAAMC,CAAA,GAAQ,IAAIlb,GAAA,CAAIlP,CAAA,CAAmBqO,KAAK;YAC9C+b,CAAA,CAAM3P,GAAA,CAAI0P,CAAI,GACdnqB,CAAA,CAAmBqO,KAAA,GAAQ+b,CAAA,EAC3B/0B,CAAA,CAAK,gBAAgB80B,CAAI;UAC3B;UACAqnB,KAAA,EAAOA,CAAA,KAAM;YACQxxC,CAAA,CAAAqO,KAAA,CAAMjB,OAAA,CAAS+c,CAAA,IAAS;cACzC90B,CAAA,CAAK,kBAAkB80B,CAAI;YAAA,CAC5B,GACkBnqB,CAAA,CAAAqO,KAAA,sBAAYa,GAAA;UACjC;UACAmP,MAAA,EAAS8L,CAAA,IAAoB;YAC3B,MAAMC,CAAA,GAAQ,IAAIlb,GAAA,CAAIlP,CAAA,CAAmBqO,KAAK;YAC9C+b,CAAA,CAAM/L,MAAA,CAAO8L,CAAI,GACjBnqB,CAAA,CAAmBqO,KAAA,GAAQ+b,CAAA,EAC3B/0B,CAAA,CAAK,kBAAkB80B,CAAI;UAC7B;UAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;UASA3a,GAAA,EAAM2a,CAAA,IAAoBnqB,CAAA,CAAmBqO,KAAA,CAAMmB,GAAA,CAAI2a,CAAI;QAAA;QAMvDjqB,CAAA,GAAgBoO,CAAA,CAAiB,EAAE;QAEnCnO,CAAA,GAAkB8f,CAAA,CAAcpoB,CAAa;QAC7CmG,CAAA,GAAciiB,CAAA,CAAcxqB,CAAS;QACrCqL,CAAA,GAA0Bmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMw8C,gBAAgB;QACpE1wC,CAAA,GAA2Bkf,CAAA,CAAc,MAAMhrB,CAAA,CAAMy8C,iBAAiB;QACtE1wC,CAAA,GAA6Bif,CAAA,CAAc,MAAMhrB,CAAA,CAAM08C,mBAAmB;QAC1EzwC,CAAA,GAAoB+e,CAAA,CAAc,MAAMhrB,CAAA,CAAM28C,UAAU;QACxDzwC,CAAA,GAAwB8e,CAAA,CAAc,MAAMhrB,CAAA,CAAM48C,cAAc;QAEhEzwC,CAAA,GAAgBuT,EAAA,CAAY,MAAM1f,CAAA,CAAMy4C,OAAA,EAAS;UAAC94B,MAAA,EAAQ;QAAA,CAAW;QACrEtT,CAAA,GAAoBqT,EAAA,CAAY,MAAM1f,CAAA,CAAM68C,WAAA,EAAa;UAACl9B,MAAA,EAAQ;QAAA,CAAW;QAE7EpT,CAAA,GAAoBqS,CAAA,CAAM,MAAM,CAAC,CAAC5e,CAAA,CAAMyL,MAAM;QAC9CsC,CAAA,GAAe6Q,CAAA,CAAM,MAAM5e,CAAA,CAAM88C,QAAA,KAAa,MAAS;QACvD9uC,CAAA,GAAc4Q,CAAA,CAAM,MAAM7T,CAAA,CAAmBqO,KAAA,CAAM5H,IAAA,GAAO,CAAC;QAE3DvD,CAAA,GAAaiL,CAAA,CACjB,MACE5Y,CAAA,CAAY8Y,KAAA,KAAU,UACtBpZ,CAAA,CAAM27C,MAAA,CAAOh3C,IAAA,CAAMuwB,CAAA,IAAW,OAAOA,CAAA,IAAU,WAAW,KAAQA,CAAA,CAAM6nB,QAAS;QAG/E7uC,CAAA,GAAiBgL,CAAA,CAAuB,MAC5ClZ,CAAA,CAAM27C,MAAA,CAAOlxC,GAAA,CAAKyqB,CAAA,IAChB,OAAOA,CAAA,IAAO,WACVA,CAAA,GACA;UACE,GAAGA,CAAA;UACH8nB,MAAA,EAAQ;YACN,aACE/uC,CAAA,CAAWmL,KAAA,KAAU,KACjB,SACA9Y,CAAA,CAAY8Y,KAAA,KAAU8b,CAAA,CAAGnU,GAAA,GACzB,SACA7V,CAAA,CAAgBkO,KAAA,KAAU,KAC1B,eACA;YACN,GAAG8b,CAAA,CAAG8nB;UACR;QACF,CACN;QAGI7uC,CAAA,GAAe+K,CAAA,CAAS,OAAO;UACnC,gBAAgBnQ,CAAA,CAAYqQ,KAAA;UAC5B,sBAAsBnN,CAAA,CAAkBmN,KAAA;UACxC,oBAAoBnN,CAAA,CAAkBmN,KAAA,IAASpL,CAAA,CAAYoL;QAC3D;QAEIhL,CAAA,GAAoB8K,CAAA,CAAS,MAAM,CACvClZ,CAAA,CAAMs8C,YAAA,GACF,OAAOt8C,CAAA,CAAMs8C,YAAA,IAAiB,aAC5Bt8C,CAAA,CAAMs8C,YAAA,CAAa,MAAM,YAAY,IACrCt8C,CAAA,CAAMs8C,YAAA,GACR,KACL;QACKjuC,CAAA,GAAyB6mB,CAAA,IAA4B,CACzD;UACE,2BAA2BjnB,CAAA,CAAWmL,KAAA,IAAS8b,CAAA,CAAM6nB;QACvD;QAMIzuC,CAAA,GAAgB+tC,CAACnnB,CAAA,EAAwBC,CAAA,KAAiB,CAC9D;UACE,CAAC,kBAAkBn1B,CAAA,CAAMi9C,gBAAgB,EAAE,GACzChxC,CAAA,CAAkBmN,KAAA,IAAS8b,CAAA,IAAQlqB,CAAA,CAA0BuP,GAAA,CAAI2a,CAAI;QACzE,GACAl1B,CAAA,CAAMs8C,YAAA,GACF,OAAOt8C,CAAA,CAAMs8C,YAAA,IAAiB,aAC5Bt8C,CAAA,CAAMs8C,YAAA,CAAapnB,CAAA,EAAMC,CAAI,IAC7Bn1B,CAAA,CAAMs8C,YAAA,GACR;QAEA/tC,CAAA,GAAgB2mB,CAAA,IACpB50B,CAAA,CAAY8Y,KAAA,KAAU8b,CAAA,CAAMnU,GAAA,GAAM;UAAC0E,OAAA,EAAS;QAAG,IAAI;QAE/CjX,CAAA,GAAgB0K,CAAA,CAAsB,MAAM;UAC1C,MAAAgc,CAAA,GAAaM,CAAA,IAAuB;cACxC,MAAMC,CAAA,GAAUn1B,CAAA,CAAY8Y,KAAA;cAE5B,IAAIqc,CAAA,KAAY,QACP,OAAAD,CAAA;cAGT,MAAME,CAAA,GAAYxnB,CAAA,CAAekL,KAAA,CAAMrI,IAAA,CAAM4kB,EAAA,IACvC,OAAOA,EAAA,IAAO,WAAiB,KAC5BA,EAAA,CAAG5U,GAAA,KAAQ0U,CACnB;cAGD,OAAI,OAAOC,CAAA,IAAc,aAAYA,CAAA,oBAAAA,CAAA,CAAWqnB,QAAA,MAAa,KACpDvnB,CAAA,GAGF,CAAC,GAAGA,CAAK,EAAEjmB,IAAA,CAAK,CAAComB,EAAA,EAAGE,EAAA,KAAM;gBAC/B,IAAI71B,CAAA,CAAMk9C,WAAA,KAAgB,QACxB,OAAOl9C,CAAA,CAAMk9C,WAAA,CAAYvnB,EAAA,EAAGE,EAAA,EAAGJ,CAAA,EAASvqB,CAAA,CAAgBkO,KAAK;gBAE/D,MAAM8Z,EAAA,GAAWC,EAAA,IACf,OAAOA,EAAA,IAAO,YAAYA,EAAA,KAAO,OAAOzxB,IAAA,CAAKC,SAAA,CAAUwxB,EAAE,KAAIA,EAAA,oBAAAA,EAAA,CAAI/xB,QAAA,OAAc;gBAE7E,OAAA8xB,EAAA,CAAQyC,EAAA,CAAEF,CAAO,CAAC,IAAIvC,EAAA,CAAQ2C,EAAA,CAAEJ,CAAO,CAAC,IACnCvqB,CAAA,CAAgBkO,KAAA,GAAQ,KAAK,IAGlC8Z,EAAA,CAAQ2C,EAAA,CAAEJ,CAAO,CAAC,IAAIvC,EAAA,CAAQyC,EAAA,CAAEF,CAAO,CAAC,IACnCvqB,CAAA,CAAgBkO,KAAA,GAAQ,IAAI,KAG9B;cAAA,CACR;YAAA;YAGG+b,CAAA,GAAeK,CAAA,IACnBA,CAAA,CAAM/pB,MAAA,CAAQgqB,CAAA,IACZv2B,MAAA,CAAO4jB,OAAA,CAAQ2S,CAAI,EAAE9wB,IAAA,CAAK,CAAC,CAAC+wB,CAAA,EAAKC,EAAG,MAAM;;cACpC,QAACA,EAAA,IAAOD,CAAA,CAAI,CAAC,MAAM,OAAO,GAACxC,EAAA,GAAAlzB,CAAA,CAAMm9C,UAAA,KAAN,QAAAjqB,EAAA,CAAkBnpB,QAAA,CAAS2rB,CAAA,KAAa,MAErE,OAAOC,EAAA,IAAQ,WAAWj0B,IAAA,CAAKC,SAAA,CAAUzC,MAAA,CAAOomB,MAAA,CAAOqQ,EAAG,CAAC,IAAIA,EAAA,CAAIv0B,QAAA,CAAS,GAC7DwF,WAAA,GAAcmD,QAAA,GAASopB,EAAA,GAAAnzB,CAAA,CAAMyL,MAAA,KAAN,gBAAA0nB,EAAA,CAAcvsB,WAAA,OAAiB,EAAE;YAAA,CAC1E;UAGL,IAAIwuB,CAAA,GAAcrnB,CAAA,CAAaqL,KAAA,GAAQnO,CAAA,CAAcmO,KAAA,GAAQpZ,CAAA,CAAM0rB,KAAA;UAEnE,QACGnf,CAAA,CAAkB6M,KAAA,KAAU,MAAQ,CAACrL,CAAA,CAAaqL,KAAA,IAClD7M,CAAA,CAAkB6M,KAAA,KAAU,MAAQrL,CAAA,CAAaqL,KAAA,IAASrN,CAAA,CAA2BqN,KAAA,MAEtFgc,CAAA,GAAcD,CAAA,CAAYC,CAAW,KAIpCnnB,CAAA,CAAWmL,KAAA,KAAU,MAAQ,CAACrL,CAAA,CAAaqL,KAAA,IAC3CnL,CAAA,CAAWmL,KAAA,KAAU,MAAQrL,CAAA,CAAaqL,KAAA,IAAStN,CAAA,CAAyBsN,KAAA,MAE7Egc,CAAA,GAAcF,CAAA,CAAUE,CAAW,IAG9BA,CAAA;QAAA,CACR;QAYK3mB,EAAA,GAAuByK,CAAA,CAAsB,MAC7C1R,MAAA,CAAOsY,KAAA,CAAM3T,CAAA,CAAciN,KAAK,KAAMrL,CAAA,CAAaqL,KAAA,IAAS,CAACvN,CAAA,CAAwBuN,KAAA,GAChF5K,CAAA,CAAc4K,KAAA,GAGhB5K,CAAA,CAAc4K,KAAA,CAAMhX,KAAA,EACxBiK,CAAA,CAAkB+M,KAAA,GAAQ,MAAMjN,CAAA,CAAciN,KAAA,IAAS,QACxD/M,CAAA,CAAkB+M,KAAA,IAASjN,CAAA,CAAciN,KAAA,IAAS,OAErD;QAEKzK,EAAA,GAAqByuC,CACzBloB,CAAA,EACAC,CAAA,EACAC,CAAA,GAAe,IACfI,CAAA,GAAc,IACdC,CAAA,GAAc,OACX;UACH,IAAKxpB,CAAA,CAAkBmN,KAAA,EAEvB;YAAA,IAAIpZ,CAAA,CAAMq9C,UAAA,KAAe,YAAYr9C,CAAA,CAAMq9C,UAAA,KAAe,SAAS;cAEjE,IAAIjoB,CAAA,IAAgBI,CAAA,EAAa;cAE7BxqB,CAAA,CAA0BuP,GAAA,CAAI2a,CAAG,IACnClqB,CAAA,CAA0Boe,MAAA,CAAO8L,CAAG,KAGhCl1B,CAAA,CAAMq9C,UAAA,KAAe,YACvBryC,CAAA,CAA0BuxC,KAAA,CAAM,GAGlCvxC,CAAA,CAA0Bwa,GAAA,CAAI0P,CAAG;YACnC,WAEIM,CAAA,IAAeC,CAAA,EAEbzqB,CAAA,CAA0BuP,GAAA,CAAI2a,CAAG,IACnClqB,CAAA,CAA0Boe,MAAA,CAAO8L,CAAG,IAGpClqB,CAAA,CAA0Bwa,GAAA,CAAI0P,CAAG,WAG1BE,CAAA,EAAc;cACvB,MAAMM,CAAA,GAAmB,CAAC,GAAG3qB,CAAA,CAAmBqO,KAAK,EAAEkkC,GAAA,CAAI;gBACrD3nB,EAAA,GAAoB31B,CAAA,CAAM0rB,KAAA,CAAMwF,SAAA,CAAWiC,EAAA,IAAMA,EAAA,KAAMuC,CAAgB;gBACvEG,EAAA,GAAmBxtB,IAAA,CAAKC,GAAA,CAAIqtB,EAAA,EAAmBR,CAAK;gBACpDjC,EAAA,GAAiB7qB,IAAA,CAAKG,GAAA,CAAImtB,EAAA,EAAmBR,CAAK;cAClDn1B,CAAA,CAAA0rB,KAAA,CAAMtpB,KAAA,CAAMyzB,EAAA,EAAkB3C,EAAA,GAAiB,CAAC,EAAE/a,OAAA,CAASgb,EAAA,IAAS;gBACnEnoB,CAAA,CAA0BuP,GAAA,CAAI4Y,EAAI,KACrCnoB,CAAA,CAA0Bwa,GAAA,CAAI2N,EAAI;cACpC,CACD;YAAA,OAGDnoB,CAAA,CAA0BuxC,KAAA,CAAM,GAChCvxC,CAAA,CAA0Bwa,GAAA,CAAI0P,CAAG;YAIhBH,EAAA;;QAAA;QAGjB9kB,EAAA,GAAastC,CAACroB,CAAA,EAAgBC,CAAA,EAAeC,CAAA,KAAkB;UACnEzmB,EAAA,CAAmBumB,CAAA,EAAKC,CAAA,EAAOC,CAAA,CAAEooB,QAAA,EAAUpoB,CAAA,CAAEmZ,OAAA,EAASnZ,CAAA,CAAEoZ,OAAO,GAC1DpuC,CAAA,gBAAe80B,CAAA,EAAKC,CAAA,EAAOC,CAAC;QAAA;QAG7BhB,EAAA,GAAsBc,CAAA,IAAsB;UAChD,IAAI,CAACjnB,CAAA,CAAWmL,KAAA,EAAO;UAEvB,MAAM+b,CAAA,GAAW,OAAOD,CAAA,IAAU,WAAWA,CAAA,GAAQA,CAAA,CAAMnU,GAAA;YACrDqU,CAAA,GAAgB,OAAOF,CAAA,IAAU,WAAW,KAAQA,CAAA,CAAM6nB,QAAA;UAE1D9uC,CAAA,CAAWmL,KAAA,KAAU,MAAQgc,CAAA,KAAkB,OAEjD90B,CAAA,CAAY8Y,KAAA,KAAU+b,CAAA,IACxB70B,CAAA,CAAY8Y,KAAA,GAAQ+b,CAAA,EACpBvyB,CAAA,CAAcwW,KAAA,GAAQ,MAElBlO,CAAA,CAAgBkO,KAAA,KAAU,KAC5BxW,CAAA,CAAcwW,KAAA,GAAQ,MAEtB9Y,CAAA,CAAY8Y,KAAA,GAAQ,QACpBxW,CAAA,CAAcwW,KAAA,GAAQ,KAGrBhZ,CAAA,WAAU+0B,CAAA,EAAU70B,CAAA,CAAY8Y,KAAA,KAAU,SAAY,KAAQ,CAAClO,CAAA,CAAgBkO,KAAK;QAAA;QAGrFib,EAAA,GAAmBopB,CACvBvoB,CAAA,EACAC,CAAA,EACAC,CAAA,EACAI,CAAA,GAAW,OACR;UACHp1B,CAAA,CAAK,gBAAgB80B,CAAA,EAAUC,CAAA,EAAOC,CAAA,EAAOI,CAAQ,GACrDpB,EAAA,CAAmBe,CAAK;QAAA;QAGpBL,EAAA,GAAoB,MAAA4oB,CAAA,KAAY;UACpC,IAAI,CAAC3vC,CAAA,CAAaqL,KAAA,IAASpZ,CAAA,CAAM88C,QAAA,KAAa,UAAa/zC,CAAA,CAAYqQ,KAAA,EAAO;UAC9E5Y,CAAA,CAAU4Y,KAAA,GAAQ;UACZ,MAAA8b,CAAA,GAAWl1B,CAAA,CAAM88C,QAAA,CAAS;YAC9BD,WAAA,EAAaxwC,CAAA,CAAkB+M,KAAA;YAC/B3N,MAAA,EAAQzL,CAAA,CAAMyL,MAAA;YACdkyC,MAAA,EAAQr9C,CAAA,CAAY8Y,KAAA;YACpBwkC,QAAA,EAAU59C,CAAA,CAAM49C,QAAA;YAChBnF,OAAA,EAAStsC,CAAA,CAAciN;UAAA,CACxB;UACG;YACF,MAAM+b,CAAA,GAAQD,CAAA,YAAoBtX,OAAA,GAAU,MAAMsX,CAAA,GAAWA,CAAA;YAE7D,IAAIC,CAAA,KAAU,QAAW;YACzBlqB,CAAA,CAAcmO,KAAA,GAAQ+b,CAAA;UAAA,UACtB;YACA30B,CAAA,CAAU4Y,KAAA,GAAQ;UACpB;QAAA;QAGI2b,EAAA,GAAuB8oB,CAAA,KAAM;UAC5B5xC,CAAA,CAAkBmN,KAAA,IACvBhZ,CAAA,CAAK,aAAa,CAAC,GAAG2K,CAAA,CAAmBqO,KAAK,CAAC;QAAA;QAE3C4b,EAAA,GAAsB,MAAA8oB,CAAA,KAAY;UACtC,IAAI/vC,CAAA,CAAaqL,KAAA,EAAO;YACtB,MAAM0b,EAAA,CAAkB;YACxB;UACF;UACK10B,CAAA,aAAYoO,CAAA,CAAc4K,KAAK;QAAA;QAGhC6b,EAAA,GAAqB,MAAA8oB,CAAO7oB,CAAA,EAAcC,CAAA,EAAcC,CAAA,KAAoB;UAChF,IAAID,CAAA,KAAQC,CAAA,EAAQ;UAGpB,MAAMI,CAAA,GAAgBK,EAAA;;cAAyB,SAAA3C,EAAA,GAAAlzB,CAAA,CAAMg+C,UAAA,KAAN,gBAAA9qB,EAAA,CAAkBnpB,QAAA,CAAS8rB,EAAA,OAAS;YAAA;YAC7EJ,CAAA,IACHP,CAAA,KAAS,iBAAiBA,CAAA,KAAS,eACnCM,CAAA,CAAa,QAAQ,KAAK3pB,CAAA,CAAwBuN,KAAA,KAAU;YACzDsc,CAAA,GACJR,CAAA,KAAS,aAAaM,CAAA,CAAa,WAAW,KAAKzpB,CAAA,CAA2BqN,KAAA,KAAU;YACpFuc,EAAA,IACHT,CAAA,KAAS,YAAYA,CAAA,KAAS,gBAC9BM,CAAA,CAAa,SAAS,KAAK1pB,CAAA,CAAyBsN,KAAA,KAAU;UAE7Dqc,CAAA,IAAuBC,CAAA,IAA0BC,EAAA,KAErD,MAAMb,EAAA,CAAkB,GAElBI,CAAA,KAAS,iBAAiBA,CAAA,KAAS,aAAgCF,EAAA;QAAA;MAG3E,OAAAxb,EAAA,CACE,MAAMxZ,CAAA,CAAMyL,MAAA,EACZ,CAACypB,CAAA,EAAQC,CAAA,KAAc;QACFF,EAAA,WAAUC,CAAA,EAAQC,CAAS,GAE1C,EAAAD,CAAA,KAAWC,CAAA,IAAapnB,CAAA,CAAaqL,KAAA,MACpC8b,CAAA,IACE90B,CAAA,aAAYoO,CAAA,CAAc4K,KAAK;MAExC,IAEII,EAAA,CAAAnN,CAAA,EAAmB,CAAC6oB,CAAA,EAAKC,CAAA,KAAW;QACrBF,EAAA,gBAAeC,CAAA,EAAKC,CAAM;MAAA,CAC9C,GACK3b,EAAA,CAAArN,CAAA,EAAe,CAAC+oB,CAAA,EAAKC,CAAA,KAAW;QACjBF,EAAA,YAAWC,CAAA,EAAKC,CAAM;MAAA,CAC1C,GACK3b,EAAA,CAAAlZ,CAAA,EAAa,CAAC40B,CAAA,EAAKC,CAAA,KAAW;QACfF,EAAA,WAAUC,CAAA,EAAKC,CAAM;MAAA,CACzC,GACK3b,EAAA,CAAAtO,CAAA,EAAiB,CAACgqB,CAAA,EAAKC,CAAA,KAAW;QACnBF,EAAA,aAAYC,CAAA,EAAKC,CAAM;MAAA,CAC3C,GAED3b,EAAA,CACE,MAAMxZ,CAAA,CAAM88C,QAAA,EACX5nB,CAAA,IAAa;QAEZ,IAAIA,CAAA,KAAa,QAAW;UAC1BjqB,CAAA,CAAcmO,KAAA,GAAQ;UACtB;QACF;QAEkB0b,EAAA;MACpB,IAGF3V,EAAA,CAAU2V,EAAiB,GAEdn2B,CAAA;QAAA;QAEXs/C,aAAA,EAAeA,CAAA,KAAM;UACdhyC,CAAA,CAAkBmN,KAAA,KACvBpO,CAAA,CAA0BuxC,KAAA,CAAM,GACXxnB,EAAA;QACvB;QACAmpB,OAAA,EAASppB,EAAA;QACTqpB,aAAA,EAAeA,CAAA,KAAM;UACnB,IAAI,CAAClyC,CAAA,CAAkBmN,KAAA,EAAO;UACxB,MAAA8b,CAAA,GAAoBnqB,CAAA,CAAmBqO,KAAA,CAAM5H,IAAA,GAAO,IAAI,CAAC,GAAGzG,CAAA,CAAmBqO,KAAK,IAAI;UAC9FrO,CAAA,CAAmBqO,KAAA,GAAY,mBAAAa,GAAA,CAAI,CAAC,GAAGzL,CAAA,CAAc4K,KAAK,CAAC,GACxCrO,CAAA,CAAAqO,KAAA,CAAMjB,OAAA,CAASgd,CAAA,IAAS;YACrCD,CAAA,CAAkBnrB,QAAA,CAASorB,CAAI,KACnC/0B,CAAA,CAAK,gBAAgB+0B,CAAI;UAAA,CAC1B,GACoBJ,EAAA;QACvB;QACAqpB,SAAA,EAAYlpB,CAAA,IAAkB;UAC5B,IAAI,CAACjpB,CAAA,CAAkBmN,KAAA,EAAO;UACxB,MAAA+b,CAAA,GAAO3mB,CAAA,CAAc4K,KAAA,CAAM8b,CAAK;UAClC,CAACC,CAAA,IAAQnqB,CAAA,CAA0BuP,GAAA,CAAI4a,CAAI,MAC/CnqB,CAAA,CAA0Bwa,GAAA,CAAI2P,CAAI,GACbJ,EAAA;QACvB;QACAspB,WAAA,EAAcnpB,CAAA,IAAkB;UAC9B,IAAI,CAACjpB,CAAA,CAAkBmN,KAAA,EAAO;UACxB,MAAA+b,CAAA,GAAO3mB,CAAA,CAAc4K,KAAA,CAAM8b,CAAK;UAClC,CAACC,CAAA,IAAQ,CAACnqB,CAAA,CAA0BuP,GAAA,CAAI4a,CAAI,MAChDnqB,CAAA,CAA0Boe,MAAA,CAAO+L,CAAI,GAChBJ,EAAA;QACvB;MAAA,CACD,IAAAG,CAAA,EAAAC,CAAA,MAAAoB,CAAA,IAAAztB,CAAA,CAAAw1C,EAAA,EAAA1iB,CAAA,CAAA57B,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCvoBD,MAAMpB,CAAA,GAAQyC,CAAA;QA+BRrB,CAAA,GAAQ08B,EAAA;QAORt8B,CAAA,GAAOzB,CAAA;QAQP2B,CAAA,GAAaq7B,EAAA,CAAO3C,EAAA,EAAkB,IAAI;QAC1Cx4B,CAAA,GAAaotB,EAAA,CAAM,MAAMhvB,CAAA,CAAMqvB,EAAA,EAAI,SAAS;QAC5CrrB,CAAA,GAAWgrB,EAAA,CAAM,MAAMhvB,CAAA,CAAM2/C,QAAA,EAAU,KAAK;QAE5CzzC,CAAA,GAAgBkgB,CAAA,CAAc,MAAMpsB,CAAA,CAAMm4B,MAAM;QAChDhsB,CAAA,GAAkBigB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiJ,QAAQ;QACpDmD,CAAA,GAAcggB,CAAA,CAAc,MAAMpsB,CAAA,CAAM4/C,QAAA,IAAY5/C,CAAA,CAAMuvB,IAAI;QAC9DljB,CAAA,GAAgB+f,CAAA,CAAc,MAAMpsB,CAAA,CAAM2iC,MAAM;QAEhDr2B,CAAA,GAAsBmO,CAAA,CAAI,EAAK;QAC/BtQ,CAAA,GAAKsQ,CAAA,CAAwB,IAAI;QAEjC;UAACqxB,OAAA,EAAA7+B,CAAA;UAAS,GAAGC;QAAA,IAAS4vB,EAAA,CAAS;QAE/B3vB,CAAA,GAAMmN,CAAA,CACV,OACG;UACC+U,EAAA,EAAIztB,CAAA,CAAW4Y,KAAA;UACfmlC,QAAA,EAAU37C,CAAA,CAASwW,KAAA;UACnBvR,QAAA,EAAUkD,CAAA,CAAgBqO,KAAA;UAC1B6a,KAAA,EAAOr1B,CAAA,CAAMq1B,KAAA;UACbwqB,cAAA,EAAgBz+C,CAAA,CAAMi0B,KAAA;UACtByqB,cAAA,EAAgB9/C,CAAA,CAAM8/C,cAAA;UACtBC,mBAAA,EAAqB//C,CAAA,CAAM+/C,mBAAA;UAC3BC,cAAA,EAAgBhgD,CAAA,CAAMggD,cAAA;UACtBlU,OAAA,EAAA7+B,CAAA;UACA6N,EAAA,EAAI3Q,CAAA,CAAGqQ;QAAA,EACT;MAGJ+F,EAAA,CAAU,MAAM;QACT7e,CAAA,KACLA,CAAA,CAAWu+C,WAAA,CAAY9yC,CAAG,GACtBjB,CAAA,CAAcsO,KAAA,IACL9Y,CAAA,CAAAw+C,WAAA,CAAYt+C,CAAA,CAAW4Y,KAAK;MACzC,CACD,GAED2lC,EAAA,CAAY,MAAM;QACXz+C,CAAA,IACMA,CAAA,CAAA0+C,aAAA,CAAcx+C,CAAA,CAAW4Y,KAAK;MAAA,CAC1C;MAED,MAAMnN,CAAA,GAAW2S,CAAA,CAAM,OAAMte,CAAA,oBAAAA,CAAA,CAAY2+C,QAAA,CAAS7lC,KAAA,MAAU5Y,CAAA,CAAW4Y,KAAK;QACtElN,CAAA,GAAOmN,CAAA,CAAIpN,CAAA,CAASmN,KAAK;QAEzBjN,CAAA,GAAeyS,CAAA,CAAM,MAAM,CAAC,EAAEte,CAAA,YAAAA,CAAA,CAAY6tB,IAAA,CAAK/U,KAAA,IAASpO,CAAA,CAAYoO,KAAA,CAAM;QAC1E/M,CAAA,GAAmBuS,CAAA,CAAM,MAAMhgB,CAAA,CAAM4/C,QAAA,KAAa,MAAS;QAE3DjyC,CAAA,GAAiBqS,CAAA,CAAM,MAAM3S,CAAA,CAASmN,KAAA,IAAS,CAACrO,CAAA,CAAgBqO,KAAK;QACrErL,CAAA,GAAW6Q,CAAA,CACf,MACErS,CAAA,CAAe6M,KAAA,IACf,CAACjN,CAAA,CAAaiN,KAAA,IACbjN,CAAA,CAAaiN,KAAA,IAAS/M,CAAA,CAAiB+M,KAAA,IAASlO,CAAA,CAAoBkO,KAAA;MAGnEI,EAAA,CAAAvN,CAAA,EAAWgC,CAAA,IAAW;QAC1B,IAAIA,CAAA,EAAQ;UACV7N,CAAA,CAAK,iBAAiB,EAAI,GAC1BoX,UAAA,CAAW,MAAM;YACftL,CAAA,CAAKkN,KAAA,GAAQ;UAAA,GACZ,CAAC;UACJ;QACF;QACAlN,CAAA,CAAKkN,KAAA,GAAQ,IACbhZ,CAAA,CAAK,iBAAiB,EAAK;MAAA,CAC5B,GACKoZ,EAAA,CAAA1O,CAAA,EAAgBmD,CAAA,IAAW;QAC/B,IAAK3N,CAAA,EACL;UAAA,IAAI,CAAC2N,CAAA,EAAQ;YACPhC,CAAA,CAASmN,KAAA,IACX9Y,CAAA,CAAWw+C,WAAA,CAAY,MAAS;YAElC;UACF;UACWx+C,CAAA,CAAAw+C,WAAA,CAAYt+C,CAAA,CAAW4Y,KAAK;QAAA;MAAA,CACxC;MAEK,MAAApL,CAAA,GAAkBkL,CAAA,CAAS,MAAM,CACrC;QACE6d,MAAA,EAAU9qB,CAAA,CAASmN,KAAA;QACnBoY,IAAA,EAAQtlB,CAAA,CAAKkN,KAAA;QACb,cAAa9Y,CAAA,oBAAAA,CAAA,CAAY4+C,IAAA,CAAK9lC,KAAA,KAASnO,CAAA,CAAcmO,KAAA,KAAU;QAC/Dic,IAAA,EAAQ,EAAC/0B,CAAA,YAAAA,CAAA,CAAYozB,MAAA,CAAOta,KAAA;MAC9B,GACAlN,CAAA,CAAKkN,KAAA,IAAS9Y,CAAA,YAAAA,CAAA,CAAY6+C,cAAA,GAAiB7+C,CAAA,CAAW6+C,cAAA,GAAiB,KACxE;MAEK,OAAA3lC,EAAA,CAAAzL,CAAA,EAAWE,CAAA,IAAU;QACrBA,CAAA,IAAS,CAAC/C,CAAA,CAAoBkO,KAAA,KAAOlO,CAAA,CAAoBkO,KAAA,GAAQ;MAAA,CACtE,IAAAnL,CAAA,EAAAC,CAAA,MAAAqoB,CAAA,IAAAztB,CAAA,CAAAk3B,EAAA,CAAA/xB,CAAA,CAAAowB,GAAA,GAAAzC,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MClFD,MAAMh9B,CAAA,GAAQyC,CAAA;QAiDRrB,CAAA,GAAOrB,CAAA;QAkBPyB,CAAA,GAAagqB,EAAA,CAAUxrB,CAAA,EAAO,cAAcoB,CAAA,EAAM;UAACwD,OAAA,EAAS;QAAA,CAAK;QACjElD,CAAA,GAAW8pB,EAAA,CAAUxrB,CAAA,EAAO,YAAYoB,CAAA,EAAM;UAACwD,OAAA,EAAS;QAAA,CAAK;QAE7DhD,CAAA,GAAcwqB,CAAA,CAAc,MAAMpsB,CAAA,CAAMsgD,IAAI;QAC5Ct8C,CAAA,GAAaooB,CAAA,CAAc,MAAMpsB,CAAA,CAAM2K,GAAG;QAC1CuB,CAAA,GAAckgB,CAAA,CAAc,MAAMpsB,CAAA,CAAMiwC,IAAI;QAC5C9jC,CAAA,GAAmBigB,CAAA,CAAc,MAAMpsB,CAAA,CAAMg3C,SAAS;QACtD5qC,CAAA,GAAcggB,CAAA,CAAc,MAAMpsB,CAAA,CAAMuvB,IAAI;QAC5CljB,CAAA,GAAgB+f,CAAA,CAAc,MAAMpsB,CAAA,CAAM80B,MAAM;QAChDxoB,CAAA,GAAoB8f,CAAA,CAAc,MAAMpsB,CAAA,CAAMwgD,UAAU;QACxDr2C,CAAA,GAAeiiB,CAAA,CAAc,MAAMpsB,CAAA,CAAMi3C,KAAK;QAC9ChqC,CAAA,GAAemf,CAAA,CAAc,MAAMpsB,CAAA,CAAM+c,KAAK;QAC9C7P,CAAA,GAAkBkf,CAAA,CAAc,MAAMpsB,CAAA,CAAMwhC,QAAQ;QAEpDr0B,CAAA,GAAesN,CAAA,CAAoB,EAAE;QAErCpN,CAAA,GAAOiN,CAAA,CAAS,MACpBnN,CAAA,CAAaqN,KAAA,CAAM3O,GAAA,CAAK6D,CAAA,IAAS;UACzB,MAAAC,CAAA,GAAMqK,CAAA,CAAMtK,CAAI;YAChBE,CAAA,GAASD,CAAA,CAAI0f,EAAA,KAAO3tB,CAAA,CAAS8Y,KAAA;UAE5B;YACL,GAAG7K,CAAA;YACHwoB,MAAA,EAAAvoB,CAAA;YACA6wC,cAAA,EAAgB,CACd;cACEtoB,MAAA,EAAAvoB,CAAA;cACA3G,QAAA,EAAU0G,CAAA,CAAI1G;YAChB,GACA2G,CAAA,IAAU5P,CAAA,CAAM0gD,kBAAA,GAAqB1gD,CAAA,CAAM0gD,kBAAA,GAAqB,MAChE/wC,CAAA,CAAIqwC,cAAA;UACN;QACF,CACD;QAGG1yC,CAAA,GAAY0S,CAAA,CAAM,MAAM,EAAE3S,CAAA,YAAAA,CAAA,CAAMmN,KAAA,IAASnN,CAAA,CAAKmN,KAAA,CAAMna,MAAA,GAAS,EAAE;QAE/DkN,CAAA,GAAkB+M,CAAA,CAAS,OAAO;UACtC,UAAUpN,CAAA,CAAgBsN,KAAA;UAC1B,qBAAqBtN,CAAA,CAAgBsN;QACrC;QAEI/M,CAAA,GAAYwe,EAAA,CAAa,MAAMjsB,CAAA,CAAM8iC,KAAK;QAE1Cn1B,CAAA,GAAiB2M,CAAA,CAAS,OAAO;UACrC,aAAanQ,CAAA,CAAaqQ,KAAA;UAC1B,oBAAoBtN,CAAA,CAAgBsN,KAAA;UACpC,CAAC/M,CAAA,CAAU+M,KAAK,GAAGxa,CAAA,CAAM8iC,KAAA,KAAU;UACnC,YAAY52B,CAAA,CAAYsO,KAAA;UACxB,oBAAoB5Y,CAAA,CAAY4Y,KAAA;UAChC,iBAAiBrO,CAAA,CAAiBqO,KAAA;UAClC,YAAY,CAAClO,CAAA,CAAkBkO,KAAA,IAAS,CAACrQ,CAAA,CAAaqQ,KAAA;UACtDuC,KAAA,EAAS9P,CAAA,CAAauN;QACtB;QAEIrL,CAAA,GAAeO,CAAA,IAAwB;;UAC3C,IAAIA,CAAA,KAAU,QAAW;YACvB,MAAME,CAAA,IAAKD,CAAA,GAAAtC,CAAA,CAAKmN,KAAA,CAAM9K,CAAK,MAAhB,gBAAAC,CAAA,CAAmB0f,EAAA;YAE5B,IAAA3f,CAAA,GAAQ,MACRA,CAAA,GAAQrC,CAAA,CAAKmN,KAAA,CAAMna,MAAA,IACnB,CAACgN,CAAA,CAAKmN,KAAA,CAAM9K,CAAK,EAAEzG,QAAA,KAClBzH,CAAA,CAAWgZ,KAAA,GAAQ,KAAK9Y,CAAA,CAAS8Y,KAAA,KAAU5K,CAAA,IAAMpO,CAAA,CAAWgZ,KAAA,KAAU9K,CAAA,GACvE;cACA,MAAMG,EAAA,GAAW,IAAIhQ,EAAA,CAAQ,gBAAgB;gBAACc,UAAA,EAAY;cAAA,CAAK;cAC/DS,CAAA,CAAK,gBAAgBsO,CAAA,EAAOlO,CAAA,CAAWgZ,KAAA,EAAO3K,EAAQ,GACjDA,EAAA,CAASjP,gBAAA,KACRc,CAAA,CAAS8Y,KAAA,KAAU5K,CAAA,KAAIlO,CAAA,CAAS8Y,KAAA,GAAQ5K,CAAA,GACxCpO,CAAA,CAAWgZ,KAAA,KAAU9K,CAAA,KAAOlO,CAAA,CAAWgZ,KAAA,GAAQ9K,CAAA;YAEvD;UACF;QAAA;QAGIN,CAAA,GAAcuxC,CAACjxC,CAAA,EAAmBC,CAAA,KAAkB;;UACxDR,CAAA,CAAYQ,CAAK,GAEfA,CAAA,IAAS,KACT,CAACtC,CAAA,CAAKmN,KAAA,CAAM7K,CAAK,EAAE1G,QAAA,KACnB2G,CAAA,GAAAvC,CAAA,CAAKmN,KAAA,CAAM7K,CAAK,MAAhB,QAAAC,CAAA,CAAmBk8B,OAAA,IACnB,OAAOz+B,CAAA,CAAKmN,KAAA,CAAM7K,CAAK,EAAEm8B,OAAA,IAAY,gBAErC/7B,EAAA,IAAAF,EAAA,GAAAxC,CAAA,CAAKmN,KAAA,CAAM7K,CAAK,GAAEm8B,OAAA,KAAlB,QAAA/7B,EAAA,CAAAlN,IAAA,CAAAgN,EAAA,EAA4BH,CAAA;QAC9B;QAGIL,CAAA,GAAUK,CAAA,IAAsB;;UAChCrC,CAAA,CAAKmN,KAAA,CAAMna,MAAA,IAAU,MACzBmB,CAAA,CAAWgZ,KAAA,GAAQlL,CAAA,CAAU9N,CAAA,CAAWgZ,KAAA,GAAQ9K,CAAA,EAAWA,CAAS,IAC3DE,CAAA,GAAAxL,QAAA,CAAAkD,cAAA,EAAeqI,CAAA,GAAAtC,CAAA,CAAKmN,KAAA,CAAMhZ,CAAA,CAAWgZ,KAAK,MAA3B,gBAAA7K,CAAA,CAA8BgwC,QAAQ,MAArD,QAAA/vC,CAAA,CAAwDzJ,KAAA;QAAM;QAGnEmJ,CAAA,GAAYsxC,CAAClxC,CAAA,EAAeC,CAAA,KAAsB;UAClD,IAAAtC,CAAA,CAAKmN,KAAA,CAAMna,MAAA,IAAU,GAAU;UACnC,IAAIuP,CAAA,GAAQF,CAAA;UACN,MAAAG,EAAA,GAASxC,CAAA,CAAKmN,KAAA,CAAM3O,GAAA,CAAKwF,EAAA,IAAQ,CAACA,EAAA,CAAIpI,QAAQ,EAAE43C,WAAA,CAAY,EAAI;YAChE9wC,EAAA,GAAS1C,CAAA,CAAKmN,KAAA,CAAM3O,GAAA,CAAKwF,EAAA,IAAQ,CAACA,EAAA,CAAIpI,QAAQ,EAAEC,OAAA,CAAQ,EAAI;UAC3D,OAAA0G,CAAA,IAASG,EAAA,IAAUH,CAAA,IAASC,EAAA,IAAUxC,CAAA,CAAKmN,KAAA,CAAM5K,CAAK,EAAE3G,QAAA,GACpD2G,CAAA,IAAAD,CAAA;UAEX,OAAIC,CAAA,GAAQG,EAAA,KAAgBH,CAAA,GAAAG,EAAA,GACxBH,CAAA,IAASC,EAAA,KAAgBD,CAAA,GAAAC,EAAA,GACtBD,CAAA;QAAA;MAGHgL,EAAA,CAAApZ,CAAA,EAAY,CAACkO,CAAA,EAAUC,CAAA,KAAa;QAEpC,IADAD,CAAA,KAAaC,CAAA,IACbtC,CAAA,CAAKmN,KAAA,CAAMna,MAAA,IAAU,GACvB;QAGF,MAAMuP,CAAA,GAAQN,CAAA,CAAUI,CAAA,EAAUA,CAAA,GAAWC,CAAA,GAAW,IAAI,EAAE;QAC9D6Q,EAAA,CAAS,MAAM;UACbrR,CAAA,CAAYS,CAAK;QAAA,CAClB;MAAA,CACF,GAEKgL,EAAA,CAAAlZ,CAAA,EAAU,CAACgO,CAAA,EAAUC,CAAA,KAAa;QAChC,MAAAC,CAAA,GAAQvC,CAAA,CAAKmN,KAAA,CAAM8X,SAAA,CAAWziB,EAAA,IAAMA,EAAA,CAAEwf,EAAA,KAAO3f,CAAQ;QAC3D,IAAIA,CAAA,KAAaC,CAAA,IACb,EAAAtC,CAAA,CAAKmN,KAAA,CAAMna,MAAA,IAAU,IAGzB;UAAA,IAAIuP,CAAA,KAAU,IAAI;YACJT,CAAA,CAAAG,CAAA,CAAU,GAAG,CAAC,CAAC;YAC3B;UACF;UACAH,CAAA,CAAYS,CAAK;QAAA;MAAA,CAClB;MAEK,MAAAL,CAAA,GAAeG,CAAA,IAAsB;UACpCvC,CAAA,CAAaqN,KAAA,CAAMrI,IAAA,CAAMxC,CAAA,IAAMA,CAAA,CAAE6K,KAAA,CAAM6U,EAAA,KAAO3f,CAAA,CAAI8K,KAAA,CAAM6U,EAAE,IAG7DliB,CAAA,CAAaqN,KAAA,CAAMrN,CAAA,CAAaqN,KAAA,CAAM8X,SAAA,CAAW3iB,CAAA,IAAMA,CAAA,CAAE6K,KAAA,CAAM6U,EAAA,KAAO3f,CAAA,CAAI8K,KAAA,CAAM6U,EAAE,CAAC,IAAI3f,CAAA,GAF1EvC,CAAA,CAAAqN,KAAA,CAAMpJ,IAAA,CAAK1B,CAAG,GAI7BvC,CAAA,CAAaqN,KAAA,GAAQrN,CAAA,CAAaqN,KAAA,CAAM7J,IAAA,CAAK,CAAChB,CAAA,EAAGC,CAAA,KAAM;YACjD,KAACpK,IAAA,IAAQ,CAACmK,CAAA,CAAE6K,KAAA,CAAMM,EAAA,IAAM,CAAClL,CAAA,CAAE4K,KAAA,CAAMM,EAAA,EAAW;YAChD,MAAMjL,EAAA,GAAWF,CAAA,CAAE6K,KAAA,CAAMM,EAAA,CAAGgmC,uBAAA,CAAwBlxC,CAAA,CAAE4K,KAAA,CAAMM,EAAE;YAC9D,OAAIjL,EAAA,GAAWrK,IAAA,CAAKu7C,2BAAA,GAAoC,KACpDlxC,EAAA,GAAWrK,IAAA,CAAKw7C,2BAAA,GAAoC,IACjD;UAAA,CACR;QAAA;QAEGxxC,CAAA,GAAiBE,CAAA,IAAe;UAChCvC,CAAA,CAAaqN,KAAA,CAAMrI,IAAA,CAAMxC,CAAA,IAAMA,CAAA,CAAE6K,KAAA,CAAM6U,EAAA,KAAO3f,CAAE,KAClDvC,CAAA,CAAaqN,KAAA,CAAMuS,MAAA,CACjB5f,CAAA,CAAaqN,KAAA,CAAM8X,SAAA,CAAW3iB,CAAA,IAAMA,CAAA,CAAE6K,KAAA,CAAM6U,EAAA,KAAO3f,CAAE,GACrD;QAEJ;MAGFkL,EAAA,CACEzN,CAAA,EACA,MAAM;QACOsC,CAAA;MACb,GACA;QAAC8U,IAAA,EAAM;MAAI;MAGb,MAAM9U,CAAA,GAAawxC,CAAA,KAAM;;QACnB,IAAA5zC,CAAA,CAAKmN,KAAA,CAAMna,MAAA,KAAW,GAAG;UAC3BmB,CAAA,CAAWgZ,KAAA,GAAQ,IACnB9Y,CAAA,CAAS8Y,KAAA,GAAQ;UACjB;QACF;QAII,IAHAhZ,CAAA,CAAWgZ,KAAA,IAAS,KAAK,CAAC9Y,CAAA,CAAS8Y,KAAA,KACrC9Y,CAAA,CAAS8Y,KAAA,IAAQ9K,CAAA,GAAArC,CAAA,CAAKmN,KAAA,CAAMhZ,CAAA,CAAWgZ,KAAK,MAA3B,gBAAA9K,CAAA,CAA8B2f,EAAA,GAE7ChiB,CAAA,CAAKmN,KAAA,CAAMrI,IAAA,CAAMxC,CAAA,IAAMA,CAAA,CAAE0f,EAAA,KAAO3tB,CAAA,CAAS8Y,KAAK,GAAG;UACvCrL,CAAA,CAAA9B,CAAA,CAAKmN,KAAA,CAAM8X,SAAA,CAAW3iB,CAAA,IAAMA,CAAA,CAAE0f,EAAA,KAAO3tB,CAAA,CAAS8Y,KAAK,CAAC;UAChE;QACF;QACYrL,CAAA,CAAA9B,CAAA,CAAKmN,KAAA,CAAM3O,GAAA,CAAK8D,CAAA,IAAQ,CAACA,CAAA,CAAI1G,QAAQ,EAAEC,OAAA,CAAQ,EAAI,CAAC;MAAA;MAGlE,OAAA+yB,EAAA,CAAQ7B,EAAA,EAAkB;QACxB7K,IAAA,EAAMnjB,CAAA;QACNk0C,IAAA,EAAM1+C,CAAA;QACNkzB,MAAA,EAAQzoB,CAAA;QACRk0C,cAAA,EAAgBvgC,CAAA,CAAM,MAAMhgB,CAAA,CAAMugD,cAAc;QAChDN,WAAA,EAAA1wC,CAAA;QACA6wC,aAAA,EAAA5wC,CAAA;QACA6wC,QAAA,EAAA3+C,CAAA;QACAw+C,WAAA,EAAcxwC,CAAA,IAAO;UACb,MAAAC,CAAA,GAAMtC,CAAA,CAAKmN,KAAA,CAAM8X,SAAA,CAAW1iB,CAAA,IAAMA,CAAA,CAAEyf,EAAA,KAAO3f,CAAE;UAC/C,IAAAA,CAAA,KAAO,UAAaC,CAAA,KAAQ,IAAI;YACtBR,CAAA,CAAAG,CAAA,CAAU,GAAG,CAAC,CAAC;YAC3B;UACF;UACAH,CAAA,CAAYQ,CAAG;QACjB;MAAA,CACD,IAAAD,CAAA,EAAAC,CAAA,MAAAgoB,CAAA,IAAAztB,CAAA,CAAAk3B,EAAA,CAAA1xB,CAAA,CAAA+vB,GAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MC3QD,MAAMr+B,CAAA,GAAQqB,CAAA;QA+CRjB,CAAA,GAAOxB,CAAA;QAQP0B,CAAA,GAAU+Y,CAAA,CAAwB,IAAI;QAEtC7Y,CAAA,GAAaulB,EAAA,CAAgBzlB,CAAO;QACpCsC,CAAA,GAAawnB,EAAA,CAAUpqB,CAAA,EAAO,cAAcI,CAAI;QAEhD;UAACmrB,YAAA,EAAAzgB,CAAA;UAAc0gB,iBAAA,EAAAzgB;QAAiB,IAAIogB,EAAA,CAAenrB,CAAK;MAIrCgrB,CAAA,CAAc,MAAMhrB,CAAA,CAAMs5C,SAAS;MAC5D,MAAMtuC,CAAA,GAAkBggB,CAAA,CAAc,MAAMhrB,CAAA,CAAM8/C,QAAQ;MAGlC90B,CAAA,CAAc,MAAMhrB,CAAA,CAAM+/C,QAAQ;MAC1D,MAAM90C,CAAA,GAAuB+f,CAAA,CAAc,MAAMhrB,CAAA,CAAMggD,aAAa;QAC9D90C,CAAA,GAAgB8f,CAAA,CAAc,MAAMhrB,CAAA,CAAM0zB,MAAM;QAChD3qB,CAAA,GAAsBiiB,CAAA,CAAc,MAAMhrB,CAAA,CAAMy+B,YAAY;QAC5D5yB,CAAA,GAAqBmf,CAAA,CAAc,MAAMhrB,CAAA,CAAMw+B,WAAW;QAC1D1yB,CAAA,GAAiB4T,EAAA,CAAY,MAAM1f,CAAA,CAAM0+B,QAAQ;MAGlC1T,CAAA,CAAc,MAAMhrB,CAAA,CAAMigD,KAAK;MAC9C,MAAAl0C,CAAA,GAA4BggB,EAAA,CAAuB/rB,CAAK;QACxDiM,CAAA,GAAkB2S,CAAA,CAAM,MAAO,OAAOhc,CAAA,CAAWwW,KAAA,IAAU,YAAY,IAAIxW,CAAA,CAAWwW,KAAM;QAE5F;UACJmF,QAAA,EAAArS,CAAA;UACAuS,KAAA,EAAAtS,CAAA;UACAqgB,OAAA,EAAAngB,CAAA;UACAqS,MAAA,EAAAnS,CAAA;UACAuQ,IAAA,EAAA/O,CAAA;UACA4e,QAAA,EAAA3e,CAAA;UACAoL,KAAA,EAAOnL;QAAA,IACLoe,EAAA,CAAapgB,CAAA,EAAiBH,CAAA,EAAgB;UAChDwT,SAAA,EAAW,OAAO1c,CAAA,CAAWwW,KAAA,IAAU;QAAA,CACxC;MAEDqI,EAAA,CAAY,MAAM;QACXrhB,CAAA,oBAAmB6N,CAAA,CAAYmL,KAAK;MAAA,CAC1C;MAED,MAAMlL,CAAA,GAAc0Q,CAAA,CAAM,MAAO9T,CAAA,CAAasO,KAAA,GAAQwjB,EAAA,GAAQ,KAAM;QAE9DzuB,CAAA,GAAiByQ,CAAA,CAAM,MAC3B,OAAOhc,CAAA,CAAWwW,KAAA,IAAU,YACxBxW,CAAA,CAAWwW,KAAA,GACXlN,CAAA,CAASkN,KAAA,IAAUvN,CAAA,CAAmBuN,KAAA,IAASpL,CAAA,CAASoL,KAAA;MAIxDI,EAAA,CAAAtN,CAAA,EAAWqC,CAAA,IAAa;QACxBA,CAAA,KAAa,MAASP,CAAA,CAASoL,KAAA,KAAU,MAC3ChZ,CAAA,CAAK,WAAW;MAClB,CACD;MAEK,MAAAgO,CAAA,GAAkB8K,CAAA,CAAS,MAAM,CACrCnN,CAAA,CAA0BqN,KAAA,EAC1B;UACEoY,IAAA,EAAMrjB,CAAA,CAAeiL;QACvB,EACD;QAEK/K,CAAA,GAAOgC,CAAA,KAAM;UACjBjQ,CAAA,CAAK,OAAO,GAER,OAAOwC,CAAA,CAAWwW,KAAA,IAAU,YAC9BxW,CAAA,CAAWwW,KAAA,GAAQ,MAEnBxW,CAAA,CAAWwW,KAAA,GAAQ,GACdrL,CAAA,KAGP3N,CAAA,CAAK,QAAQ;QAAA;QAGTkO,CAAA,GAAeuwB,CAAA,KAAM;UACrB91B,CAAA,CAAoBqQ,KAAA,IAClBjN,CAAA;QAAA;MAGF,OAAAqN,EAAA,CAAAhZ,CAAA,EAAa+N,CAAA,IAAa;QAC9B,IAAIA,CAAA,EAAU;UACCD,CAAA;UACb;QACF;QACO/B,CAAA;MAAA,CACR,GAED+pB,EAAA,CAAgBvoB,CAAI,GAEPpP,CAAA;QACX8f,KAAA,EAAAtS,CAAA;QACAqgB,OAAA,EAAAngB,CAAA;QACAqS,MAAA,EAAAnS,CAAA;QACAuQ,IAAA,EAAA/O;MAAA,CACD,IAAAQ,CAAA,EAAAC,CAAA,MAAA+nB,CAAA,IAAAztB,CAAA,CAAAg2B,EAAA;QAAA,WAAAlmB,CAAA,CAAA1N,CAAA;MAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCjMD,MAAMtM,CAAA,GAAQyC,CAAA;QAaRrB,CAAA,GAA0BgrB,CAAA,CAAc,MAAMpsB,CAAA,CAAM20C,gBAAgB;QAEpEnzC,CAAA,GAAiB;UACrB,YAAY;UACZ,cAAc;UACd,aAAa;UACb,eAAe;UACf,iBAAiB;UACjB,gBAAgB;UAChB,eAAe;UACf,iBAAiB;UACjB,gBAAgB;QAAA;QAGZ;UAACiQ,IAAA,EAAA/P,CAAA;UAAMmyB,MAAA,EAAAjyB,CAAA;UAAQgxB,IAAA,EAAA5uB;QAAA,IAAQ4vB,EAAA,CAAS;QAEhC1nB,CAAA,GAAkBC,CAAA,IAAoCkvB,EAAA,CAAKlvB,CAAA,EAAS,CAAC,SAAS,QAAQ,KAAK,CAAC;MAErF,OAAApM,CAAA;QACX0R,IAAA,EAAA/P,CAAA;QACAkxB,IAAA,EAAA5uB;MAAA,CACD,IAAAmI,CAAA,EAAAC,CAAA,MAAAurB,CAAA,IAAAztB,CAAA,CAAAg9B,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MCpBK,MAAAlnC,CAAA,GAAUya,CAAA,CAA0C,IAAI;MAEjD,OAAA1a,CAAA;QACX0R,IAAA,GAAMrQ,CAAA,GAAApB,CAAA,CAAQwa,KAAA,KAAR,gBAAApZ,CAAA,CAAeqQ,IAAA;QACrBmhB,IAAA,GAAMpxB,CAAA,GAAAxB,CAAA,CAAQwa,KAAA,KAAR,gBAAAhZ,CAAA,CAAeoxB,IAAA;QACrBnB,MAAA,GAAQ/vB,CAAA,GAAA1B,CAAA,CAAQwa,KAAA,KAAR,gBAAA9Y,CAAA,CAAe+vB;MAAA,CACxB,IAAA7vB,CAAA,EAAAoC,CAAA,MAAA2zB,CAAA,IAAAztB,CAAA,CAAAiqB,EAAA,EAAA6I,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ECoEKskB,EAAA,GAAiB;IACrBC,QAAQ9+C,CAAA,EAAU1C,CAAA,GAA+B;MAAC0oC,UAAA,EAAY;MAAM+Y,UAAA,EAAY;IAAA,GAAO;MACrF,MAAMxhD,CAAA,GACJ,OAAOD,CAAA,CAAQ0oC,UAAA,IAAe,aAAa,OAAO1oC,CAAA,CAAQ0oC,UAAA,GAAe,MACrE;UAAC9M,GAAA,EAAK;QAAA,IACN57B,CAAA,CAAQ0oC,UAAA;QAERrnC,CAAA,GAAgBd,MAAA,CAAOkd,IAAA,CAAKikC,EAAU;MAC5ChmB,EAAA,CAAmBz7B,CAAA,EAAoBoB,CAAa,EAAEmY,OAAA,CAAS3X,CAAA,IAAS;QAChE,MAAAoC,CAAA,GAAYy9C,EAAA,CAAW7/C,CAAI;QAC7Ba,CAAA,CAAA67B,SAAA,CAAU18B,CAAA,EAAMoC,CAAS;MAAA,CAC9B;MAED,MAAMxC,CAAA,GACJ,QAAOzB,CAAA,oBAAAA,CAAA,CAASyhD,UAAA,KAAe,aAAa,OAAOzhD,CAAA,CAAQyhD,UAAA,GAAe,MACtE;UAAC7lB,GAAA,EAAK;QAAA,IACN57B,CAAA,oBAAAA,CAAA,CAASyhD,UAAA;QAET9/C,CAAA,GAAgBpB,MAAA,CAAOkd,IAAA,CAAKo7B,EAAU;MAC5Cnd,EAAA,CAAmBj6B,CAAA,EAAoBE,CAAa,EAAE6X,OAAA,CAAS3X,CAAA,IAAS;QAChE,MAAAoC,CAAA,GAAapC,CAAA,CAAKoG,WAAA,GAAcutB,UAAA,CAAW,GAAG,IAAI3zB,CAAA,CAAK4B,KAAA,CAAM,CAAC,IAAI5B,CAAA;UAClEsK,CAAA,GAAY0sC,EAAA,CAAWh3C,CAAI;QAC7Ba,CAAA,CAAAi/C,SAAA,CAAU19C,CAAA,EAAYkI,CAAS;MAAA,CACpC;IACH;EACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}