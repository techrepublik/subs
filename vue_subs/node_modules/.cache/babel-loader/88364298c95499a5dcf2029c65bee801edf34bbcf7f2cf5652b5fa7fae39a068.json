{"ast":null,"code":"/**\r\n * An Adapter can be used to apply chained synchronous transformations to any\r\n * value at runtime.\r\n *\r\n * Each type class using Adapters must have `adapters` property and adapter\r\n * interface defined.\r\n *\r\n * Adapters can be used to allow external code to apply transformations to any\r\n * value at any time.\r\n *\r\n * For example we have a Weather class which has a method `now()` which returns\r\n * current temperature.\r\n *\r\n * ```\r\n * function now() {\r\n *   // ... calculate temperature\r\n *   let temp = \"Temperature now is \" + degrees + \"F\";\r\n *   return temp;\r\n * }\r\n * ```\r\n *\r\n * Now, supposed we want to let other classes to modify the output of the\r\n * `now()`? We just apply an adapter to the `temp` before it is returned:\r\n *\r\n * ```\r\n * temp = this.adapters.apply(\"now\", {\r\n *   temp: temp,\r\n *   degrees: degrees\r\n * }).temp;\r\n * ```\r\n *\r\n * Some other class might tap onto it by defining an Adapter that calculates\r\n * the temperature in Celsius:\r\n *\r\n * weather.adapters.add(\"now\", (arg) => {\r\n *   arg.temp += \"(\" + farenheitToCelsius(arg.degrees) + \"C)\";\r\n *   return arh;\r\n * });\r\n *\r\n * Furthermore some time-related class could add time:\r\n *\r\n * weather.adapters.add(\"now\", (arg) => {\r\n *   arg.temp += \"; the time now is \" + (new Date().toLocaleString());\r\n *   return arh;\r\n * });\r\n *\r\n * So without adapters we would get output like this:\r\n *\r\n * ```\r\n * Temperature now is 90F\r\n * ```\r\n *\r\n * With adapters applied we now have:\r\n *\r\n * ```\r\n * Temperature now is 90F (32C); the time now is 12/11/2012, 7:00:00 PM\r\n * ```\r\n */\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { SortedList } from \"./SortedList\";\nimport * as $number from \"./Number\";\nimport * as $order from \"./Order\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport * as $object from \"../utils/Object\";\n/**\r\n * ============================================================================\r\n * GLOBAL ADAPTER\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * A global adapter is an adpater that is attached to a class type rather than\r\n * specific object instance.\r\n *\r\n * @ignore Exclude from docs\r\n */\nvar GlobalAdapter = /** @class */function () {\n  function GlobalAdapter() {\n    /**\r\n     * Callback id iterator.\r\n     */\n    this._callbackId = 0;\n    /**\r\n     * A list of if callbacks (adapters).\r\n     */\n    this._callbacks = new SortedList(function (left, right) {\n      return $order.or($number.order(left.priority, right.priority), $number.order(left.id, right.id));\n    });\n  }\n  /**\r\n   * Adds a global callback which is not specific to any particular object.\r\n   * Whenever an adapter in any object of the specific class type is invoked\r\n   * global adapters will kick in.\r\n   *\r\n   * @param type      Class type\r\n   * @param key       Adapter key\r\n   * @param callback  Callback function\r\n   * @param priority  Priority (higher priority meaning adapter will be applied later)\r\n   * @param scope     Callback function scaope\r\n   */\n  GlobalAdapter.prototype.addAll = function (type, key, callback, priority, scope) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n    this._callbacks.insert({\n      id: ++this._callbackId,\n      key: key,\n      callback: callback,\n      priority: priority,\n      scope: scope,\n      type: type\n    });\n  };\n  /**\r\n   * Returns if there are adapters for specific type available.\r\n   *\r\n   * @param type  Adapter type\r\n   * @param key   Adapter key\r\n   * @return {boolean}\r\n   */\n  GlobalAdapter.prototype.isEnabled = function (type, key) {\n    return $array.any(this._callbacks.values, function (x) {\n      return x.key === key && type instanceof x.type;\n    });\n  };\n  /**\r\n   * Applies global adapters for the object of the specific type.\r\n   *\r\n   * @param type   Class type\r\n   * @param key    Adapter key\r\n   * @param value  Value\r\n   */\n  GlobalAdapter.prototype.applyAll = function (type, key, value) {\n    // This is needed to improve the performance and reduce garbage collection\n    var callbacks = this._callbacks.values;\n    var length = callbacks.length;\n    if (length == 0) {\n      return value;\n    }\n    // Cycle through all callbacks and find the ones we need to use\n    for (var i = 0; i < length; ++i) {\n      var item = callbacks[i];\n      if (item.key === key && type instanceof item.type) {\n        value = item.callback.call(item.scope, value, type, key);\n      }\n    }\n    return value;\n  };\n  return GlobalAdapter;\n}();\nexport { GlobalAdapter };\n/**\r\n * A global Adapter for plugins that want to add specific\r\n * functionality for any chart, not just specific instance.\r\n *\r\n * If you want to add an adapter which applies to all instances of the same\r\n * object type, like, for instance all slices in PieSeries, you can use\r\n * global adapter.\r\n *\r\n * Global adapter is a system-wide instance, accessible via `globalAdapter`.\r\n *\r\n * ```TypeScript\r\n * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, \"fill\">(am4charts.PieSeries, \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n * ```JavaScript\r\n * am4core.globalAdapter.addAll(am4charts.PieSeries, \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n *\r\n * @ignore\r\n */\nexport var globalAdapter = new GlobalAdapter();\n/**\r\n * ============================================================================\r\n * REGULAR ADAPTER\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Adapter allows adding ordered callback functions and associating them with a\r\n * string-based key. An Adapter user can then easily invoke those callbacks to\r\n * apply custom functions on its input, output or intermediate values.\r\n *\r\n * Custom code and plugins can add their own callbacks to modify and enhance\r\n * core functionality.\r\n *\r\n * See the description of `add()` for an example.\r\n *\r\n * Almost any object in amCharts4 has own adapter, accessible with `adapter`\r\n * property.\r\n *\r\n * Any adapters added to it will be applied to that object only.\r\n *\r\n * ### Global Adapters\r\n *\r\n * If you want to add an adapter which applies to all instances of the same\r\n * object type, like, for instance all slices in PieSeries, you can use\r\n * global adapter.\r\n *\r\n * Global adapter is a system-wide instance, accessible via `globalAdapter`.\r\n *\r\n * ```TypeScript\r\n * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, \"fill\">(am4charts.PieSeries. \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n * ```JavaScript\r\n * am4core.globalAdapter.addAll(am4charts.PieSeries. \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n *\r\n * {@link https://www.amcharts.com/docs/v4/reference/adapter_module/#globalAdapter_property More info}.\r\n *\r\n * @important\r\n */\nvar Adapter = /** @class */function () {\n  /**\r\n   * Constructor, sets the object referece this Adapter should be used for.\r\n   *\r\n   * @param c Object\r\n   */\n  function Adapter(c) {\n    /**\r\n     * Internal counter for callback ids.\r\n     */\n    this._callbackId = 0;\n    /**\r\n     * A list of adapter callbacks.\r\n     *\r\n     * @param $number.order(left.priority, right.priority) [description]\r\n     * @param $number.order(left.id,       right.id));\t}  [description]\r\n     */\n    this._callbacks = new SortedList(function (left, right) {\n      return $order.or($number.order(left.priority, right.priority), $number.order(left.id, right.id));\n    });\n    this._disabled = {};\n    this.object = c;\n    // TODO this exposes the internal events\n    this.events = this._callbacks.events;\n  }\n  /**\r\n   * Adds a callback for a specific key.\r\n   *\r\n   * ```TypeScript\r\n   * // Override fill color value and make all slices green\r\n   * chart.series.template.adapter.add(\"fill\", (value, target, key) => {\r\n   *   return am4core.color(\"#005500\");\r\n   * });\r\n   * ```\r\n   * ```JavaScript\r\n   * // Override fill color value and make all slices green\r\n   * chart.series.template.adapter.add(\"fill\", function(value, target, key) {\r\n   *   return am4core.color(\"#005500\");\r\n   * });\r\n   * ```\r\n   * ```JSON\r\n   * {\r\n   *   // ...\r\n   *   \"series\": [{\r\n   *     // ...\r\n   *     \"adapter\": {\r\n   *     \t// Override fill color value and make all slices green\r\n   *     \t\"fill\": function(value, target, key) {\r\n   *     \t  return am4core.color(\"#005500\");\r\n   *     \t}\r\n   *     }\r\n   *   }]\r\n   * }\r\n   * ```\r\n   *\r\n   * The above will call user-defined function (adapter) whenever `fill` value\r\n   * is requested from the Pie series, allowing it to override the default\r\n   * using custom code and any fuzzy logic.\r\n   *\r\n   * There can be any number of adapters set on one property key.\r\n   *\r\n   * In this case adapters will be applied in daisy-chain fashion. The first\r\n   * adapter in queue will make its transformation. The next one will have\r\n   * the output of the first adapter as a starting value, etc.\r\n   *\r\n   * The order of the adapters are determined either by the order they were\r\n   * added in, or their `priority` value.\r\n   *\r\n   * The heigher the `priority`, the later in the game adapter will be applied.\r\n   *\r\n   * @param key       Key\r\n   * @param callback  A callback function\r\n   * @param priority  The higher priority, the more chance the adapter will be applied last\r\n   * @param scope     Scope for the callback function\r\n   */\n  Adapter.prototype.add = function (key, callback, priority, scope) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n    this._callbacks.insert({\n      id: ++this._callbackId,\n      key: key,\n      callback: callback,\n      priority: priority,\n      scope: scope\n    });\n  };\n  /**\r\n   * Checks whether specific adapter is already set.\r\n   *\r\n   * @param key       Key\r\n   * @param callback  A callback function\r\n   * @param priority  The higher priority, the more chance the adapter will be applied last\r\n   * @param scope     Scope for the callback function\r\n   * @returns                            Adapter set?\r\n   */\n  Adapter.prototype.has = function (key, callback, priority, scope) {\n    if (priority === void 0) {\n      priority = 0;\n    }\n    return $iter.contains(this._callbacks.iterator(), function (item) {\n      return item.key === key && item.callback === callback && item.priority === priority && item.scope === scope;\n    });\n  };\n  /**\r\n   * Removes adapter callbacks for the specific `key`.\r\n   *\r\n   * If `priority` is specified, only callbacks for that priority are removed.\r\n   *\r\n   * @param key      Key\r\n   * @param priority Priority\r\n   * @todo Implement\r\n   */\n  Adapter.prototype.remove = function (key, priority) {\n    var _this = this;\n    // It has to make a copy because it removes the elements while iterating\n    // TODO inefficient\n    // TODO should this re-enable the key ?\n    $array.each($iter.toArray(this._callbacks.iterator()), function (item) {\n      // TODO test this\n      if (item.key === key && (!$type.isNumber(priority) || priority === item.priority)) {\n        _this._callbacks.remove(item);\n      }\n    });\n  };\n  /**\r\n   * Enable applying adapters for a certain key, if it was disabled before by\r\n   * `disableKey()`.\r\n   *\r\n   * @param key Key\r\n   */\n  Adapter.prototype.enableKey = function (key) {\n    delete this._disabled[key];\n  };\n  /**\r\n   * Disable applying adapters for a certain key.\r\n   *\r\n   * Optionally, can set how many applies to skip before automatically\r\n   * re-enabling the applying.\r\n   *\r\n   * @param key     Key\r\n   * @param amount  Number of applies to skip\r\n   */\n  Adapter.prototype.disableKey = function (key, amount) {\n    if (amount === void 0) {\n      amount = Infinity;\n    }\n    this._disabled[key] = amount;\n  };\n  Adapter.prototype._hasListenersByType = function (key) {\n    return $array.any(this._callbacks.values, function (x) {\n      return x.key === key;\n    });\n  };\n  /**\r\n   * Returns if there are any enabled adapters set for the specific `key`.\r\n   *\r\n   * @returns Are there any adapters for the key?\r\n   */\n  Adapter.prototype.isEnabled = function (key) {\n    return this._disabled[key] == null && (this._hasListenersByType(key) || globalAdapter.isEnabled(this.object, key));\n  };\n  Adapter.prototype._shouldDispatch = function (key) {\n    var count = this._disabled[key];\n    if (!$type.isNumber(count)) {\n      return true;\n    } else {\n      if (count <= 1) {\n        delete this._disabled[key];\n      } else {\n        --this._disabled[key];\n      }\n      return false;\n    }\n  };\n  /**\r\n   * Passes the input value through all the callbacks for the defined `key`.\r\n   *\r\n   * @param key      Key\r\n   * @param value    Input value\r\n   * @param ...rest  Rest of the parameters to be passed into callback\r\n   * @return Output value\r\n   */\n  Adapter.prototype.apply = function (key, value) {\n    if (this._shouldDispatch(key)) {\n      // This is needed to improve the performance and reduce garbage collection\n      var callbacks = this._callbacks.values;\n      var length_1 = callbacks.length;\n      if (length_1 > 0) {\n        for (var i = 0; i < length_1; ++i) {\n          var item = callbacks[i];\n          if (item.key === key) {\n            value = item.callback.call(item.scope, value, this.object, key);\n          }\n        }\n      }\n      // Apply global adapters\n      value = globalAdapter.applyAll(this.object, key, value);\n      return value;\n    } else {\n      return value;\n    }\n  };\n  /**\r\n   * Returns all adapter keys which are in this adapter.\r\n   *\r\n   * @return Adapter keys\r\n   */\n  Adapter.prototype.keys = function () {\n    // TODO inefficient\n    return $iter.toArray($iter.map(this._callbacks.iterator(), function (x) {\n      return x.key;\n    }));\n  };\n  /**\r\n   * Copies all the adapter callbacks from `source`.\r\n   *\r\n   * @param source  An Adapter to copy items from\r\n   */\n  Adapter.prototype.copyFrom = function (source) {\n    var _this = this;\n    $iter.each(source._callbacks.iterator(), function (x) {\n      _this.add(x.key, x.callback, x.priority, x.scope);\n    });\n    $object.each(source._disabled, function (key, val) {\n      _this._disabled[key] = val;\n    });\n  };\n  /**\r\n   * Clears all callbacks from this Adapter.\r\n   */\n  Adapter.prototype.clear = function () {\n    // TODO should this also re-enable all the keys ?\n    this._callbacks.clear();\n  };\n  return Adapter;\n}();\nexport { Adapter };","map":{"version":3,"names":["SortedList","$number","$order","$iter","$array","$type","$object","GlobalAdapter","_callbackId","_callbacks","left","right","or","order","priority","id","prototype","addAll","type","key","callback","scope","insert","isEnabled","any","values","x","applyAll","value","callbacks","length","i","item","call","globalAdapter","Adapter","c","_disabled","object","events","add","has","contains","iterator","remove","_this","each","toArray","isNumber","enableKey","disableKey","amount","Infinity","_hasListenersByType","_shouldDispatch","count","apply","length_1","keys","map","copyFrom","source","val","clear"],"sources":["../../../../../src/.internal/core/utils/Adapter.ts"],"sourcesContent":["/**\r\n * An Adapter can be used to apply chained synchronous transformations to any\r\n * value at runtime.\r\n *\r\n * Each type class using Adapters must have `adapters` property and adapter\r\n * interface defined.\r\n *\r\n * Adapters can be used to allow external code to apply transformations to any\r\n * value at any time.\r\n *\r\n * For example we have a Weather class which has a method `now()` which returns\r\n * current temperature.\r\n *\r\n * ```\r\n * function now() {\r\n *   // ... calculate temperature\r\n *   let temp = \"Temperature now is \" + degrees + \"F\";\r\n *   return temp;\r\n * }\r\n * ```\r\n *\r\n * Now, supposed we want to let other classes to modify the output of the\r\n * `now()`? We just apply an adapter to the `temp` before it is returned:\r\n *\r\n * ```\r\n * temp = this.adapters.apply(\"now\", {\r\n *   temp: temp,\r\n *   degrees: degrees\r\n * }).temp;\r\n * ```\r\n *\r\n * Some other class might tap onto it by defining an Adapter that calculates\r\n * the temperature in Celsius:\r\n *\r\n * weather.adapters.add(\"now\", (arg) => {\r\n *   arg.temp += \"(\" + farenheitToCelsius(arg.degrees) + \"C)\";\r\n *   return arh;\r\n * });\r\n *\r\n * Furthermore some time-related class could add time:\r\n *\r\n * weather.adapters.add(\"now\", (arg) => {\r\n *   arg.temp += \"; the time now is \" + (new Date().toLocaleString());\r\n *   return arh;\r\n * });\r\n *\r\n * So without adapters we would get output like this:\r\n *\r\n * ```\r\n * Temperature now is 90F\r\n * ```\r\n *\r\n * With adapters applied we now have:\r\n *\r\n * ```\r\n * Temperature now is 90F (32C); the time now is 12/11/2012, 7:00:00 PM\r\n * ```\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { SortedList } from \"./SortedList\";\r\nimport { EventDispatcher } from \"./EventDispatcher\";\r\nimport * as $number from \"./Number\";\r\nimport * as $order from \"./Order\";\r\nimport * as $iter from \"../utils/Iterator\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $object from \"../utils/Object\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n/**\r\n * Adapter interface.\r\n */\r\ninterface IAdapterCallback<Target, T> {\r\n\tid: number;\r\n\tkey: any;\r\n\tcallback: any;\r\n\tscope: any;\r\n\tpriority: number;\r\n}\r\n\r\n/**\r\n * Defines an interface for a global adapter.\r\n */\r\ninterface IGlobalAdapterCallback {\r\n\tid: number;\r\n\tkey: string;\r\n\tcallback: <T, Target, Key extends keyof T, C>(this: C, value: T[Key], target: Target, key?: keyof T) => T[Key];\r\n\tscope: any;\r\n\tpriority: number;\r\n\ttype: { new(): any };\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL ADAPTER\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global adapter is an adpater that is attached to a class type rather than\r\n * specific object instance.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport class GlobalAdapter {\r\n\r\n\t/**\r\n\t * Callback id iterator.\r\n\t */\r\n\tprivate _callbackId: number = 0;\r\n\r\n\t/**\r\n\t * A list of if callbacks (adapters).\r\n\t */\r\n\tprivate _callbacks = new SortedList<IGlobalAdapterCallback>((left, right) => {\r\n\t\treturn $order.or($number.order(left.priority, right.priority),\r\n\t\t\t$number.order(left.id, right.id));\r\n\t});\r\n\r\n\tpublic addAll<T, Target, Key extends keyof T>(\r\n\t\ttype: { new(): Target },\r\n\t\tkey: Key,\r\n\t\tcallback: (value: T[Key], target: Target, key: keyof T) => T[Key],\r\n\t\tpriority?: number\r\n\t): void;\r\n\r\n\tpublic addAll<T, Target, Key extends keyof T, C>(\r\n\t\ttype: { new(): Target },\r\n\t\tkey: Key,\r\n\t\tcallback: (this: C, value: T[Key], target: Target, key: keyof T) => T[Key],\r\n\t\tpriority?: number,\r\n\t\tscope?: C\r\n\t): void;\r\n\r\n\t/**\r\n\t * Adds a global callback which is not specific to any particular object.\r\n\t * Whenever an adapter in any object of the specific class type is invoked\r\n\t * global adapters will kick in.\r\n\t *\r\n\t * @param type      Class type\r\n\t * @param key       Adapter key\r\n\t * @param callback  Callback function\r\n\t * @param priority  Priority (higher priority meaning adapter will be applied later)\r\n\t * @param scope     Callback function scaope\r\n\t */\r\n\tpublic addAll(type: any, key: any, callback: any, priority: number = 0, scope?: any): void {\r\n\t\tthis._callbacks.insert({\r\n\t\t\tid: ++this._callbackId,\r\n\t\t\tkey: key,\r\n\t\t\tcallback: callback,\r\n\t\t\tpriority: priority,\r\n\t\t\tscope: scope,\r\n\t\t\ttype: type\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if there are adapters for specific type available.\r\n\t *\r\n\t * @param type  Adapter type\r\n\t * @param key   Adapter key\r\n\t * @return {boolean}\r\n\t */\r\n\tpublic isEnabled<T, Target, Key extends keyof T>(type: Target, key: Key): boolean {\r\n\t\treturn $array.any(this._callbacks.values, (x) => x.key === key && type instanceof x.type);\r\n\t}\r\n\r\n\t/**\r\n\t * Applies global adapters for the object of the specific type.\r\n\t *\r\n\t * @param type   Class type\r\n\t * @param key    Adapter key\r\n\t * @param value  Value\r\n\t */\r\n\tpublic applyAll<T, Target, Key extends keyof T = keyof T>(type: Target, key: Key, value: T[Key]): T[Key] {\r\n\t\t// This is needed to improve the performance and reduce garbage collection\r\n\t\tconst callbacks = this._callbacks.values;\r\n\t\tconst length = callbacks.length;\r\n\r\n\t\tif (length == 0) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\t// Cycle through all callbacks and find the ones we need to use\r\n\t\tfor (let i = 0; i < length; ++i) {\r\n\t\t\tconst item = callbacks[i];\r\n\r\n\t\t\tif (item.key === key && type instanceof item.type) {\r\n\t\t\t\tvalue = (<any>item).callback.call(item.scope, value, type, key);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * A global Adapter for plugins that want to add specific\r\n * functionality for any chart, not just specific instance.\r\n *\r\n * If you want to add an adapter which applies to all instances of the same\r\n * object type, like, for instance all slices in PieSeries, you can use\r\n * global adapter.\r\n *\r\n * Global adapter is a system-wide instance, accessible via `globalAdapter`.\r\n *\r\n * ```TypeScript\r\n * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, \"fill\">(am4charts.PieSeries, \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n * ```JavaScript\r\n * am4core.globalAdapter.addAll(am4charts.PieSeries, \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n *\r\n * @ignore\r\n */\r\nexport let globalAdapter: GlobalAdapter = new GlobalAdapter();\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REGULAR ADAPTER\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Adapter allows adding ordered callback functions and associating them with a\r\n * string-based key. An Adapter user can then easily invoke those callbacks to\r\n * apply custom functions on its input, output or intermediate values.\r\n *\r\n * Custom code and plugins can add their own callbacks to modify and enhance\r\n * core functionality.\r\n *\r\n * See the description of `add()` for an example.\r\n *\r\n * Almost any object in amCharts4 has own adapter, accessible with `adapter`\r\n * property.\r\n *\r\n * Any adapters added to it will be applied to that object only.\r\n *\r\n * ### Global Adapters\r\n *\r\n * If you want to add an adapter which applies to all instances of the same\r\n * object type, like, for instance all slices in PieSeries, you can use\r\n * global adapter.\r\n *\r\n * Global adapter is a system-wide instance, accessible via `globalAdapter`.\r\n *\r\n * ```TypeScript\r\n * am4core.globalAdapter.addAll<am4charts.IPieSeriesAdapters, am4charts.PieSeries, \"fill\">(am4charts.PieSeries. \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n * ```JavaScript\r\n * am4core.globalAdapter.addAll(am4charts.PieSeries. \"fill\", (value, target, key) => {\r\n *   return am4core.color(\"#005500\");\r\n * });\r\n * ```\r\n *\r\n * {@link https://www.amcharts.com/docs/v4/reference/adapter_module/#globalAdapter_property More info}.\r\n *\r\n * @important\r\n */\r\nexport class Adapter<Target, T> {\r\n\r\n\t/**\r\n\t * Internal counter for callback ids.\r\n\t */\r\n\tprivate _callbackId: number = 0;\r\n\r\n\t/**\r\n\t * A list of adapter callbacks.\r\n\t *\r\n\t * @param $number.order(left.priority, right.priority) [description]\r\n\t * @param $number.order(left.id,       right.id));\t}  [description]\r\n\t */\r\n\tprivate _callbacks = new SortedList<IAdapterCallback<Target, T>>((left, right) => {\r\n\t\treturn $order.or($number.order(left.priority, right.priority),\r\n\t\t\t$number.order(left.id, right.id));\r\n\t});\r\n\r\n\tprotected _disabled: { [key in keyof T]?: number } = {};\r\n\r\n\t/**\r\n\t * Holds an object reference this Adapter is for.\r\n\t */\r\n\tpublic object: Target;\r\n\r\n\t/**\r\n\t * Event dispatcher.\r\n\t */\r\n\tpublic events: EventDispatcher<{\r\n\t\tinserted: {};\r\n\t\tremoved: {};\r\n\t}>;\r\n\r\n\t/**\r\n\t * Constructor, sets the object referece this Adapter should be used for.\r\n\t *\r\n\t * @param c Object\r\n\t */\r\n\tconstructor(c: Target) {\r\n\t\tthis.object = c;\r\n\r\n\t\t// TODO this exposes the internal events\r\n\t\tthis.events = this._callbacks.events;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a callback for a specific key.\r\n\t *\r\n\t * ```TypeScript\r\n\t * // Override fill color value and make all slices green\r\n\t * chart.series.template.adapter.add(\"fill\", (value, target, key) => {\r\n\t *   return am4core.color(\"#005500\");\r\n\t * });\r\n\t * ```\r\n\t * ```JavaScript\r\n\t * // Override fill color value and make all slices green\r\n\t * chart.series.template.adapter.add(\"fill\", function(value, target, key) {\r\n\t *   return am4core.color(\"#005500\");\r\n\t * });\r\n\t * ```\r\n\t * ```JSON\r\n\t * {\r\n\t *   // ...\r\n\t *   \"series\": [{\r\n\t *     // ...\r\n\t *     \"adapter\": {\r\n\t *     \t// Override fill color value and make all slices green\r\n\t *     \t\"fill\": function(value, target, key) {\r\n\t *     \t  return am4core.color(\"#005500\");\r\n\t *     \t}\r\n\t *     }\r\n\t *   }]\r\n\t * }\r\n\t * ```\r\n\t *\r\n\t * The above will call user-defined function (adapter) whenever `fill` value\r\n\t * is requested from the Pie series, allowing it to override the default\r\n\t * using custom code and any fuzzy logic.\r\n\t *\r\n\t * There can be any number of adapters set on one property key.\r\n\t *\r\n\t * In this case adapters will be applied in daisy-chain fashion. The first\r\n\t * adapter in queue will make its transformation. The next one will have\r\n\t * the output of the first adapter as a starting value, etc.\r\n\t *\r\n\t * The order of the adapters are determined either by the order they were\r\n\t * added in, or their `priority` value.\r\n\t *\r\n\t * The heigher the `priority`, the later in the game adapter will be applied.\r\n\t *\r\n\t * @param key       Key\r\n\t * @param callback  A callback function\r\n\t * @param priority  The higher priority, the more chance the adapter will be applied last\r\n\t * @param scope     Scope for the callback function\r\n\t */\r\n\tpublic add<Key extends keyof T, C>(key: Key, callback: (this: C, value: T[Key], target: Target, key: Key) => T[Key], priority: number = 0, scope?: C): void {\r\n\t\tthis._callbacks.insert({\r\n\t\t\tid: ++this._callbackId,\r\n\t\t\tkey: key,\r\n\t\t\tcallback: callback,\r\n\t\t\tpriority: priority,\r\n\t\t\tscope: scope\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether specific adapter is already set.\r\n\t *\r\n\t * @param key       Key\r\n\t * @param callback  A callback function\r\n\t * @param priority  The higher priority, the more chance the adapter will be applied last\r\n\t * @param scope     Scope for the callback function\r\n\t * @returns                            Adapter set?\r\n\t */\r\n\tpublic has<Key extends keyof T, C>(key: Key, callback: (this: C, value: T[Key], target: Target, key: Key) => T[Key], priority: number = 0, scope?: C): boolean {\r\n\t\treturn $iter.contains(this._callbacks.iterator(), (item) => {\r\n\t\t\treturn item.key === key && item.callback === callback && item.priority === priority && item.scope === scope;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Removes adapter callbacks for the specific `key`.\r\n\t *\r\n\t * If `priority` is specified, only callbacks for that priority are removed.\r\n\t *\r\n\t * @param key      Key\r\n\t * @param priority Priority\r\n\t * @todo Implement\r\n\t */\r\n\tpublic remove(key: string, priority?: number): void {\r\n\t\t// It has to make a copy because it removes the elements while iterating\r\n\t\t// TODO inefficient\r\n\t\t// TODO should this re-enable the key ?\r\n\t\t$array.each($iter.toArray(this._callbacks.iterator()), (item) => {\r\n\t\t\t// TODO test this\r\n\t\t\tif (item.key === key && (!$type.isNumber(priority) || priority === item.priority)) {\r\n\t\t\t\tthis._callbacks.remove(item);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Enable applying adapters for a certain key, if it was disabled before by\r\n\t * `disableKey()`.\r\n\t *\r\n\t * @param key Key\r\n\t */\r\n\tpublic enableKey<Key extends keyof T>(key: Key): void {\r\n\t\tdelete this._disabled[key];\r\n\t}\r\n\r\n\t/**\r\n\t * Disable applying adapters for a certain key.\r\n\t *\r\n\t * Optionally, can set how many applies to skip before automatically\r\n\t * re-enabling the applying.\r\n\t *\r\n\t * @param key     Key\r\n\t * @param amount  Number of applies to skip\r\n\t */\r\n\tpublic disableKey<Key extends keyof T>(key: Key, amount: number = Infinity): void {\r\n\t\tthis._disabled[key] = amount;\r\n\t}\r\n\r\n\tprotected _hasListenersByType<Key extends keyof T>(key: Key): boolean {\r\n\t\treturn $array.any(this._callbacks.values, (x) => x.key === key);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if there are any enabled adapters set for the specific `key`.\r\n\t *\r\n\t * @returns Are there any adapters for the key?\r\n\t */\r\n\tpublic isEnabled<Key extends keyof T>(key: Key): boolean {\r\n\t\treturn this._disabled[key] == null && (this._hasListenersByType(key) || globalAdapter.isEnabled<T, Target, Key>(this.object, key));\r\n\t}\r\n\r\n\tprotected _shouldDispatch<Key extends keyof T>(key: Key): boolean {\r\n\t\tconst count = this._disabled[key];\r\n\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\t\t\tif (count <= 1) {\r\n\t\t\t\tdelete this._disabled[key];\r\n\r\n\t\t\t} else {\r\n\t\t\t\t--this._disabled[key];\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Passes the input value through all the callbacks for the defined `key`.\r\n\t *\r\n\t * @param key      Key\r\n\t * @param value    Input value\r\n\t * @param ...rest  Rest of the parameters to be passed into callback\r\n\t * @return Output value\r\n\t */\r\n\tpublic apply<Key extends keyof T>(key: Key, value: T[Key]): T[Key] {\r\n\t\tif (this._shouldDispatch(key)) {\r\n\t\t\t// This is needed to improve the performance and reduce garbage collection\r\n\t\t\tconst callbacks = this._callbacks.values;\r\n\t\t\tconst length = callbacks.length;\r\n\r\n\t\t\tif (length > 0) {\r\n\t\t\t\tfor (let i = 0; i < length; ++i) {\r\n\t\t\t\t\tconst item = callbacks[i];\r\n\r\n\t\t\t\t\tif (item.key === key) {\r\n\t\t\t\t\t\tvalue = item.callback.call(item.scope, value, this.object, key);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply global adapters\r\n\t\t\tvalue = globalAdapter.applyAll<T, Target, Key>(this.object, key, value);\r\n\r\n\t\t\treturn value;\r\n\r\n\t\t} else {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns all adapter keys which are in this adapter.\r\n\t *\r\n\t * @return Adapter keys\r\n\t */\r\n\tpublic keys(): Array<string> {\r\n\t\t// TODO inefficient\r\n\t\treturn $iter.toArray($iter.map(this._callbacks.iterator(), (x) => x.key));\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Copies all the adapter callbacks from `source`.\r\n\t *\r\n\t * @param source  An Adapter to copy items from\r\n\t */\r\n\tpublic copyFrom(source: this): void {\r\n\t\t$iter.each(source._callbacks.iterator(), (x) => {\r\n\t\t\tthis.add(x.key, x.callback, x.priority, x.scope);\r\n\t\t});\r\n\t\t$object.each(source._disabled, (key, val) => {\r\n\t\t\tthis._disabled[key] = val;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Clears all callbacks from this Adapter.\r\n\t */\r\n\tpublic clear(): void {\r\n\t\t// TODO should this also re-enable all the keys ?\r\n\t\tthis._callbacks.clear();\r\n\t}\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}