{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { __extends } from \"tslib\";\nimport { Dictionary } from \"./utils/Dictionary\";\nimport { TargetedEventDispatcher } from \"./utils/EventDispatcher\";\nimport { MultiDisposer, CounterDisposer } from \"./utils/Disposer\";\nimport * as $utils from \"./utils/Utils\";\nimport * as $object from \"./utils/Object\";\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\nvar SpriteEventDispatcher = /** @class */function (_super) {\n  __extends(SpriteEventDispatcher, _super);\n  function SpriteEventDispatcher() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * [_interactionEvents description]\r\n     *\r\n     * @todo Description\r\n     */\n    _this._interactionEvents = new Dictionary();\n    return _this;\n  }\n  /**\r\n   * [_dispatchSpriteEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n  SpriteEventDispatcher.prototype._dispatchSpriteEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    }\n    // TODO remove this <any> later\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_dispatchSpritePointEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n  SpriteEventDispatcher.prototype._dispatchSpritePointEvent = function (ev) {\n    if (this.target.disabled || this.target.isTemplate) {\n      return;\n    }\n    // TODO remove this <any> later\n    if (this.target.events.isEnabled(ev.type)) {\n      var imev = $object.merge(ev, {\n        target: this.target,\n        spritePoint: ev.point ? $utils.documentPointToSprite(ev.point, this.target) : undefined,\n        svgPoint: this.target.getSvgPoint(ev.point)\n      });\n      this.target.events.dispatchImmediately(imev.type, imev);\n    }\n  };\n  /**\r\n   * [_addInteractionObjectEvent description]\r\n   *\r\n   * @todo Description\r\n   */\n  SpriteEventDispatcher.prototype._addInteractionObjectEvent = function (type, callback, context, shouldClone) {\n    var _this = this;\n    var key = shouldClone + \"-\" + type;\n    var counter = this._interactionEvents.insertKeyIfEmpty(key, function () {\n      var disposer = _this.target.interactions.events.on(type, callback, context, shouldClone);\n      return new CounterDisposer(function () {\n        _this._interactionEvents.removeKey(key);\n        disposer.dispose();\n      });\n    });\n    return counter.increment();\n  };\n  /**\r\n   * [_on description]\r\n   *\r\n   * @todo Description\r\n   */\n  SpriteEventDispatcher.prototype._on = function (once, type, callback, context, shouldClone, dispatch) {\n    var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);\n    var disposers = [info.disposer];\n    /**\r\n     * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n     * triggering them on sprite\r\n     */\n    switch (type) {\n      case \"hit\":\n      case \"track\":\n      case \"doublehit\":\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpritePointEvent, this, shouldClone));\n        break;\n      case \"rightclick\":\n      case \"down\":\n      //case \"hold\":\n      case \"up\":\n      case \"drag\":\n      case \"dragged\":\n      case \"dragstart\":\n      case \"dragstop\":\n      case \"over\":\n      case \"out\":\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n      case \"resize\":\n      //case \"rotate\":\n      case \"focus\":\n      case \"blur\":\n      case \"toggled\":\n        disposers.push(this._addInteractionObjectEvent(type, this._dispatchSpriteEvent, this, shouldClone));\n        break;\n    }\n    /**\r\n     * Set functional properties based on events. For example if we add a\r\n     * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n     * don't explicitly set \"draggable\"\r\n     */\n    switch (type) {\n      case \"hit\":\n      case \"doublehit\":\n      case \"rightclick\":\n      case \"down\":\n      case \"up\":\n        this.target.clickable = true;\n        break;\n      case \"toggled\":\n        this.target.togglable = true;\n        break;\n      case \"drag\":\n      case \"dragstart\":\n      case \"dragstop\":\n        this.target.draggable = true;\n        break;\n      case \"track\":\n        this.target.trackable = true;\n        break;\n      case \"resize\":\n        this.target.resizable = true;\n        break;\n      case \"swipe\":\n      case \"swipeleft\":\n      case \"swiperight\":\n        this.target.swipeable = true;\n        break;\n      case \"wheel\":\n      case \"wheelup\":\n      case \"wheeldown\":\n      case \"wheelleft\":\n      case \"wheelright\":\n        this.target.wheelable = true;\n        break;\n      case \"over\":\n        this.target.hoverable = true;\n      case \"out\":\n        this.target.hoverable = true;\n        break;\n      case \"focus\":\n      case \"blur\":\n        this.target.focusable = true;\n        break;\n    }\n    info.disposer = new MultiDisposer(disposers);\n    return info;\n  };\n  return SpriteEventDispatcher;\n}(TargetedEventDispatcher);\nexport { SpriteEventDispatcher };","map":{"version":3,"names":["Dictionary","TargetedEventDispatcher","MultiDisposer","CounterDisposer","$utils","$object","SpriteEventDispatcher","_super","__extends","_this","apply","arguments","_interactionEvents","prototype","_dispatchSpriteEvent","ev","target","disabled","isTemplate","events","isEnabled","type","imev","merge","dispatchImmediately","_dispatchSpritePointEvent","spritePoint","point","documentPointToSprite","undefined","svgPoint","getSvgPoint","_addInteractionObjectEvent","callback","context","shouldClone","key","counter","insertKeyIfEmpty","disposer","interactions","on","removeKey","dispose","increment","_on","once","dispatch","info","call","disposers","push","clickable","togglable","draggable","trackable","resizable","swipeable","wheelable","hoverable","focusable"],"sources":["../../../../src/.internal/core/SpriteEvents.ts"],"sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"./Sprite\";\r\nimport { Dictionary } from \"./utils/Dictionary\";\r\nimport { EventListener, TargetedEventDispatcher, AMEvent } from \"./utils/EventDispatcher\";\r\nimport { InteractionObject, IInteractionObjectEvents } from \"./interaction/InteractionObject\";\r\nimport { IPointer } from \"./interaction/Pointer\";\r\nimport { MultiDisposer, IDisposer, CounterDisposer } from \"./utils/Disposer\";\r\nimport { IPoint } from \"./defs/IPoint\";\r\nimport * as $utils from \"./utils/Utils\";\r\nimport * as $object from \"./utils/Object\";\r\n\r\n/**\r\n * ============================================================================\r\n * RE-EXPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nexport { AMEvent };\r\n\r\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @important\r\n */\r\nexport class SpriteEventDispatcher<T extends AMEvent<Sprite, ISpriteEvents>> extends TargetedEventDispatcher<Sprite, T> {\r\n\r\n\t/**\r\n\t * [_interactionEvents description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _interactionEvents = new Dictionary<string, CounterDisposer>();\r\n\r\n\t/**\r\n\t * [_dispatchSpriteEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _dispatchSpriteEvent<Key extends keyof IInteractionObjectEvents>(ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]): void {\r\n\t\tif (this.target.disabled || this.target.isTemplate) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// TODO remove this <any> later\r\n\t\tif (this.target.events.isEnabled(ev.type)) {\r\n\t\t\tlet imev: AMEvent<Sprite, ISpriteEvents>[Key] = <any>$object.merge(ev, {\r\n\t\t\t\ttarget: this.target\r\n\t\t\t});\r\n\t\t\tthis.target.events.dispatchImmediately(imev.type, imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_dispatchSpritePointEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _dispatchSpritePointEvent<Key extends \"hit\" | \"track\">(ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]): void {\r\n\t\tif (this.target.disabled || this.target.isTemplate) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// TODO remove this <any> later\r\n\t\tif (this.target.events.isEnabled(ev.type)) {\r\n\r\n\t\t\tlet imev: AMEvent<Sprite, ISpriteEvents>[Key] = <any>$object.merge(ev, {\r\n\t\t\t\ttarget: this.target,\r\n\t\t\t\tspritePoint: ev.point ? $utils.documentPointToSprite(ev.point, this.target) : undefined,\r\n\t\t\t\tsvgPoint: this.target.getSvgPoint(ev.point)\r\n\t\t\t});\r\n\t\t\tthis.target.events.dispatchImmediately(imev.type, imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [_addInteractionObjectEvent description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprivate _addInteractionObjectEvent<C, Key extends keyof IInteractionObjectEvents>(type: Key, callback: (this: C, ev: AMEvent<InteractionObject, IInteractionObjectEvents>[Key]) => void, context: C, shouldClone: boolean): IDisposer {\r\n\t\tconst key = shouldClone + \"-\" + type;\r\n\r\n\t\tconst counter = this._interactionEvents.insertKeyIfEmpty(key, () => {\r\n\t\t\tconst disposer = this.target.interactions.events.on(type, callback, context, shouldClone);\r\n\r\n\t\t\treturn new CounterDisposer(() => {\r\n\t\t\t\tthis._interactionEvents.removeKey(key);\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\treturn counter.increment();\r\n\t}\r\n\r\n\t/**\r\n\t * [_on description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _on<A, B, Key extends keyof T>(once: boolean, type: Key | null, callback: A, context: B, shouldClone: boolean, dispatch: (type: Key, event: T[Key]) => void): EventListener<T> {\r\n\t\tconst info = super._on(once, type, callback, context, shouldClone, dispatch);\r\n\r\n\t\tconst disposers = [info.disposer];\r\n\r\n\t\t/**\r\n\t\t * Catching Sprite-related events, converting them to [[SpriteEvent]] and\r\n\t\t * triggering them on sprite\r\n\t\t */\r\n\t\tswitch (type) {\r\n\t\t\tcase \"hit\":\r\n\t\t\tcase \"track\":\r\n\t\t\tcase \"doublehit\":\r\n\t\t\tcase \"wheel\":\r\n\t\t\tcase \"wheelup\":\r\n\t\t\tcase \"wheeldown\":\r\n\t\t\tcase \"wheelleft\":\r\n\t\t\tcase \"wheelright\":\r\n\t\t\t\tdisposers.push(this._addInteractionObjectEvent(<any>type, this._dispatchSpritePointEvent, this, shouldClone));\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"rightclick\":\r\n\t\t\tcase \"down\":\r\n\t\t\t//case \"hold\":\r\n\t\t\tcase \"up\":\r\n\t\t\tcase \"drag\":\r\n\t\t\tcase \"dragged\":\r\n\t\t\tcase \"dragstart\":\r\n\t\t\tcase \"dragstop\":\r\n\t\t\tcase \"over\":\r\n\t\t\tcase \"out\":\r\n\t\t\tcase \"swipe\":\r\n\t\t\tcase \"swipeleft\":\r\n\t\t\tcase \"swiperight\":\r\n\t\t\tcase \"resize\":\r\n\t\t\t//case \"rotate\":\r\n\t\t\tcase \"focus\":\r\n\t\t\tcase \"blur\":\r\n\t\t\tcase \"toggled\":\r\n\t\t\t\tdisposers.push(this._addInteractionObjectEvent(<any>type, this._dispatchSpriteEvent, this, shouldClone));\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Set functional properties based on events. For example if we add a\r\n\t\t * \"drag\" event handler, we want to make the Sprite draggable, even if we\r\n\t\t * don't explicitly set \"draggable\"\r\n\t\t */\r\n\t\tswitch (type) {\r\n\t\t\tcase \"hit\":\r\n\t\t\tcase \"doublehit\":\r\n\t\t\tcase \"rightclick\":\r\n\t\t\tcase \"down\":\r\n\t\t\tcase \"up\":\r\n\t\t\t\tthis.target.clickable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"toggled\":\r\n\t\t\t\tthis.target.togglable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"drag\":\r\n\t\t\tcase \"dragstart\":\r\n\t\t\tcase \"dragstop\":\r\n\t\t\t\tthis.target.draggable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"track\":\r\n\t\t\t\tthis.target.trackable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"resize\":\r\n\t\t\t\tthis.target.resizable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"swipe\":\r\n\t\t\tcase \"swipeleft\":\r\n\t\t\tcase \"swiperight\":\r\n\t\t\t\tthis.target.swipeable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"wheel\":\r\n\t\t\tcase \"wheelup\":\r\n\t\t\tcase \"wheeldown\":\r\n\t\t\tcase \"wheelleft\":\r\n\t\t\tcase \"wheelright\":\r\n\t\t\t\tthis.target.wheelable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"over\":\r\n\t\t\t\tthis.target.hoverable = true;\r\n\t\t\tcase \"out\":\r\n\t\t\t\tthis.target.hoverable = true;\r\n\t\t\t\tbreak;\r\n\t\t\tcase \"focus\":\r\n\t\t\tcase \"blur\":\r\n\t\t\t\tthis.target.focusable = true;\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tinfo.disposer = new MultiDisposer(disposers);\r\n\r\n\t\treturn info;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Defines a type of event that has a single point of reference.\r\n */\r\nexport type SpritePointerTypeEvent = {\r\n\r\n\t/**\r\n\t * Is event originated by touch pointer?\r\n\t */\r\n\ttouch: boolean;\r\n\r\n};\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains point information.\r\n */\r\nexport type SpritePointEvent = {\r\n\t/**\r\n\t * Event point in global (document) coordinates.\r\n\t */\r\n\tpoint: IPoint;\r\n\r\n\t/**\r\n\t * Event point in local Sprite coordinates.\r\n\t */\r\n\tspritePoint: IPoint;\r\n\r\n\t/**\r\n\t * Event point with chart (svg) coodinates.\r\n\t */\r\n\tsvgPoint: IPoint;\r\n};\r\n\r\n\r\n/**\r\n * Defines a type of event that has a related Pointer.\r\n */\r\nexport type SpritePointerEvent = {\r\n\r\n\t/**\r\n\t * Coordinates of the primary cursor position.\r\n\t */\r\n\tpointer: IPointer;\r\n\r\n};\r\n\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains mouse or touch\r\n * event.\r\n */\r\nexport type SpriteMouseTouchEvent = {\r\n\r\n\t/**\r\n\t * Original mouse/touch event.\r\n\t */\r\n\tevent: MouseEvent | TouchEvent;\r\n\r\n};\r\n\r\n/**\r\n * Defines property set for a [[Sprite]] event that contains coordinate shift\r\n * information, such as drag events.\r\n */\r\nexport type SpriteShiftEvent = {\r\n\r\n\t/**\r\n\t * Shift in coordinates after dragging.\r\n\t */\r\n\tshift: IPoint;\r\n\r\n};\r\n\r\n/**\r\n * Defines available events available for [[Sprite]].\r\n */\r\nexport interface ISpriteEvents extends IInteractionObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when Sprite completes transition to a [[SpriteState]].\r\n\t */\r\n\ttransitionended: {};\r\n\r\n\t/**\r\n\t * Invoked when size of the Sprite changes.\r\n\t */\r\n\tsizechanged: {};\r\n\r\n\t/**\r\n\t * Invoked when maximum available size of the Sprite changes, i.e. when the\r\n\t * size of parent container changes.\r\n\t */\r\n\tmaxsizechanged: {\r\n\t\tpreviousWidth: number,\r\n\t\tpreviousHeight: number\r\n\t};\r\n\r\n\t/**\r\n\t * @todo Description\r\n\t */\r\n\ttransformed: {\r\n\r\n\t\t/**\r\n\t\t * [string description]\r\n\t\t * @todo Needs description\r\n\t\t */\r\n\t\tdummyData?: string;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when position of the [[Sprite]] changes.\r\n\t */\r\n\tpositionchanged: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is initialized.\r\n\t */\r\n\tinited: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] appears. Sprite appears when `sprite.appear()` method\r\n\t * is called and show animation is finished.\r\n\t */\r\n\tappeared: {};\r\n\r\n\t/**\r\n\t * Invoked when chart is shown if `am4core.options.queue = true` or/and `am4core.options.onlyShowOnViewport = true`.\r\n\t */\r\n\tremovedfromqueue: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is becomes ready, that is it has finished all\r\n\t * calculations and building itself.\r\n\t *\r\n\t * For [[Container]] object (and all those inheriting it, including charts)\r\n\t * this event will fire when all children become ready.\r\n\t */\r\n\tready: {};\r\n\r\n\t/**\r\n\t * Invoked before [[Sprite]] is validated.\r\n\t *\r\n\t * @todo Description (check)\r\n\t */\r\n\tbeforevalidated: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is validated. (on init or after update)\r\n\t *\r\n\t * @todo Description (check)\r\n\t */\r\n\tvalidated: {};\r\n\r\n\t/**\r\n\t * Invoked when visibility of the [[Sprite]] changes. (from visible to hidden,\r\n\t * and vice versa)\r\n\t */\r\n\tvisibilitychanged: {\r\n\t\tvisible: boolean;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when hidden [[Sprite]] is shown.\r\n\t */\r\n\tshown: {};\r\n\r\n\t/**\r\n\t * Invoked when visible [[Sprite]] is hidden.\r\n\t */\r\n\thidden: {};\r\n\r\n\t/**\r\n\t * Invoked when zIndex of a sprite is changed\r\n\t */\r\n\tzIndexChanged: {};\r\n\r\n\t/**\r\n\t * Invoked when property of the [[Sprite]] changes.\r\n\t */\r\n\tpropertychanged: {\r\n\r\n\t\t/**\r\n\t\t * Property key.\r\n\t\t */\r\n\t\tproperty: string;\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when the global scale changed, meaning that scale of [[Sprite]]\r\n\t * or any of its ascendants changed.\r\n\t */\r\n\tglobalscalechanged: {};\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is clicked or touched.\r\n\t */\r\n\thit: SpritePointerTypeEvent & SpritePointEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when [[Sprite]] is clicked or touched twice in rapid succession.\r\n\t */\r\n\tdoublehit: SpritePointerTypeEvent & SpritePointEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when pointer (mouse cursor or touch point) moves over `trackable`\r\n\t * [[Sprite]].\r\n\t */\r\n\ttrack:  SpritePointerTypeEvent & SpritePointEvent & SpritePointerEvent & SpriteMouseTouchEvent;\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel while over the [[Sprite]].\r\n\t */\r\n\twheel: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel upwards while over the [[Sprite]].\r\n\t */\r\n\twheelup: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel downwards while over the [[Sprite]].\r\n\t */\r\n\twheeldown: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel leftwards while over the [[Sprite]].\r\n\t */\r\n\twheelleft: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when user turns mouse wheel rightwards while over the [[Sprite]].\r\n\t */\r\n\twheelright: SpritePointEvent & SpriteShiftEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original JavaScript event.\r\n\t\t */\r\n\t\tevent: WheelEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when `togglable` Sprite is being toggled on and off. (its\r\n\t * `isActive` property is being changed)\r\n\t */\r\n\ttoggled: {};\r\n\r\n\t/**\r\n\t * Invoked just before Sprite is disposed.\r\n\t */\r\n\tbeforedisposed: {};\r\n\r\n\t/**\r\n\t * Invoked when sprite is disabled\r\n\t */\r\n\tdisabled: {};\r\n\r\n\t/**\r\n\t * Invoked when sprite is enabled\r\n\t */\r\n\tenabled: {};\r\n\r\n\t/**\r\n\t * Invoked when `draggable` object is being dragged. (using mouse, touch or\r\n\t * keyboard).\r\n\t *\r\n\t * This is simmilar but different then `\"drag\"` event in that it kicks in\r\n\t * after `\"drag\"` which modifies [[Sprite]] coordinates. This allows doing\r\n\t * own manipulations and corrections to element positions.\r\n\t */\r\n\tdragged: SpritePointerTypeEvent & SpriteShiftEvent & SpritePointEvent & {\r\n\r\n\t\t/**\r\n\t\t * Original coordinates of the pointer's position when the dragging started.\r\n\t\t */\r\n\t\tstartPoint: IPoint,\r\n\r\n\t\t/**\r\n\t\t * An original JavaScript event that triggered dragging.\r\n\t\t */\r\n\t\tevent?: MouseEvent | TouchEvent | KeyboardEvent\r\n\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when a sprite is added to a parent\r\n\t */\r\n\tparentset: {};\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}