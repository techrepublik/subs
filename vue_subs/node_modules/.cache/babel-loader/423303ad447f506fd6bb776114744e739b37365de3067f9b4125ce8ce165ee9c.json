{"ast":null,"code":"import { geoEquirectangular, geoOrthographic } from \"d3-geo\";\nimport { asin, atan, degrees, radians, sin, tan } from \"./math.js\";\nfunction gilbertForward(point) {\n  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\nfunction gilbertInvert(point) {\n  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\nexport default function (projectionType) {\n  if (projectionType == null) projectionType = geoOrthographic;\n  var projection = projectionType(),\n    equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n\n  function gilbert(point) {\n    return projection(gilbertForward(point));\n  }\n  if (projection.invert) gilbert.invert = function (point) {\n    return gilbertInvert(projection.invert(point));\n  };\n  gilbert.stream = function (stream) {\n    var s1 = projection.stream(stream),\n      s0 = equirectangular.stream({\n        point: function (lambda, phi) {\n          s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees);\n        },\n        lineStart: function () {\n          s1.lineStart();\n        },\n        lineEnd: function () {\n          s1.lineEnd();\n        },\n        polygonStart: function () {\n          s1.polygonStart();\n        },\n        polygonEnd: function () {\n          s1.polygonEnd();\n        }\n      });\n    s0.sphere = s1.sphere;\n    return s0;\n  };\n  function property(name) {\n    gilbert[name] = function () {\n      return arguments.length ? (projection[name].apply(projection, arguments), gilbert) : projection[name]();\n    };\n  }\n  gilbert.rotate = function (_) {\n    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n  };\n  gilbert.center = function (_) {\n    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n  };\n  property(\"angle\");\n  property(\"clipAngle\");\n  property(\"clipExtent\");\n  property(\"fitExtent\");\n  property(\"fitHeight\");\n  property(\"fitSize\");\n  property(\"fitWidth\");\n  property(\"scale\");\n  property(\"translate\");\n  property(\"precision\");\n  return gilbert.scale(249.5);\n}","map":{"version":3,"names":["geoEquirectangular","geoOrthographic","asin","atan","degrees","radians","sin","tan","gilbertForward","point","gilbertInvert","projectionType","projection","equirectangular","scale","precision","clipAngle","translate","gilbert","invert","stream","s1","s0","lambda","phi","lineStart","lineEnd","polygonStart","polygonEnd","sphere","property","name","arguments","length","apply","rotate","_","center"],"sources":["/Users/admin/Desktop/techrepublik/pro/subs/vue_subs/node_modules/d3-geo-projection/src/gilbert.js"],"sourcesContent":["import {geoEquirectangular, geoOrthographic} from \"d3-geo\";\nimport {asin, atan, degrees, radians, sin, tan} from \"./math.js\";\n\nfunction gilbertForward(point) {\n  return [point[0] / 2, asin(tan(point[1] / 2 * radians)) * degrees];\n}\n\nfunction gilbertInvert(point) {\n  return [point[0] * 2, 2 * atan(sin(point[1] * radians)) * degrees];\n}\n\nexport default function(projectionType) {\n  if (projectionType == null) projectionType = geoOrthographic;\n  var projection = projectionType(),\n      equirectangular = geoEquirectangular().scale(degrees).precision(0).clipAngle(null).translate([0, 0]); // antimeridian cutting\n\n  function gilbert(point) {\n    return projection(gilbertForward(point));\n  }\n\n  if (projection.invert) gilbert.invert = function(point) {\n    return gilbertInvert(projection.invert(point));\n  };\n\n  gilbert.stream = function(stream) {\n    var s1 = projection.stream(stream), s0 = equirectangular.stream({\n      point: function(lambda, phi) { s1.point(lambda / 2, asin(tan(-phi / 2 * radians)) * degrees); },\n      lineStart: function() { s1.lineStart(); },\n      lineEnd: function() { s1.lineEnd(); },\n      polygonStart: function() { s1.polygonStart(); },\n      polygonEnd: function() { s1.polygonEnd(); }\n    });\n    s0.sphere = s1.sphere;\n    return s0;\n  };\n\n  function property(name) {\n    gilbert[name] = function() {\n      return arguments.length ? (projection[name].apply(projection, arguments), gilbert) : projection[name]();\n    };\n  }\n\n  gilbert.rotate = function(_) {\n    return arguments.length ? (equirectangular.rotate(_), gilbert) : equirectangular.rotate();\n  };\n\n  gilbert.center = function(_) {\n    return arguments.length ? (projection.center(gilbertForward(_)), gilbert) : gilbertInvert(projection.center());\n  };\n\n  property(\"angle\");\n  property(\"clipAngle\");\n  property(\"clipExtent\");\n  property(\"fitExtent\");\n  property(\"fitHeight\");\n  property(\"fitSize\");\n  property(\"fitWidth\");\n  property(\"scale\");\n  property(\"translate\");\n  property(\"precision\");\n\n  return gilbert\n      .scale(249.5);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}