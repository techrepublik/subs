{"ast":null,"code":"/**\r\n * This module contains funcitonality related to geographical projections\r\n */\nimport { registry } from \"../../../core/Registry\";\nimport * as $math from \"../../../core/utils/Math\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * This is a base class for a geographical projection.\r\n */\nvar Projection = /** @class */function () {\n  function Projection() {\n    this.d3Projection = d3geo.geoEquirectangular();\n  }\n  Object.defineProperty(Projection.prototype, \"d3Projection\", {\n    /**\r\n     * d3 projection\r\n     */\n    get: function () {\n      return this._d3Projection;\n    },\n    /**\r\n     * d3 projection\r\n     */\n    set: function (projection) {\n      this._d3Projection = projection;\n      projection.precision(0.1);\n      this._d3Path = d3geo.geoPath().projection(projection);\n      if (this.chart) {\n        this.chart.invalidateProjection();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Projection.prototype, \"d3Path\", {\n    /**\r\n     * d3 path generator method\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._d3Path;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Projection.prototype, \"scale\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      return this.d3Projection.scale() / 100;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a geographical point (lat/long) to a screen point (x/y)\r\n   * @param geoPoint Geo point (lat/long)\r\n   * @return Screen point (x/y)\r\n   */\n  Projection.prototype.convert = function (geoPoint) {\n    /*\r\n    geoPoint = $geo.normalizePoint(geoPoint);\r\n    geoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n    let pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n    return {\r\n        x: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 4) * this.scale,\r\n        y: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 4) * this.scale\r\n    };*/\n    var p = this.d3Projection([geoPoint.longitude, geoPoint.latitude]);\n    if (p) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n  };\n  /**\r\n   * Converts a screen point (x/y) to a geographical point (lat/long)\r\n   * @param point Screen point (x/y)\r\n   * @return Geo point (lat/long)\r\n   */\n  Projection.prototype.invert = function (point) {\n    /*\r\n    let pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n      let geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n      geoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n    */\n    var p = this.d3Projection.invert([point.x, point.y]);\n    if (p) {\n      return {\n        longitude: p[0],\n        latitude: p[1]\n      };\n    }\n  };\n  /**\r\n   * Returns X/Y coordinates.\r\n   * Individual projections will override this method to apply their own\r\n   * projection logic.\r\n   * @deprecated\r\n   * @param lambda [description]\r\n   * @param phi    [description]\r\n   * @return X/Y coordinates\r\n   * @todo Needs description\r\n   */\n  Projection.prototype.project = function (lambda, phi) {\n    return this.convert({\n      longitude: lambda * $math.DEGREES,\n      latitude: phi * $math.DEGREES\n    });\n  };\n  /**\r\n   * Returns geographical coordinates (lat/long).\r\n   * Individual projections will override this method to apply their own\r\n   * projection logic.\r\n   * @deprecated\r\n   * @param x X coordinate\r\n   * @param y Y coordinate\r\n   * @return Geographical point\r\n   * @todo Needs description\r\n   */\n  Projection.prototype.unproject = function (x, y) {\n    return this.invert({\n      x: x,\n      y: y\n    });\n  };\n  /**\r\n   * @ignore\r\n   * @deprecated\r\n   */\n  Projection.prototype.rotate = function (geoPoint, deltaLongitude, deltaLatitude, deltaGamma) {\n    var deltaLambda = deltaLongitude * $math.RADIANS;\n    var deltaPhi = deltaLatitude * $math.RADIANS;\n    deltaGamma = deltaGamma * $math.RADIANS;\n    var lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\n    var phi = geoPoint.latitude * $math.RADIANS;\n    var cosDeltaPhi = Math.cos(deltaPhi);\n    var sinDeltaPhi = Math.sin(deltaPhi);\n    var cosDeltaGamma = Math.cos(deltaGamma);\n    var sinDeltaGamma = Math.sin(deltaGamma);\n    var cosPhi = Math.cos(phi);\n    var x = Math.cos(lambda) * cosPhi;\n    var y = Math.sin(lambda) * cosPhi;\n    var z = Math.sin(phi);\n    var k = z * cosDeltaPhi + x * sinDeltaPhi;\n    return {\n      longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),\n      latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma)\n    };\n  };\n  /**\r\n   * @ignore\r\n   * @deprecated\r\n   */\n  Projection.prototype.unrotate = function (geoPoint, deltaLongitude, deltaLatitude, deltaGamma) {\n    var deltaLambda = deltaLongitude * $math.RADIANS;\n    var deltaPhi = deltaLatitude * $math.RADIANS;\n    deltaGamma = deltaGamma * $math.RADIANS;\n    var lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\n    var phi = geoPoint.latitude * $math.RADIANS;\n    var cosDeltaPhi = Math.cos(deltaPhi);\n    var sinDeltaPhi = Math.sin(deltaPhi);\n    var cosDeltaGamma = Math.cos(deltaGamma);\n    var sinDeltaGamma = Math.sin(deltaGamma);\n    var cosPhi = Math.cos(phi);\n    var x = Math.cos(lambda) * cosPhi;\n    var y = Math.sin(lambda) * cosPhi;\n    var z = Math.sin(phi);\n    var k = z * cosDeltaGamma - y * sinDeltaGamma;\n    return {\n      longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),\n      latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi)\n    };\n  };\n  //@todo: move to some utils?\n  //@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\n  Projection.prototype.intermediatePoint = function (pointA, pointB, position) {\n    var p = d3geo.geoInterpolate([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude])(position);\n    return {\n      longitude: p[0],\n      latitude: p[1]\n    };\n  };\n  ;\n  // returns radians\n  Projection.prototype.multiDistance = function (multiGeoLine) {\n    var distance = 0;\n    for (var s = 0; s < multiGeoLine.length; s++) {\n      var points = multiGeoLine[s];\n      if (points.length > 1) {\n        for (var p = 1; p < points.length; p++) {\n          var pointA = points[p - 1];\n          var pointB = points[p];\n          distance += this.distance(pointA, pointB);\n        }\n      }\n    }\n    return distance;\n  };\n  // returns radians\n  Projection.prototype.distance = function (pointA, pointB) {\n    return d3geo.geoDistance([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude]);\n  };\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n  Projection.prototype.positionToPoint = function (multiGeoLine, position) {\n    if (multiGeoLine) {\n      var intermediatePoint = this.positionToGeoPoint(multiGeoLine, position);\n      var intermediatePointA = this.positionToGeoPoint(multiGeoLine, position - 0.01);\n      var intermediatePointB = this.positionToGeoPoint(multiGeoLine, position + 0.01);\n      if (intermediatePointA && intermediatePointB) {\n        var point = this.convert(intermediatePoint);\n        var pa = this.convert(intermediatePointA);\n        var pb = this.convert(intermediatePointB);\n        return {\n          x: point.x,\n          y: point.y,\n          angle: $math.getAngle(pa, pb)\n        };\n      }\n    }\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  };\n  /**\r\n   * Converts relative position along the line (0-1) into pixel coordinates.\r\n   *\r\n   * @param position  Position (0-1)\r\n   * @return Coordinates\r\n   */\n  Projection.prototype.positionToGeoPoint = function (multiGeoLine, position) {\n    if (multiGeoLine) {\n      var totalDistance = this.multiDistance(multiGeoLine);\n      var currentDistance = 0;\n      var distanceAB = void 0;\n      var positionA = 0;\n      var positionB = 0;\n      var pointA = void 0;\n      var pointB = void 0;\n      for (var s = 0; s < multiGeoLine.length; s++) {\n        var points = multiGeoLine[s];\n        if (points.length > 1) {\n          for (var p = 1; p < points.length; p++) {\n            pointA = points[p - 1];\n            pointB = points[p];\n            positionA = currentDistance / totalDistance;\n            distanceAB = this.distance(pointA, pointB);\n            currentDistance += distanceAB;\n            positionB = currentDistance / totalDistance;\n            if (positionA <= position && positionB > position) {\n              s = multiGeoLine.length;\n              break;\n            }\n          }\n        } else if (points.length == 1) {\n          pointA = points[0];\n          pointB = points[0];\n          positionA = 0;\n          positionB = 1;\n        }\n      }\n      if (pointA && pointB) {\n        var positionAB = (position - positionA) / (positionB - positionA);\n        return this.intermediatePoint(pointA, pointB, positionAB);\n      }\n    }\n    return {\n      longitude: 0,\n      latitude: 0\n    };\n  };\n  return Projection;\n}();\nexport { Projection };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"Projection\"] = Projection;","map":{"version":3,"names":["registry","$math","d3geo","Projection","d3Projection","geoEquirectangular","Object","defineProperty","prototype","get","_d3Projection","set","projection","precision","_d3Path","geoPath","chart","invalidateProjection","scale","convert","geoPoint","p","longitude","latitude","x","y","invert","point","project","lambda","phi","DEGREES","unproject","rotate","deltaLongitude","deltaLatitude","deltaGamma","deltaLambda","RADIANS","deltaPhi","cosDeltaPhi","Math","cos","sinDeltaPhi","sin","cosDeltaGamma","sinDeltaGamma","cosPhi","z","k","atan2","asin","unrotate","intermediatePoint","pointA","pointB","position","geoInterpolate","multiDistance","multiGeoLine","distance","s","length","points","geoDistance","positionToPoint","positionToGeoPoint","intermediatePointA","intermediatePointB","pa","pb","angle","getAngle","totalDistance","currentDistance","distanceAB","positionA","positionB","positionAB","registeredClasses"],"sources":["../../../../../../src/.internal/charts/map/projections/Projection.ts"],"sourcesContent":["/**\r\n * This module contains funcitonality related to geographical projections\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IGeoPoint } from \"../../../core/defs/IGeoPoint\";\r\n//import { IGeoRectangle } from \"../../../core/defs/IGeoRectangle\";\r\nimport { IPoint, IOrientationPoint } from \"../../../core/defs/IPoint\";\r\nimport { registry } from \"../../../core/Registry\";\r\nimport * as $math from \"../../../core/utils/Math\";\r\nimport * as d3geo from \"d3-geo\";\r\nimport { MapChart } from \"../../types/MapChart\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * This is a base class for a geographical projection.\r\n */\r\nexport class Projection {\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _d3Projection: d3geo.GeoProjection;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected _d3Path: d3geo.GeoPath;\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic chart: MapChart;\r\n\r\n\r\n\tconstructor() {\r\n\t\tthis.d3Projection = d3geo.geoEquirectangular();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * d3 projection\r\n\t */\r\n\tpublic set d3Projection(projection: d3geo.GeoProjection) {\r\n\t\tthis._d3Projection = projection;\r\n\t\tprojection.precision(0.1);\r\n\t\tthis._d3Path = d3geo.geoPath().projection(projection);\r\n\r\n\t\tif (this.chart) {\r\n\t\t\tthis.chart.invalidateProjection();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * d3 projection\r\n\t */\r\n\tpublic get d3Projection(): d3geo.GeoProjection {\r\n\t\treturn this._d3Projection;\r\n\t}\r\n\r\n\t/**\r\n\t * d3 path generator method\r\n\t * @ignore\r\n\t */\r\n\tpublic get d3Path(): d3geo.GeoPath {\r\n\t\treturn this._d3Path;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic get scale(): number {\r\n\t\treturn this.d3Projection.scale() / 100;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a geographical point (lat/long) to a screen point (x/y)\r\n\t * @param geoPoint Geo point (lat/long)\r\n\t * @return Screen point (x/y)\r\n\t */\r\n\tpublic convert(geoPoint: IGeoPoint): IPoint {\r\n\t\t/*\r\n\t\tgeoPoint = $geo.normalizePoint(geoPoint);\r\n\t\tgeoPoint = this.rotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\tlet pointInRadians: IPoint = this.project(geoPoint.longitude * $math.RADIANS, geoPoint.latitude * $math.RADIANS);\r\n\t\treturn {\r\n\t\t\tx: $math.round(pointInRadians.x * $math.DEGREES - this.centerPoint.x, 4) * this.scale,\r\n\t\t\ty: $math.round(-pointInRadians.y * $math.DEGREES - this.centerPoint.y, 4) * this.scale\r\n\t\t};*/\r\n\r\n\t\tlet p = this.d3Projection([geoPoint.longitude, geoPoint.latitude]);\r\n\t\tif (p) {\r\n\t\t\treturn { x: p[0], y: p[1] };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a screen point (x/y) to a geographical point (lat/long)\r\n\t * @param point Screen point (x/y)\r\n\t * @return Geo point (lat/long)\r\n\t */\r\n\tpublic invert(point: IPoint): IGeoPoint {\r\n\t\t/*\r\n\t\tlet pointInRadians: IGeoPoint = this.unproject((point.x / this.scale + this.centerPoint.x) * $math.RADIANS, (-point.y / this.scale - this.centerPoint.y) * $math.RADIANS);\r\n\r\n\t\tlet geoPoint = { longitude: pointInRadians.longitude * $math.DEGREES, latitude: pointInRadians.latitude * $math.DEGREES };\r\n\r\n\t\tgeoPoint = this.unrotate(geoPoint, this.deltaLongitude, this.deltaLatitude, this.deltaGama);\r\n\t\t*/\r\n\t\tlet p = this.d3Projection.invert([point.x, point.y]);\r\n\t\tif (p) {\r\n\t\t\treturn { longitude: p[0], latitude: p[1] };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns X/Y coordinates.\r\n\t * Individual projections will override this method to apply their own\r\n\t * projection logic.\r\n\t * @deprecated\r\n\t * @param lambda [description]\r\n\t * @param phi    [description]\r\n\t * @return X/Y coordinates\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic project(lambda: number, phi: number): IPoint {\r\n\t\treturn this.convert({ longitude: lambda * $math.DEGREES, latitude: phi * $math.DEGREES });\r\n\t}\r\n\r\n\t/**\r\n\t * Returns geographical coordinates (lat/long).\r\n\t * Individual projections will override this method to apply their own\r\n\t * projection logic.\r\n\t * @deprecated\r\n\t * @param x X coordinate\r\n\t * @param y Y coordinate\r\n\t * @return Geographical point\r\n\t * @todo Needs description\r\n\t */\r\n\tpublic unproject(x: number, y: number): IGeoPoint {\r\n\t\treturn this.invert({ x: x, y: y });\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * @deprecated\r\n\t */\r\n\tpublic rotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS + deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaPhi + x * sinDeltaPhi;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaGamma + y * sinDeltaGamma) };\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * @deprecated\r\n\t */\r\n\tpublic unrotate(geoPoint: IGeoPoint, deltaLongitude: number, deltaLatitude: number, deltaGamma?: number): IGeoPoint {\r\n\r\n\t\tlet deltaLambda = deltaLongitude * $math.RADIANS;\r\n\t\tlet deltaPhi = deltaLatitude * $math.RADIANS;\r\n\t\tdeltaGamma = deltaGamma * $math.RADIANS;\r\n\r\n\t\tlet lambda = geoPoint.longitude * $math.RADIANS - deltaLambda;\r\n\t\tlet phi = geoPoint.latitude * $math.RADIANS;\r\n\r\n\t\tlet cosDeltaPhi = Math.cos(deltaPhi);\r\n\t\tlet sinDeltaPhi = Math.sin(deltaPhi);\r\n\t\tlet cosDeltaGamma = Math.cos(deltaGamma);\r\n\t\tlet sinDeltaGamma = Math.sin(deltaGamma);\r\n\r\n\t\tlet cosPhi = Math.cos(phi);\r\n\r\n\t\tlet x = Math.cos(lambda) * cosPhi;\r\n\t\tlet y = Math.sin(lambda) * cosPhi;\r\n\t\tlet z = Math.sin(phi);\r\n\t\tlet k = z * cosDeltaGamma - y * sinDeltaGamma;\r\n\r\n\t\treturn { longitude: $math.DEGREES * Math.atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), latitude: $math.DEGREES * Math.asin(k * cosDeltaPhi - x * sinDeltaPhi) };\r\n\t}\r\n\r\n\r\n\t//@todo: move to some utils?\r\n\t//@todo: add credits to: https://www.movable-type.co.uk/scripts/latlong.html\r\n\tpublic intermediatePoint(pointA: IGeoPoint, pointB: IGeoPoint, position: number): IGeoPoint {\r\n\t\tlet p = d3geo.geoInterpolate([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude])(position);\r\n\t\treturn { longitude: p[0], latitude: p[1] };\r\n\t};\r\n\r\n\t// returns radians\r\n\tpublic multiDistance(multiGeoLine: Array<Array<IGeoPoint>>): number {\r\n\t\tlet distance = 0;\r\n\t\tfor (let s = 0; s < multiGeoLine.length; s++) {\r\n\t\t\tlet points: Array<IGeoPoint> = multiGeoLine[s];\r\n\t\t\tif (points.length > 1) {\r\n\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\tlet pointA = points[p - 1];\r\n\t\t\t\t\tlet pointB = points[p];\r\n\t\t\t\t\tdistance += this.distance(pointA, pointB);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t// returns radians\r\n\tpublic distance(pointA: IGeoPoint, pointB: IGeoPoint): number {\r\n\t\treturn d3geo.geoDistance([pointA.longitude, pointA.latitude], [pointB.longitude, pointB.latitude]);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToPoint(multiGeoLine: Array<Array<IGeoPoint>>, position: number): IOrientationPoint {\r\n\r\n\t\tif (multiGeoLine) {\r\n\t\t\tlet intermediatePoint = this.positionToGeoPoint(multiGeoLine, position);\r\n\t\t\tlet intermediatePointA = this.positionToGeoPoint(multiGeoLine, position - 0.01);\r\n\t\t\tlet intermediatePointB = this.positionToGeoPoint(multiGeoLine, position + 0.01);\r\n\r\n\t\t\tif (intermediatePointA && intermediatePointB) {\r\n\r\n\t\t\t\tlet point = this.convert(intermediatePoint);\r\n\r\n\t\t\t\tlet pa = this.convert(intermediatePointA);\r\n\t\t\t\tlet pb = this.convert(intermediatePointB);\r\n\r\n\t\t\t\treturn { x: point.x, y: point.y, angle: $math.getAngle(pa, pb) };\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn { x: 0, y: 0, angle: 0 };\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Converts relative position along the line (0-1) into pixel coordinates.\r\n\t *\r\n\t * @param position  Position (0-1)\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic positionToGeoPoint(multiGeoLine: Array<Array<IGeoPoint>>, position: number): IGeoPoint {\r\n\r\n\t\tif (multiGeoLine) {\r\n\t\t\tlet totalDistance: number = this.multiDistance(multiGeoLine);\r\n\t\t\tlet currentDistance: number = 0;\r\n\r\n\t\t\tlet distanceAB: number;\r\n\t\t\tlet positionA: number = 0;\r\n\t\t\tlet positionB: number = 0;\r\n\t\t\tlet pointA: IGeoPoint;\r\n\t\t\tlet pointB: IGeoPoint;\r\n\r\n\t\t\tfor (let s = 0; s < multiGeoLine.length; s++) {\r\n\t\t\t\tlet points: Array<IGeoPoint> = multiGeoLine[s];\r\n\t\t\t\tif (points.length > 1) {\r\n\t\t\t\t\tfor (let p = 1; p < points.length; p++) {\r\n\t\t\t\t\t\tpointA = points[p - 1];\r\n\t\t\t\t\t\tpointB = points[p];\r\n\r\n\t\t\t\t\t\tpositionA = currentDistance / totalDistance;\r\n\t\t\t\t\t\tdistanceAB = this.distance(pointA, pointB);\r\n\t\t\t\t\t\tcurrentDistance += distanceAB;\r\n\t\t\t\t\t\tpositionB = currentDistance / totalDistance;\r\n\r\n\t\t\t\t\t\tif (positionA <= position && positionB > position) {\r\n\t\t\t\t\t\t\ts = multiGeoLine.length;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (points.length == 1) {\r\n\t\t\t\t\tpointA = points[0];\r\n\t\t\t\t\tpointB = points[0];\r\n\t\t\t\t\tpositionA = 0;\r\n\t\t\t\t\tpositionB = 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (pointA && pointB) {\r\n\t\t\t\tlet positionAB: number = (position - positionA) / (positionB - positionA);\r\n\t\t\t\treturn this.intermediatePoint(pointA, pointB, positionAB);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn { longitude: 0, latitude: 0 };\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"Projection\"] = Projection;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}