{"ast":null,"code":"/**\r\n * JSON parser.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DataParser } from \"./DataParser\";\nimport * as $object from \"../utils/Object\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * A parser for JSON.\r\n *\r\n * @important\r\n */\nvar JSONParser = /** @class */function (_super) {\n  __extends(JSONParser, _super);\n  function JSONParser() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Content-type suitable for JSON format.\r\n     */\n    _this.contentType = \"application/json\";\n    /**\r\n     * Parser options.\r\n     *\r\n     * @see {@link IJSONOptions} for description of each option\r\n     */\n    _this.options = {};\n    return _this;\n  }\n  /**\r\n   * Tests if the data is valid JSON.\r\n   *\r\n   * @param data  Source data\r\n   * @return Is it JSON?\r\n   */\n  JSONParser.isJSON = function (data) {\n    try {\n      // Try parsing JSON\n      JSON.parse(data);\n      // If we got to this point it means it's a valid JSON\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n  /**\r\n   * Parses and returns data.\r\n   *\r\n   * @param data  Unparsed data\r\n   * @return Parsed data\r\n   */\n  JSONParser.prototype.parse = function (data) {\n    var _this = this;\n    // Init return\n    var res;\n    // Try parsing\n    try {\n      if ($type.hasValue(JSON)) {\n        res = JSON.parse(data);\n      }\n    } catch (e) {\n      return undefined;\n    }\n    // Do we need to cast some fields to numbers or dates?\n    var empty = $type.hasValue(this.options.emptyAs);\n    var numbers = this.parsableNumbers;\n    var dates = this.parsableDates;\n    if (Array.isArray(res) && (numbers || dates || empty)) {\n      var _loop_1 = function (i, len) {\n        var row = res[i];\n        $object.each(row, function (key, value) {\n          if (empty) {\n            row[key] = _this.maybeToEmpty(row[key]);\n          }\n          if (numbers) {\n            row[key] = _this.maybeToNumber(key, row[key]);\n          }\n          if (dates) {\n            row[key] = _this.maybeToDate(key, row[key]);\n          }\n        });\n      };\n      // Iterate through the data and check if it needs to be converted\n      for (var i = 0, len = res.length; i < len; i++) {\n        _loop_1(i, len);\n      }\n    }\n    // Convert to array\n    //return Array.isArray(res) ? res : [res];\n    return res;\n  };\n  return JSONParser;\n}(DataParser);\nexport { JSONParser };","map":{"version":3,"names":["DataParser","$object","$type","JSONParser","_super","__extends","_this","apply","arguments","contentType","options","isJSON","data","JSON","parse","e","prototype","res","hasValue","undefined","empty","emptyAs","numbers","parsableNumbers","dates","parsableDates","Array","isArray","i","len","row","each","key","value","maybeToEmpty","maybeToNumber","maybeToDate","length"],"sources":["../../../../../src/.internal/core/data/JSONParser.ts"],"sourcesContent":["/**\r\n * JSON parser.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DataParser, IDataParserOptions } from \"./DataParser\";\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * Defines options for JSON format parser\r\n */\r\nexport interface IJSONOptions extends IDataParserOptions {\r\n\r\n\t/**\r\n\t * A list of fields that should be treaded as numeric.\r\n\t *\r\n\t * Any information container in such fields will be converted to `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * A list of fields that hold date/time infromation.\r\n\t *\r\n\t * Parser will try to convert such fields into `Date` objects.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * A date formatted to be used when parsing dates.\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n}\r\n\r\n/**\r\n * A parser for JSON.\r\n *\r\n * @important\r\n */\r\nexport class JSONParser extends DataParser {\r\n\r\n\t/**\r\n\t * Tests if the data is valid JSON.\r\n\t *\r\n\t * @param data  Source data\r\n\t * @return Is it JSON?\r\n\t */\r\n\tstatic isJSON(data: string): boolean {\r\n\t\ttry {\r\n\r\n\t\t\t// Try parsing JSON\r\n\t\t\tJSON.parse(data);\r\n\r\n\t\t\t// If we got to this point it means it's a valid JSON\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tcatch (e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Content-type suitable for JSON format.\r\n\t */\r\n\tpublic contentType: string = \"application/json\";\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IJSONOptions} for description of each option\r\n\t */\r\n\tpublic options: IJSONOptions = {};\r\n\r\n\t/**\r\n\t * Parses and returns data.\r\n\t *\r\n\t * @param data  Unparsed data\r\n\t * @return Parsed data\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\r\n\t\t// Init return\r\n\t\tlet res: any;\r\n\r\n\t\t// Try parsing\r\n\t\ttry {\r\n\t\t\tif ($type.hasValue(JSON)) {\r\n\t\t\t\tres = JSON.parse(data);\r\n\t\t\t}\r\n\t\t} catch (e) {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\r\n\t\t// Do we need to cast some fields to numbers or dates?\r\n\t\tlet empty = $type.hasValue(this.options.emptyAs);\r\n\t\tlet numbers = this.parsableNumbers;\r\n\t\tlet dates = this.parsableDates;\r\n\t\tif (Array.isArray(res) && (numbers || dates || empty)) {\r\n\r\n\t\t\t// Iterate through the data and check if it needs to be converted\r\n\t\t\tfor (let i = 0, len = res.length; i < len; i++) {\r\n\t\t\t\tlet row = res[i];\r\n\t\t\t\t$object.each(row, (key, value) => {\r\n\t\t\t\t\tif (empty) {\r\n\t\t\t\t\t\trow[key] = this.maybeToEmpty(row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (numbers) {\r\n\t\t\t\t\t\trow[key] = this.maybeToNumber(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (dates) {\r\n\t\t\t\t\t\trow[key] = this.maybeToDate(key, row[key]);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Convert to array\r\n\t\t//return Array.isArray(res) ? res : [res];\r\n\t\treturn res;\r\n\r\n\t}\r\n\r\n}\r\n"],"mappings":"AAAA;;;;AAIA;;;;;;AAMA,SAASA,UAAU,QAA4B,cAAc;AAE7D,OAAO,KAAKC,OAAO,MAAM,iBAAiB;AAC1C,OAAO,KAAKC,KAAK,MAAM,eAAe;AA6BtC;;;;;AAKA,IAAAC,UAAA,0BAAAC,MAAA;EAAgCC,SAAA,CAAAF,UAAA,EAAAC,MAAA;EAAhC,SAAAD,WAAA;IAAA,IAAAG,KAAA,GAAAF,MAAA,aAAAA,MAAA,CAAAG,KAAA,OAAAC,SAAA;IAsBC;;;IAGOF,KAAA,CAAAG,WAAW,GAAW,kBAAkB;IAE/C;;;;;IAKOH,KAAA,CAAAI,OAAO,GAAiB,EAAE;;EAoDlC;EAlFC;;;;;;EAMOP,UAAA,CAAAQ,MAAM,GAAb,UAAcC,IAAY;IACzB,IAAI;MAEH;MACAC,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;MAEhB;MACA,OAAO,IAAI;KACX,CACD,OAAOG,CAAC,EAAE;MACT,OAAO,KAAK;;EAEd,CAAC;EAcD;;;;;;EAMOZ,UAAA,CAAAa,SAAA,CAAAF,KAAK,GAAZ,UAAaF,IAAY;IAAzB,IAAAN,KAAA;IAEC;IACA,IAAIW,GAAQ;IAEZ;IACA,IAAI;MACH,IAAIf,KAAK,CAACgB,QAAQ,CAACL,IAAI,CAAC,EAAE;QACzBI,GAAG,GAAGJ,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;;KAEvB,CAAC,OAAOG,CAAC,EAAE;MACX,OAAOI,SAAS;;IAGjB;IACA,IAAIC,KAAK,GAAGlB,KAAK,CAACgB,QAAQ,CAAC,IAAI,CAACR,OAAO,CAACW,OAAO,CAAC;IAChD,IAAIC,OAAO,GAAG,IAAI,CAACC,eAAe;IAClC,IAAIC,KAAK,GAAG,IAAI,CAACC,aAAa;IAC9B,IAAIC,KAAK,CAACC,OAAO,CAACV,GAAG,CAAC,KAAKK,OAAO,IAAIE,KAAK,IAAIJ,KAAK,CAAC,EAAE;8BAG7CQ,CAAC,EAAMC,GAAG;QAClB,IAAIC,GAAG,GAAGb,GAAG,CAACW,CAAC,CAAC;QAChB3B,OAAO,CAAC8B,IAAI,CAACD,GAAG,EAAE,UAACE,GAAG,EAAEC,KAAK;UAC5B,IAAIb,KAAK,EAAE;YACVU,GAAG,CAACE,GAAG,CAAC,GAAG1B,KAAI,CAAC4B,YAAY,CAACJ,GAAG,CAACE,GAAG,CAAC,CAAC;;UAEvC,IAAIV,OAAO,EAAE;YACZQ,GAAG,CAACE,GAAG,CAAC,GAAG1B,KAAI,CAAC6B,aAAa,CAACH,GAAG,EAAEF,GAAG,CAACE,GAAG,CAAC,CAAC;;UAE7C,IAAIR,KAAK,EAAE;YACVM,GAAG,CAACE,GAAG,CAAC,GAAG1B,KAAI,CAAC8B,WAAW,CAACJ,GAAG,EAAEF,GAAG,CAACE,GAAG,CAAC,CAAC;;QAE5C,CAAC,CAAC;;MAbH;MACA,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGZ,GAAG,CAACoB,MAAM,EAAET,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE;gBAArCA,CAAC,EAAMC,GAAG;;;IAiBpB;IACA;IACA,OAAOZ,GAAG;EAEX,CAAC;EAEF,OAAAd,UAAC;AAAD,CAAC,CApF+BH,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}