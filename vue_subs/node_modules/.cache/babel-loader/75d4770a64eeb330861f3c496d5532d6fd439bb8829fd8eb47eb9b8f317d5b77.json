{"ast":null,"code":"/**\r\n * Data parser module.\r\n */\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { DateFormatter } from \"../formatters/DateFormatter\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Base class for the data parsers.\r\n */\nvar DataParser = /** @class */function () {\n  function DataParser() {}\n  /**\r\n   * A \"placeholder\" function for real parsers to override.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param data  Source data\r\n   * @return Parsed data (empty)\r\n   */\n  DataParser.prototype.parse = function (data) {\n    return [];\n  };\n  ;\n  Object.defineProperty(DataParser.prototype, \"parsableNumbers\", {\n    /**\r\n     * Checks if there are any numeric fields that need to be converted to\r\n     * numbers.\r\n     *\r\n     * @return Numeric fields?\r\n     */\n    get: function () {\n      return this.options.numberFields && this.options.numberFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to 'number' if it is in `numberFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n  DataParser.prototype.maybeToNumber = function (field, value) {\n    if (this.options.numberFields.indexOf(field) !== -1) {\n      return $utils.anyToNumber(value);\n    }\n    return value;\n  };\n  Object.defineProperty(DataParser.prototype, \"parsableDates\", {\n    /**\r\n     * Checks if there are any date fields that need to be converted to `Date`\r\n     * objects.\r\n     *\r\n     * @return Date fields?\r\n     */\n    get: function () {\n      return this.options.dateFields && this.options.dateFields.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Converts a value to `Date` if it is in `dateFields`.\r\n   *\r\n   * @param field  Field name\r\n   * @param value  Value\r\n   * @return Parsed or original value\r\n   */\n  DataParser.prototype.maybeToDate = function (field, value) {\n    if (this.options.dateFields.indexOf(field) !== -1) {\n      return this.options.dateFormatter.parse(value, this.dateFormat);\n    }\n    return value;\n  };\n  /**\r\n   * Replaces empty value with something else.\r\n   *\r\n   * @param value  Source value\r\n   * @return Source value or replacement\r\n   */\n  DataParser.prototype.maybeToEmpty = function (value) {\n    if ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\n      return this.options.emptyAs;\n    }\n    return value;\n  };\n  Object.defineProperty(DataParser.prototype, \"dateFormatter\", {\n    /**\r\n     * [[DateFormatter]] object for date parsing.\r\n     *\r\n     * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n     * is created.\r\n     *\r\n     * @return Date formatter\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function () {\n      if (!this.options.dateFormatter) {\n        this.options.dateFormatter = new DateFormatter();\n        if (this.options.dateFormat) {\n          this.options.dateFormat = this.options.dateFormat;\n        }\n      }\n      return this.options.dateFormatter;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(DataParser.prototype, \"dateFormat\", {\n    /**\r\n     * A date format to use when parsing dates.\r\n     *\r\n     * @return Date format\r\n     * @see {@link DateFormatter}\r\n     */\n    get: function () {\n      return this.options.dateFormat || this.dateFormatter.inputDateFormat;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return DataParser;\n}();\nexport { DataParser };","map":{"version":3,"names":["DateFormatter","$utils","$type","DataParser","prototype","parse","data","Object","defineProperty","get","options","numberFields","length","maybeToNumber","field","value","indexOf","anyToNumber","dateFields","maybeToDate","dateFormatter","dateFormat","maybeToEmpty","hasValue","emptyAs","inputDateFormat"],"sources":["../../../../../src/.internal/core/data/DataParser.ts"],"sourcesContent":["/**\r\n * Data parser module.\r\n */\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { DateFormatter } from \"../formatters/DateFormatter\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines common options for all data parsers.\r\n */\r\nexport interface IDataParserOptions {\r\n\r\n\t/**\r\n\t * Empty values (e.g. empty strings, `null`, etc.) will be replaced with\r\n\t * this.\r\n\t */\r\n\temptyAs?: any;\r\n\r\n\t/**\r\n\t * List of fields in data that hold numeric values. Parser will try to\r\n\t * convert the value in those fields to a `number`.\r\n\t */\r\n\tnumberFields?: string[];\r\n\r\n\t/**\r\n\t * List of fields in data that need to be treated as Dates, i.e. converted\r\n\t * to `Date` objects from whatever source format they are currently in.\r\n\t */\r\n\tdateFields?: string[];\r\n\r\n\t/**\r\n\t * An instance of [[DateFormatter]] to use when parsing string-based dates.\r\n\t * If it's not set, the parser will create it's own instance of\r\n\t * [[DateFormatter]], should any date parsing required. (`dateFields` is set)\r\n\t *\r\n\t * Unless `dateFormat` is set in parser options, the parser will try to look\r\n\t * for `dateFormat` in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormatter?: DateFormatter;\r\n\r\n\t/**\r\n\t * Override date format set in `dateFormatter`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-date-time/#Parsing_Dates} Tutorial on date parsing\r\n\t */\r\n\tdateFormat?: string;\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Base class for the data parsers.\r\n */\r\nexport class DataParser {\r\n\r\n\t/**\r\n\t * Content type, relevant to the specific format.\r\n\t */\r\n\tpublic contentType: string;\r\n\r\n\t/**\r\n\t * Parser options.\r\n\t *\r\n\t * @see {@link IDataParserOptions} for description of each option\r\n\t */\r\n\tpublic options: IDataParserOptions;\r\n\r\n\t/**\r\n\t * A \"placeholder\" function for real parsers to override.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param data  Source data\r\n\t * @return Parsed data (empty)\r\n\t */\r\n\tpublic parse(data: string): any {\r\n\t\treturn [];\r\n\t};\r\n\r\n\t/**\r\n\t * Checks if there are any numeric fields that need to be converted to\r\n\t * numbers.\r\n\t *\r\n\t * @return Numeric fields?\r\n\t */\r\n\tprotected get parsableNumbers(): boolean {\r\n\t\treturn this.options.numberFields && (this.options.numberFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to 'number' if it is in `numberFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToNumber(field: string, value: any): any {\r\n\t\tif (this.options.numberFields.indexOf(field) !== -1) {\r\n\t\t\treturn $utils.anyToNumber(value);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if there are any date fields that need to be converted to `Date`\r\n\t * objects.\r\n\t *\r\n\t * @return Date fields?\r\n\t */\r\n\tprotected get parsableDates(): boolean {\r\n\t\treturn this.options.dateFields && (this.options.dateFields.length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a value to `Date` if it is in `dateFields`.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @param value  Value\r\n\t * @return Parsed or original value\r\n\t */\r\n\tprotected maybeToDate(field: string, value: any): any {\r\n\t\tif (this.options.dateFields.indexOf(field) !== -1) {\r\n\t\t\treturn this.options.dateFormatter.parse(value, this.dateFormat);\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces empty value with something else.\r\n\t *\r\n\t * @param value  Source value\r\n\t * @return Source value or replacement\r\n\t */\r\n\tprotected maybeToEmpty(value: any): any {\r\n\t\tif ((!$type.hasValue(value) || value == \"\") && $type.hasValue(this.options.emptyAs)) {\r\n\t\t\treturn this.options.emptyAs;\r\n\t\t}\r\n\t\treturn value;\r\n\t}\r\n\r\n\t/**\r\n\t * [[DateFormatter]] object for date parsing.\r\n\t *\r\n\t * If there was not [[DateFormatter]] supplied in parser options, a new one\r\n\t * is created.\r\n\t *\r\n\t * @return Date formatter\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormatter(): DateFormatter {\r\n\t\tif (!this.options.dateFormatter) {\r\n\t\t\tthis.options.dateFormatter = new DateFormatter;\r\n\t\t\tif (this.options.dateFormat) {\r\n\t\t\t\tthis.options.dateFormat = this.options.dateFormat;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this.options.dateFormatter;\r\n\t}\r\n\r\n\t/**\r\n\t * A date format to use when parsing dates.\r\n\t *\r\n\t * @return Date format\r\n\t * @see {@link DateFormatter}\r\n\t */\r\n\tprotected get dateFormat(): string {\r\n\t\treturn this.options.dateFormat || this.dateFormatter.inputDateFormat;\r\n\t}\r\n\r\n}\r\n"],"mappings":"AAAA;;;AAKA;;;;;;AAMA,SAASA,aAAa,QAAQ,6BAA6B;AAC3D,OAAO,KAAKC,MAAM,MAAM,gBAAgB;AACxC,OAAO,KAAKC,KAAK,MAAM,eAAe;AAuDtC;;;;;;AAOA;;;AAGA,IAAAC,UAAA;EAAA,SAAAA,WAAA,GAmHA;EArGC;;;;;;;EAOOA,UAAA,CAAAC,SAAA,CAAAC,KAAK,GAAZ,UAAaC,IAAY;IACxB,OAAO,EAAE;EACV,CAAC;EAAA;EAQDC,MAAA,CAAAC,cAAA,CAAcL,UAAA,CAAAC,SAAA,mBAAe;IAN7B;;;;;;SAMA,SAAAK,CAAA;MACC,OAAO,IAAI,CAACC,OAAO,CAACC,YAAY,IAAK,IAAI,CAACD,OAAO,CAACC,YAAY,CAACC,MAAM,GAAG,CAAE;IAC3E,CAAC;;;;EAED;;;;;;;EAOUT,UAAA,CAAAC,SAAA,CAAAS,aAAa,GAAvB,UAAwBC,KAAa,EAAEC,KAAU;IAChD,IAAI,IAAI,CAACL,OAAO,CAACC,YAAY,CAACK,OAAO,CAACF,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MACpD,OAAOb,MAAM,CAACgB,WAAW,CAACF,KAAK,CAAC;;IAEjC,OAAOA,KAAK;EACb,CAAC;EAQDR,MAAA,CAAAC,cAAA,CAAcL,UAAA,CAAAC,SAAA,iBAAa;IAN3B;;;;;;SAMA,SAAAK,CAAA;MACC,OAAO,IAAI,CAACC,OAAO,CAACQ,UAAU,IAAK,IAAI,CAACR,OAAO,CAACQ,UAAU,CAACN,MAAM,GAAG,CAAE;IACvE,CAAC;;;;EAED;;;;;;;EAOUT,UAAA,CAAAC,SAAA,CAAAe,WAAW,GAArB,UAAsBL,KAAa,EAAEC,KAAU;IAC9C,IAAI,IAAI,CAACL,OAAO,CAACQ,UAAU,CAACF,OAAO,CAACF,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE;MAClD,OAAO,IAAI,CAACJ,OAAO,CAACU,aAAa,CAACf,KAAK,CAACU,KAAK,EAAE,IAAI,CAACM,UAAU,CAAC;;IAEhE,OAAON,KAAK;EACb,CAAC;EAED;;;;;;EAMUZ,UAAA,CAAAC,SAAA,CAAAkB,YAAY,GAAtB,UAAuBP,KAAU;IAChC,IAAI,CAAC,CAACb,KAAK,CAACqB,QAAQ,CAACR,KAAK,CAAC,IAAIA,KAAK,IAAI,EAAE,KAAKb,KAAK,CAACqB,QAAQ,CAAC,IAAI,CAACb,OAAO,CAACc,OAAO,CAAC,EAAE;MACpF,OAAO,IAAI,CAACd,OAAO,CAACc,OAAO;;IAE5B,OAAOT,KAAK;EACb,CAAC;EAWDR,MAAA,CAAAC,cAAA,CAAcL,UAAA,CAAAC,SAAA,iBAAa;IAT3B;;;;;;;;;SASA,SAAAK,CAAA;MACC,IAAI,CAAC,IAAI,CAACC,OAAO,CAACU,aAAa,EAAE;QAChC,IAAI,CAACV,OAAO,CAACU,aAAa,GAAG,IAAIpB,aAAa,CAAb,CAAa;QAC9C,IAAI,IAAI,CAACU,OAAO,CAACW,UAAU,EAAE;UAC5B,IAAI,CAACX,OAAO,CAACW,UAAU,GAAG,IAAI,CAACX,OAAO,CAACW,UAAU;;;MAGnD,OAAO,IAAI,CAACX,OAAO,CAACU,aAAa;IAClC,CAAC;;;;EAQDb,MAAA,CAAAC,cAAA,CAAcL,UAAA,CAAAC,SAAA,cAAU;IANxB;;;;;;SAMA,SAAAK,CAAA;MACC,OAAO,IAAI,CAACC,OAAO,CAACW,UAAU,IAAI,IAAI,CAACD,aAAa,CAACK,eAAe;IACrE,CAAC;;;;EAEF,OAAAtB,UAAC;AAAD,CAAC,CAnHD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}