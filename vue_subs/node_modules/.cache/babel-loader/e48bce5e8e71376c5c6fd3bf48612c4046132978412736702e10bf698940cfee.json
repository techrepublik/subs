{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * Animation module.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObjectEvents } from \"../Base\";\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\nimport { Disposer } from \"../utils/Disposer\";\nimport { Color } from \"../utils/Color\";\nimport { Percent, percent } from \"../utils/Percent\";\nimport * as $async from \"../utils/AsyncPending\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $colors from \"../utils/Colors\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $type from \"../utils/Type\";\nimport { system } from \"../System\";\nimport { options } from \"../Options\";\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\nexport function animate(duration, callback) {\n  var disposed = false;\n  // TODO use performance.now() ?\n  var startTime = Date.now();\n  function loop(now) {\n    if (!disposed) {\n      var diff = now - startTime;\n      if (diff >= duration) {\n        callback(1);\n      } else {\n        $async.nextFrame(loop);\n        callback(diff / duration);\n      }\n    }\n  }\n  $async.nextFrame(loop);\n  return new Disposer(function () {\n    disposed = true;\n  });\n}\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\nfunction getProgressNumber(progress, from, to) {\n  return from + (to - from) * progress;\n}\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\nfunction getProgressPercent(progress, from, to) {\n  return new Percent(getProgressNumber(progress, from.percent, to.percent));\n}\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\nfunction getProgressColor(progress, from, to) {\n  var color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\n  if (from.alpha != to.alpha) {\n    color.alpha = from.alpha + (to.alpha - from.alpha) * progress;\n  }\n  return color;\n}\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\nfunction getHybridProperty(property, type) {\n  return type + property.charAt(0).toUpperCase() + property.substr(1);\n}\nvar AnimationDisposer = /** @class */function () {\n  function AnimationDisposer(array) {\n    this._disposer = new Disposer(function () {\n      while (array.length !== 0) {\n        array[0].dispose();\n      }\n    });\n  }\n  AnimationDisposer.prototype.isDisposed = function () {\n    return this._disposer.isDisposed();\n  };\n  AnimationDisposer.prototype.dispose = function () {\n    this._disposer.dispose();\n  };\n  return AnimationDisposer;\n}();\nexport { AnimationDisposer };\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\nvar Animation = /** @class */function (_super) {\n  __extends(Animation, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param object            An object animation should run on\r\n   * @param animationOptions  One or several (array) of animation options\r\n   * @param duration          Duration (ms)\r\n   * @param easing            Easing function\r\n   */\n  function Animation(object, animationOptions, duration, easing) {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    /**\r\n     * Duration of the animation in milliseconds.\r\n     */\n    _this.duration = 0;\n    /**\r\n     * Easing function to use.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n    _this.easing = $ease.linear;\n    /**\r\n     * Contains progress of the current animation: 0 (start) to 1 (end).\r\n     */\n    _this.progress = 0;\n    /**\r\n     * Indicated how many times animation should loop.\r\n     */\n    _this._loop = 0;\n    /**\r\n     * Animation is paused.\r\n     */\n    _this._pause = false;\n    /**\r\n     * Holds reference to timeout for delayed play.\r\n     */\n    _this._delayTimeout = null;\n    /**\r\n     * Elapsed time in currently playing animation.\r\n     */\n    _this._time = 0;\n    _this._isFinished = false;\n    _this.className = \"Animation\";\n    // Override duration if animations disabled system-wide\n    if (options.animationsEnabled === false) {\n      duration = 0;\n    }\n    // Set parameters\n    _this.object = object;\n    _this.animationOptions = $array.toArray(animationOptions);\n    _this.duration = duration;\n    if (easing) {\n      _this.easing = easing;\n    }\n    // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    //this.stopSameAnimations();\n    /*if ($type.hasValue(callback)) {\r\n        // TODO don't use .call\r\n        this.events.on(\"animationended\", callback, object);\r\n    }*/\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  // TODO verify that this is correct\n  Animation.prototype.debug = function () {};\n  /**\r\n   * Disposes this object, clears up after itself.\r\n   */\n  Animation.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n    this.pause();\n  };\n  /**\r\n   * Delays animation start by X milliseconds.\r\n   *\r\n   * @param delay  Delay (ms)\r\n   * @return Animation\r\n   */\n  Animation.prototype.delay = function (delay) {\n    var _this = this;\n    //@todo Maybe not use `bind()`\n    if (delay > 0) {\n      this.pause();\n      // This is so that it will get disposed if `this.object` is disposed\n      // TODO hacky, figure out a better way\n      $array.move(this.object.animations, this);\n      var id_1 = setTimeout(function () {\n        _this._delayTimeout = null;\n        _this.start();\n      }, delay);\n      this._delayTimeout = new Disposer(function () {\n        clearTimeout(id_1);\n      });\n    }\n    return this;\n  };\n  Animation.prototype._start = function () {\n    this._isFinished = false;\n    // Clear delay timeout if there was one\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n    // Run check if there are already animations playing on the same properties\n    // and stop them - the last animation takes precedence\n    this.stopSameAnimations();\n    // Reset counters\n    this._pause = false;\n    // Register animation\n    $array.move(system.animations, this);\n    // Register this animation in object's `animations` list\n    $array.move(this.object.animations, this);\n    system.requestFrame();\n  };\n  /**\r\n   * Starts animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.start = function () {\n    this._start();\n    this._startTime = Date.now();\n    this._time = 0;\n    this.staticOptions = [];\n    // Process initial property values\n    for (var i = this.animationOptions.length - 1; i >= 0; i--) {\n      var options_1 = this.animationOptions[i];\n      if (!$type.hasValue(options_1.from)) {\n        if (options_1.childObject) {\n          options_1.from = options_1.childObject[options_1.property];\n        } else {\n          options_1.from = this.object[options_1.property];\n          if (!$type.hasValue(options_1.from)) {\n            options_1.from = SVGDefaults[options_1.property];\n          }\n        }\n        /*if (!$type.hasValue(options.from)) {\r\n            throw Error(\"Could not get initial transition value.\");\r\n        }*/\n      }\n      if (options_1.from == options_1.to) {\n        // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\n        $array.remove(this.animationOptions, options_1);\n      } else if (!$type.hasValue(options_1.from) || !(options_1.from instanceof Percent) && options_1.to instanceof Percent || options_1.from instanceof Percent && !(options_1.to instanceof Percent)) {\n        // Initial value is undefined, treat it as static\n        this.staticOptions.push(options_1);\n        $array.remove(this.animationOptions, options_1);\n      } else {\n        // Use different update methods for different value types\n        if ($type.isNumber(options_1.to)) {\n          // Numeric value\n          options_1.updateMethod = getProgressNumber;\n          // Check if initial value is not Percent\n          if (options_1.from instanceof Percent) {\n            // It is. Let's convert it to pixel value\n            // @todo Check if we can do this in a less hacky way\n            var convertedFrom = this.object[getHybridProperty(options_1.property, \"pixel\")];\n            if (!isNaN(convertedFrom)) {\n              options_1.from = convertedFrom;\n            } else {\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (isNaN(options_1.from)) {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        } else {\n          // Check if maybe we have a color or percent value\n          if (options_1.to instanceof Color) {\n            // Yup - set resolved named color\n            //options.from = $colors.stringToColor(<string>options.from);\n            if (options_1.from) {\n              options_1.updateMethod = getProgressColor;\n            } else {\n              // Static value\n              this.staticOptions.push(options_1);\n              $array.remove(this.animationOptions, options_1);\n            }\n          } else if (options_1.to instanceof Percent) {\n            // Percent\n            options_1.updateMethod = getProgressPercent;\n            // Check if the initial value is maybe in pixels\n            if (!isNaN(options_1.from)) {\n              // It is. Let's convert it\n              // @todo Check if we can do this in a less hacky way\n              var convertedFrom = this.object[getHybridProperty(options_1.property, \"relative\")];\n              if (!isNaN(convertedFrom)) {\n                options_1.from = percent(convertedFrom * 100);\n              }\n            }\n          } else {\n            // Static value\n            this.staticOptions.push(options_1);\n            $array.remove(this.animationOptions, options_1);\n          }\n        }\n      }\n    }\n    // Apply static options (just in case they were reset by previous\n    // animation loop)\n    this.applyStaticOptions();\n    if (this.events.isEnabled(\"animationstarted\")) {\n      var event_1 = {\n        type: \"animationstarted\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationstarted\", event_1);\n    }\n    this.update();\n    // If duration is 0, just end animation\n    if (this.duration === 0) {\n      this.end();\n    }\n    return this;\n  };\n  /**\r\n   * Sets loop count for the animation. If parameter is not a valid number the\r\n   * animation will keep on looping indefinitely.\r\n   *\r\n   * @param count  Number of times to loop animation\r\n   * @return Animation\r\n   */\n  Animation.prototype.loop = function (count) {\n    if (!$type.isNumber(count)) {\n      count = Infinity;\n    }\n    this._loop = count;\n    return this;\n  };\n  /**\r\n   * Pauses animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.pause = function () {\n    this._pause = true;\n    if (this._delayTimeout) {\n      this.removeDispose(this._delayTimeout);\n      this._delayTimeout = null;\n    }\n    $array.remove(system.animations, this);\n    $array.remove(this.object.animations, this);\n    return this;\n  };\n  /**\r\n   * Resumes paused animation.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.resume = function () {\n    this._start();\n    this._startTime = Date.now() - this._time;\n    return this;\n  };\n  /**\r\n   * Jumps to animation end. If animation is set to loop, this will start\r\n   * another round of animation from start.\r\n   *\r\n   * @return Animation\r\n   */\n  Animation.prototype.end = function () {\n    // Pause and complete the progress\n    if (this._loop == 0) {\n      this.pause();\n    }\n    this.setProgress(1);\n    // Apply static options\n    this.applyStaticOptions();\n    if (this.events.isEnabled(\"animationended\")) {\n      var event_2 = {\n        type: \"animationended\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationended\", event_2);\n    }\n    // Check if we should loop\n    if (this._loop > 0) {\n      this._loop--;\n      this.start();\n    } else {\n      this.stop();\n      this._isFinished = true;\n    }\n    return this;\n  };\n  /**\r\n   * Stops animation immediately leaving properties in their current values.\r\n   */\n  Animation.prototype.kill = function () {\n    this.pause();\n    this._isFinished = true;\n  };\n  /**\r\n   * Returns indicator if this animation is finished or not\r\n   *\r\n   * @return Is finished?\r\n   */\n  Animation.prototype.isFinished = function () {\n    return this._isFinished;\n  };\n  /**\r\n   * Applies static options that can't be animated.\r\n   */\n  Animation.prototype.applyStaticOptions = function () {\n    var _this = this;\n    $array.each(this.staticOptions, function (options) {\n      if (options.childObject) {\n        options.childObject[options.property] = _this.progress == 1 ? options.to : options.from;\n      } else {\n        _this.object[options.property] = _this.progress == 1 ? options.to : options.from;\n      }\n    });\n  };\n  /**\r\n   * Stops animation.\r\n   *\r\n   * When animation is stopped, the properties of the target object will remain\r\n   * where they were at the moment when `stop()` was called.\r\n   *\r\n   * @param skipEvent  Do not trigger `animationstopped` event\r\n   * @return Animation\r\n   */\n  Animation.prototype.stop = function (skipEvent) {\n    this.pause();\n    if (!skipEvent) {\n      if (this.events.isEnabled(\"animationstopped\")) {\n        var event_3 = {\n          type: \"animationstopped\",\n          target: this,\n          progress: this.progress\n        };\n        this.events.dispatchImmediately(\"animationstopped\", event_3);\n      }\n    }\n    return this;\n  };\n  /**\r\n   * Sets current progress and updates object's numeric and color values.\r\n   *\r\n   * @param progress Progress (0-1)\r\n   */\n  Animation.prototype.setProgress = function (progress) {\n    var _this = this;\n    this._time = this.duration * progress; // just in case we call this from outside\n    $array.each(this.animationOptions, function (options) {\n      if (options.updateMethod && $type.hasValue(options.from)) {\n        var value = options.updateMethod(progress, options.from, options.to);\n        if (options.childObject) {\n          options.childObject[options.property] = value;\n        } else {\n          _this.object[options.property] = value;\n        }\n      }\n    });\n    this.progress = progress;\n    if (this.events.isEnabled(\"animationprogress\")) {\n      var event_4 = {\n        type: \"animationprogress\",\n        target: this,\n        progress: this.progress\n      };\n      this.events.dispatchImmediately(\"animationprogress\", event_4);\n    }\n    system.requestFrame();\n  };\n  /**\r\n   * Tracks and sets progress according to time or frames.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @return Animation\r\n   */\n  Animation.prototype.update = function () {\n    if (!this._pause) {\n      var progress = void 0;\n      this._time = $math.fitToRange(Date.now() - this._startTime, 0, this.duration);\n      var timeProgress = this._time / this.duration;\n      progress = this.easing(timeProgress);\n      if (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\n        progress = 1;\n      }\n      this.setProgress(progress);\n      if ($math.round(this._time / this.duration, 6) == 1) {\n        this.end();\n      }\n    }\n    return this;\n  };\n  Object.defineProperty(Animation.prototype, \"delayed\", {\n    /**\r\n     * Returns `true` if this animation is delayed.\r\n     *\r\n     * @readonly\r\n     * @return [description]\r\n     */\n    get: function () {\n      return this._delayTimeout ? true : false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Checks other animations currently running on the same object and removes\r\n   * overlapping options from those other animations that are contained in\r\n   * this animation.\r\n   *\r\n   * This is needed to ensure that no two confurent animations step on each\r\n   * other's toes by trying to animate the same property.\r\n   */\n  Animation.prototype.stopSameAnimations = function () {\n    var _this = this;\n    // stop animation of the same property\n    // TODO make this more efficient\n    // TODO don't copy the array\n    $array.each($array.copy(this.object.animations), function (animation) {\n      if (animation !== _this && !animation.delayed) {\n        var killed_1 = [];\n        $array.each(_this.animationOptions, function (newOptions) {\n          $array.each(animation.animationOptions, function (oldOptions) {\n            if (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\n              killed_1.push(oldOptions);\n              if (animation.animationOptions.length == 0) {\n                animation.kill();\n              }\n            }\n          });\n        });\n        $array.each(killed_1, function (oldOptions) {\n          $array.remove(animation.animationOptions, oldOptions);\n        });\n      }\n    });\n  };\n  /**\r\n   * Adds easing functions to \"function\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as function?\r\n   */\n  Animation.prototype.asFunction = function (field) {\n    return field == \"easing\" || _super.prototype.asIs.call(this, field);\n  };\n  return Animation;\n}(BaseObjectEvents);\nexport { Animation };","map":{"version":3,"names":["BaseObjectEvents","SVGDefaults","Disposer","Color","Percent","percent","$async","$ease","$colors","$math","$array","$type","system","options","animate","duration","callback","disposed","startTime","Date","now","loop","diff","nextFrame","getProgressNumber","progress","from","to","getProgressPercent","getProgressColor","color","interpolate","rgb","alpha","getHybridProperty","property","type","charAt","toUpperCase","substr","AnimationDisposer","array","_disposer","length","dispose","prototype","isDisposed","Animation","_super","__extends","object","animationOptions","easing","_this","call","linear","_loop","_pause","_delayTimeout","_time","_isFinished","className","animationsEnabled","toArray","applyTheme","debug","pause","delay","move","animations","id_1","setTimeout","start","clearTimeout","_start","removeDispose","stopSameAnimations","requestFrame","_startTime","staticOptions","i","options_1","hasValue","childObject","remove","push","isNumber","updateMethod","convertedFrom","isNaN","applyStaticOptions","events","isEnabled","event_1","target","dispatchImmediately","update","end","count","Infinity","resume","setProgress","event_2","stop","kill","isFinished","each","skipEvent","event_3","value","event_4","fitToRange","timeProgress","round","Object","defineProperty","get","copy","animation","delayed","killed_1","newOptions","oldOptions","asFunction","field","asIs"],"sources":["../../../../../src/.internal/core/utils/Animation.ts"],"sourcesContent":["/**\r\n * Animation module.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { SVGDefaults } from \"../defs/SVGDefaults\";\r\nimport { Disposer, IDisposer } from \"../utils/Disposer\";\r\nimport { Color } from \"../utils/Color\";\r\nimport { Percent, percent } from \"../utils/Percent\";\r\nimport * as $async from \"../utils/AsyncPending\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $colors from \"../utils/Colors\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { system } from \"../System\";\r\nimport { options } from \"../Options\";\r\n\r\n\r\n/**\r\n * Defines interface for animation objects.\r\n *\r\n * Should at least contain `update()` method.\r\n */\r\nexport interface IAnimationObject {\r\n\tupdate: () => void\r\n}\r\n\r\n/**\r\n * Defines interface for objects that can be animated\r\n */\r\nexport interface IAnimatable {\r\n\tanimations: Array<Animation>;\r\n}\r\n\r\n\r\nexport type IAnimationOption = Color | Percent | number | string | boolean;\r\n\r\n/**\r\n * Defines interface for animation options.\r\n */\r\nexport interface IAnimationOptions {\r\n\r\n\t/**\r\n\t * An initial value to animate from.\r\n\t *\r\n\t * If omitted, the source value will be current value.\r\n\t */\r\n\tfrom?: IAnimationOption;\r\n\r\n\t/**\r\n\t * A target value to animate from.\r\n\t */\r\n\tto: IAnimationOption;\r\n\r\n\t/**\r\n\t * Property name to animate.\r\n\t */\r\n\tproperty?: any;\r\n\r\n\t/**\r\n\t * If current values should be taken from different object than the target\r\n\t * element of the animation, this property should be set to that object.\r\n\t */\r\n\tchildObject?: { [index: string]: any };\r\n\r\n\t/**\r\n\t * A method/function reference that will be called to for updating the\r\n\t * property value.\r\n\t */\r\n\tupdateMethod?(progress: number, from: IAnimationOption, to: IAnimationOption): IAnimationOption;\r\n\r\n\r\n\t/**\r\n\t * sometimes we need to pass some dummy data in animationOptions\r\n\t */\r\n\tdummyData?: any;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Percent]] animation.\r\n */\r\nexport interface IPercentAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Percent;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Percent;\r\n\r\n}\r\n\r\n/**\r\n * An interface for an object defining [[Color]] animation.\r\n */\r\nexport interface IColorAnimationOptions extends IAnimationOptions {\r\n\r\n\t/**\r\n\t * Initial value.\r\n\t */\r\n\tfrom?: Color;\r\n\r\n\t/**\r\n\t * Target value.\r\n\t */\r\n\tto: Color;\r\n\r\n}\r\n\r\n\r\n/**\r\n * Calls a `callback` function for the `duration` of milliseconds.\r\n *\r\n * @todo Needed?\r\n * @deprecated Not used anywhere\r\n * @ignore Exclude from docs\r\n * @param duration  Duration (ms)\r\n * @param callback  Callback function\r\n * @return Disposer\r\n */\r\nexport function animate(duration: number, callback: (time: number) => void): IDisposer {\r\n\tlet disposed = false;\r\n\r\n\t// TODO use performance.now() ?\r\n\tconst startTime = Date.now();\r\n\r\n\tfunction loop(now: number): void {\r\n\t\tif (!disposed) {\r\n\t\t\tconst diff = now - startTime;\r\n\r\n\t\t\tif (diff >= duration) {\r\n\t\t\t\tcallback(1);\r\n\r\n\t\t\t} else {\r\n\t\t\t\t$async.nextFrame(loop);\r\n\t\t\t\tcallback(diff / duration);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t$async.nextFrame(loop);\r\n\r\n\treturn new Disposer(() => {\r\n\t\tdisposed = true;\r\n\t});\r\n}\r\n\r\n\r\n/**\r\n * Defines events for [[Animation]].\r\n */\r\nexport interface IAnimationEvents extends IBaseObjectEvents {\r\n\r\n\t/**\r\n\t * Invoked when animation starts playing.\r\n\t */\r\n\tanimationstarted: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation finishes playing.\r\n\t */\r\n\tanimationended: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation makes progress.\r\n\t */\r\n\tanimationprogress: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n\t/**\r\n\t * Invoked when animation is stopped by some other process, before it had\r\n\t * a chance to finish.\r\n\t */\r\n\tanimationstopped: {\r\n\t\tprogress: number;\r\n\t};\r\n\r\n}\r\n\r\n\r\n/**\r\n * Returns numeric value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressNumber(progress: number, from: number, to: number): number {\r\n\treturn from + ((to - from) * progress);\r\n}\r\n\r\n/**\r\n * Returns [[Percent]] value accoring to progress between start and end\r\n * values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Value according to progress\r\n */\r\nfunction getProgressPercent(progress: number, from: Percent, to: Percent): Percent {\r\n\treturn new Percent(getProgressNumber(progress, from.percent, to.percent));\r\n}\r\n\r\n/**\r\n * Returns color value accoring to progress between start and end values.\r\n *\r\n * @param progress  Progress (0-1)\r\n * @param from\r\n * @param to\r\n * @return Color according to progress\r\n */\r\nfunction getProgressColor(progress: number, from: Color, to: Color): Color {\r\n\tconst color = new Color($colors.interpolate(from.rgb, to.rgb, progress));\r\n\tif (from.alpha != to.alpha) {\r\n\t\tcolor.alpha = from.alpha + (to.alpha - from.alpha) * progress;\r\n\t}\r\n\treturn color;\r\n}\r\n\r\n/**\r\n * [getHybridProperty description]\r\n *\r\n * @todo Description\r\n * @param property [description]\r\n * @param type [description]\r\n * @return [description]\r\n */\r\nfunction getHybridProperty(property: string, type: \"pixel\" | \"relative\"): string {\r\n\treturn type + property.charAt(0).toUpperCase() + property.substr(1);\r\n}\r\n\r\n\r\nexport class AnimationDisposer implements IDisposer {\r\n\tprivate _disposer: Disposer;\r\n\r\n\tconstructor(array: Array<Animation>) {\r\n\t\tthis._disposer = new Disposer(() => {\r\n\t\t\twhile (array.length !== 0) {\r\n\t\t\t\tarray[0].dispose();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tisDisposed(): boolean {\r\n\t\treturn this._disposer.isDisposed();\r\n\t}\r\n\r\n\tdispose(): void {\r\n\t\tthis._disposer.dispose();\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Animation can be used to transition certain properties on an object that\r\n * implements [[IAnimatable]] interface.\r\n *\r\n * @see {@link IAnimationEvents} for a list of available events\r\n */\r\nexport class Animation extends BaseObjectEvents implements IAnimationObject {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IAnimationEvents;\r\n\r\n\t/**\r\n\t * An animation target object. [[Animation]] will update properties of\r\n\t * this object.\r\n\t */\r\n\tpublic object: IAnimatable;\r\n\r\n\t/**\r\n\t * An array of animation option objects. Each animation object represent\r\n\t * one property. Animation can animate any number of properties\r\n\t * simultaneously.\r\n\t */\r\n\tpublic animationOptions: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Duration of the animation in milliseconds.\r\n\t */\r\n\tpublic duration: number = 0;\r\n\r\n\t/**\r\n\t * Easing function to use.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t */\r\n\tpublic easing: (value: number) => number = $ease.linear;\r\n\r\n\t/**\r\n\t * Contains progress of the current animation: 0 (start) to 1 (end).\r\n\t */\r\n\tpublic progress: number = 0;\r\n\r\n\t/**\r\n\t * A list of options that cannot be animated. Those will be applied when\r\n\t * Animation ends.\r\n\t */\r\n\tprotected staticOptions!: IAnimationOptions[];\r\n\r\n\t/**\r\n\t * Indicated how many times animation should loop.\r\n\t */\r\n\tprotected _loop: number = 0;\r\n\r\n\t/**\r\n\t * Animation is paused.\r\n\t */\r\n\tprotected _pause: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to timeout for delayed play.\r\n\t */\r\n\tprotected _delayTimeout: IDisposer | null = null;\r\n\r\n\t/**\r\n\t * A timestamp of when animation started playing.\r\n\t */\r\n\tprotected _startTime: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * Elapsed time in currently playing animation.\r\n\t */\r\n\tprotected _time: number = 0;\r\n\r\n\t// TODO verify that this is correct\r\n\tprotected debug(): void { }\r\n\r\n\tprotected _isFinished: boolean = false;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t *\r\n\t * @param object            An object animation should run on\r\n\t * @param animationOptions  One or several (array) of animation options\r\n\t * @param duration          Duration (ms)\r\n\t * @param easing            Easing function\r\n\t */\r\n\tconstructor(object: IAnimatable, animationOptions: IAnimationOptions[] | IAnimationOptions, duration: number, easing?: (value: number) => number) {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"Animation\";\r\n\r\n\t\t// Override duration if animations disabled system-wide\r\n\t\tif (options.animationsEnabled === false) {\r\n\t\t\tduration = 0;\r\n\t\t}\r\n\r\n\t\t// Set parameters\r\n\t\tthis.object = object;\r\n\t\tthis.animationOptions = $array.toArray(animationOptions);\r\n\t\tthis.duration = duration;\r\n\t\tif (easing) {\r\n\t\t\tthis.easing = easing;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\t//this.stopSameAnimations();\r\n\r\n\t\t/*if ($type.hasValue(callback)) {\r\n\t\t\t// TODO don't use .call\r\n\t\t\tthis.events.on(\"animationended\", callback, object);\r\n\t\t}*/\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object, clears up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\t\tthis.pause();\r\n\t}\r\n\r\n\t/**\r\n\t * Delays animation start by X milliseconds.\r\n\t *\r\n\t * @param delay  Delay (ms)\r\n\t * @return Animation\r\n\t */\r\n\tpublic delay(delay: number): Animation {\r\n\t\t//@todo Maybe not use `bind()`\r\n\t\tif (delay > 0) {\r\n\t\t\tthis.pause();\r\n\r\n\t\t\t// This is so that it will get disposed if `this.object` is disposed\r\n\t\t\t// TODO hacky, figure out a better way\r\n\t\t\t$array.move(this.object.animations, this);\r\n\r\n\t\t\tlet id = setTimeout(() => {\r\n\t\t\t\tthis._delayTimeout = null;\r\n\t\t\t\tthis.start();\r\n\t\t\t}, delay);\r\n\r\n\t\t\tthis._delayTimeout = new Disposer(() => {\r\n\t\t\t\tclearTimeout(id);\r\n\t\t\t});\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprivate _start() {\r\n\t\tthis._isFinished = false;\r\n\t\t// Clear delay timeout if there was one\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t// Run check if there are already animations playing on the same properties\r\n\t\t// and stop them - the last animation takes precedence\r\n\t\tthis.stopSameAnimations();\r\n\r\n\t\t// Reset counters\r\n\t\tthis._pause = false;\r\n\r\n\t\t// Register animation\r\n\t\t$array.move(system.animations, this);\r\n\r\n\t\t// Register this animation in object's `animations` list\r\n\t\t$array.move(this.object.animations, this);\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Starts animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic start(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now();\r\n\t\tthis._time = 0;\r\n\t\tthis.staticOptions = [];\r\n\r\n\t\t// Process initial property values\r\n\t\tfor (let i: number = this.animationOptions.length - 1; i >= 0; i--) {\r\n\t\t\tlet options: IAnimationOptions = this.animationOptions[i];\r\n\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.from = options.childObject[options.property];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\toptions.from = (<any>this.object)[options.property];\r\n\r\n\t\t\t\t\tif (!$type.hasValue(options.from)) {\r\n\t\t\t\t\t\toptions.from = (<any>SVGDefaults)[options.property];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/*if (!$type.hasValue(options.from)) {\r\n\t\t\t\t\tthrow Error(\"Could not get initial transition value.\");\r\n\t\t\t\t}*/\r\n\t\t\t}\r\n\r\n\t\t\tif (options.from == options.to) { // || options.to == (<any>this.object)[options.property]){ this is not good, as dataItem.value is set to final at once, and we animate workingValue\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse if (!$type.hasValue(options.from) || (!(options.from instanceof Percent) && (options.to instanceof Percent)) || ((options.from instanceof Percent) && !(options.to instanceof Percent))) {\r\n\t\t\t\t// Initial value is undefined, treat it as static\r\n\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Use different update methods for different value types\r\n\t\t\t\tif ($type.isNumber(<number>options.to)) {\r\n\r\n\t\t\t\t\t// Numeric value\r\n\t\t\t\t\toptions.updateMethod = getProgressNumber;\r\n\r\n\t\t\t\t\t// Check if initial value is not Percent\r\n\t\t\t\t\tif (options.from instanceof Percent) {\r\n\t\t\t\t\t\t// It is. Let's convert it to pixel value\r\n\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"pixel\")];\r\n\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\toptions.from = convertedFrom;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Check if maybe we have a color or percent value\r\n\t\t\t\t\tif (options.to instanceof Color) {\r\n\t\t\t\t\t\t// Yup - set resolved named color\r\n\t\t\t\t\t\t//options.from = $colors.stringToColor(<string>options.from);\r\n\t\t\t\t\t\tif (options.from) {\r\n\t\t\t\t\t\t\toptions.updateMethod = getProgressColor;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (options.to instanceof Percent) {\r\n\t\t\t\t\t\t// Percent\r\n\t\t\t\t\t\toptions.updateMethod = getProgressPercent;\r\n\r\n\t\t\t\t\t\t// Check if the initial value is maybe in pixels\r\n\t\t\t\t\t\tif (!isNaN(<number>options.from)) {\r\n\t\t\t\t\t\t\t// It is. Let's convert it\r\n\t\t\t\t\t\t\t// @todo Check if we can do this in a less hacky way\r\n\t\t\t\t\t\t\tlet convertedFrom: number = (<any>this.object)[getHybridProperty(options.property, \"relative\")];\r\n\t\t\t\t\t\t\tif (!isNaN(convertedFrom)) {\r\n\t\t\t\t\t\t\t\toptions.from = percent(convertedFrom * 100);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\t// Static value\r\n\t\t\t\t\t\tthis.staticOptions.push(options);\r\n\t\t\t\t\t\t$array.remove(this.animationOptions, options);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Apply static options (just in case they were reset by previous\r\n\t\t// animation loop)\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationstarted\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstarted\"] = {\r\n\t\t\t\ttype: \"animationstarted\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationstarted\", event);\r\n\t\t}\r\n\r\n\t\tthis.update();\r\n\r\n\t\t// If duration is 0, just end animation\r\n\t\tif (this.duration === 0) {\r\n\t\t\tthis.end();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets loop count for the animation. If parameter is not a valid number the\r\n\t * animation will keep on looping indefinitely.\r\n\t *\r\n\t * @param count  Number of times to loop animation\r\n\t * @return Animation\r\n\t */\r\n\tpublic loop(count?: number): Animation {\r\n\t\tif (!$type.isNumber(count)) {\r\n\t\t\tcount = Infinity;\r\n\t\t}\r\n\t\tthis._loop = count;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Pauses animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic pause(): Animation {\r\n\t\tthis._pause = true;\r\n\r\n\t\tif (this._delayTimeout) {\r\n\t\t\tthis.removeDispose(this._delayTimeout);\r\n\t\t\tthis._delayTimeout = null;\r\n\t\t}\r\n\r\n\t\t$array.remove(system.animations, this);\r\n\t\t$array.remove(this.object.animations, this);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Resumes paused animation.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic resume(): Animation {\r\n\t\tthis._start();\r\n\t\tthis._startTime = Date.now() - this._time;\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Jumps to animation end. If animation is set to loop, this will start\r\n\t * another round of animation from start.\r\n\t *\r\n\t * @return Animation\r\n\t */\r\n\tpublic end(): Animation {\r\n\r\n\t\t// Pause and complete the progress\r\n\t\tif (this._loop == 0) {\r\n\t\t\tthis.pause();\r\n\t\t}\r\n\t\tthis.setProgress(1);\r\n\r\n\t\t// Apply static options\r\n\t\tthis.applyStaticOptions();\r\n\r\n\t\tif (this.events.isEnabled(\"animationended\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationended\"] = {\r\n\t\t\t\ttype: \"animationended\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationended\", event);\r\n\t\t}\r\n\r\n\t\t// Check if we should loop\r\n\t\tif (this._loop > 0) {\r\n\t\t\tthis._loop--;\r\n\t\t\tthis.start();\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.stop();\r\n\t\t\tthis._isFinished = true;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation immediately leaving properties in their current values.\r\n\t */\r\n\tpublic kill() {\r\n\t\tthis.pause();\r\n\t\tthis._isFinished = true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns indicator if this animation is finished or not\r\n\t *\r\n\t * @return Is finished?\r\n\t */\r\n\tpublic isFinished(): boolean {\r\n\t\treturn this._isFinished;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies static options that can't be animated.\r\n\t */\r\n\tprotected applyStaticOptions(): void {\r\n\t\t$array.each(this.staticOptions, (options) => {\r\n\t\t\tif (options.childObject) {\r\n\t\t\t\toptions.childObject[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t(<any>this.object)[options.property] = this.progress == 1 ? options.to : options.from;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Stops animation.\r\n\t *\r\n\t * When animation is stopped, the properties of the target object will remain\r\n\t * where they were at the moment when `stop()` was called.\r\n\t *\r\n\t * @param skipEvent  Do not trigger `animationstopped` event\r\n\t * @return Animation\r\n\t */\r\n\tpublic stop(skipEvent?: boolean): Animation {\r\n\t\tthis.pause();\r\n\t\tif (!skipEvent) {\r\n\t\t\tif (this.events.isEnabled(\"animationstopped\")) {\r\n\t\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationstopped\"] = {\r\n\t\t\t\t\ttype: \"animationstopped\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tprogress: this.progress\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"animationstopped\", event);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets current progress and updates object's numeric and color values.\r\n\t *\r\n\t * @param progress Progress (0-1)\r\n\t */\r\n\tpublic setProgress(progress: number): void {\r\n\t\tthis._time = this.duration * progress; // just in case we call this from outside\r\n\t\t$array.each(this.animationOptions, (options) => {\r\n\t\t\tif (options.updateMethod && $type.hasValue(options.from)) {\r\n\t\t\t\tlet value = options.updateMethod(progress, options.from, options.to);\r\n\r\n\t\t\t\tif (options.childObject) {\r\n\t\t\t\t\toptions.childObject[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t(<any>this.object)[options.property] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tthis.progress = progress;\r\n\t\tif (this.events.isEnabled(\"animationprogress\")) {\r\n\t\t\tconst event: AMEvent<this, IAnimationEvents>[\"animationprogress\"] = {\r\n\t\t\t\ttype: \"animationprogress\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tprogress: this.progress\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"animationprogress\", event);\r\n\t\t}\r\n\r\n\t\tsystem.requestFrame();\r\n\t}\r\n\r\n\t/**\r\n\t * Tracks and sets progress according to time or frames.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @return Animation\r\n\t */\r\n\tpublic update(): Animation {\r\n\t\tif (!this._pause) {\r\n\r\n\t\t\tlet progress;\r\n\t\t\tthis._time = $math.fitToRange(Date.now() - this._startTime!, 0, this.duration);\r\n\t\t\tlet timeProgress = this._time / this.duration;\r\n\t\t\tprogress = this.easing(timeProgress);\r\n\t\t\tif (this.duration == 0 || !$type.isNumber(progress) || timeProgress >= 1) {\r\n\t\t\t\tprogress = 1;\r\n\t\t\t}\r\n\r\n\t\t\tthis.setProgress(progress);\r\n\r\n\t\t\tif ($math.round(this._time / this.duration, 6) == 1) {\r\n\t\t\t\tthis.end();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if this animation is delayed.\r\n\t *\r\n\t * @readonly\r\n\t * @return [description]\r\n\t */\r\n\tpublic get delayed(): boolean {\r\n\t\treturn this._delayTimeout ? true : false;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks other animations currently running on the same object and removes\r\n\t * overlapping options from those other animations that are contained in\r\n\t * this animation.\r\n\t *\r\n\t * This is needed to ensure that no two confurent animations step on each\r\n\t * other's toes by trying to animate the same property.\r\n\t */\r\n\tprivate stopSameAnimations(): void {\r\n\t\t// stop animation of the same property\r\n\t\t// TODO make this more efficient\r\n\t\t// TODO don't copy the array\r\n\t\t$array.each($array.copy(this.object.animations), (animation) => {\r\n\t\t\tif (animation !== this && !animation.delayed) {\r\n\t\t\t\tconst killed: Array<IAnimationOptions> = [];\r\n\r\n\t\t\t\t$array.each(this.animationOptions, (newOptions) => {\r\n\t\t\t\t\t$array.each(animation.animationOptions, (oldOptions) => {\r\n\t\t\t\t\t\tif (newOptions.property == oldOptions.property && newOptions.childObject == oldOptions.childObject) {\r\n\t\t\t\t\t\t\tkilled.push(oldOptions);\r\n\r\n\t\t\t\t\t\t\tif (animation.animationOptions.length == 0) {\r\n\t\t\t\t\t\t\t\tanimation.kill();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\t$array.each(killed, (oldOptions) => {\r\n\t\t\t\t\t$array.remove(animation.animationOptions, oldOptions);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Adds easing functions to \"function\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as function?\r\n\t */\r\n\tprotected asFunction(field: string): boolean {\r\n\t\treturn field == \"easing\" || super.asIs(field);\r\n\t}\r\n\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}