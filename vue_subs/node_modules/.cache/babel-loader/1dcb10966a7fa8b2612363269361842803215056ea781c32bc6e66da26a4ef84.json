{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\n/**\r\n * HeatLegend module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Container } from \"../../core/Container\";\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\nimport { registry } from \"../../core/Registry\";\nimport { toColor, Color } from \"../../core/utils/Color\";\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\nimport { percent } from \"../../core/utils/Percent\";\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\nimport * as $iter from \"../../core/utils/Iterator\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $colors from \"../../core/utils/Colors\";\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\nvar HeatLegend = /** @class */function (_super) {\n  __extends(HeatLegend, _super);\n  /**\r\n   * Constructor\r\n   */\n  function HeatLegend() {\n    var _this = _super.call(this) || this;\n    _this.className = \"HeatLegend\";\n    _this.markerContainer = _this.createChild(Container);\n    _this.markerContainer.shouldClone = false;\n    _this.markerCount = 1;\n    // Create a template container and list for the a marker\n    var marker = new RoundedRectangle();\n    marker.minHeight = 20;\n    marker.minWidth = 20;\n    marker.interactionsEnabled = false;\n    marker.fillOpacity = 1;\n    marker.cornerRadius(0, 0, 0, 0);\n    _this.markerContainer.minHeight = 20;\n    _this.markerContainer.minWidth = 20;\n    _this.orientation = \"horizontal\";\n    _this.markers = new ListTemplate(marker);\n    _this._disposers.push(new ListDisposer(_this.markers));\n    _this._disposers.push(_this.markers.template);\n    _this.applyTheme();\n    return _this;\n  }\n  HeatLegend.prototype.getMinFromRules = function (property) {\n    var series = this.series;\n    if (series) {\n      var minValue_1;\n      $iter.eachContinue(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          minValue_1 = heatRule.min;\n          return false;\n        }\n        return true;\n      });\n      return minValue_1;\n    }\n  };\n  HeatLegend.prototype.getMaxFromRules = function (property) {\n    var series = this.series;\n    if (series) {\n      var maxValue_1;\n      $iter.each(series.heatRules.iterator(), function (heatRule) {\n        if (heatRule.property == property) {\n          maxValue_1 = heatRule.max;\n          return false;\n        }\n        return true;\n      });\n      return maxValue_1;\n    }\n  };\n  /**\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  HeatLegend.prototype.validate = function () {\n    _super.prototype.validate.call(this);\n    this.valueAxis.renderer.inversed = this.reverseOrder;\n    var series = this.series;\n    var minColor = this.minColor;\n    var maxColor = this.maxColor;\n    if (!$type.hasValue(minColor)) {\n      minColor = toColor(this.getMinFromRules(\"fill\"));\n    }\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n    if (series) {\n      var seriesFill = series.fill;\n      if (!$type.hasValue(minColor) && seriesFill instanceof Color) {\n        minColor = seriesFill;\n      }\n      if (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\n        maxColor = seriesFill;\n      }\n    }\n    if (!$type.hasValue(maxColor)) {\n      maxColor = toColor(this.getMaxFromRules(\"fill\"));\n    }\n    var minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\n    if (!$type.isNumber(minOpacity)) {\n      minOpacity = 1;\n    }\n    var maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\n    if (!$type.isNumber(maxOpacity)) {\n      maxOpacity = 1;\n    }\n    var minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\n    if (!$type.isNumber(minStrokeOpacity)) {\n      minStrokeOpacity = 1;\n    }\n    var maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\n    if (!$type.isNumber(maxStrokeOpacity)) {\n      maxStrokeOpacity = 1;\n    }\n    var minStroke = toColor(this.getMinFromRules(\"stroke\"));\n    var maxStroke = toColor(this.getMaxFromRules(\"stroke\"));\n    //if (series) {\n    for (var i = 0; i < this.markerCount; i++) {\n      var marker = this.markers.getIndex(i);\n      if (!marker) {\n        marker = this.markers.create();\n        marker.parent = this.markerContainer;\n        marker.height = percent(100);\n        marker.width = percent(100);\n      }\n      if (this.markerCount == 1) {\n        var gradient = new LinearGradient();\n        if (this.reverseOrder) {\n          gradient.addColor(maxColor, maxOpacity);\n          gradient.addColor(minColor, minOpacity);\n        } else {\n          gradient.addColor(minColor, minOpacity);\n          gradient.addColor(maxColor, maxOpacity);\n        }\n        if (this.orientation == \"vertical\") {\n          gradient.rotation = -90;\n        }\n        marker.fill = gradient;\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var strokeGradient = new LinearGradient();\n          if (this.reverseOrder) {\n            strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n            strokeGradient.addColor(minStroke, minStrokeOpacity);\n          } else {\n            strokeGradient.addColor(minStroke, minStrokeOpacity);\n            strokeGradient.addColor(maxStroke, maxStrokeOpacity);\n          }\n          if (this.orientation == \"vertical\") {\n            strokeGradient.rotation = -90;\n          }\n          marker.stroke = strokeGradient;\n        }\n      } else {\n        var c = i;\n        if (this.reverseOrder) {\n          c = this.markerCount - i - 1;\n        }\n        var color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));\n        marker.fill = color;\n        var opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;\n        marker.fillOpacity = opacity;\n        if ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\n          var color_1 = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));\n          marker.stroke = color_1;\n          var opacity_1 = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;\n          marker.strokeOpacity = opacity_1;\n        }\n      }\n    }\n    var renderer = this.valueAxis.renderer;\n    if (this.markerCount > 1) {\n      if (this.orientation == \"horizontal\") {\n        renderer.minGridDistance = this.measuredWidth / this.markerCount;\n      } else {\n        renderer.minGridDistance = this.measuredHeight / this.markerCount;\n      }\n    }\n    this.valueAxis.invalidate();\n    for (var i = this.markerCount, len = this.markers.length; i < len; i++) {\n      this.markers.getIndex(i).parent = undefined;\n    }\n  };\n  Object.defineProperty(HeatLegend.prototype, \"minColor\", {\n    /**\r\n     * Returns minColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minColor\");\n    },\n    /**\r\n     * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n      this.setColorProperty(\"minColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxColor\", {\n    /**\r\n     * Returns maxColor value\r\n     * @return {Color}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxColor\");\n    },\n    /**\r\n     * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n     *\r\n     * @param {Color}\r\n     */\n    set: function (value) {\n      if (!(value instanceof Color)) {\n        value = toColor(value);\n      }\n      this.setColorProperty(\"maxColor\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"markerCount\", {\n    /**\r\n     * Returns number of color squares (markers).\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"markerCount\");\n    },\n    /**\r\n     * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"markerCount\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"minValue\", {\n    /**\r\n     * Returns minimum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"minValue\");\n    },\n    /**\r\n     * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"minValue\", value);\n      this.valueAxis.min = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"maxValue\", {\n    /**\r\n     * Returns maximum value of heat legend.\r\n     * @return {number}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"maxValue\");\n    },\n    /**\r\n     * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n     *\r\n     * @param {number}\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"maxValue\", value);\n      this.valueAxis.max = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"orientation\", {\n    /**\r\n     * Returns orientation value.\r\n     *\r\n     * @return {\"horizontal\" | \"vertical\"}\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"orientation\");\n    },\n    /**\r\n    * Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n    *\r\n    * @param {\"horizontal\" | \"vertical\"}\r\n    */\n    set: function (value) {\n      this.setPropertyValue(\"orientation\", value, true);\n      var markerContainer = this.markerContainer;\n      var valueAxis = this.valueAxis;\n      // HORIZONTAL\n      if (value == \"horizontal\") {\n        if (!$type.hasValue(this.width)) {\n          this.width = 200;\n        }\n        this.height = undefined;\n        valueAxis.width = percent(100);\n        valueAxis.height = undefined;\n        valueAxis.tooltip.pointerOrientation = \"vertical\";\n        this.layout = \"vertical\";\n        markerContainer.width = percent(100);\n        markerContainer.height = undefined;\n        if (!(valueAxis.renderer instanceof AxisRendererX)) {\n          valueAxis.renderer = new AxisRendererX();\n        }\n      }\n      // VERTICAL\n      else {\n        if (!$type.hasValue(this.height)) {\n          this.height = 200;\n        }\n        this.width = undefined;\n        this.layout = \"horizontal\";\n        markerContainer.width = undefined;\n        markerContainer.height = percent(100);\n        valueAxis.height = percent(100);\n        valueAxis.width = undefined;\n        valueAxis.tooltip.pointerOrientation = \"horizontal\";\n        if (!(valueAxis.renderer instanceof AxisRendererY)) {\n          valueAxis.renderer = new AxisRendererY();\n        }\n        valueAxis.renderer.inside = true;\n        valueAxis.renderer.labels.template.inside = true;\n        this.markerContainer.reverseOrder = true;\n      }\n      var renderer = valueAxis.renderer;\n      renderer.grid.template.disabled = true;\n      renderer.axisFills.template.disabled = true;\n      renderer.baseGrid.disabled = true;\n      renderer.labels.template.padding(2, 3, 2, 3);\n      renderer.minHeight = undefined;\n      renderer.minWidth = undefined;\n      this.markerContainer.layout = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"valueAxis\", {\n    /**\r\n     * Returns valueAxis value.\r\n     * @return {ValueAxis}\r\n     */\n    get: function () {\n      if (!this._valueAxis) {\n        this.valueAxis = this.createChild(ValueAxis);\n        this.valueAxis.shouldClone = false;\n      }\n      return this._valueAxis;\n    },\n    /**\r\n     * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n     * @param {ValueAxis}\r\n     */\n    set: function (valueAxis) {\n      this._valueAxis = valueAxis;\n      valueAxis.parent = this;\n      valueAxis.strictMinMax = true;\n      this.orientation = this.orientation;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HeatLegend.prototype, \"series\", {\n    /**\r\n     * Returns series value.\r\n     * @return {Series}\r\n     */\n    get: function () {\n      return this._series;\n    },\n    /**\r\n     * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n     * @param series\r\n     */\n    set: function (series) {\n      var _this = this;\n      this._series = series;\n      var dataField = \"value\";\n      try {\n        var dataFieldDefined = series.heatRules.getIndex(0).dataField;\n        if (dataFieldDefined) {\n          dataField = dataFieldDefined;\n        }\n      } catch (err) {}\n      this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      series.dataItem.events.on(\"calculatedvaluechanged\", function (event) {\n        _this.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\n      }, undefined, false);\n      series.heatRules.events.on(\"inserted\", this.invalidate, this, false);\n      series.heatRules.events.on(\"removed\", this.invalidate, this, false);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates min/max of value axis.\r\n   * @ignore\r\n   */\n  HeatLegend.prototype.updateMinMax = function (min, max) {\n    var valueAxis = this.valueAxis;\n    if (!$type.isNumber(this.minValue)) {\n      valueAxis.min = min;\n      valueAxis.invalidate();\n    }\n    if (!$type.isNumber(this.maxValue)) {\n      valueAxis.max = max;\n      valueAxis.invalidate();\n    }\n  };\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n  HeatLegend.prototype.processConfig = function (config) {\n    if (config) {\n      // Set up series\n      if ($type.hasValue(config.series) && $type.isString(config.series)) {\n        if ($type.isString(config.series)) {\n          if (this.map.hasKey(config.series)) {\n            config.series = this.map.getKey(config.series);\n          } else {\n            var seriesId_1 = config.series;\n            var disposer_1 = this.map.events.on(\"insertKey\", function (ev) {\n              if (ev.key == seriesId_1) {\n                this.series = ev.newValue;\n                disposer_1.dispose();\n              }\n            }, this);\n            this._disposers.push(disposer_1);\n            delete config.series;\n          }\n        }\n      }\n    }\n    _super.prototype.processConfig.call(this, config);\n  };\n  return HeatLegend;\n}(Container);\nexport { HeatLegend };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;","map":{"version":3,"names":["Container","LinearGradient","registry","toColor","Color","ListTemplate","ListDisposer","percent","ValueAxis","AxisRendererX","AxisRendererY","$iter","$type","$colors","RoundedRectangle","HeatLegend","_super","__extends","_this","call","className","markerContainer","createChild","shouldClone","markerCount","marker","minHeight","minWidth","interactionsEnabled","fillOpacity","cornerRadius","orientation","markers","_disposers","push","template","applyTheme","prototype","getMinFromRules","property","series","minValue_1","eachContinue","heatRules","iterator","heatRule","min","getMaxFromRules","maxValue_1","each","max","validate","valueAxis","renderer","inversed","reverseOrder","minColor","maxColor","hasValue","seriesFill","fill","minOpacity","toNumber","isNumber","maxOpacity","minStrokeOpacity","maxStrokeOpacity","minStroke","maxStroke","i","getIndex","create","parent","height","width","gradient","addColor","rotation","strokeGradient","stroke","c","color","interpolate","rgb","opacity","color_1","opacity_1","strokeOpacity","minGridDistance","measuredWidth","measuredHeight","invalidate","len","length","undefined","Object","defineProperty","get","getPropertyValue","set","value","setColorProperty","setPropertyValue","tooltip","pointerOrientation","layout","inside","labels","grid","disabled","axisFills","baseGrid","padding","_valueAxis","strictMinMax","_series","dataField","dataFieldDefined","err","updateMinMax","dataItem","values","low","high","events","on","event","minValue","maxValue","processConfig","config","isString","map","hasKey","getKey","seriesId_1","disposer_1","ev","key","newValue","dispose","registeredClasses"],"sources":["../../../../../src/.internal/charts/elements/HeatLegend.ts"],"sourcesContent":["/**\r\n * HeatLegend module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Container, IContainerProperties, IContainerEvents, IContainerAdapters } from \"../../core/Container\";\r\nimport { Series } from \"../series/Series\";\r\nimport { LinearGradient } from \"../../core/rendering/fills/LinearGradient\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport { toColor, Color } from \"../../core/utils/Color\";\r\nimport { ListTemplate, ListDisposer } from \"../../core/utils/List\";\r\nimport { percent } from \"../../core/utils/Percent\";\r\nimport { ValueAxis } from \"../../charts/axes/ValueAxis\";\r\nimport { AxisRendererX } from \"../../charts/axes/AxisRendererX\";\r\nimport { AxisRendererY } from \"../../charts/axes/AxisRendererY\";\r\nimport * as $iter from \"../../core/utils/Iterator\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $colors from \"../../core/utils/Colors\";\r\nimport { RoundedRectangle } from \"../../core/elements/RoundedRectangle\";\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[HeatLegend]].\r\n */\r\nexport interface IHeatLegendProperties extends IContainerProperties {\r\n\r\n\t/**\r\n\t * Minimum color\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tminColor?: Color;\r\n\r\n\t/**\r\n\t * Minimum value\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tminValue?: number;\r\n\r\n\t/**\r\n\t * Maximum value\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tmaxValue?: number;\r\n\r\n\r\n\t/**\r\n\t * Maximum color\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tmaxColor?: Color;\r\n\r\n\t/**\r\n\t * Number of markers (steps)\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tmarkerCount?: number;\r\n\r\n\r\n\t/**\r\n\t * Orientation\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\torientation?: \"horizontal\" | \"vertical\";\r\n\r\n}\r\n\r\n/**\r\n * Defines events for [[HeatLegend]].\r\n */\r\nexport interface IHeatLegendEvents extends IContainerEvents { }\r\n\r\n/**\r\n * Defines adapters for [[HeatLegend]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IHeatLegendAdapters extends IContainerAdapters, IHeatLegendProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * This class creates a link (waved color-filled line) between two nodes in a\r\n * Sankey Diagram.\r\n *\r\n * @see {@link IHeatLegendEvents} for a list of available events\r\n * @see {@link IHeatLegendAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class HeatLegend extends Container {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IHeatLegendProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IHeatLegendAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IHeatLegendEvents;\r\n\r\n\t/**\r\n\t * List of heat legend markers (color step rectangles).\r\n\t */\r\n\tpublic markers: ListTemplate<RoundedRectangle>;\r\n\r\n\t/**\r\n\t * Container which holds markers\r\n\t */\r\n\tpublic markerContainer: Container;\r\n\r\n\t/**\r\n\t * Value axis of a heat legend\r\n\t * @ignore\r\n\t */\r\n\tprotected _valueAxis: ValueAxis;\r\n\r\n\t/**\r\n\t * Series of a heat legend\r\n\t * @ignore\r\n\t */\r\n\tprotected _series: Series;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"HeatLegend\";\r\n\r\n\t\tthis.markerContainer = this.createChild(Container);\r\n\t\tthis.markerContainer.shouldClone = false;\r\n\r\n\t\tthis.markerCount = 1;\r\n\r\n\t\t// Create a template container and list for the a marker\r\n\t\tlet marker: RoundedRectangle = new RoundedRectangle();\r\n\t\tmarker.minHeight = 20;\r\n\t\tmarker.minWidth = 20;\r\n\t\tmarker.interactionsEnabled = false;\r\n\t\tmarker.fillOpacity = 1;\r\n\t\tmarker.cornerRadius(0, 0, 0, 0);\r\n\r\n\t\tthis.markerContainer.minHeight = 20;\r\n\t\tthis.markerContainer.minWidth = 20;\r\n\r\n\t\tthis.orientation = \"horizontal\";\r\n\r\n\t\tthis.markers = new ListTemplate<RoundedRectangle>(marker);\r\n\t\tthis._disposers.push(new ListDisposer(this.markers));\r\n\t\tthis._disposers.push(this.markers.template);\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\r\n\tprotected getMinFromRules(property: string, ) {\r\n\t\tlet series = this.series;\r\n\t\tif (series) {\r\n\t\t\tlet minValue;\r\n\t\t\t$iter.eachContinue(series.heatRules.iterator(), (heatRule) => {\r\n\t\t\t\tif (heatRule.property == property) {\r\n\t\t\t\t\tminValue = heatRule.min;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t})\r\n\t\t\treturn minValue;\r\n\t\t}\r\n\t}\r\n\r\n\tprotected getMaxFromRules(property: string, ) {\r\n\t\tlet series = this.series;\r\n\t\tif (series) {\r\n\t\t\tlet maxValue;\r\n\t\t\t$iter.each(series.heatRules.iterator(), (heatRule) => {\r\n\t\t\t\tif (heatRule.property == property) {\r\n\t\t\t\t\tmaxValue = heatRule.max;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t});\r\n\t\t\treturn maxValue;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate() {\r\n\t\tsuper.validate();\r\n\r\n\t\tthis.valueAxis.renderer.inversed = this.reverseOrder;\r\n\r\n\t\tlet series = this.series;\r\n\r\n\t\tlet minColor = this.minColor;\r\n\t\tlet maxColor = this.maxColor;\r\n\r\n\t\tif (!$type.hasValue(minColor)) {\r\n\t\t\tminColor = toColor(this.getMinFromRules(\"fill\"));\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(maxColor)) {\r\n\t\t\tmaxColor = toColor(this.getMaxFromRules(\"fill\"));\r\n\t\t}\r\n\r\n\t\tif (series) {\r\n\t\t\tlet seriesFill = series.fill;\r\n\t\t\tif (!$type.hasValue(minColor) && seriesFill instanceof Color) {\r\n\t\t\t\tminColor = seriesFill;\r\n\t\t\t}\r\n\t\t\tif (!$type.hasValue(maxColor) && seriesFill instanceof Color) {\r\n\t\t\t\tmaxColor = seriesFill;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(maxColor)) {\r\n\t\t\tmaxColor = toColor(this.getMaxFromRules(\"fill\"));\r\n\t\t}\r\n\r\n\t\tlet minOpacity = $type.toNumber(this.getMinFromRules(\"fillOpacity\"));\r\n\t\tif (!$type.isNumber(minOpacity)) {\r\n\t\t\tminOpacity = 1;\r\n\t\t}\r\n\t\tlet maxOpacity = $type.toNumber(this.getMaxFromRules(\"fillOpacity\"));\r\n\t\tif (!$type.isNumber(maxOpacity)) {\r\n\t\t\tmaxOpacity = 1;\r\n\t\t}\r\n\r\n\r\n\t\tlet minStrokeOpacity = $type.toNumber(this.getMinFromRules(\"strokeOpacity\"));\r\n\t\tif (!$type.isNumber(minStrokeOpacity)) {\r\n\t\t\tminStrokeOpacity = 1;\r\n\t\t}\r\n\t\tlet maxStrokeOpacity = $type.toNumber(this.getMaxFromRules(\"strokeOpacity\"));\r\n\t\tif (!$type.isNumber(maxStrokeOpacity)) {\r\n\t\t\tmaxStrokeOpacity = 1;\r\n\t\t}\r\n\r\n\t\tlet minStroke = toColor(this.getMinFromRules(\"stroke\"));\r\n\t\tlet maxStroke = toColor(this.getMaxFromRules(\"stroke\"));\r\n\r\n\r\n\t\t//if (series) {\r\n\t\tfor (let i = 0; i < this.markerCount; i++) {\r\n\t\t\tlet marker = this.markers.getIndex(i);\r\n\r\n\t\t\tif (!marker) {\r\n\t\t\t\tmarker = this.markers.create();\r\n\t\t\t\tmarker.parent = this.markerContainer;\r\n\t\t\t\tmarker.height = percent(100);\r\n\t\t\t\tmarker.width = percent(100);\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif (this.markerCount == 1) {\r\n\t\t\t\tlet gradient = new LinearGradient();\r\n\t\t\t\tif (this.reverseOrder) {\r\n\t\t\t\t\tgradient.addColor(maxColor, maxOpacity);\r\n\t\t\t\t\tgradient.addColor(minColor, minOpacity);\r\n\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tgradient.addColor(minColor, minOpacity);\r\n\t\t\t\t\tgradient.addColor(maxColor, maxOpacity);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif (this.orientation == \"vertical\") {\r\n\t\t\t\t\tgradient.rotation = -90;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmarker.fill = gradient;\r\n\t\t\t\tif ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\r\n\t\t\t\t\tlet strokeGradient = new LinearGradient();\r\n\t\t\t\t\tif (this.reverseOrder) {\r\n\t\t\t\t\t\tstrokeGradient.addColor(maxStroke, maxStrokeOpacity);\r\n\t\t\t\t\t\tstrokeGradient.addColor(minStroke, minStrokeOpacity);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tstrokeGradient.addColor(minStroke, minStrokeOpacity);\r\n\t\t\t\t\t\tstrokeGradient.addColor(maxStroke, maxStrokeOpacity);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this.orientation == \"vertical\") {\r\n\t\t\t\t\t\tstrokeGradient.rotation = -90;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmarker.stroke = strokeGradient;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet c = i;\r\n\t\t\t\tif (this.reverseOrder) {\r\n\t\t\t\t\tc = this.markerCount - i - 1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet color = new Color($colors.interpolate(minColor.rgb, maxColor.rgb, c / this.markerCount));\r\n\t\t\t\tmarker.fill = color;\r\n\r\n\t\t\t\tlet opacity = minOpacity + (maxOpacity - minOpacity) * c / this.markerCount;\r\n\t\t\t\tmarker.fillOpacity = opacity;\r\n\r\n\t\t\t\tif ($type.hasValue(minStroke) && $type.hasValue(maxStroke)) {\r\n\t\t\t\t\tlet color = new Color($colors.interpolate(minStroke.rgb, maxStroke.rgb, c / this.markerCount));\r\n\t\t\t\t\tmarker.stroke = color;\r\n\r\n\t\t\t\t\tlet opacity = minStrokeOpacity + (maxStrokeOpacity - minStrokeOpacity) * c / this.markerCount;\r\n\t\t\t\t\tmarker.strokeOpacity = opacity;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet renderer = this.valueAxis.renderer;\r\n\t\tif (this.markerCount > 1) {\r\n\t\t\tif (this.orientation == \"horizontal\") {\r\n\t\t\t\trenderer.minGridDistance = this.measuredWidth / this.markerCount;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\trenderer.minGridDistance = this.measuredHeight / this.markerCount;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.valueAxis.invalidate();\r\n\r\n\t\tfor (let i = this.markerCount, len = this.markers.length; i < len; i++) {\r\n\t\t\tthis.markers.getIndex(i).parent = undefined;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Min color of a heat legend. If a series is set for the legend, minColor is taken from series.\r\n\t *\r\n\t * @param {Color}\r\n\t */\r\n\tpublic set minColor(value: Color) {\r\n\r\n\t\tif (!(value instanceof Color)) {\r\n\t\t\tvalue = toColor(value);\r\n\t\t}\r\n\r\n\t\tthis.setColorProperty(\"minColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns minColor value\r\n\t * @return {Color}\r\n\t */\r\n\tpublic get minColor(): Color {\r\n\t\treturn this.getPropertyValue(\"minColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * Max color of a heat legend. If a series is set for the legend, maxColor is taken from series.\r\n\t *\r\n\t * @param {Color}\r\n\t */\r\n\tpublic set maxColor(value: Color) {\r\n\r\n\t\tif (!(value instanceof Color)) {\r\n\t\t\tvalue = toColor(value);\r\n\t\t}\r\n\r\n\t\tthis.setColorProperty(\"maxColor\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns maxColor value\r\n\t * @return {Color}\r\n\t */\r\n\tpublic get maxColor(): Color {\r\n\t\treturn this.getPropertyValue(\"maxColor\");\r\n\t}\r\n\r\n\t/**\r\n\t * Number of color squares (markers) in the heat legend. If only 1 marker is used, it will be filled with gradient.\r\n\t *\r\n\t * @param {number}\r\n\t */\r\n\tpublic set markerCount(value: number) {\r\n\t\tthis.setPropertyValue(\"markerCount\", value, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns number of color squares (markers).\r\n\t * @return {number}\r\n\t */\r\n\tpublic get markerCount(): number {\r\n\t\treturn this.getPropertyValue(\"markerCount\");\r\n\t}\r\n\r\n\t/**\r\n\t * Minimum value of heat legend's value axis. If a series is set for the legend, min is taken from series.\r\n\t *\r\n\t * @param {number}\r\n\t */\r\n\tpublic set minValue(value: number) {\r\n\t\tthis.setPropertyValue(\"minValue\", value);\r\n\t\tthis.valueAxis.min = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns minimum value of heat legend.\r\n\t * @return {number}\r\n\t */\r\n\tpublic get minValue(): number {\r\n\t\treturn this.getPropertyValue(\"minValue\");\r\n\t}\r\n\r\n\t/**\r\n\t * Maximum value of heat legend's value axis. If a series is set for the legend, max is taken from series.\r\n\t *\r\n\t * @param {number}\r\n\t */\r\n\tpublic set maxValue(value: number) {\r\n\t\tthis.setPropertyValue(\"maxValue\", value);\r\n\t\tthis.valueAxis.max = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns maximum value of heat legend.\r\n\t * @return {number}\r\n\t */\r\n\tpublic get maxValue(): number {\r\n\t\treturn this.getPropertyValue(\"maxValue\");\r\n\t}\r\n\r\n\t/**\r\n\t* Heat legend orientation. Note, if you change orientation of a heat legend, you must set value axis renderer properties after that, as with orientation renderer changes.\r\n\t*\r\n\t* @param {\"horizontal\" | \"vertical\"}\r\n\t*/\r\n\tpublic set orientation(value: \"horizontal\" | \"vertical\") {\r\n\t\tthis.setPropertyValue(\"orientation\", value, true);\r\n\t\tlet markerContainer = this.markerContainer;\r\n\t\tlet valueAxis = this.valueAxis;\r\n\r\n\t\t// HORIZONTAL\r\n\t\tif (value == \"horizontal\") {\r\n\t\t\tif (!$type.hasValue(this.width)) {\r\n\t\t\t\tthis.width = 200;\r\n\t\t\t}\r\n\t\t\tthis.height = undefined;\r\n\r\n\t\t\tvalueAxis.width = percent(100);\r\n\t\t\tvalueAxis.height = undefined;\r\n\t\t\tvalueAxis.tooltip.pointerOrientation = \"vertical\";\r\n\r\n\t\t\tthis.layout = \"vertical\";\r\n\t\t\tmarkerContainer.width = percent(100);\r\n\t\t\tmarkerContainer.height = undefined;\r\n\t\t\tif (!(valueAxis.renderer instanceof AxisRendererX)) {\r\n\t\t\t\tvalueAxis.renderer = new AxisRendererX();\r\n\t\t\t}\r\n\t\t}\r\n\t\t// VERTICAL\r\n\t\telse {\r\n\t\t\tif (!$type.hasValue(this.height)) {\r\n\t\t\t\tthis.height = 200;\r\n\t\t\t}\r\n\t\t\tthis.width = undefined;\r\n\t\t\tthis.layout = \"horizontal\";\r\n\t\t\tmarkerContainer.width = undefined;\r\n\t\t\tmarkerContainer.height = percent(100);\r\n\t\t\tvalueAxis.height = percent(100);\r\n\t\t\tvalueAxis.width = undefined;\r\n\t\t\tvalueAxis.tooltip.pointerOrientation = \"horizontal\";\r\n\r\n\t\t\tif (!(valueAxis.renderer instanceof AxisRendererY)) {\r\n\t\t\t\tvalueAxis.renderer = new AxisRendererY();\r\n\t\t\t}\r\n\t\t\tvalueAxis.renderer.inside = true;\r\n\t\t\tvalueAxis.renderer.labels.template.inside = true;\r\n\r\n\t\t\tthis.markerContainer.reverseOrder = true;\r\n\t\t}\r\n\r\n\t\tlet renderer = valueAxis.renderer;\r\n\t\trenderer.grid.template.disabled = true;\r\n\t\trenderer.axisFills.template.disabled = true;\r\n\t\trenderer.baseGrid.disabled = true;\r\n\t\trenderer.labels.template.padding(2, 3, 2, 3);\r\n\r\n\t\trenderer.minHeight = undefined;\r\n\t\trenderer.minWidth = undefined;\r\n\r\n\t\tthis.markerContainer.layout = value;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns orientation value.\r\n\t *\r\n\t * @return {\"horizontal\" | \"vertical\"}\r\n\t */\r\n\tpublic get orientation(): \"horizontal\" | \"vertical\" {\r\n\t\treturn this.getPropertyValue(\"orientation\");\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a value axis of heat legend. Value axis for heat legend is created automatically.\r\n\t * @param {ValueAxis}\r\n\t */\r\n\tpublic set valueAxis(valueAxis: ValueAxis) {\r\n\r\n\t\tthis._valueAxis = valueAxis;\r\n\r\n\t\tvalueAxis.parent = this;\r\n\t\tvalueAxis.strictMinMax = true;\r\n\t\tthis.orientation = this.orientation;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns valueAxis value.\r\n\t * @return {ValueAxis}\r\n\t */\r\n\tpublic get valueAxis(): ValueAxis {\r\n\t\tif (!this._valueAxis) {\r\n\t\t\tthis.valueAxis = this.createChild(ValueAxis);\r\n\t\t\tthis.valueAxis.shouldClone = false;\r\n\t\t}\r\n\t\treturn this._valueAxis;\r\n\t}\r\n\r\n\t/**\r\n\t * You can set series for heat legend. It will take min, max, minColor and maxColor values from this series.\r\n\t * @param series\r\n\t */\r\n\tset series(series: Series) {\r\n\t\tthis._series = series;\r\n\r\n\t\tlet dataField = \"value\";\r\n\r\n\t\ttry {\r\n\t\t\tlet dataFieldDefined = series.heatRules.getIndex(0).dataField;\r\n\t\t\tif (dataFieldDefined) {\r\n\t\t\t\tdataField = dataFieldDefined;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (err) {\r\n\r\n\t\t}\r\n\r\n\t\tthis.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\r\n\r\n\t\tseries.dataItem.events.on(\"calculatedvaluechanged\", (event) => {\r\n\t\t\tthis.updateMinMax(series.dataItem.values[dataField].low, series.dataItem.values[dataField].high);\r\n\t\t}, undefined, false);\r\n\r\n\t\tseries.heatRules.events.on(\"inserted\", this.invalidate, this, false);\r\n\t\tseries.heatRules.events.on(\"removed\", this.invalidate, this, false);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns series value.\r\n\t * @return {Series}\r\n\t */\r\n\tget series(): Series {\r\n\t\treturn this._series;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates min/max of value axis.\r\n\t * @ignore\r\n\t */\r\n\tprotected updateMinMax(min: number, max: number) {\r\n\t\tlet valueAxis = this.valueAxis;\r\n\t\tif (!$type.isNumber(this.minValue)) {\r\n\t\t\tvalueAxis.min = min;\r\n\t\t\tvalueAxis.invalidate();\r\n\t\t}\r\n\t\tif (!$type.isNumber(this.maxValue)) {\r\n\t\t\tvalueAxis.max = max;\r\n\t\t\tvalueAxis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif (config) {\r\n\r\n\t\t\t// Set up series\r\n\t\t\tif ($type.hasValue(config.series) && $type.isString(config.series)) {\r\n\t\t\t\tif ($type.isString(config.series)) {\r\n\t\t\t\t\tif (this.map.hasKey(config.series)) {\r\n\t\t\t\t\t\tconfig.series = this.map.getKey(config.series);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlet seriesId = config.series;\r\n\t\t\t\t\t\tconst disposer = this.map.events.on(\"insertKey\", function(ev) {\r\n\t\t\t\t\t\t\tif (ev.key == seriesId) {\r\n\t\t\t\t\t\t\t\tthis.series = ev.newValue;\r\n\t\t\t\t\t\t\t\tdisposer.dispose();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}, this);\r\n\t\t\t\t\t\tthis._disposers.push(disposer);\r\n\t\t\t\t\t\tdelete config.series;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\r\n\t}\r\n}\r\n\r\n\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"HeatLegend\"] = HeatLegend;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}