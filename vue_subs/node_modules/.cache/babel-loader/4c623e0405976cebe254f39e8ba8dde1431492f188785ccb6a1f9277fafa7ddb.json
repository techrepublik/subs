{"ast":null,"code":"/**\r\n * Map series module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Series, SeriesDataItem } from \"../series/Series\";\nimport { registry } from \"../../core/Registry\";\nimport * as $type from \"../../core/utils/Type\";\nimport * as $math from \"../../core/utils/Math\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Defines a [[DataItem]] for [[MapSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\nvar MapSeriesDataItem = /** @class */function (_super) {\n  __extends(MapSeriesDataItem, _super);\n  /**\r\n   * Constructor\r\n   */\n  function MapSeriesDataItem() {\n    var _this = _super.call(this) || this;\n    _this.className = \"MapSeriesDataItem\";\n    _this.values.value = {};\n    _this.applyTheme();\n    return _this;\n  }\n  Object.defineProperty(MapSeriesDataItem.prototype, \"value\", {\n    /**\r\n     * @return Value\r\n     */\n    get: function () {\n      return this.values.value.value;\n    },\n    /**\r\n     * Numeric value of the data item.\r\n     *\r\n     * Value may be used in heat-map calculations.\r\n     *\r\n     * @param value  Value\r\n     */\n    set: function (value) {\n      this.setValue(\"value\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"zoomLevel\", {\n    /**\r\n     * @return Zoom level\r\n     */\n    get: function () {\n      return this.properties[\"zoomLevel\"];\n    },\n    /**\r\n     * When `zoomToMapObject()` is called the map will either calculate suitable\r\n     * zoom level itself or use object's `zoomLevel` if set.\r\n     *\r\n     * @param value  Zoom level\r\n     */\n    set: function (value) {\n      this.setProperty(\"zoomLevel\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"zoomGeoPoint\", {\n    /**\r\n     * @return Zoom geo point\r\n     */\n    get: function () {\n      return this.properties[\"zoomGeoPoint\"];\n    },\n    /**\r\n     * When `zoomToMapObject()` is called the map will either calculate suitable\r\n     * center position itself or use object's `zoomGeoPoint` if set.\r\n     *\r\n     * @param value  Zoom geo point\r\n     */\n    set: function (value) {\n      this.setProperty(\"zoomGeoPoint\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"east\", {\n    /**\r\n     * Longitude of the East-most point of the element.\r\n     */\n    get: function () {\n      return this._east;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"west\", {\n    /**\r\n     * Longitude of the West-most point of the element.\r\n     */\n    get: function () {\n      return this._west;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"south\", {\n    /**\r\n     * Latitude of the South-most point of the element.\r\n     */\n    get: function () {\n      return this._south;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeriesDataItem.prototype, \"north\", {\n    /**\r\n     * Latitude of the North-most point of the element.\r\n     */\n    get: function () {\n      return this._north;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Updates the item's bounding coordinates: coordinates of the East, West,\r\n   * North, and South-most points.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  MapSeriesDataItem.prototype.updateExtremes = function () {\n    var geometry = this.getFeature().geometry;\n    if (geometry) {\n      var bounds = d3geo.geoBounds(geometry);\n      var west = bounds[0][0];\n      var south = bounds[0][1];\n      var north = bounds[1][1];\n      var east = bounds[1][0];\n      var changed = false;\n      if (north != this.north) {\n        this._north = $math.round(north, 6);\n        changed = true;\n      }\n      if (south != this.south) {\n        this._south = $math.round(south, 6);\n        changed = true;\n      }\n      if (east != this.east) {\n        this._east = $math.round(east, 6);\n        changed = true;\n      }\n      if (west != this.west) {\n        this._west = $math.round(west, 6);\n        changed = true;\n      }\n      // solves single russia prob\n      if (this._east < this._west) {\n        this._east = 180;\n        this._west = -180;\n      }\n      if (changed) {\n        this.component.invalidateDataItems();\n      }\n    }\n  };\n  MapSeriesDataItem.prototype.getFeature = function () {\n    return {};\n  };\n  return MapSeriesDataItem;\n}(SeriesDataItem);\nexport { MapSeriesDataItem };\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * A base class for series of map objects.\r\n *\r\n * @see {@link IMapSeriesEvents} for a list of available Events\r\n * @see {@link IMapSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\nvar MapSeries = /** @class */function (_super) {\n  __extends(MapSeries, _super);\n  /**\r\n   * Constructor\r\n   */\n  function MapSeries() {\n    var _this =\n    // Init\n    _super.call(this) || this;\n    _this.className = \"MapSeries\";\n    // Set defaults\n    _this.isMeasured = false;\n    _this.nonScalingStroke = true;\n    // Set data fields\n    _this.dataFields.value = \"value\";\n    _this.ignoreBounds = false;\n    if (_this.tooltip) {\n      _this.tooltip.showInViewport = true;\n    }\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Returns a new/empty DataItem of the type appropriate for this object.\r\n   *\r\n   * @see {@link DataItem}\r\n   * @return Data Item\r\n   */\n  MapSeries.prototype.createDataItem = function () {\n    return new MapSeriesDataItem();\n  };\n  /**\r\n   * Checks whether object should be included in series.\r\n   *\r\n   * @param includes  A list of explicitly included ids\r\n   * @param excludes  A list of explicitly excluded ids\r\n   * @param id        Id of the object\r\n   * @return Include?\r\n   */\n  MapSeries.prototype.checkInclude = function (includes, excludes, id) {\n    if (includes) {\n      if (includes.length == 0) {\n        return false;\n      } else {\n        if (includes.indexOf(id) == -1) {\n          return false;\n        }\n      }\n    }\n    if (excludes && excludes.length > 0) {\n      if (excludes.indexOf(id) != -1) {\n        return false;\n      }\n    }\n    return true;\n  };\n  Object.defineProperty(MapSeries.prototype, \"useGeodata\", {\n    /**\r\n     * @return Use GeoJSON data?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"useGeodata\");\n    },\n    /**\r\n     * Should the map extract all the data about element from the GeoJSON?\r\n     *\r\n     * This is especially relevant for [[MapPolygonSeries]]. If not set to `true`\r\n     * polygon series will need to contain geographical data in itself in order\r\n     * to be drawn.\r\n     *\r\n     * If this is set to `true`, series will try to extract data for its objects\r\n     * from either chart-level `geodata` or from series' `geodata` which holds\r\n     * map infor in GeoJSON format.\r\n     *\r\n     * @default false\r\n     * @param value  Use GeoJSON data?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"useGeodata\", value)) {\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"include\", {\n    /**\r\n     * @return Included objects\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"include\");\n    },\n    /**\r\n     * A list of object ids that should be explictly included in the series.\r\n     *\r\n     * If this is not set, the series will automatically include all of the\r\n     * objects, available in the GeoJSON map. (minus the ones listed in\r\n     * `exclude`)\r\n     *\r\n     * If you need to display only specific objects, use `include`. E.g.:\r\n     *\r\n     * `include = [\"FR\", \"ES\", \"DE\"];`\r\n     *\r\n     * The above will show only France, Spain, and Germany out of the whole map.\r\n     *\r\n     * @param value  Included objects\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"include\", value)) {\n        this.processIncExc();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  MapSeries.prototype.processIncExc = function () {\n    //this.data = [];\n    this.invalidateData();\n  };\n  Object.defineProperty(MapSeries.prototype, \"ignoreBounds\", {\n    /**\r\n     * @return Ignore bounds?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"ignoreBounds\");\n    },\n    /**\r\n     * Should this series be included when calculating bounds of the map?\r\n     *\r\n     * This affects initial zoom as well as limits for zoom/pan.\r\n     *\r\n     * By default, `MapPolygonSeries` included (true), while `MapImageSeries` and\r\n     * `MapLineSeries` are not (`false`).\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Ignore bounds?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"ignoreBounds\", value)) {\n        if (this.chart) {\n          this.chart.updateExtremes();\n        }\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"exclude\", {\n    /**\r\n     * @return Excluded ids\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"exclude\");\n    },\n    /**\r\n     * A list of object ids that should be excluded from the series.\r\n     *\r\n     * E.g. you want to include all of the areas from a GeoJSON map, except\r\n     * Antarctica.\r\n     *\r\n     * You'd leave `include` empty, and set `exclude = [\"AQ\"]`.\r\n     *\r\n     * @param value  Excluded ids\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"exclude\", value)) {\n        this.processIncExc();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Decorates a newly added object.\r\n   *\r\n   * @param event [description]\r\n   */\n  MapSeries.prototype.handleObjectAdded = function (event) {\n    var mapObject = event.newValue;\n    mapObject.parent = this;\n    mapObject.series = this;\n    mapObject.strokeWidth = mapObject.strokeWidth;\n  };\n  Object.defineProperty(MapSeries.prototype, \"geodata\", {\n    /**\r\n     * @return GeoJSON data\r\n     */\n    get: function () {\n      return this._geodata;\n    },\n    /**\r\n     * Map data in GeoJSON format.\r\n     *\r\n     * The series supports the following GeoJSON objects: `Point`, `LineString`,\r\n     * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n     *\r\n     * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n     * @param geoJSON GeoJSON data\r\n     */\n    set: function (geodata) {\n      if (geodata != this._geodata) {\n        this._geodata = geodata;\n        if (this.reverseGeodata) {\n          this.chart.processReverseGeodata(this._geodata);\n        }\n        for (var i = this.data.length - 1; i >= 0; i--) {\n          if (this.data[i].madeFromGeoData == true) {\n            this.data.splice(i, 1);\n          }\n        }\n        this.disposeData();\n        this.invalidateData();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"reverseGeodata\", {\n    /**\r\n     * @returns Reverse the order of geodata coordinates?\r\n     */\n    get: function () {\n      return this.getPropertyValue(\"reverseGeodata\");\n    },\n    /**\r\n     * Indicates whether GeoJSON geodata supplied to the chart uses\r\n     * ESRI (clockwise) or non-ESRI (counter-clockwise) order of the polygon\r\n     * coordinates.\r\n     *\r\n     * `MapChart` supports only ESRI standard, so if your custom maps appears\r\n     * garbled, try setting `reverseGeodata = true`.\r\n     *\r\n     * @default false\r\n     * @since 4.10.11\r\n     * @param  value  Reverse the order of geodata coordinates?\r\n     */\n    set: function (value) {\n      if (this.setPropertyValue(\"reverseGeodata\", value) && this._geodata) {\n        this.chart.processReverseGeodata(this._geodata);\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"geodataSource\", {\n    /**\r\n     * Returns a [[DataSource]] specifically for loading Component's data.\r\n     *\r\n     * @return Data source\r\n     */\n    get: function () {\n      if (!this._dataSources[\"geodata\"]) {\n        this.getDataSource(\"geodata\");\n      }\n      return this._dataSources[\"geodata\"];\n    },\n    /**\r\n     * Sets a [[DataSource]] to be used for loading Component's data.\r\n     *\r\n     * @param value Data source\r\n     */\n    set: function (value) {\n      var _this = this;\n      if (this._dataSources[\"geodata\"]) {\n        this.removeDispose(this._dataSources[\"geodata\"]);\n      }\n      this._dataSources[\"geodata\"] = value;\n      this._dataSources[\"geodata\"].component = this;\n      this.events.on(\"inited\", function () {\n        _this.loadData(\"geodata\");\n      }, undefined, false);\n      this.setDataSourceEvents(value, \"geodata\");\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * @ignore\r\n   */\n  MapSeries.prototype.getFeatures = function () {\n    return;\n  };\n  /**\r\n   * @ignore\r\n   */\n  MapSeries.prototype.validateDataItems = function () {\n    _super.prototype.validateDataItems.call(this);\n    this.updateExtremes();\n  };\n  /**\r\n   * @ignore\r\n   */\n  MapSeries.prototype.updateExtremes = function () {\n    var north;\n    var south;\n    var east;\n    var west;\n    this.dataItems.each(function (dataItem) {\n      if (dataItem.north > north || !$type.isNumber(north)) {\n        north = dataItem.north;\n      }\n      if (dataItem.south < south || !$type.isNumber(south)) {\n        south = dataItem.south;\n      }\n      if (dataItem.west < west || !$type.isNumber(west)) {\n        west = dataItem.west;\n      }\n      if (dataItem.east > east || !$type.isNumber(east)) {\n        east = dataItem.east;\n      }\n    });\n    if (this._mapObjects) {\n      this._mapObjects.each(function (mapObject) {\n        if (mapObject.north > north || !$type.isNumber(north)) {\n          north = mapObject.north;\n        }\n        if (mapObject.south < south || !$type.isNumber(south)) {\n          south = mapObject.south;\n        }\n        if (mapObject.west < west || !$type.isNumber(west)) {\n          west = mapObject.west;\n        }\n        if (mapObject.east > east || !$type.isNumber(east)) {\n          east = mapObject.east;\n        }\n      });\n    }\n    if (this.north != north || this.east != east || this.south != south || this.west != west) {\n      this._north = north;\n      this._east = east;\n      this._west = west;\n      this._south = south;\n      this.dispatch(\"geoBoundsChanged\");\n      if (!this.ignoreBounds) {\n        this.chart.updateExtremes();\n      }\n    }\n  };\n  Object.defineProperty(MapSeries.prototype, \"north\", {\n    /**\r\n     * @return Latitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._northDefined)) {\n        return this._northDefined;\n      }\n      return this._north;\n    },\n    /**\r\n     * North-most latitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated latitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this._northDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"south\", {\n    /**\r\n     * @return Latitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._southDefined)) {\n        return this._southDefined;\n      }\n      return this._south;\n    },\n    /**\r\n     * South-most latitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated latitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this._southDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"west\", {\n    /**\r\n     * @return Longitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._westDefined)) {\n        return this._westDefined;\n      }\n      return this._west;\n    },\n    /**\r\n     * West-most longitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated longitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this._westDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapSeries.prototype, \"east\", {\n    /**\r\n     * @return Longitude\r\n     */\n    get: function () {\n      if ($type.isNumber(this._eastDefined)) {\n        return this._eastDefined;\n      }\n      return this._east;\n    },\n    /**\r\n     * East-most longitude of the series.\r\n     *\r\n     * By default, this holds auto-calculated longitude of the extremity.\r\n     *\r\n     * It can be overridden manually.\r\n     *\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this._eastDefined = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Processes JSON-based config before it is applied to the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param config  Config\r\n   */\n  MapSeries.prototype.processConfig = function (config) {\n    if ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\n      var name_1 = config[\"geodata\"];\n      // Check if there's a map loaded by such name\n      if ($type.hasValue(window[\"am4geodata_\" + config[\"geodata\"]])) {\n        config[\"geodata\"] = window[\"am4geodata_\" + config[\"geodata\"]];\n      }\n      // Nope. Let's try maybe we got JSON as string?\n      else {\n        try {\n          config[\"geodata\"] = JSON.parse(config[\"geodata\"]);\n        } catch (e) {\n          // No go again. Error out.\n          throw Error(\"MapChart error: Geodata `\" + name_1 + \"` is not loaded or is incorrect.\");\n        }\n      }\n    }\n    _super.prototype.processConfig.call(this, config);\n  };\n  /**\r\n   * Adds `projection` to \"as is\" fields.\r\n   *\r\n   * @param field  Field name\r\n   * @return Assign as is?\r\n   */\n  MapSeries.prototype.asIs = function (field) {\n    return field == \"geodata\" || _super.prototype.asIs.call(this, field);\n  };\n  /**\r\n   * @ignore\r\n   */\n  MapSeries.prototype.updateTooltipBounds = function () {\n    if (this.tooltip && this.topParent) {\n      this.tooltip.setBounds({\n        x: 10,\n        y: 10,\n        width: this.topParent.maxWidth - 20,\n        height: this.topParent.maxHeight - 20\n      });\n    }\n  };\n  return MapSeries;\n}(Series);\nexport { MapSeries };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"MapSeries\"] = MapSeries;\nregistry.registeredClasses[\"MapSeriesDataItem\"] = MapSeriesDataItem;","map":{"version":3,"names":["Series","SeriesDataItem","registry","$type","$math","d3geo","MapSeriesDataItem","_super","__extends","_this","call","className","values","value","applyTheme","Object","defineProperty","prototype","get","set","setValue","properties","setProperty","_east","_west","_south","_north","updateExtremes","geometry","getFeature","bounds","geoBounds","west","south","north","east","changed","round","component","invalidateDataItems","MapSeries","isMeasured","nonScalingStroke","dataFields","ignoreBounds","tooltip","showInViewport","createDataItem","checkInclude","includes","excludes","id","length","indexOf","getPropertyValue","setPropertyValue","invalidateData","processIncExc","chart","handleObjectAdded","event","mapObject","newValue","parent","series","strokeWidth","_geodata","geodata","reverseGeodata","processReverseGeodata","i","data","madeFromGeoData","splice","disposeData","_dataSources","getDataSource","removeDispose","events","on","loadData","undefined","setDataSourceEvents","getFeatures","validateDataItems","dataItems","each","dataItem","isNumber","_mapObjects","dispatch","_northDefined","_southDefined","_westDefined","_eastDefined","processConfig","config","hasValue","isString","name_1","window","JSON","parse","e","Error","asIs","field","updateTooltipBounds","topParent","setBounds","x","y","width","maxWidth","height","maxHeight","registeredClasses"],"sources":["../../../../../src/.internal/charts/map/MapSeries.ts"],"sourcesContent":["/**\r\n * Map series module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Series, SeriesDataItem, ISeriesProperties, ISeriesDataFields, ISeriesAdapters, ISeriesEvents } from \"../series/Series\";\r\nimport { MapChart } from \"../types/MapChart\";\r\nimport { MapObject } from \"./MapObject\";\r\nimport { IListEvents } from \"../../core/utils/List\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { DataSource } from \"../../core/data/DataSource\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport * as $math from \"../../core/utils/Math\";\r\nimport { ListTemplate } from \"../../core/utils/List\";\r\nimport * as d3geo from \"d3-geo\";\r\n\r\n/**\r\n * ============================================================================\r\n * DATA ITEM\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines a [[DataItem]] for [[MapSeries]].\r\n *\r\n * @see {@link DataItem}\r\n */\r\nexport class MapSeriesDataItem extends SeriesDataItem {\r\n\r\n\t/**\r\n\t * South-most latitude.\r\n\t */\r\n\tprotected _south: number;\r\n\r\n\t/**\r\n\t * North-most latitude.\r\n\t */\r\n\tprotected _north: number;\r\n\r\n\t/**\r\n\t * East-most longitude.\r\n\t */\r\n\tprotected _east: number;\r\n\r\n\t/**\r\n\t * West-most longitude.\r\n\t */\r\n\tprotected _west: number;\r\n\r\n\t/**\r\n\t * Defines a type of [[Component]] this data item is used for.\r\n\t */\r\n\tpublic _component!: MapSeries;\r\n\r\n\t/**\r\n\t * Shortcut to either [[MapLine]], [[MapImage]], or [[MapPolygon]].\r\n\t */\r\n\tpublic mapObject: MapObject;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSeriesDataItem\";\r\n\t\tthis.values.value = {};\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Numeric value of the data item.\r\n\t *\r\n\t * Value may be used in heat-map calculations.\r\n\t *\r\n\t * @param value  Value\r\n\t */\r\n\tpublic set value(value: number) {\r\n\t\tthis.setValue(\"value\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Value\r\n\t */\r\n\tpublic get value(): number {\r\n\t\treturn this.values.value.value;\r\n\t}\r\n\r\n\t/**\r\n\t * When `zoomToMapObject()` is called the map will either calculate suitable\r\n\t * zoom level itself or use object's `zoomLevel` if set.\r\n\t *\r\n\t * @param value  Zoom level\r\n\t */\r\n\tpublic set zoomLevel(value: number) {\r\n\t\tthis.setProperty(\"zoomLevel\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Zoom level\r\n\t */\r\n\tpublic get zoomLevel(): number {\r\n\t\treturn this.properties[\"zoomLevel\"];\r\n\t}\r\n\r\n\t/**\r\n\t * When `zoomToMapObject()` is called the map will either calculate suitable\r\n\t * center position itself or use object's `zoomGeoPoint` if set.\r\n\t *\r\n\t * @param value  Zoom geo point\r\n\t */\r\n\tpublic set zoomGeoPoint(value: IGeoPoint) {\r\n\t\tthis.setProperty(\"zoomGeoPoint\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Zoom geo point\r\n\t */\r\n\tpublic get zoomGeoPoint(): IGeoPoint {\r\n\t\treturn this.properties[\"zoomGeoPoint\"];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Longitude of the East-most point of the element.\r\n\t */\r\n\tpublic get east(): number {\r\n\t\treturn this._east;\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the West-most point of the element.\r\n\t */\r\n\tpublic get west(): number {\r\n\t\treturn this._west;\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the South-most point of the element.\r\n\t */\r\n\tpublic get south(): number {\r\n\t\treturn this._south;\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the North-most point of the element.\r\n\t */\r\n\tpublic get north(): number {\r\n\t\treturn this._north;\r\n\t}\r\n\r\n\t/**\r\n\t * Updates the item's bounding coordinates: coordinates of the East, West,\r\n\t * North, and South-most points.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic updateExtremes(): void {\r\n\t\tlet geometry = this.getFeature().geometry;\r\n\t\tif (geometry) {\r\n\r\n\t\t\tlet bounds = d3geo.geoBounds(geometry);\r\n\r\n\t\t\tlet west = bounds[0][0];\r\n\t\t\tlet south = bounds[0][1];\r\n\r\n\t\t\tlet north = bounds[1][1];\r\n\t\t\tlet east = bounds[1][0];\r\n\r\n\t\t\tlet changed = false;\r\n\t\t\tif (north != this.north) {\r\n\t\t\t\tthis._north = $math.round(north, 6);\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (south != this.south) {\r\n\t\t\t\tthis._south = $math.round(south, 6);\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (east != this.east) {\r\n\t\t\t\tthis._east = $math.round(east, 6);\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (west != this.west) {\r\n\t\t\t\tthis._west = $math.round(west, 6);\r\n\t\t\t\tchanged = true;\r\n\t\t\t}\r\n\r\n\t\t\t// solves single russia prob\r\n\t\t\tif (this._east < this._west) {\r\n\t\t\t\tthis._east = 180;\r\n\t\t\t\tthis._west = -180;\r\n\t\t\t}\r\n\r\n\t\t\tif (changed) {\r\n\t\t\t\tthis.component.invalidateDataItems();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic getFeature(): any {\r\n\t\treturn {};\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * [GEOJSONGeometry description]\r\n *\r\n * @todo Description\r\n */\r\nexport type GEOJSONGeometry = \"Point\" | \"LineString\" | \"Polygon\" | \"MultiPoint\" | \"MultiLineString\" | \"MultiPolygon\";\r\n\r\n/**\r\n * Defines data fields for [[MapSeries]].\r\n *\r\n * @todo Alllow any number of values?\r\n */\r\nexport interface IMapSeriesDataFields extends ISeriesDataFields {\r\n\r\n\t/**\r\n\t * A field name in data for a numeric value of the map object.\r\n\t */\r\n\tvalue?: string;\r\n\r\n\t/**\r\n\t * A field name in data for a `zoomLevel` of the map object.\r\n\t */\r\n\tzoomLevel?: string;\r\n\r\n\t/**\r\n\t * A field name in data for a `zoomGeoPoint` of the map object.\r\n\t */\r\n\tzoomGeoPoint?: string;\r\n\r\n}\r\n\r\n/**\r\n * Defines properties for [[MapSeries]].\r\n */\r\nexport interface IMapSeriesProperties extends ISeriesProperties {\r\n\r\n\t/**\r\n\t * A flag telling if the series should get data from `geodata` or not\r\n\t *\r\n\t * @default false\r\n\t */\r\n\tuseGeodata?: boolean;\r\n\r\n\t/**\r\n\t * A list of object ids to include from the series.\r\n\t */\r\n\tinclude?: string[];\r\n\r\n\t/**\r\n\t * A list of object ids to exclude from the series.\r\n\t */\r\n\texclude?: string[];\r\n\r\n\t/**\r\n\t * Should this series be included when calculating bounds of the map?\r\n\t *\r\n\t * This affects initial zoom as well as limits for zoom/pan.\r\n\t *\r\n\t * By default, `MapPolygonSeries` included (true), while `MapImageSeries` and\r\n\t * `MapLineSeries` are not (`false`).\r\n\t */\r\n\tignoreBounds?: boolean;\r\n\r\n\t/**\r\n\t * Indicates whether GeoJSON geodata supplied to the chart uses\r\n\t * ESRI (clockwise) or non-ESRI (counter-clockwise) order of the polygon\r\n\t * coordinates.\r\n\t *\r\n\t * `MapChart` supports only ESRI standard, so if your custom maps appears\r\n\t * garbled, try setting `reverseGeodata = true`.\r\n\t * \r\n\t * @default false\r\n\t * @since 4.10.11\r\n\t */\r\n\treverseGeodata?: boolean;\r\n}\r\n\r\n/**\r\n * Defines events for [[MapSeries]].\r\n */\r\nexport interface IMapSeriesEvents extends ISeriesEvents {\r\n\tgeoBoundsChanged: {};\r\n}\r\n\r\n/**\r\n * Defines adapters for [[MapSeries]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapSeriesAdapters extends ISeriesAdapters, IMapSeriesProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A base class for series of map objects.\r\n *\r\n * @see {@link IMapSeriesEvents} for a list of available Events\r\n * @see {@link IMapSeriesAdapters} for a list of available Adapters\r\n * @important\r\n */\r\nexport class MapSeries extends Series {\r\n\r\n\t/**\r\n\t * Defines available data fields.\r\n\t */\r\n\tpublic _dataFields: IMapSeriesDataFields;\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IMapSeriesProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IMapSeriesAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IMapSeriesEvents;\r\n\r\n\t/**\r\n\t * Defines the type of data item.\r\n\t */\r\n\tpublic _dataItem: MapSeriesDataItem;\r\n\r\n\t/**\r\n\t * The longitude of the East-most point in the series. (out of all elements)\r\n\t */\r\n\tprotected _east: number;\r\n\r\n\t/**\r\n\t * The longitude of the West-most point in the series. (out of all elements)\r\n\t */\r\n\tprotected _west: number;\r\n\r\n\t/**\r\n\t * The latitude of the South-most point in the series. (out of all elements)\r\n\t */\r\n\tprotected _south: number;\r\n\r\n\t/**\r\n\t * The latitude of the North-most point in the series. (out of all elements)\r\n\t */\r\n\tprotected _north: number;\r\n\r\n\tprotected _eastDefined: number;\r\n\r\n\tprotected _westDefined: number;\r\n\r\n\tprotected _southDefined: number;\r\n\r\n\tprotected _northDefined: number;\r\n\r\n\t/**\r\n\t * A chart series belongs to.\r\n\t */\r\n\tpublic _chart: MapChart;\r\n\r\n\t/**\r\n\t * Map data in GeoJSON format.\r\n\t *\r\n\t * @see {@link http://geojson.org/} GeoJSON official specification\r\n\t */\r\n\tprotected _geodata: Object;\r\n\r\n\r\n\tprotected _mapObjects: ListTemplate<MapObject>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Init\r\n\t\tsuper();\r\n\t\tthis.className = \"MapSeries\";\r\n\r\n\t\t// Set defaults\r\n\t\tthis.isMeasured = false;\r\n\t\tthis.nonScalingStroke = true;\r\n\r\n\t\t// Set data fields\r\n\t\tthis.dataFields.value = \"value\";\r\n\r\n\t\tthis.ignoreBounds = false;\r\n\r\n\t\tif (this.tooltip) {\r\n\t\t\tthis.tooltip.showInViewport = true;\r\n\t\t}\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new/empty DataItem of the type appropriate for this object.\r\n\t *\r\n\t * @see {@link DataItem}\r\n\t * @return Data Item\r\n\t */\r\n\tprotected createDataItem(): this[\"_dataItem\"] {\r\n\t\treturn new MapSeriesDataItem();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Checks whether object should be included in series.\r\n\t *\r\n\t * @param includes  A list of explicitly included ids\r\n\t * @param excludes  A list of explicitly excluded ids\r\n\t * @param id        Id of the object\r\n\t * @return Include?\r\n\t */\r\n\tprotected checkInclude(includes: string[], excludes: string[], id: string): boolean {\r\n\t\tif (includes) {\r\n\t\t\tif (includes.length == 0) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (includes.indexOf(id) == -1) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (excludes && excludes.length > 0) {\r\n\t\t\tif (excludes.indexOf(id) != -1) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Should the map extract all the data about element from the GeoJSON?\r\n\t *\r\n\t * This is especially relevant for [[MapPolygonSeries]]. If not set to `true`\r\n\t * polygon series will need to contain geographical data in itself in order\r\n\t * to be drawn.\r\n\t *\r\n\t * If this is set to `true`, series will try to extract data for its objects\r\n\t * from either chart-level `geodata` or from series' `geodata` which holds\r\n\t * map infor in GeoJSON format.\r\n\t *\r\n\t * @default false\r\n\t * @param value  Use GeoJSON data?\r\n\t */\r\n\tpublic set useGeodata(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"useGeodata\", value)) {\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Use GeoJSON data?\r\n\t */\r\n\tpublic get useGeodata(): boolean {\r\n\t\treturn this.getPropertyValue(\"useGeodata\");\r\n\t}\r\n\r\n\t/**\r\n\t * A list of object ids that should be explictly included in the series.\r\n\t *\r\n\t * If this is not set, the series will automatically include all of the\r\n\t * objects, available in the GeoJSON map. (minus the ones listed in\r\n\t * `exclude`)\r\n\t *\r\n\t * If you need to display only specific objects, use `include`. E.g.:\r\n\t *\r\n\t * `include = [\"FR\", \"ES\", \"DE\"];`\r\n\t *\r\n\t * The above will show only France, Spain, and Germany out of the whole map.\r\n\t *\r\n\t * @param value  Included objects\r\n\t */\r\n\tpublic set include(value: string[]) {\r\n\t\tif (this.setPropertyValue(\"include\", value)) {\r\n\t\t\tthis.processIncExc();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tprotected processIncExc() {\r\n\t\t//this.data = [];\r\n\t\tthis.invalidateData();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Included objects\r\n\t */\r\n\tpublic get include(): string[] {\r\n\t\treturn this.getPropertyValue(\"include\");\r\n\t}\r\n\r\n\t/**\r\n\t * Should this series be included when calculating bounds of the map?\r\n\t *\r\n\t * This affects initial zoom as well as limits for zoom/pan.\r\n\t *\r\n\t * By default, `MapPolygonSeries` included (true), while `MapImageSeries` and\r\n\t * `MapLineSeries` are not (`false`).\r\n\t *\r\n\t * @since 4.3.0\r\n\t * @param  value  Ignore bounds?\r\n\t */\r\n\tpublic set ignoreBounds(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"ignoreBounds\", value)) {\r\n\t\t\tif (this.chart) {\r\n\t\t\t\tthis.chart.updateExtremes();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Ignore bounds?\r\n\t */\r\n\tpublic get ignoreBounds(): boolean {\r\n\t\treturn this.getPropertyValue(\"ignoreBounds\");\r\n\t}\r\n\r\n\t/**\r\n\t * A list of object ids that should be excluded from the series.\r\n\t *\r\n\t * E.g. you want to include all of the areas from a GeoJSON map, except\r\n\t * Antarctica.\r\n\t *\r\n\t * You'd leave `include` empty, and set `exclude = [\"AQ\"]`.\r\n\t *\r\n\t * @param value  Excluded ids\r\n\t */\r\n\tpublic set exclude(value: string[]) {\r\n\t\tif (this.setPropertyValue(\"exclude\", value)) {\r\n\t\t\tthis.processIncExc();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Excluded ids\r\n\t */\r\n\tpublic get exclude(): string[] {\r\n\t\treturn this.getPropertyValue(\"exclude\");\r\n\t}\r\n\r\n\t/**\r\n\t * Decorates a newly added object.\r\n\t *\r\n\t * @param event [description]\r\n\t */\r\n\tprotected handleObjectAdded(event: IListEvents<MapObject>[\"inserted\"]) {\r\n\t\tlet mapObject: MapObject = event.newValue;\r\n\t\tmapObject.parent = this;\r\n\t\tmapObject.series = this;\r\n\t\tmapObject.strokeWidth = mapObject.strokeWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Map data in GeoJSON format.\r\n\t *\r\n\t * The series supports the following GeoJSON objects: `Point`, `LineString`,\r\n\t * `Polygon`, `MultiPoint`, `MultiLineString`, and `MultiPolygon`.\r\n\t *\r\n\t * @see {@link http://geojson.org/} Official GeoJSON format specification\r\n\t * @param geoJSON GeoJSON data\r\n\t */\r\n\tpublic set geodata(geodata: Object) {\r\n\t\tif (geodata != this._geodata) {\r\n\t\t\tthis._geodata = geodata;\r\n\t\t\tif (this.reverseGeodata) {\r\n\t\t\t\tthis.chart.processReverseGeodata(this._geodata);\r\n\t\t\t}\r\n\t\t\tfor (let i = this.data.length - 1; i >= 0; i--) {\r\n\t\t\t\tif (this.data[i].madeFromGeoData == true) {\r\n\t\t\t\t\tthis.data.splice(i, 1);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.disposeData();\r\n\t\t\tthis.invalidateData();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return GeoJSON data\r\n\t */\r\n\tpublic get geodata(): Object {\r\n\t\treturn this._geodata;\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates whether GeoJSON geodata supplied to the chart uses\r\n\t * ESRI (clockwise) or non-ESRI (counter-clockwise) order of the polygon\r\n\t * coordinates.\r\n\t *\r\n\t * `MapChart` supports only ESRI standard, so if your custom maps appears\r\n\t * garbled, try setting `reverseGeodata = true`.\r\n\t * \r\n\t * @default false\r\n\t * @since 4.10.11\r\n\t * @param  value  Reverse the order of geodata coordinates?\r\n\t */\r\n\tpublic set reverseGeodata(value: boolean) {\r\n\t\tif (this.setPropertyValue(\"reverseGeodata\", value) && this._geodata) {\r\n\t\t\tthis.chart.processReverseGeodata(this._geodata);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @returns Reverse the order of geodata coordinates?\r\n\t */\r\n\tpublic get reverseGeodata(): boolean {\r\n\t\treturn this.getPropertyValue(\"reverseGeodata\");\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a [[DataSource]] to be used for loading Component's data.\r\n\t *\r\n\t * @param value Data source\r\n\t */\r\n\tpublic set geodataSource(value: DataSource) {\r\n\t\tif (this._dataSources[\"geodata\"]) {\r\n\t\t\tthis.removeDispose(this._dataSources[\"geodata\"]);\r\n\t\t}\r\n\t\tthis._dataSources[\"geodata\"] = value;\r\n\t\tthis._dataSources[\"geodata\"].component = this;\r\n\t\tthis.events.on(\"inited\", () => {\r\n\t\t\tthis.loadData(\"geodata\")\r\n\t\t}, undefined, false);\r\n\t\tthis.setDataSourceEvents(value, \"geodata\");\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a [[DataSource]] specifically for loading Component's data.\r\n\t *\r\n\t * @return Data source\r\n\t */\r\n\tpublic get geodataSource(): DataSource {\r\n\t\tif (!this._dataSources[\"geodata\"]) {\r\n\t\t\tthis.getDataSource(\"geodata\");\r\n\t\t}\r\n\t\treturn this._dataSources[\"geodata\"];\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic getFeatures(): { \"type\": \"Feature\", geometry: { type: \"Point\" | \"MultiLineString\" | \"MultiPolygon\", coordinates: [number, number] | Array<Array<[number, number]>> | Array<Array<Array<[number, number]>>> } }[] {\r\n\t\treturn;\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic validateDataItems() {\r\n\t\tsuper.validateDataItems();\r\n\t\tthis.updateExtremes();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateExtremes() {\r\n\t\tlet north: number;\r\n\t\tlet south: number;\r\n\t\tlet east: number;\r\n\t\tlet west: number;\r\n\r\n\t\tthis.dataItems.each((dataItem) => {\r\n\t\t\tif (dataItem.north > north || !$type.isNumber(north)) {\r\n\t\t\t\tnorth = dataItem.north;\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.south < south || !$type.isNumber(south)) {\r\n\t\t\t\tsouth = dataItem.south;\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.west < west || !$type.isNumber(west)) {\r\n\t\t\t\twest = dataItem.west;\r\n\t\t\t}\r\n\r\n\t\t\tif (dataItem.east > east || !$type.isNumber(east)) {\r\n\t\t\t\teast = dataItem.east;\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\tif (this._mapObjects) {\r\n\t\t\tthis._mapObjects.each((mapObject) => {\r\n\t\t\t\tif (mapObject.north > north || !$type.isNumber(north)) {\r\n\t\t\t\t\tnorth = mapObject.north;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapObject.south < south || !$type.isNumber(south)) {\r\n\t\t\t\t\tsouth = mapObject.south;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapObject.west < west || !$type.isNumber(west)) {\r\n\t\t\t\t\twest = mapObject.west;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapObject.east > east || !$type.isNumber(east)) {\r\n\t\t\t\t\teast = mapObject.east;\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\r\n\r\n\t\tif (this.north != north || this.east != east || this.south != south || this.west != west) {\r\n\t\t\tthis._north = north;\r\n\t\t\tthis._east = east;\r\n\t\t\tthis._west = west;\r\n\t\t\tthis._south = south;\r\n\r\n\t\t\tthis.dispatch(\"geoBoundsChanged\");\r\n\t\t\tif (!this.ignoreBounds) {\r\n\t\t\t\tthis.chart.updateExtremes();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * North-most latitude of the series.\r\n\t *\r\n\t * By default, this holds auto-calculated latitude of the extremity.\r\n\t *\r\n\t * It can be overridden manually.\r\n\t *\r\n\t * @param  value  Latitude\r\n\t */\r\n\tpublic set north(value: number) {\r\n\t\tthis._northDefined = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Latitude\r\n\t */\r\n\tpublic get north(): number {\r\n\t\tif ($type.isNumber(this._northDefined)) {\r\n\t\t\treturn this._northDefined;\r\n\t\t}\r\n\t\treturn this._north;\r\n\t}\r\n\r\n\t/**\r\n\t * South-most latitude of the series.\r\n\t *\r\n\t * By default, this holds auto-calculated latitude of the extremity.\r\n\t *\r\n\t * It can be overridden manually.\r\n\t *\r\n\t * @param  value  Latitude\r\n\t */\r\n\tpublic set south(value: number) {\r\n\t\tthis._southDefined = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Latitude\r\n\t */\r\n\tpublic get south(): number {\r\n\t\tif ($type.isNumber(this._southDefined)) {\r\n\t\t\treturn this._southDefined;\r\n\t\t}\r\n\t\treturn this._south;\r\n\t}\r\n\r\n\t/**\r\n\t * West-most longitude of the series.\r\n\t *\r\n\t * By default, this holds auto-calculated longitude of the extremity.\r\n\t *\r\n\t * It can be overridden manually.\r\n\t *\r\n\t * @param  value  Longitude\r\n\t */\r\n\tpublic set west(value: number) {\r\n\t\tthis._westDefined = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Longitude\r\n\t */\r\n\tpublic get west(): number {\r\n\t\tif ($type.isNumber(this._westDefined)) {\r\n\t\t\treturn this._westDefined;\r\n\t\t}\r\n\t\treturn this._west;\r\n\t}\r\n\r\n\t/**\r\n\t * East-most longitude of the series.\r\n\t *\r\n\t * By default, this holds auto-calculated longitude of the extremity.\r\n\t *\r\n\t * It can be overridden manually.\r\n\t *\r\n\t * @param  value  Longitude\r\n\t */\r\n\tpublic set east(value: number) {\r\n\t\tthis._eastDefined = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Longitude\r\n\t */\r\n\tpublic get east(): number {\r\n\t\tif ($type.isNumber(this._eastDefined)) {\r\n\t\t\treturn this._eastDefined;\r\n\t\t}\r\n\t\treturn this._east;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes JSON-based config before it is applied to the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param config  Config\r\n\t */\r\n\tpublic processConfig(config?: { [index: string]: any }): void {\r\n\r\n\t\tif ($type.hasValue(config[\"geodata\"]) && $type.isString(config[\"geodata\"])) {\r\n\t\t\tconst name = config[\"geodata\"];\r\n\t\t\t// Check if there's a map loaded by such name\r\n\t\t\tif ($type.hasValue((<any>window)[\"am4geodata_\" + config[\"geodata\"]])) {\r\n\t\t\t\tconfig[\"geodata\"] = (<any>window)[\"am4geodata_\" + config[\"geodata\"]];\r\n\t\t\t}\r\n\t\t\t// Nope. Let's try maybe we got JSON as string?\r\n\t\t\telse {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tconfig[\"geodata\"] = JSON.parse(config[\"geodata\"]);\r\n\t\t\t\t}\r\n\t\t\t\tcatch (e) {\r\n\t\t\t\t\t// No go again. Error out.\r\n\t\t\t\t\tthrow Error(\"MapChart error: Geodata `\" + name + \"` is not loaded or is incorrect.\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.processConfig(config);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds `projection` to \"as is\" fields.\r\n\t *\r\n\t * @param field  Field name\r\n\t * @return Assign as is?\r\n\t */\r\n\tprotected asIs(field: string): boolean {\r\n\t\treturn field == \"geodata\" || super.asIs(field);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateTooltipBounds() {\r\n\t\tif (this.tooltip && this.topParent) {\r\n\t\t\tthis.tooltip.setBounds({ x: 10, y: 10, width: this.topParent.maxWidth - 20, height: this.topParent.maxHeight - 20 });\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"MapSeries\"] = MapSeries;\r\nregistry.registeredClasses[\"MapSeriesDataItem\"] = MapSeriesDataItem;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}