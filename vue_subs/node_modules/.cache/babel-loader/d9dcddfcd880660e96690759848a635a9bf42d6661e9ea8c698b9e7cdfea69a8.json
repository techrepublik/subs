{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObject } from \"../Base\";\nimport { Animation, AnimationDisposer } from \"../utils/Animation\";\nimport * as $math from \"../utils/Math\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $type from \"../utils/Type\";\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\nvar Morpher = /** @class */function (_super) {\n  __extends(Morpher, _super);\n  /**\r\n   * Constructor.\r\n   *\r\n   * @param morphable An object to morph\r\n   */\n  function Morpher(morphable) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A storage for measurements.\r\n     */\n    _this._bboxes = [];\n    /**\r\n     * Duration of the morphing animation in milliseconds.\r\n     */\n    _this.morphDuration = 800;\n    /**\r\n     * An easing function to use for morphing animation.\r\n     *\r\n     * @see {@link Ease}\r\n     */\n    _this.morphEasing = $ease.cubicOut;\n    /**\r\n     * If set to `true`, all separate parts of the multi-part polygon will\r\n     * morph into a single circle or polygon when using built-in methods\r\n     * `morphToCircle()` or `morphToPolygon()`.\r\n     *\r\n     * Otherwise each separate part of polygon will morph to individual target\r\n     * circle or polgyon.\r\n     */\n    _this.morphToSingle = true;\n    /**\r\n     * A ratio to scale morphed object in relation to the source object.\r\n     */\n    _this.scaleRatio = 1;\n    _this.className = \"Morpher\";\n    _this.morphable = morphable;\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * Morphs a polygon to another polygon.\r\n   *\r\n   * @param toPoints  Corner points of the target shape\r\n   * @param duration  Duration in milliseconds\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n  Morpher.prototype.morphToPolygon = function (toPoints, duration, easing) {\n    var points = this.morphable.currentPoints;\n    if (points && toPoints) {\n      this.sortPoints(points);\n      this.sortPoints(toPoints);\n      this._morphFromPointsReal = [];\n      this._morphToPointsReal = [];\n      if (!$type.hasValue(duration)) {\n        duration = this.morphDuration;\n      }\n      if (!$type.hasValue(easing)) {\n        easing = this.morphEasing;\n      }\n      this._morphFromPointsReal = this.normalizePoints(toPoints, points);\n      this._morphToPointsReal = this.normalizePoints(points, toPoints);\n      this.morphable.currentPoints = this._morphFromPointsReal;\n      var animation = new Animation(this, {\n        property: \"morphProgress\",\n        from: 0,\n        to: 1\n      }, duration, easing);\n      this._disposers.push(animation);\n      animation.start();\n      return animation;\n    }\n  };\n  /**\r\n   * [normalizePoints description]\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @todo Description\r\n   * @param pointsA  Point A\r\n   * @param pointsB  Point B\r\n   * @return Normalized points\r\n   */\n  Morpher.prototype.normalizePoints = function (pointsA, pointsB) {\n    for (var i = 0, len = pointsA.length; i < len; i++) {\n      var surfaceA = pointsA[i][0];\n      var holeA = pointsA[i][1];\n      var bboxA = $type.getValue($math.getBBox(surfaceA));\n      var middleX = bboxA.x + bboxA.width;\n      var middleY = bboxA.y + bboxA.height;\n      // check if we have the same in PointsB\n      if (!pointsB[i]) {\n        pointsB[i] = [];\n      }\n      // check if we have surface in pointsB\n      if (surfaceA && !pointsB[i][0]) {\n        pointsB[i][0] = [{\n          x: middleX,\n          y: middleY\n        }, {\n          x: middleX,\n          y: middleY\n        }];\n      }\n      if (pointsB[i][0]) {\n        pointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\n        var distance = Infinity;\n        var splitAt = 0;\n        for (var a = 0; a < pointsB[i][0].length; a++) {\n          var newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\n          if (newDistance < distance) {\n            splitAt = a;\n            distance = newDistance;\n          }\n        }\n        var partA = pointsB[i][0].slice(0, splitAt);\n        var partB = pointsB[i][0].slice(splitAt);\n        pointsB[i][0] = partB.concat(partA);\n      }\n      if (holeA) {\n        if (!pointsB[i][1]) {\n          pointsB[i][1] = [{\n            x: middleX,\n            y: middleY\n          }, {\n            x: middleX,\n            y: middleY\n          }];\n        }\n        pointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\n      }\n    }\n    return pointsB;\n  };\n  /**\r\n   * [sortPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points  [description]\r\n   * @return                        common bbox of points\r\n   */\n  Morpher.prototype.sortPoints = function (points) {\n    points.sort(function (a, b) {\n      var bbox1 = $type.getValue($math.getBBox(a[0]));\n      var bbox2 = $type.getValue($math.getBBox(b[0]));\n      if (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\n        return -1;\n      } else {\n        return 1;\n      }\n    });\n    var bboxes = [];\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      if (surface) {\n        bboxes.push($type.getValue($math.getBBox(surface)));\n      }\n    }\n    return $math.getCommonRectangle(bboxes);\n  };\n  /**\r\n   * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n   *\r\n   * @param radius    Target circle radius (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n  Morpher.prototype.morphToCircle = function (radius, duration, easing) {\n    var points = this.morphable.points;\n    var commonBBox = this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    }\n    // surface\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = $type.getValue($math.getBBox(fromPoints)); // this._bboxes[i];\n        if (this.morphToSingle) {\n          bbox = $type.getValue(commonBBox);\n        }\n        var middleX = bbox.x + bbox.width / 2;\n        var middleY = bbox.y + bbox.height / 2;\n        var realRadius = radius;\n        if (!$type.isNumber(realRadius)) {\n          realRadius = Math.min(bbox.width / 2, bbox.height / 2);\n        }\n        toPoints = [];\n        // find angle for the first point\n        var startAngle = $math.getAngle({\n          x: middleX,\n          y: middleY\n        }, surface[0]);\n        var count = 100;\n        if (surface.length > count) {\n          count = surface.length;\n        }\n        fromPoints = this.addPoints(surface, count);\n        count = fromPoints.length; // add Points might increase number a bit\n        var angle = 360 / (count - 1);\n        for (var a = 0; a < count; a++) {\n          var realAngle = angle * a + startAngle;\n          var pointOnCircle = {\n            x: middleX + realRadius * $math.cos(realAngle),\n            y: middleY + realRadius * $math.sin(realAngle)\n          };\n          toPoints[a] = pointOnCircle;\n        }\n        if (hole && hole.length > 0) {\n          for (var i_1 = 0, hlen = hole.length; i_1 < hlen; i_1++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n    this._disposers.push(animation);\n    animation.start();\n    return animation;\n  };\n  /**\r\n   * [addPoints description]\r\n   *\r\n   * @ignore Exclude from doc\r\n   * @todo Description\r\n   * @param points         [description]\r\n   * @param mustHaveCount  [description]\r\n   * @return [description]\r\n   */\n  Morpher.prototype.addPoints = function (points, mustHaveCount) {\n    var addToSegmentCount = Math.round(mustHaveCount / points.length);\n    var newPoints = [];\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point0 = points[i];\n      var point1 = void 0;\n      if (i == points.length - 1) {\n        point1 = points[0];\n      } else {\n        point1 = points[i + 1];\n      }\n      newPoints.push(point0);\n      for (var p = 1; p < addToSegmentCount; p++) {\n        var percent = p / addToSegmentCount;\n        var extraPoint = {\n          x: point0.x + (point1.x - point0.x) * percent,\n          y: point0.y + (point1.y - point0.y) * percent\n        };\n        newPoints.push(extraPoint);\n      }\n      // stop adding in case we already added more than left in original\n      if (newPoints.length + points.length - i == mustHaveCount) {\n        addToSegmentCount = 0;\n      }\n    }\n    if (newPoints.length < mustHaveCount && points.length > 0) {\n      var lastPoint = points[points.length - 1];\n      for (var p = newPoints.length; p < mustHaveCount; p++) {\n        // add same as last\n        newPoints.push({\n          x: lastPoint.x,\n          y: lastPoint.y\n        });\n      }\n    }\n    return newPoints;\n  };\n  /**\r\n   * Morphs polygon into a rectangular polygon.\r\n   *\r\n   * @param width     Width of the target rectangle (px)\r\n   * @param height    Height of the target rectangle (px)\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n  Morpher.prototype.morphToRectangle = function (width, height, duration, easing) {\n    var points = this.morphable.points;\n    this.sortPoints(points);\n    this._morphFromPointsReal = [];\n    this._morphToPointsReal = [];\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    }\n    //\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\n    // surface\n    for (var i = 0, len = points.length; i < len; i++) {\n      var surface = points[i][0];\n      var hole = points[i][1];\n      this._morphFromPointsReal[i] = [];\n      this._morphToPointsReal[i] = [];\n      if (surface) {\n        var toPoints = surface;\n        var fromPoints = surface;\n        var bbox = this._bboxes[i];\n        // we only work with first area. TODO: maybe we should find the biggest one?\n        if (this.morphToSingle) {\n          //if (i != this._biggestIndex) {\n          //\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\n          //}\n        }\n        var x = bbox.x;\n        var y = bbox.y;\n        var realWidth = width;\n        var realHeight = height;\n        if (!$type.isNumber(realWidth)) {\n          realWidth = bbox.width;\n        }\n        if (!$type.isNumber(realHeight)) {\n          realHeight = bbox.height;\n        }\n        toPoints = [{\n          x: x,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y\n        }, {\n          x: x + realWidth,\n          y: y + realHeight\n        }, {\n          x: x,\n          y: y + realHeight\n        }];\n        toPoints = this.addPoints(toPoints, surface.length);\n        // if polygon has less points then count, add\n        if (surface.length < 4) {\n          for (var i_2 = surface.length; i_2 < 4; i_2++) {\n            toPoints.push({\n              x: surface[i_2].x,\n              y: surface[i_2].y\n            });\n          }\n        }\n        if (hole && hole.length > 0) {\n          var middleX = bbox.x + bbox.width / 2;\n          var middleY = bbox.y + bbox.height / 2;\n          for (var i_3 = 0, hlen = hole.length; i_3 < hlen; i_3++) {\n            toPoints.push({\n              x: middleX,\n              y: middleY\n            });\n          }\n        }\n        this._morphFromPointsReal[i][0] = fromPoints;\n        this._morphToPointsReal[i][0] = toPoints;\n      }\n    }\n    this.morphable.currentPoints = this._morphFromPointsReal;\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n    this._disposers.push(animation);\n    animation.start();\n    return animation;\n  };\n  Object.defineProperty(Morpher.prototype, \"morphProgress\", {\n    /**\r\n     * Returns the progress of morph transition.\r\n     *\r\n     * @return Progress (0-1)\r\n     */\n    get: function () {\n      return this._morphProgress;\n    },\n    /**\r\n     * Progress of the morph transition.\r\n     *\r\n     * Setting this will also trigger actual transformation.\r\n     *\r\n     * @param value  Progress (0-1)\r\n     */\n    set: function (value) {\n      this._morphProgress = value;\n      var currentPoints = [];\n      if (value != null) {\n        var fromPoints = this._morphFromPointsReal;\n        var toPoints = this._morphToPointsReal;\n        if (fromPoints != null && toPoints != null) {\n          for (var i = 0, len = fromPoints.length; i < len; i++) {\n            var currentArea = [];\n            currentPoints.push(currentArea);\n            var surfaceFrom = fromPoints[i][0];\n            var holeFrom = fromPoints[i][1];\n            var surfaceTo = toPoints[i][0];\n            var holeTo = toPoints[i][1];\n            if (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\n              var currentSurface = [];\n              for (var i_4 = 0, slen = surfaceFrom.length; i_4 < slen; i_4++) {\n                var point0 = surfaceFrom[i_4];\n                var point1 = surfaceTo[i_4];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentSurface.push(currentPoint);\n              }\n              currentArea[0] = currentSurface;\n            }\n            if (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\n              var currentHole = [];\n              for (var i_5 = 0, hlen = holeFrom.length; i_5 < hlen; i_5++) {\n                var point0 = holeFrom[i_5];\n                var point1 = holeTo[i_5];\n                var currentPoint = {\n                  x: point0.x + (point1.x * this.scaleRatio - point0.x) * value,\n                  y: point0.y + (point1.y * this.scaleRatio - point0.y) * value\n                };\n                currentHole.push(currentPoint);\n              }\n              currentArea[1] = currentHole;\n            }\n          }\n        }\n      }\n      this.morphable.currentPoints = currentPoints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Restores the polygon to its original appearance.\r\n   *\r\n   * @param duration  Duration (ms)\r\n   * @param easing    Easing function\r\n   * @return Animation\r\n   */\n  Morpher.prototype.morphBack = function (duration, easing) {\n    this._morphToPointsReal = this._morphFromPointsReal;\n    this._morphFromPointsReal = this.morphable.currentPoints;\n    if (!$type.hasValue(duration)) {\n      duration = this.morphDuration;\n    }\n    if (!$type.hasValue(easing)) {\n      easing = this.morphEasing;\n    }\n    var animation = new Animation(this, {\n      property: \"morphProgress\",\n      from: 0,\n      to: 1\n    }, duration, easing);\n    this._disposers.push(animation);\n    animation.start();\n    return animation;\n  };\n  Object.defineProperty(Morpher.prototype, \"animations\", {\n    /**\r\n     * Returns a list of morph animations currently being played.\r\n     *\r\n     * @return List of animations\r\n     */\n    get: function () {\n      if (!this._animations) {\n        this._animations = [];\n        this._disposers.push(new AnimationDisposer(this._animations));\n      }\n      return this._animations;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Morpher;\n}(BaseObject);\nexport { Morpher };","map":{"version":3,"names":["BaseObject","Animation","AnimationDisposer","$math","$ease","$type","Morpher","_super","__extends","morphable","_this","call","_bboxes","morphDuration","morphEasing","cubicOut","morphToSingle","scaleRatio","className","applyTheme","prototype","morphToPolygon","toPoints","duration","easing","points","currentPoints","sortPoints","_morphFromPointsReal","_morphToPointsReal","hasValue","normalizePoints","animation","property","from","to","_disposers","push","start","pointsA","pointsB","i","len","length","surfaceA","holeA","bboxA","getValue","getBBox","middleX","x","width","middleY","y","height","addPoints","distance","Infinity","splitAt","a","newDistance","getDistance","partA","slice","partB","concat","sort","b","bbox1","bbox2","bboxes","surface","getCommonRectangle","morphToCircle","radius","commonBBox","hole","fromPoints","bbox","realRadius","isNumber","Math","min","startAngle","getAngle","count","angle","realAngle","pointOnCircle","cos","sin","i_1","hlen","mustHaveCount","addToSegmentCount","round","newPoints","point0","point1","p","percent","extraPoint","lastPoint","morphToRectangle","realWidth","realHeight","i_2","i_3","Object","defineProperty","get","_morphProgress","set","value","currentArea","surfaceFrom","holeFrom","surfaceTo","holeTo","currentSurface","i_4","slen","currentPoint","currentHole","i_5","morphBack","_animations"],"sources":["../../../../../src/.internal/core/utils/Morpher.ts"],"sourcesContent":["/**\r\n * Morpher module contains functionality that allows morphing one polygon to\r\n * another.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObject } from \"../Base\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport { IMorphable } from \"../defs/IMorphable\";\r\nimport { IAnimatable, Animation, AnimationDisposer } from \"../utils/Animation\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $type from \"../utils/Type\";\r\n\r\n\r\n/**\r\n * Morpher can be used to morph one polygon to some other polygon.\r\n */\r\nexport class Morpher extends BaseObject implements IAnimatable {\r\n\r\n\t/**\r\n\t * An element that will be a subject for morphing.\r\n\t */\r\n\tpublic morphable: IMorphable;\r\n\r\n\t/**\r\n\t * [_morphFromPointsReal description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _morphFromPointsReal: $type.Optional<Array<Array<Array<IPoint>>>>;\r\n\r\n\t/**\r\n\t * [_morphToPointsReal description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _morphToPointsReal: $type.Optional<Array<Array<Array<IPoint>>>>;\r\n\r\n\t/**\r\n\t * [_morphToPoints description]\r\n\t *\r\n\t * @todo Description\r\n\t */\r\n\tprotected _morphToPoints: $type.Optional<Array<Array<Array<IPoint>>>>;\r\n\r\n\t/**\r\n\t * Morph progress (0-1)\r\n\t */\r\n\tprotected _morphProgress: $type.Optional<number>;\r\n\r\n\t/**\r\n\t * List of animations currently running.\r\n\t */\r\n\tprotected _animations: $type.Optional<Array<Animation>>;\r\n\r\n\t/**\r\n\t * A storage for measurements.\r\n\t */\r\n\tprotected _bboxes: IRectangle[] = [];\r\n\r\n\t/**\r\n\t * Duration of the morphing animation in milliseconds.\r\n\t */\r\n\tpublic morphDuration: number = 800;\r\n\r\n\t/**\r\n\t * An easing function to use for morphing animation.\r\n\t *\r\n\t * @see {@link Ease}\r\n\t */\r\n\tpublic morphEasing: (value: number) => number = $ease.cubicOut;\r\n\r\n\t/**\r\n\t * If set to `true`, all separate parts of the multi-part polygon will\r\n\t * morph into a single circle or polygon when using built-in methods\r\n\t * `morphToCircle()` or `morphToPolygon()`.\r\n\t *\r\n\t * Otherwise each separate part of polygon will morph to individual target\r\n\t * circle or polgyon.\r\n\t */\r\n\tpublic morphToSingle: boolean = true;\r\n\r\n\t/**\r\n\t * A ratio to scale morphed object in relation to the source object.\r\n\t */\r\n\tpublic scaleRatio: number = 1;\r\n\r\n\t/**\r\n\t * Constructor.\r\n\t *\r\n\t * @param morphable An object to morph\r\n\t */\r\n\tconstructor(morphable: IMorphable) {\r\n\t\tsuper();\r\n\t\tthis.className = \"Morpher\";\r\n\t\tthis.morphable = morphable;\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * Morphs a polygon to another polygon.\r\n\t *\r\n\t * @param toPoints  Corner points of the target shape\r\n\t * @param duration  Duration in milliseconds\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphToPolygon(toPoints: Array<Array<Array<IPoint>>>, duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this.morphable.currentPoints;\r\n\t\tif(points && toPoints){\r\n\t\t\tthis.sortPoints(points);\r\n\t\t\tthis.sortPoints(toPoints);\r\n\r\n\t\t\tthis._morphFromPointsReal = [];\r\n\t\t\tthis._morphToPointsReal = [];\r\n\r\n\t\t\tif (!$type.hasValue(duration)) {\r\n\t\t\t\tduration = this.morphDuration;\r\n\t\t\t}\r\n\r\n\t\t\tif (!$type.hasValue(easing)) {\r\n\t\t\t\teasing = this.morphEasing;\r\n\t\t\t}\r\n\r\n\t\t\tthis._morphFromPointsReal = this.normalizePoints(toPoints, points);\r\n\t\t\tthis._morphToPointsReal = this.normalizePoints(points, toPoints);\r\n\r\n\t\t\tthis.morphable.currentPoints = this._morphFromPointsReal;\r\n\r\n\t\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\t\tthis._disposers.push(animation);\r\n\t\t\tanimation.start()\r\n\t\t\treturn animation;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * [normalizePoints description]\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @todo Description\r\n\t * @param pointsA  Point A\r\n\t * @param pointsB  Point B\r\n\t * @return Normalized points\r\n\t */\r\n\tpublic normalizePoints(pointsA: Array<Array<Array<IPoint>>>, pointsB: Array<Array<Array<IPoint>>>): Array<Array<Array<IPoint>>> {\r\n\t\tfor (let i = 0, len = pointsA.length; i < len; i++) {\r\n\t\t\tlet surfaceA: Array<IPoint> = pointsA[i][0];\r\n\r\n\t\t\tlet holeA: Array<IPoint> = pointsA[i][1];\r\n\t\t\tlet bboxA: IRectangle = $type.getValue($math.getBBox(surfaceA));\r\n\r\n\t\t\tlet middleX = bboxA.x + bboxA.width;\r\n\t\t\tlet middleY = bboxA.y + bboxA.height;\r\n\r\n\t\t\t// check if we have the same in PointsB\r\n\t\t\tif (!pointsB[i]) {\r\n\t\t\t\tpointsB[i] = [];\r\n\t\t\t}\r\n\r\n\t\t\t// check if we have surface in pointsB\r\n\t\t\tif (surfaceA && !pointsB[i][0]) {\r\n\t\t\t\tpointsB[i][0] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];\r\n\t\t\t}\r\n\r\n\t\t\tif (pointsB[i][0]) {\r\n\t\t\t\tpointsB[i][0] = this.addPoints(pointsB[i][0], surfaceA.length);\r\n\r\n\t\t\t\tlet distance = Infinity;\r\n\t\t\t\tlet splitAt = 0;\r\n\r\n\t\t\t\tfor (let a = 0; a < pointsB[i][0].length; a++) {\r\n\t\t\t\t\tlet newDistance = $math.getDistance(pointsB[i][0][a], surfaceA[0]);\r\n\t\t\t\t\tif (newDistance < distance) {\r\n\t\t\t\t\t\tsplitAt = a;\r\n\t\t\t\t\t\tdistance = newDistance;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet partA = pointsB[i][0].slice(0, splitAt);\r\n\t\t\t\tlet partB = pointsB[i][0].slice(splitAt);\r\n\t\t\t\tpointsB[i][0] = partB.concat(partA);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif (holeA) {\r\n\t\t\t\tif (!pointsB[i][1]) {\r\n\t\t\t\t\tpointsB[i][1] = [{ x: middleX, y: middleY }, { x: middleX, y: middleY }];\r\n\t\t\t\t}\r\n\t\t\t\tpointsB[i][1] = this.addPoints(pointsB[i][1], holeA.length);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn pointsB;\r\n\t}\r\n\r\n\t/**\r\n\t * [sortPoints description]\r\n\t *\r\n\t * @ignore Exclude from doc\r\n\t * @todo Description\r\n\t * @param points  [description]\r\n\t * @return                        common bbox of points\r\n\t */\r\n\tpublic sortPoints(points: Array<Array<Array<IPoint>>>): $type.Optional<IRectangle> {\r\n\t\tpoints.sort(function(a, b) {\r\n\t\t\tlet bbox1: IRectangle = $type.getValue($math.getBBox(a[0]));\r\n\t\t\tlet bbox2: IRectangle = $type.getValue($math.getBBox(b[0]));\r\n\r\n\t\t\tif (bbox1.width * bbox1.height > bbox2.width * bbox2.height) {\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tlet bboxes: IRectangle[] = [];\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\tif (surface) {\r\n\t\t\t\tbboxes.push($type.getValue($math.getBBox(surface)));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn $math.getCommonRectangle(bboxes);\r\n\t}\r\n\r\n\t/**\r\n\t * Morphs polygon to a circle (it is actually a polygon which makes a circle).\r\n\t *\r\n\t * @param radius    Target circle radius (px)\r\n\t * @param duration  Duration (ms)\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphToCircle(radius?: number, duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this.morphable.points;\r\n\r\n\t\tlet commonBBox = this.sortPoints(points);\r\n\r\n\t\tthis._morphFromPointsReal = [];\r\n\t\tthis._morphToPointsReal = [];\r\n\r\n\t\tif (!$type.hasValue(duration)) {\r\n\t\t\tduration = this.morphDuration;\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(easing)) {\r\n\t\t\teasing = this.morphEasing;\r\n\t\t}\r\n\r\n\t\t// surface\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\tthis._morphFromPointsReal[i] = [];\r\n\t\t\tthis._morphToPointsReal[i] = [];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet toPoints: IPoint[] = surface;\r\n\t\t\t\tlet fromPoints: IPoint[] = surface;\r\n\t\t\t\tlet bbox: IRectangle = $type.getValue($math.getBBox(fromPoints)) // this._bboxes[i];\r\n\r\n\t\t\t\tif (this.morphToSingle) {\r\n\t\t\t\t\tbbox = $type.getValue(commonBBox);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet middleX: number = bbox.x + bbox.width / 2;\r\n\t\t\t\tlet middleY: number = bbox.y + bbox.height / 2;\r\n\t\t\t\tlet realRadius: $type.Optional<number> = radius;\r\n\t\t\t\tif (!$type.isNumber(realRadius)) {\r\n\t\t\t\t\trealRadius = Math.min(bbox.width / 2, bbox.height / 2);\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttoPoints = [];\r\n\r\n\t\t\t\t// find angle for the first point\r\n\t\t\t\tlet startAngle: number = $math.getAngle({ x: middleX, y: middleY }, surface[0]);\r\n\t\t\t\tlet count: number = 100;\r\n\r\n\t\t\t\tif (surface.length > count) {\r\n\t\t\t\t\tcount = surface.length;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfromPoints = this.addPoints(surface, count);\r\n\t\t\t\tcount = fromPoints.length; // add Points might increase number a bit\r\n\r\n\t\t\t\tlet angle: number = 360 / (count - 1);\r\n\r\n\t\t\t\tfor (let a: number = 0; a < count; a++) {\r\n\t\t\t\t\tlet realAngle: number = angle * a + startAngle;\r\n\t\t\t\t\tlet pointOnCircle: IPoint = { x: middleX + realRadius * $math.cos(realAngle), y: middleY + realRadius * $math.sin(realAngle) };\r\n\t\t\t\t\ttoPoints[a] = pointOnCircle;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tfor (let i = 0, hlen = hole.length; i < hlen; i++) {\r\n\t\t\t\t\t\ttoPoints.push({ x: middleX, y: middleY });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._morphFromPointsReal[i][0] = fromPoints;\r\n\t\t\t\tthis._morphToPointsReal[i][0] = toPoints;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.morphable.currentPoints = this._morphFromPointsReal;\r\n\r\n\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\tthis._disposers.push(animation);\r\n\t\tanimation.start()\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * [addPoints description]\r\n\t *\r\n\t * @ignore Exclude from doc\r\n\t * @todo Description\r\n\t * @param points         [description]\r\n\t * @param mustHaveCount  [description]\r\n\t * @return [description]\r\n\t */\r\n\tpublic addPoints(points: IPoint[], mustHaveCount: number): IPoint[] {\r\n\t\tlet addToSegmentCount: number = Math.round(mustHaveCount / points.length);\r\n\t\tlet newPoints: IPoint[] = [];\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet point0: IPoint = points[i];\r\n\t\t\tlet point1: IPoint;\r\n\t\t\tif (i == points.length - 1) {\r\n\t\t\t\tpoint1 = points[0];\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tpoint1 = points[i + 1];\r\n\t\t\t}\r\n\r\n\t\t\tnewPoints.push(point0);\r\n\r\n\t\t\tfor (let p: number = 1; p < addToSegmentCount; p++) {\r\n\t\t\t\tlet percent: number = p / addToSegmentCount;\r\n\t\t\t\tlet extraPoint: IPoint = { x: point0.x + (point1.x - point0.x) * percent, y: point0.y + (point1.y - point0.y) * percent }\r\n\t\t\t\tnewPoints.push(extraPoint);\r\n\t\t\t}\r\n\r\n\t\t\t// stop adding in case we already added more than left in original\r\n\t\t\tif (newPoints.length + points.length - i == mustHaveCount) {\r\n\t\t\t\taddToSegmentCount = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (newPoints.length < mustHaveCount && points.length > 0) {\r\n\t\t\tlet lastPoint: IPoint = points[points.length - 1];\r\n\t\t\tfor (let p: number = newPoints.length; p < mustHaveCount; p++) {\r\n\t\t\t\t// add same as last\r\n\t\t\t\tnewPoints.push({ x: lastPoint.x, y: lastPoint.y });\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn newPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Morphs polygon into a rectangular polygon.\r\n\t *\r\n\t * @param width     Width of the target rectangle (px)\r\n\t * @param height    Height of the target rectangle (px)\r\n\t * @param duration  Duration (ms)\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphToRectangle(width?: number, height?: number, duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tlet points: Array<Array<Array<IPoint>>> = this.morphable.points;\r\n\r\n\t\tthis.sortPoints(points);\r\n\r\n\t\tthis._morphFromPointsReal = [];\r\n\t\tthis._morphToPointsReal = [];\r\n\r\n\t\tif (!$type.hasValue(duration)) {\r\n\t\t\tduration = this.morphDuration;\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(easing)) {\r\n\t\t\teasing = this.morphEasing;\r\n\t\t}\r\n\r\n\t\t//\t\tlet biggestBBox: IRectangle = this._bboxes[this._biggestIndex];\r\n\r\n\t\t// surface\r\n\t\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\t\tlet surface: IPoint[] = points[i][0];\r\n\t\t\tlet hole: IPoint[] = points[i][1];\r\n\r\n\t\t\tthis._morphFromPointsReal[i] = [];\r\n\t\t\tthis._morphToPointsReal[i] = [];\r\n\r\n\t\t\tif (surface) {\r\n\r\n\t\t\t\tlet toPoints: IPoint[] = surface;\r\n\t\t\t\tlet fromPoints: IPoint[] = surface;\r\n\t\t\t\tlet bbox: IRectangle = this._bboxes[i];\r\n\r\n\r\n\t\t\t\t// we only work with first area. TODO: maybe we should find the biggest one?\r\n\t\t\t\tif (this.morphToSingle) {\r\n\t\t\t\t\t//if (i != this._biggestIndex) {\r\n\t\t\t\t\t//\tbbox = { x: biggestBBox.x + biggestBBox.width / 2, y: biggestBBox.y + biggestBBox.height / 2, width: 0, height: 0 };\r\n\t\t\t\t\t//}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet x: number = bbox.x;\r\n\t\t\t\tlet y: number = bbox.y;\r\n\r\n\t\t\t\tlet realWidth: $type.Optional<number> = width;\r\n\t\t\t\tlet realHeight: $type.Optional<number> = height;\r\n\r\n\t\t\t\tif (!$type.isNumber(realWidth)) {\r\n\t\t\t\t\trealWidth = bbox.width;\r\n\t\t\t\t}\r\n\t\t\t\tif (!$type.isNumber(realHeight)) {\r\n\t\t\t\t\trealHeight = bbox.height;\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttoPoints = [{ x: x, y: y }, { x: x + realWidth, y: y }, { x: x + realWidth, y: y + realHeight }, { x: x, y: y + realHeight }];\r\n\t\t\t\ttoPoints = this.addPoints(toPoints, surface.length);\r\n\r\n\t\t\t\t// if polygon has less points then count, add\r\n\t\t\t\tif (surface.length < 4) {\r\n\t\t\t\t\tfor (let i = surface.length; i < 4; i++) {\r\n\t\t\t\t\t\ttoPoints.push({ x: surface[i].x, y: surface[i].y });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (hole && hole.length > 0) {\r\n\t\t\t\t\tlet middleX: number = bbox.x + bbox.width / 2;\r\n\t\t\t\t\tlet middleY: number = bbox.y + bbox.height / 2;\r\n\r\n\t\t\t\t\tfor (let i = 0, hlen = hole.length; i < hlen; i++) {\r\n\t\t\t\t\t\ttoPoints.push({ x: middleX, y: middleY });\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis._morphFromPointsReal[i][0] = fromPoints;\r\n\t\t\t\tthis._morphToPointsReal[i][0] = toPoints;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.morphable.currentPoints = this._morphFromPointsReal;\r\n\r\n\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\tthis._disposers.push(animation);\r\n\t\tanimation.start()\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Progress of the morph transition.\r\n\t *\r\n\t * Setting this will also trigger actual transformation.\r\n\t *\r\n\t * @param value  Progress (0-1)\r\n\t */\r\n\tpublic set morphProgress(value: $type.Optional<number>) {\r\n\t\tthis._morphProgress = value;\r\n\r\n\t\tlet currentPoints: Array<Array<Array<IPoint>>> = [];\r\n\r\n\t\tif (value != null) {\r\n\t\t\tlet fromPoints: $type.Optional<Array<Array<Array<IPoint>>>> = this._morphFromPointsReal;\r\n\t\t\tlet toPoints: $type.Optional<Array<Array<Array<IPoint>>>> = this._morphToPointsReal;\r\n\r\n\t\t\tif (fromPoints != null && toPoints != null) {\r\n\r\n\t\t\t\tfor (let i = 0, len = fromPoints.length; i < len; i++) {\r\n\r\n\t\t\t\t\tlet currentArea: Array<Array<IPoint>> = [];\r\n\t\t\t\t\tcurrentPoints.push(currentArea);\r\n\r\n\t\t\t\t\tlet surfaceFrom: IPoint[] = fromPoints[i][0];\r\n\t\t\t\t\tlet holeFrom: IPoint[] = fromPoints[i][1];\r\n\r\n\t\t\t\t\tlet surfaceTo: IPoint[] = toPoints[i][0];\r\n\t\t\t\t\tlet holeTo: IPoint[] = toPoints[i][1];\r\n\r\n\t\t\t\t\tif (surfaceFrom && surfaceFrom.length > 0 && surfaceTo && surfaceTo.length > 0) {\r\n\r\n\t\t\t\t\t\tlet currentSurface: IPoint[] = [];\r\n\r\n\t\t\t\t\t\tfor (let i = 0, slen = surfaceFrom.length; i < slen; i++) {\r\n\t\t\t\t\t\t\tlet point0: IPoint = surfaceFrom[i];\r\n\t\t\t\t\t\t\tlet point1: IPoint = surfaceTo[i];\r\n\r\n\t\t\t\t\t\t\tlet currentPoint: IPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value }\r\n\r\n\t\t\t\t\t\t\tcurrentSurface.push(currentPoint);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentArea[0] = currentSurface;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (holeFrom && holeFrom.length > 0 && holeTo && holeTo.length > 0) {\r\n\t\t\t\t\t\tlet currentHole: IPoint[] = [];\r\n\t\t\t\t\t\tfor (let i = 0, hlen = holeFrom.length; i < hlen; i++) {\r\n\t\t\t\t\t\t\tlet point0: IPoint = holeFrom[i];\r\n\t\t\t\t\t\t\tlet point1: IPoint = holeTo[i];\r\n\r\n\t\t\t\t\t\t\tlet currentPoint: IPoint = { x: point0.x + (point1.x * this.scaleRatio - point0.x) * value, y: point0.y + (point1.y * this.scaleRatio - point0.y) * value }\r\n\r\n\t\t\t\t\t\t\tcurrentHole.push(currentPoint);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcurrentArea[1] = currentHole;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.morphable.currentPoints = currentPoints;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the progress of morph transition.\r\n\t *\r\n\t * @return Progress (0-1)\r\n\t */\r\n\tpublic get morphProgress(): $type.Optional<number> {\r\n\t\treturn this._morphProgress;\r\n\t}\r\n\r\n\t/**\r\n\t * Restores the polygon to its original appearance.\r\n\t *\r\n\t * @param duration  Duration (ms)\r\n\t * @param easing    Easing function\r\n\t * @return Animation\r\n\t */\r\n\tpublic morphBack(duration?: number, easing?: (value: number) => number): Animation {\r\n\t\tthis._morphToPointsReal = this._morphFromPointsReal;\r\n\t\tthis._morphFromPointsReal = this.morphable.currentPoints;\r\n\r\n\t\tif (!$type.hasValue(duration)) {\r\n\t\t\tduration = this.morphDuration;\r\n\t\t}\r\n\r\n\t\tif (!$type.hasValue(easing)) {\r\n\t\t\teasing = this.morphEasing;\r\n\t\t}\r\n\r\n\t\tlet animation = new Animation(this, { property: \"morphProgress\", from: 0, to: 1 }, duration, easing);\r\n\t\tthis._disposers.push(animation);\r\n\t\tanimation.start()\r\n\t\treturn animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a list of morph animations currently being played.\r\n\t *\r\n\t * @return List of animations\r\n\t */\r\n\tpublic get animations(): Array<Animation> {\r\n\t\tif (!this._animations) {\r\n\t\t\tthis._animations = [];\r\n\t\t\tthis._disposers.push(new AnimationDisposer(this._animations));\r\n\t\t}\r\n\t\treturn this._animations;\r\n\t}\r\n\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}