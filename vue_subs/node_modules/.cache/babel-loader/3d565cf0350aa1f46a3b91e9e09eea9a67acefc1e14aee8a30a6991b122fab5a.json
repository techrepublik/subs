{"ast":null,"code":"import { createWebHistory, createRouter } from \"vue-router\";\nimport routes from './routes';\nimport appConfig from \"../../app.config\";\nimport { useAuthStore } from '../stores/auth';\nconst router = createRouter({\n  history: createWebHistory(\"/vue/\"),\n  routes\n});\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              // Complete the redirect.\n              next(...args);\n              reject(new Error('Redirected'));\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve();\n        }\n      });\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return;\n  }\n  document.title = routeTo.meta.title + ' | ' + appConfig.title;\n  // If we reach this point, continue resolving the route.\n  next();\n});\nexport default router;","map":{"version":3,"names":["createWebHistory","createRouter","routes","appConfig","useAuthStore","router","history","beforeResolve","routeTo","routeFrom","next","route","matched","Promise","resolve","reject","meta","args","length","Error","error","document","title"],"sources":["/home/josh/Documents/projects/subs/vue_subs/src/router/index.js"],"sourcesContent":["import { createWebHistory, createRouter } from \"vue-router\";\r\nimport routes from './routes';\r\nimport appConfig from \"../../app.config\";\r\nimport { useAuthStore } from '../stores/auth';\r\n\r\n\r\nconst router = createRouter({\r\n    history: createWebHistory(\"/vue/\"),\r\n    routes,\r\n  \r\n});\r\n\r\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\r\n    // Create a `beforeResolve` hook, which fires whenever\r\n    // `beforeRouteEnter` and `beforeRouteUpdate` would. This\r\n    // allows us to ensure data is fetched even when params change,\r\n    // but the resolved route does not. We put it in `meta` to\r\n    // indicate that it's a hook we created, rather than part of\r\n    // Vue Router (yet?).\r\n    try {\r\n        // For each matched route...\r\n        for (const route of routeTo.matched) {\r\n            await new Promise((resolve, reject) => {\r\n                // If a `beforeResolve` hook is defined, call it with\r\n                // the same arguments as the `beforeEnter` hook.\r\n                if (route.meta && route.meta.beforeResolve) {\r\n                    route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\r\n                        // If the user chose to redirect...\r\n                        if (args.length) {\r\n                            // If redirecting to the same route we're coming from...\r\n                            // Complete the redirect.\r\n                            next(...args);\r\n                            reject(new Error('Redirected'));\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                } else {\r\n                    // Otherwise, continue resolving the route.\r\n                    resolve();\r\n                }\r\n            });\r\n        }\r\n        // If a `beforeResolve` hook chose to redirect, just return.\r\n    } catch (error) {\r\n        return;\r\n    }\r\n    document.title = routeTo.meta.title + ' | ' + appConfig.title;\r\n    // If we reach this point, continue resolving the route.\r\n    next();\r\n});\r\n\r\nexport default router;"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,YAAY,QAAQ,YAAY;AAC3D,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,SAAS,MAAM,kBAAkB;AACxC,SAASC,YAAY,QAAQ,gBAAgB;AAG7C,MAAMC,MAAM,GAAGJ,YAAY,CAAC;EACxBK,OAAO,EAAEN,gBAAgB,CAAC,OAAO,CAAC;EAClCE;AAEJ,CAAC,CAAC;AAEFG,MAAM,CAACE,aAAa,CAAC,OAAOC,OAAO,EAAEC,SAAS,EAAEC,IAAI,KAAK;EACrD;EACA;EACA;EACA;EACA;EACA;EACA,IAAI;IACA;IACA,KAAK,MAAMC,KAAK,IAAIH,OAAO,CAACI,OAAO,EAAE;MACjC,MAAM,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACnC;QACA;QACA,IAAIJ,KAAK,CAACK,IAAI,IAAIL,KAAK,CAACK,IAAI,CAACT,aAAa,EAAE;UACxCI,KAAK,CAACK,IAAI,CAACT,aAAa,CAACC,OAAO,EAAEC,SAAS,EAAE,CAAC,GAAGQ,IAAI,KAAK;YACtD;YACA,IAAIA,IAAI,CAACC,MAAM,EAAE;cACb;cACA;cACAR,IAAI,CAAC,GAAGO,IAAI,CAAC;cACbF,MAAM,CAAC,IAAII,KAAK,CAAC,YAAY,CAAC,CAAC;YACnC,CAAC,MAAM;cACHL,OAAO,CAAC,CAAC;YACb;UACJ,CAAC,CAAC;QACN,CAAC,MAAM;UACH;UACAA,OAAO,CAAC,CAAC;QACb;MACJ,CAAC,CAAC;IACN;IACA;EACJ,CAAC,CAAC,OAAOM,KAAK,EAAE;IACZ;EACJ;EACAC,QAAQ,CAACC,KAAK,GAAGd,OAAO,CAACQ,IAAI,CAACM,KAAK,GAAG,KAAK,GAAGnB,SAAS,CAACmB,KAAK;EAC7D;EACAZ,IAAI,CAAC,CAAC;AACV,CAAC,CAAC;AAEF,eAAeL,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}