{"ast":null,"code":"/**\r\n * Map polygon module\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { MapObject } from \"./MapObject\";\nimport { Polygon } from \"../../core/elements/Polygon\";\nimport { registry } from \"../../core/Registry\";\nimport * as $type from \"../../core/utils/Type\";\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\nimport $polylabel from \"polylabel\";\nimport * as $mapUtils from \"./MapUtils\";\nimport * as d3geo from \"d3-geo\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Used to draw a polygon on the map.\r\n *\r\n * @see {@link IMapPolygonEvents} for a list of available events\r\n * @see {@link IMapPolygonAdapters} for a list of available Adapters\r\n */\nvar MapPolygon = /** @class */function (_super) {\n  __extends(MapPolygon, _super);\n  /**\r\n   * Constructor\r\n   */\n  function MapPolygon() {\n    var _this = _super.call(this) || this;\n    _this.className = \"MapPolygon\";\n    _this.polygon = _this.createChild(Polygon);\n    _this.polygon.shouldClone = false;\n    _this.polygon.applyOnClones = true;\n    _this.setPropertyValue(\"precision\", 0.5);\n    var interfaceColors = new InterfaceColorSet();\n    _this.fill = interfaceColors.getFor(\"secondaryButton\");\n    _this.stroke = interfaceColors.getFor(\"secondaryButtonStroke\");\n    _this.strokeOpacity = 1;\n    _this.tooltipPosition = \"pointer\";\n    _this.nonScalingStroke = true;\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n  MapPolygon.prototype.getFeature = function () {\n    if (this.multiPolygon && this.multiPolygon.length > 0) {\n      return {\n        \"type\": \"Feature\",\n        geometry: {\n          type: \"MultiPolygon\",\n          coordinates: this.multiPolygon\n        }\n      };\n    }\n  };\n  Object.defineProperty(MapPolygon.prototype, \"multiGeoPolygon\", {\n    /**\r\n     * @return Polygon coordinates\r\n     */\n    get: function () {\n      var multiGeoPolygon = this.getPropertyValue(\"multiGeoPolygon\");\n      if (!multiGeoPolygon && this.dataItem) {\n        multiGeoPolygon = this.dataItem.multiGeoPolygon;\n      }\n      return multiGeoPolygon;\n    },\n    /**\r\n     * Set of coordinates for the polygon.\r\n     *\r\n     * @param multiGeoPolygon  Polygon coordinates\r\n     */\n    set: function (multiGeoPolygon) {\n      this.setPropertyValue(\"multiGeoPolygon\", multiGeoPolygon, true);\n      this.multiPolygon = $mapUtils.multiGeoPolygonToMultipolygon(multiGeoPolygon);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"multiPolygon\", {\n    /**\r\n     * @return Coordinates\r\n     */\n    get: function () {\n      var multiPolygon = this.getPropertyValue(\"multiPolygon\");\n      if (!multiPolygon && this.dataItem) {\n        multiPolygon = this.dataItem.multiPolygon;\n      }\n      return multiPolygon;\n    },\n    /**\r\n     * A collection of X/Y coordinates for a multi-part polygon. E.g.:\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   // Part 1\r\n     *   [\r\n     *     [\r\n     *       [ 100, 150 ],\r\n     *       [ 120, 200 ],\r\n     *       [ 150, 220 ],\r\n     *       [ 170, 240 ],\r\n     *       [ 100, 150 ]\r\n     *     ]\r\n     *   ],\r\n     *\r\n     *   // Part 2\r\n     *   [\r\n     *     [\r\n     *       [ 300, 350 ],\r\n     *       [ 320, 400 ],\r\n     *       [ 350, 420 ],\r\n     *       [ 370, 440 ],\r\n     *       [ 300, 350 ]\r\n     *     ]\r\n     *   ]\r\n     * ]\r\n     * ```\r\n     *\r\n     * @param multiPolygon  Coordinates\r\n     */\n    set: function (multiPolygon) {\n      if (this.setPropertyValue(\"multiPolygon\", multiPolygon)) {\n        this.updateExtremes();\n        this.invalidate();\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * (Re)validates the polygon, effectively redrawing it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  MapPolygon.prototype.validate = function () {\n    if (this.series) {\n      var projection = this.series.chart.projection;\n      var pathGenerator = projection.d3Path;\n      if (this.multiPolygon) {\n        if (this.series) {\n          var feature = {\n            type: \"MultiPolygon\",\n            coordinates: this.multiPolygon\n          };\n          projection.d3Projection.precision(this.precision);\n          this.polygon.path = pathGenerator(feature);\n        }\n        if (this.series.calculateVisualCenter) {\n          var biggestArea = 0;\n          var biggestPolygon = this.multiPolygon[0];\n          if (this.multiPolygon.length > 1) {\n            for (var i = 0; i < this.multiPolygon.length; i++) {\n              var polygon = this.multiPolygon[i];\n              var area = d3geo.geoArea({\n                type: \"Polygon\",\n                coordinates: polygon\n              });\n              if (area > biggestArea) {\n                biggestPolygon = polygon;\n                biggestArea = area;\n              }\n            }\n          }\n          var center = $polylabel(biggestPolygon);\n          this._visualLongitude = center[0];\n          this._visualLatitude = center[1];\n        } else {\n          this._visualLongitude = this.longitude;\n          this._visualLatitude = this.latitude;\n        }\n      }\n    }\n    _super.prototype.validate.call(this);\n  };\n  /**\r\n   * @ignore Exclude from docs\r\n   */\n  MapPolygon.prototype.measureElement = function () {\n    // Overriding, just to avoid extra measure\n  };\n  Object.defineProperty(MapPolygon.prototype, \"latitude\", {\n    /**\r\n     * Latitude of the geometrical center of the polygon.\r\n     *\r\n     * @readonly\r\n     * @return Center latitude\r\n     */\n    get: function () {\n      return this.north + (this.south - this.north) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"longitude\", {\n    /**\r\n     * Longitude of the geometrical center of the polygon.\r\n     *\r\n     * @readonly\r\n     * @return Center longitude\r\n     */\n    get: function () {\n      return this.east + (this.west - this.east) / 2;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"visualLatitude\", {\n    /**\r\n     * @return  Latitude\r\n     */\n    get: function () {\n      var latitude = this.getPropertyValue(\"visualLatitude\");\n      if ($type.isNumber(latitude)) {\n        return latitude;\n      }\n      if (!this._adapterO) {\n        return this._visualLatitude;\n      } else {\n        return this._adapterO.apply(\"visualLatitude\", this._visualLatitude);\n      }\n    },\n    /**\r\n     * Latitude of the visual center of the polygon.\r\n     *\r\n     * It may (and probably won't) coincide with geometrical center.\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Latitude\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"visualLatitude\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"visualLongitude\", {\n    /**\r\n     * @return  Longitude\r\n     */\n    get: function () {\n      var longitude = this.getPropertyValue(\"visualLongitude\");\n      if ($type.isNumber(longitude)) {\n        return longitude;\n      }\n      if (!this._adapterO) {\n        return this._visualLongitude;\n      } else {\n        return this._adapterO.apply(\"visualLongitude\", this._visualLongitude);\n      }\n    },\n    /**\r\n     * Longitude of the visual center of the polygon.\r\n     *\r\n     * It may (and probably won't) coincide with geometrical center.\r\n     *\r\n     * @since 4.3.0\r\n     * @param  value  Longitude\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"visualLongitude\", value);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"pixelWidth\", {\n    /**\r\n     * Not 100% sure about this, as if we add something to MapPolygon this\r\n     * won't be true, but otherwise we will get all 0 and the tooltip won't\r\n     * be positioned properly\r\n     * @hidden\r\n     */\n    /**\r\n     * Element's width in pixels.\r\n     *\r\n     * @readonly\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.polygon.pixelWidth;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(MapPolygon.prototype, \"pixelHeight\", {\n    /**\r\n     * Element's height in pixels.\r\n     *\r\n     * @readonly\r\n     * @return Width (px)\r\n     */\n    get: function () {\n      return this.polygon.pixelHeight;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Copies all properties from another instance of [[MapPolygon]].\r\n   *\r\n   * @param source  Source series\r\n   */\n  MapPolygon.prototype.copyFrom = function (source) {\n    _super.prototype.copyFrom.call(this, source);\n    this.polygon.copyFrom(source.polygon);\n  };\n  /**\r\n   * @ignore\r\n   */\n  MapPolygon.prototype.updateExtremes = function () {\n    _super.prototype.updateExtremes.call(this);\n  };\n  Object.defineProperty(MapPolygon.prototype, \"boxArea\", {\n    /**\r\n     * @ignore\r\n     * used to sorth polygons from big to small\r\n     */\n    get: function () {\n      return (this.north - this.south) * (this.east - this.west);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * X coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return X\r\n   */\n  MapPolygon.prototype.getTooltipX = function () {\n    return this.series.chart.projection.convert({\n      longitude: this.visualLongitude,\n      latitude: this.visualLatitude\n    }).x;\n  };\n  /**\r\n   * Y coordinate for the slice tooltip.\r\n   *\r\n   * @ignore\r\n   * @return Y\r\n   */\n  MapPolygon.prototype.getTooltipY = function () {\n    return this.series.chart.projection.convert({\n      longitude: this.visualLongitude,\n      latitude: this.visualLatitude\n    }).y;\n  };\n  Object.defineProperty(MapPolygon.prototype, \"precision\", {\n    get: function () {\n      return this.getPropertyValue(\"precision\");\n    },\n    /**\r\n     * When polygon's sides are plotted, they are bent according to the used\r\n     * projection.\r\n     *\r\n     * `precision` introduces a setting which can control when such bending\r\n     * occurs.\r\n     *\r\n     * If the distance (in degrees) between two points of polygon's side is less\r\n     * than `precision`, no bending will take place and the line will be straight.\r\n     *\r\n     * Set to large number (e.g. 10000) for perfectly straight lines on all\r\n     * polygon's sides.\r\n     *\r\n     * @since 4.9.1\r\n     * @default 0.5\r\n     * @param  value  Precision\r\n     */\n    set: function (value) {\n      this.setPropertyValue(\"precision\", value, true);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return MapPolygon;\n}(MapObject);\nexport { MapPolygon };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"MapPolygon\"] = MapPolygon;","map":{"version":3,"names":["MapObject","Polygon","registry","$type","InterfaceColorSet","$polylabel","$mapUtils","d3geo","MapPolygon","_super","__extends","_this","call","className","polygon","createChild","shouldClone","applyOnClones","setPropertyValue","interfaceColors","fill","getFor","stroke","strokeOpacity","tooltipPosition","nonScalingStroke","applyTheme","prototype","getFeature","multiPolygon","length","geometry","type","coordinates","Object","defineProperty","get","multiGeoPolygon","getPropertyValue","dataItem","set","multiGeoPolygonToMultipolygon","updateExtremes","invalidate","validate","series","projection","chart","pathGenerator","d3Path","feature","d3Projection","precision","path","calculateVisualCenter","biggestArea","biggestPolygon","i","area","geoArea","center","_visualLongitude","_visualLatitude","longitude","latitude","measureElement","north","south","east","west","isNumber","_adapterO","apply","value","pixelWidth","pixelHeight","copyFrom","source","getTooltipX","convert","visualLongitude","visualLatitude","x","getTooltipY","y","registeredClasses"],"sources":["../../../../../src/.internal/charts/map/MapPolygon.ts"],"sourcesContent":["/**\r\n * Map polygon module\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { MapObject, IMapObjectProperties, IMapObjectAdapters, IMapObjectEvents } from \"./MapObject\";\r\nimport { MapPolygonSeriesDataItem, MapPolygonSeries } from \"./MapPolygonSeries\";\r\nimport { IGeoPoint } from \"../../core/defs/IGeoPoint\";\r\nimport { Polygon } from \"../../core/elements/Polygon\";\r\nimport { registry } from \"../../core/Registry\";\r\nimport * as $type from \"../../core/utils/Type\";\r\nimport { InterfaceColorSet } from \"../../core/utils/InterfaceColorSet\";\r\nimport $polylabel from \"polylabel\";\r\nimport * as $mapUtils from \"./MapUtils\";\r\nimport * as d3geo from \"d3-geo\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines properties for [[MapPolygon]].\r\n */\r\nexport interface IMapPolygonProperties extends IMapObjectProperties {\r\n\r\n\t/**\r\n\t * Set of geographical coordinates for the polygon.\r\n\t */\r\n\tmultiGeoPolygon?: Array<[Array<IGeoPoint>, Array<IGeoPoint>]>;\r\n\r\n\t/**\r\n\t * Set of screen coordinates for the polygon.\r\n\t */\r\n\tmultiPolygon?: Array<Array<Array<[number, number]>>>;\r\n\r\n\t/**\r\n\t * Latitude of the visual center of the polygon.\r\n\t */\r\n\tvisualLatitude?: number;\r\n\r\n\t/**\r\n\t * Longitude of the visual center of the polygon.\r\n\t */\r\n\tvisualLongitude?: number;\r\n\r\n\t/**\r\n\t * When polygon's sides are plotted, they are bent according to the used\r\n\t * projection, to depict the shortest distance how it would go on the actual\r\n\t * land.\r\n\t *\r\n\t * `precision` introduces a setting which can control when such bending\r\n\t * occurs.\r\n\t *\r\n\t * If the distance (in degrees) between two points of polygon's side is less\r\n\t * than `precision`, no bending will take place and the line will be straight.\r\n\t *\r\n\t * Set to large number (e.g. 10000) for perfectly straight lines on all\r\n\t * polygon's sides.\r\n\t *\r\n\t * @since 4.9.1\r\n\t * @default 0.5\r\n\t */\r\n\tprecision?: number;\r\n}\r\n\r\n/**\r\n * Defines events for [[MapPolygon]].\r\n */\r\nexport interface IMapPolygonEvents extends IMapObjectEvents { }\r\n\r\n/**\r\n * Defines adapters for [[MapPolygon]].\r\n *\r\n * @see {@link Adapter}\r\n */\r\nexport interface IMapPolygonAdapters extends IMapObjectAdapters, IMapPolygonProperties { }\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Used to draw a polygon on the map.\r\n *\r\n * @see {@link IMapPolygonEvents} for a list of available events\r\n * @see {@link IMapPolygonAdapters} for a list of available Adapters\r\n */\r\nexport class MapPolygon extends MapObject {\r\n\r\n\t/**\r\n\t * Defines available properties.\r\n\t */\r\n\tpublic _properties!: IMapPolygonProperties;\r\n\r\n\t/**\r\n\t * Defines available adapters.\r\n\t */\r\n\tpublic _adapter!: IMapPolygonAdapters;\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t */\r\n\tpublic _events!: IMapPolygonEvents;\r\n\r\n\t/**\r\n\t * A visual polygon element.\r\n\t */\r\n\tpublic polygon: Polygon;\r\n\r\n\t/**\r\n\t * A related data item.\r\n\t */\r\n\tpublic _dataItem: MapPolygonSeriesDataItem;\r\n\r\n\t/**\r\n\t * A map series this object belongs to.\r\n\t */\r\n\tpublic series: MapPolygonSeries;\r\n\r\n\t/**\r\n\t * Latitude of the visual center of the polygon.\r\n\t */\r\n\tprotected _visualLatitude: number;\r\n\r\n\t/**\r\n\t * Longitude of the visual center of the polygon.\r\n\t */\r\n\tprotected _visualLongitude: number;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tthis.className = \"MapPolygon\";\r\n\r\n\t\tthis.polygon = this.createChild(Polygon);\r\n\t\tthis.polygon.shouldClone = false;\r\n\t\tthis.polygon.applyOnClones = true;\r\n\t\tthis.setPropertyValue(\"precision\", 0.5);\r\n\r\n\t\tlet interfaceColors = new InterfaceColorSet();\r\n\r\n\t\tthis.fill = interfaceColors.getFor(\"secondaryButton\");\r\n\t\tthis.stroke = interfaceColors.getFor(\"secondaryButtonStroke\");\r\n\t\tthis.strokeOpacity = 1;\r\n\r\n\t\tthis.tooltipPosition = \"pointer\";\r\n\r\n\t\tthis.nonScalingStroke = true;\r\n\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic getFeature(): { \"type\": \"Feature\", geometry: { type: \"MultiPolygon\", coordinates: Array<Array<Array<[number, number]>>> } } {\r\n\t\tif (this.multiPolygon && this.multiPolygon.length > 0) {\r\n\t\t\treturn { \"type\": \"Feature\", geometry: { type: \"MultiPolygon\", coordinates: this.multiPolygon } };\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Set of coordinates for the polygon.\r\n\t *\r\n\t * @param multiGeoPolygon  Polygon coordinates\r\n\t */\r\n\tpublic set multiGeoPolygon(multiGeoPolygon: Array<[Array<IGeoPoint>, Array<IGeoPoint>]>) {\r\n\t\tthis.setPropertyValue(\"multiGeoPolygon\", multiGeoPolygon, true);\r\n\t\tthis.multiPolygon = $mapUtils.multiGeoPolygonToMultipolygon(multiGeoPolygon);\r\n\t}\r\n\r\n\t/**\r\n\t * @return Polygon coordinates\r\n\t */\r\n\tpublic get multiGeoPolygon(): Array<[Array<IGeoPoint>, Array<IGeoPoint>]> {\r\n\t\tlet multiGeoPolygon = this.getPropertyValue(\"multiGeoPolygon\");\r\n\t\tif (!multiGeoPolygon && this.dataItem) {\r\n\t\t\tmultiGeoPolygon = this.dataItem.multiGeoPolygon;\r\n\t\t}\r\n\t\treturn multiGeoPolygon;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * A collection of X/Y coordinates for a multi-part polygon. E.g.:\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   // Part 1\r\n\t *   [\r\n\t *     [\r\n\t *       [ 100, 150 ],\r\n\t *       [ 120, 200 ],\r\n\t *       [ 150, 220 ],\r\n\t *       [ 170, 240 ],\r\n\t *       [ 100, 150 ]\r\n\t *     ]\r\n\t *   ],\r\n\t *\r\n\t *   // Part 2\r\n\t *   [\r\n\t *     [\r\n\t *       [ 300, 350 ],\r\n\t *       [ 320, 400 ],\r\n\t *       [ 350, 420 ],\r\n\t *       [ 370, 440 ],\r\n\t *       [ 300, 350 ]\r\n\t *     ]\r\n\t *   ]\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * @param multiPolygon  Coordinates\r\n\t */\r\n\tpublic set multiPolygon(multiPolygon: Array<Array<Array<[number, number]>>>) {\r\n\t\tif (this.setPropertyValue(\"multiPolygon\", multiPolygon)) {\r\n\t\t\tthis.updateExtremes();\r\n\t\t\tthis.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @return Coordinates\r\n\t */\r\n\tpublic get multiPolygon(): Array<Array<Array<[number, number]>>> {\r\n\t\tlet multiPolygon = this.getPropertyValue(\"multiPolygon\");\r\n\t\tif (!multiPolygon && this.dataItem) {\r\n\t\t\tmultiPolygon = this.dataItem.multiPolygon;\r\n\t\t}\r\n\t\treturn multiPolygon;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * (Re)validates the polygon, effectively redrawing it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic validate(): void {\r\n\t\tif (this.series) {\r\n\t\t\tlet projection = this.series.chart.projection;\r\n\r\n\t\t\tlet pathGenerator = projection.d3Path;\r\n\r\n\t\t\tif (this.multiPolygon) {\r\n\r\n\t\t\t\tif (this.series) {\r\n\t\t\t\t\tlet feature = { type: \"MultiPolygon\", coordinates: this.multiPolygon };\r\n\r\n\t\t\t\t\tprojection.d3Projection.precision(this.precision);\r\n\t\t\t\t\tthis.polygon.path = pathGenerator(<any>feature);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.series.calculateVisualCenter) {\r\n\t\t\t\t\tlet biggestArea = 0;\r\n\t\t\t\t\tlet biggestPolygon = this.multiPolygon[0];\r\n\r\n\t\t\t\t\tif (this.multiPolygon.length > 1) {\r\n\t\t\t\t\t\tfor (let i = 0; i < this.multiPolygon.length; i++) {\r\n\t\t\t\t\t\t\tlet polygon = this.multiPolygon[i];\r\n\t\t\t\t\t\t\tlet area = d3geo.geoArea({ type: \"Polygon\", coordinates: polygon });\r\n\r\n\t\t\t\t\t\t\tif (area > biggestArea) {\r\n\t\t\t\t\t\t\t\tbiggestPolygon = polygon;\r\n\t\t\t\t\t\t\t\tbiggestArea = area;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet center = $polylabel(biggestPolygon);\r\n\r\n\t\t\t\t\tthis._visualLongitude = center[0];\r\n\t\t\t\t\tthis._visualLatitude = center[1];\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tthis._visualLongitude = this.longitude;\r\n\t\t\t\t\tthis._visualLatitude = this.latitude;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tsuper.validate();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic measureElement(): void {\r\n\t\t// Overriding, just to avoid extra measure\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the geometrical center of the polygon.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center latitude\r\n\t */\r\n\tpublic get latitude(): number {\r\n\t\treturn this.north + (this.south - this.north) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the geometrical center of the polygon.\r\n\t *\r\n\t * @readonly\r\n\t * @return Center longitude\r\n\t */\r\n\tpublic get longitude(): number {\r\n\t\treturn this.east + (this.west - this.east) / 2;\r\n\t}\r\n\r\n\t/**\r\n\t * Latitude of the visual center of the polygon.\r\n\t *\r\n\t * It may (and probably won't) coincide with geometrical center.\r\n\t *\r\n\t * @since 4.3.0\r\n\t * @param  value  Latitude\r\n\t */\r\n\tpublic set visualLatitude(value: number) {\r\n\t\tthis.setPropertyValue(\"visualLatitude\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return  Latitude\r\n\t */\r\n\tpublic get visualLatitude(): number {\r\n\t\tlet latitude = this.getPropertyValue(\"visualLatitude\");\r\n\t\tif ($type.isNumber(latitude)) {\r\n\t\t\treturn (latitude);\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn this._visualLatitude;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\r\n\t\t\t\t\"visualLatitude\",\r\n\t\t\t\tthis._visualLatitude\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Longitude of the visual center of the polygon.\r\n\t *\r\n\t * It may (and probably won't) coincide with geometrical center.\r\n\t *\r\n\t * @since 4.3.0\r\n\t * @param  value  Longitude\r\n\t */\r\n\tpublic set visualLongitude(value: number) {\r\n\t\tthis.setPropertyValue(\"visualLongitude\", value);\r\n\t}\r\n\r\n\t/**\r\n\t * @return  Longitude\r\n\t */\r\n\tpublic get visualLongitude(): number {\r\n\t\tlet longitude = this.getPropertyValue(\"visualLongitude\");\r\n\t\tif ($type.isNumber(longitude)) {\r\n\t\t\treturn (longitude);\r\n\t\t}\r\n\t\tif (!this._adapterO) {\r\n\t\t\treturn this._visualLongitude;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn this._adapterO.apply(\r\n\t\t\t\t\"visualLongitude\",\r\n\t\t\t\tthis._visualLongitude\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Not 100% sure about this, as if we add something to MapPolygon this\r\n\t * won't be true, but otherwise we will get all 0 and the tooltip won't\r\n\t * be positioned properly\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Element's width in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return Width (px)\r\n\t */\r\n\tpublic get pixelWidth(): number {\r\n\t\treturn this.polygon.pixelWidth;\r\n\t}\r\n\r\n\t/**\r\n\t * Element's height in pixels.\r\n\t *\r\n\t * @readonly\r\n\t * @return Width (px)\r\n\t */\r\n\tpublic get pixelHeight(): number {\r\n\t\treturn this.polygon.pixelHeight;\r\n\t}\r\n\r\n\t/**\r\n\t * Copies all properties from another instance of [[MapPolygon]].\r\n\t *\r\n\t * @param source  Source series\r\n\t */\r\n\tpublic copyFrom(source: this) {\r\n\t\tsuper.copyFrom(source);\r\n\t\tthis.polygon.copyFrom(source.polygon);\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t */\r\n\tpublic updateExtremes() {\r\n\t\tsuper.updateExtremes();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore\r\n\t * used to sorth polygons from big to small\r\n\t */\r\n\tpublic get boxArea() {\r\n\t\treturn (this.north - this.south) * (this.east - this.west);\r\n\t}\r\n\r\n\t/**\r\n\t * X coordinate for the slice tooltip.\r\n\t *\r\n\t * @ignore\r\n\t * @return X\r\n\t */\r\n\tpublic getTooltipX(): number {\r\n\t\treturn this.series.chart.projection.convert({ longitude: this.visualLongitude, latitude: this.visualLatitude }).x;\r\n\t}\r\n\r\n\t/**\r\n\t * Y coordinate for the slice tooltip.\r\n\t *\r\n\t * @ignore\r\n\t * @return Y\r\n\t */\r\n\tpublic getTooltipY(): number {\r\n\t\treturn this.series.chart.projection.convert({ longitude: this.visualLongitude, latitude: this.visualLatitude }).y\r\n\t}\r\n\r\n\t/**\r\n\t * When polygon's sides are plotted, they are bent according to the used\r\n\t * projection.\r\n\t *\r\n\t * `precision` introduces a setting which can control when such bending\r\n\t * occurs.\r\n\t *\r\n\t * If the distance (in degrees) between two points of polygon's side is less\r\n\t * than `precision`, no bending will take place and the line will be straight.\r\n\t *\r\n\t * Set to large number (e.g. 10000) for perfectly straight lines on all\r\n\t * polygon's sides.\r\n\t *\r\n\t * @since 4.9.1\r\n\t * @default 0.5\r\n\t * @param  value  Precision\r\n\t */\r\n\tpublic set precision(value: number) {\r\n\t\tthis.setPropertyValue(\"precision\", value, true);\r\n\t}\r\n\r\n\tpublic get precision(): number {\r\n\t\treturn this.getPropertyValue(\"precision\");\r\n\t}\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"MapPolygon\"] = MapPolygon;\r\n"],"mappings":"AAAA;;;;AAIA;;;;;;AAMA,SAASA,SAAS,QAAoE,aAAa;AAGnG,SAASC,OAAO,QAAQ,6BAA6B;AACrD,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,OAAO,KAAKC,KAAK,MAAM,uBAAuB;AAC9C,SAASC,iBAAiB,QAAQ,oCAAoC;AACtE,OAAOC,UAAU,MAAM,WAAW;AAClC,OAAO,KAAKC,SAAS,MAAM,YAAY;AACvC,OAAO,KAAKC,KAAK,MAAM,QAAQ;AAoE/B;;;;;;AAOA;;;;;;AAMA,IAAAC,UAAA,0BAAAC,MAAA;EAAgCC,SAAA,CAAAF,UAAA,EAAAC,MAAA;EA0C/B;;;EAGA,SAAAD,WAAA;IAAA,IAAAG,KAAA,GACCF,MAAA,CAAAG,IAAA,MAAO;IAEPD,KAAI,CAACE,SAAS,GAAG,YAAY;IAE7BF,KAAI,CAACG,OAAO,GAAGH,KAAI,CAACI,WAAW,CAACd,OAAO,CAAC;IACxCU,KAAI,CAACG,OAAO,CAACE,WAAW,GAAG,KAAK;IAChCL,KAAI,CAACG,OAAO,CAACG,aAAa,GAAG,IAAI;IACjCN,KAAI,CAACO,gBAAgB,CAAC,WAAW,EAAE,GAAG,CAAC;IAEvC,IAAIC,eAAe,GAAG,IAAIf,iBAAiB,EAAE;IAE7CO,KAAI,CAACS,IAAI,GAAGD,eAAe,CAACE,MAAM,CAAC,iBAAiB,CAAC;IACrDV,KAAI,CAACW,MAAM,GAAGH,eAAe,CAACE,MAAM,CAAC,uBAAuB,CAAC;IAC7DV,KAAI,CAACY,aAAa,GAAG,CAAC;IAEtBZ,KAAI,CAACa,eAAe,GAAG,SAAS;IAEhCb,KAAI,CAACc,gBAAgB,GAAG,IAAI;IAE5Bd,KAAI,CAACe,UAAU,EAAE;;EAClB;EAEA;;;EAGOlB,UAAA,CAAAmB,SAAA,CAAAC,UAAU,GAAjB;IACC,IAAI,IAAI,CAACC,YAAY,IAAI,IAAI,CAACA,YAAY,CAACC,MAAM,GAAG,CAAC,EAAE;MACtD,OAAO;QAAE,MAAM,EAAE,SAAS;QAAEC,QAAQ,EAAE;UAAEC,IAAI,EAAE,cAAc;UAAEC,WAAW,EAAE,IAAI,CAACJ;QAAY;MAAE,CAAE;;EAElG,CAAC;EAODK,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,mBAAe;IAK1B;;;SAGA,SAAAS,CAAA;MACC,IAAIC,eAAe,GAAG,IAAI,CAACC,gBAAgB,CAAC,iBAAiB,CAAC;MAC9D,IAAI,CAACD,eAAe,IAAI,IAAI,CAACE,QAAQ,EAAE;QACtCF,eAAe,GAAG,IAAI,CAACE,QAAQ,CAACF,eAAe;;MAEhD,OAAOA,eAAe;IACvB,CAAC;IAnBD;;;;;SAKA,SAAAG,CAA2BH,eAA4D;MACtF,IAAI,CAACnB,gBAAgB,CAAC,iBAAiB,EAAEmB,eAAe,EAAE,IAAI,CAAC;MAC/D,IAAI,CAACR,YAAY,GAAGvB,SAAS,CAACmC,6BAA6B,CAACJ,eAAe,CAAC;IAC7E,CAAC;;;;EA6CDH,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,gBAAY;IAOvB;;;SAGA,SAAAS,CAAA;MACC,IAAIP,YAAY,GAAG,IAAI,CAACS,gBAAgB,CAAC,cAAc,CAAC;MACxD,IAAI,CAACT,YAAY,IAAI,IAAI,CAACU,QAAQ,EAAE;QACnCV,YAAY,GAAG,IAAI,CAACU,QAAQ,CAACV,YAAY;;MAE1C,OAAOA,YAAY;IACpB,CAAC;IA/CD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SA+BA,SAAAW,CAAwBX,YAAmD;MAC1E,IAAI,IAAI,CAACX,gBAAgB,CAAC,cAAc,EAAEW,YAAY,CAAC,EAAE;QACxD,IAAI,CAACa,cAAc,EAAE;QACrB,IAAI,CAACC,UAAU,EAAE;;IAEnB,CAAC;;;;EAcD;;;;;EAKOnC,UAAA,CAAAmB,SAAA,CAAAiB,QAAQ,GAAf;IACC,IAAI,IAAI,CAACC,MAAM,EAAE;MAChB,IAAIC,UAAU,GAAG,IAAI,CAACD,MAAM,CAACE,KAAK,CAACD,UAAU;MAE7C,IAAIE,aAAa,GAAGF,UAAU,CAACG,MAAM;MAErC,IAAI,IAAI,CAACpB,YAAY,EAAE;QAEtB,IAAI,IAAI,CAACgB,MAAM,EAAE;UAChB,IAAIK,OAAO,GAAG;YAAElB,IAAI,EAAE,cAAc;YAAEC,WAAW,EAAE,IAAI,CAACJ;UAAY,CAAE;UAEtEiB,UAAU,CAACK,YAAY,CAACC,SAAS,CAAC,IAAI,CAACA,SAAS,CAAC;UACjD,IAAI,CAACtC,OAAO,CAACuC,IAAI,GAAGL,aAAa,CAAME,OAAO,CAAC;;QAGhD,IAAI,IAAI,CAACL,MAAM,CAACS,qBAAqB,EAAE;UACtC,IAAIC,WAAW,GAAG,CAAC;UACnB,IAAIC,cAAc,GAAG,IAAI,CAAC3B,YAAY,CAAC,CAAC,CAAC;UAEzC,IAAI,IAAI,CAACA,YAAY,CAACC,MAAM,GAAG,CAAC,EAAE;YACjC,KAAK,IAAI2B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC5B,YAAY,CAACC,MAAM,EAAE2B,CAAC,EAAE,EAAE;cAClD,IAAI3C,OAAO,GAAG,IAAI,CAACe,YAAY,CAAC4B,CAAC,CAAC;cAClC,IAAIC,IAAI,GAAGnD,KAAK,CAACoD,OAAO,CAAC;gBAAE3B,IAAI,EAAE,SAAS;gBAAEC,WAAW,EAAEnB;cAAO,CAAE,CAAC;cAEnE,IAAI4C,IAAI,GAAGH,WAAW,EAAE;gBACvBC,cAAc,GAAG1C,OAAO;gBACxByC,WAAW,GAAGG,IAAI;;;;UAKrB,IAAIE,MAAM,GAAGvD,UAAU,CAACmD,cAAc,CAAC;UAEvC,IAAI,CAACK,gBAAgB,GAAGD,MAAM,CAAC,CAAC,CAAC;UACjC,IAAI,CAACE,eAAe,GAAGF,MAAM,CAAC,CAAC,CAAC;SAChC,MACI;UACJ,IAAI,CAACC,gBAAgB,GAAG,IAAI,CAACE,SAAS;UACtC,IAAI,CAACD,eAAe,GAAG,IAAI,CAACE,QAAQ;;;;IAKvCvD,MAAA,CAAAkB,SAAA,CAAMiB,QAAQ,CAAAhC,IAAA,MAAE;EACjB,CAAC;EAED;;;EAGOJ,UAAA,CAAAmB,SAAA,CAAAsC,cAAc,GAArB;IACC;EAAA,CACA;EAQD/B,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,YAAQ;IANnB;;;;;;SAMA,SAAAS,CAAA;MACC,OAAO,IAAI,CAAC8B,KAAK,GAAG,CAAC,IAAI,CAACC,KAAK,GAAG,IAAI,CAACD,KAAK,IAAI,CAAC;IAClD,CAAC;;;;EAQDhC,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,aAAS;IANpB;;;;;;SAMA,SAAAS,CAAA;MACC,OAAO,IAAI,CAACgC,IAAI,GAAG,CAAC,IAAI,CAACC,IAAI,GAAG,IAAI,CAACD,IAAI,IAAI,CAAC;IAC/C,CAAC;;;;EAUDlC,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,kBAAc;IAIzB;;;SAGA,SAAAS,CAAA;MACC,IAAI4B,QAAQ,GAAG,IAAI,CAAC1B,gBAAgB,CAAC,gBAAgB,CAAC;MACtD,IAAInC,KAAK,CAACmE,QAAQ,CAACN,QAAQ,CAAC,EAAE;QAC7B,OAAQA,QAAQ;;MAEjB,IAAI,CAAC,IAAI,CAACO,SAAS,EAAE;QACpB,OAAO,IAAI,CAACT,eAAe;OAC3B,MACI;QACJ,OAAO,IAAI,CAACS,SAAS,CAACC,KAAK,CAC1B,gBAAgB,EAChB,IAAI,CAACV,eAAe,CACpB;;IAEH,CAAC;IA7BD;;;;;;;;SAQA,SAAAtB,CAA0BiC,KAAa;MACtC,IAAI,CAACvD,gBAAgB,CAAC,gBAAgB,EAAEuD,KAAK,CAAC;IAC/C,CAAC;;;;EA6BDvC,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,mBAAe;IAI1B;;;SAGA,SAAAS,CAAA;MACC,IAAI2B,SAAS,GAAG,IAAI,CAACzB,gBAAgB,CAAC,iBAAiB,CAAC;MACxD,IAAInC,KAAK,CAACmE,QAAQ,CAACP,SAAS,CAAC,EAAE;QAC9B,OAAQA,SAAS;;MAElB,IAAI,CAAC,IAAI,CAACQ,SAAS,EAAE;QACpB,OAAO,IAAI,CAACV,gBAAgB;OAC5B,MACI;QACJ,OAAO,IAAI,CAACU,SAAS,CAACC,KAAK,CAC1B,iBAAiB,EACjB,IAAI,CAACX,gBAAgB,CACrB;;IAEH,CAAC;IA7BD;;;;;;;;SAQA,SAAArB,CAA2BiC,KAAa;MACvC,IAAI,CAACvD,gBAAgB,CAAC,iBAAiB,EAAEuD,KAAK,CAAC;IAChD,CAAC;;;;EAmCDvC,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,cAAU;IAbrB;;;;;;IAOA;;;;;;SAMA,SAAAS,CAAA;MACC,OAAO,IAAI,CAACtB,OAAO,CAAC4D,UAAU;IAC/B,CAAC;;;;EAQDxC,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,eAAW;IANtB;;;;;;SAMA,SAAAS,CAAA;MACC,OAAO,IAAI,CAACtB,OAAO,CAAC6D,WAAW;IAChC,CAAC;;;;EAED;;;;;EAKOnE,UAAA,CAAAmB,SAAA,CAAAiD,QAAQ,GAAf,UAAgBC,MAAY;IAC3BpE,MAAA,CAAAkB,SAAA,CAAMiD,QAAQ,CAAAhE,IAAA,OAACiE,MAAM,CAAC;IACtB,IAAI,CAAC/D,OAAO,CAAC8D,QAAQ,CAACC,MAAM,CAAC/D,OAAO,CAAC;EACtC,CAAC;EAED;;;EAGON,UAAA,CAAAmB,SAAA,CAAAe,cAAc,GAArB;IACCjC,MAAA,CAAAkB,SAAA,CAAMe,cAAc,CAAA9B,IAAA,MAAE;EACvB,CAAC;EAMDsB,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,WAAO;IAJlB;;;;SAIA,SAAAS,CAAA;MACC,OAAO,CAAC,IAAI,CAAC8B,KAAK,GAAG,IAAI,CAACC,KAAK,KAAK,IAAI,CAACC,IAAI,GAAG,IAAI,CAACC,IAAI,CAAC;IAC3D,CAAC;;;;EAED;;;;;;EAMO7D,UAAA,CAAAmB,SAAA,CAAAmD,WAAW,GAAlB;IACC,OAAO,IAAI,CAACjC,MAAM,CAACE,KAAK,CAACD,UAAU,CAACiC,OAAO,CAAC;MAAEhB,SAAS,EAAE,IAAI,CAACiB,eAAe;MAAEhB,QAAQ,EAAE,IAAI,CAACiB;IAAc,CAAE,CAAC,CAACC,CAAC;EAClH,CAAC;EAED;;;;;;EAMO1E,UAAA,CAAAmB,SAAA,CAAAwD,WAAW,GAAlB;IACC,OAAO,IAAI,CAACtC,MAAM,CAACE,KAAK,CAACD,UAAU,CAACiC,OAAO,CAAC;MAAEhB,SAAS,EAAE,IAAI,CAACiB,eAAe;MAAEhB,QAAQ,EAAE,IAAI,CAACiB;IAAc,CAAE,CAAC,CAACG,CAAC;EAClH,CAAC;EAmBDlD,MAAA,CAAAC,cAAA,CAAW3B,UAAA,CAAAmB,SAAA,aAAS;SAIpB,SAAAS,CAAA;MACC,OAAO,IAAI,CAACE,gBAAgB,CAAC,WAAW,CAAC;IAC1C,CAAC;IAvBD;;;;;;;;;;;;;;;;;SAiBA,SAAAE,CAAqBiC,KAAa;MACjC,IAAI,CAACvD,gBAAgB,CAAC,WAAW,EAAEuD,KAAK,EAAE,IAAI,CAAC;IAChD,CAAC;;;;EAKF,OAAAjE,UAAC;AAAD,CAAC,CAlY+BR,SAAS;;AAoYzC;;;;;;AAMAE,QAAQ,CAACmF,iBAAiB,CAAC,YAAY,CAAC,GAAG7E,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}