{"ast":null,"code":"import { createWebHistory, createRouter } from \"vue-router\";\nimport routes from './routes';\nimport appConfig from \"../../app.config\";\n// import { useAuthStore } from '../stores/auth';\n\nconst router = createRouter({\n  history: createWebHistory(\"/vue/\"),\n  routes\n});\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\n  // Create a `beforeResolve` hook, which fires whenever\n  // `beforeRouteEnter` and `beforeRouteUpdate` would. This\n  // allows us to ensure data is fetched even when params change,\n  // but the resolved route does not. We put it in `meta` to\n  // indicate that it's a hook we created, rather than part of\n  // Vue Router (yet?).\n  try {\n    // For each matched route...\n    for (const route of routeTo.matched) {\n      await new Promise((resolve, reject) => {\n        // If a `beforeResolve` hook is defined, call it with\n        // the same arguments as the `beforeEnter` hook.\n        if (route.meta && route.meta.beforeResolve) {\n          route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\n            // If the user chose to redirect...\n            if (args.length) {\n              // If redirecting to the same route we're coming from...\n              // Complete the redirect.\n              next(...args);\n              reject(new Error('Redirected'));\n            } else {\n              resolve();\n            }\n          });\n        } else {\n          // Otherwise, continue resolving the route.\n          resolve();\n        }\n      });\n    }\n    // If a `beforeResolve` hook chose to redirect, just return.\n  } catch (error) {\n    return;\n  }\n  document.title = routeTo.meta.title + ' | ' + appConfig.title;\n  // If we reach this point, continue resolving the route.\n  next();\n});\nrouter.beforeEach(async to => {\n  // clear alert on route change\n  // const alertStore = useAlertStore();\n  // alertStore.clear();\n\n  // redirect to login page if not logged in and trying to access a restricted page \n  const publicPages = ['/account/login', '/account/register'];\n  const authRequired = !publicPages.includes(to.path);\n  const authStore = useAuthStore();\n  if (authRequired && !authStore.user) {\n    authStore.returnUrl = to.fullPath;\n    return '/account/login';\n  }\n});\nexport default router;","map":{"version":3,"names":["createWebHistory","createRouter","routes","appConfig","router","history","beforeResolve","routeTo","routeFrom","next","route","matched","Promise","resolve","reject","meta","args","length","Error","error","document","title","beforeEach","to","publicPages","authRequired","includes","path","authStore","useAuthStore","user","returnUrl","fullPath"],"sources":["/home/josh/Documents/projects/subs/vue_subs/src/router/index.js"],"sourcesContent":["import { createWebHistory, createRouter } from \"vue-router\";\r\nimport routes from './routes';\r\nimport appConfig from \"../../app.config\";\r\n// import { useAuthStore } from '../stores/auth';\r\n\r\n\r\nconst router = createRouter({\r\n    history: createWebHistory(\"/vue/\"),\r\n    routes,\r\n  \r\n});\r\n\r\nrouter.beforeResolve(async (routeTo, routeFrom, next) => {\r\n    // Create a `beforeResolve` hook, which fires whenever\r\n    // `beforeRouteEnter` and `beforeRouteUpdate` would. This\r\n    // allows us to ensure data is fetched even when params change,\r\n    // but the resolved route does not. We put it in `meta` to\r\n    // indicate that it's a hook we created, rather than part of\r\n    // Vue Router (yet?).\r\n    try {\r\n        // For each matched route...\r\n        for (const route of routeTo.matched) {\r\n            await new Promise((resolve, reject) => {\r\n                // If a `beforeResolve` hook is defined, call it with\r\n                // the same arguments as the `beforeEnter` hook.\r\n                if (route.meta && route.meta.beforeResolve) {\r\n                    route.meta.beforeResolve(routeTo, routeFrom, (...args) => {\r\n                        // If the user chose to redirect...\r\n                        if (args.length) {\r\n                            // If redirecting to the same route we're coming from...\r\n                            // Complete the redirect.\r\n                            next(...args);\r\n                            reject(new Error('Redirected'));\r\n                        } else {\r\n                            resolve();\r\n                        }\r\n                    });\r\n                } else {\r\n                    // Otherwise, continue resolving the route.\r\n                    resolve();\r\n                }\r\n            });\r\n        }\r\n        // If a `beforeResolve` hook chose to redirect, just return.\r\n    } catch (error) {\r\n        return;\r\n    }\r\n    document.title = routeTo.meta.title + ' | ' + appConfig.title;\r\n    // If we reach this point, continue resolving the route.\r\n    next();\r\n});\r\n\r\nrouter.beforeEach(async (to) => {\r\n    // clear alert on route change\r\n    // const alertStore = useAlertStore();\r\n    // alertStore.clear();\r\n\r\n    // redirect to login page if not logged in and trying to access a restricted page \r\n    const publicPages = ['/account/login', '/account/register'];\r\n    const authRequired = !publicPages.includes(to.path);\r\n    const authStore = useAuthStore();\r\n\r\n    if (authRequired && !authStore.user) {\r\n        authStore.returnUrl = to.fullPath;\r\n        return '/account/login';\r\n    }\r\n});\r\n\r\nexport default router;"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,YAAY,QAAQ,YAAY;AAC3D,OAAOC,MAAM,MAAM,UAAU;AAC7B,OAAOC,SAAS,MAAM,kBAAkB;AACxC;;AAGA,MAAMC,MAAM,GAAGH,YAAY,CAAC;EACxBI,OAAO,EAAEL,gBAAgB,CAAC,OAAO,CAAC;EAClCE;AAEJ,CAAC,CAAC;AAEFE,MAAM,CAACE,aAAa,CAAC,OAAOC,OAAO,EAAEC,SAAS,EAAEC,IAAI,KAAK;EACrD;EACA;EACA;EACA;EACA;EACA;EACA,IAAI;IACA;IACA,KAAK,MAAMC,KAAK,IAAIH,OAAO,CAACI,OAAO,EAAE;MACjC,MAAM,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;QACnC;QACA;QACA,IAAIJ,KAAK,CAACK,IAAI,IAAIL,KAAK,CAACK,IAAI,CAACT,aAAa,EAAE;UACxCI,KAAK,CAACK,IAAI,CAACT,aAAa,CAACC,OAAO,EAAEC,SAAS,EAAE,CAAC,GAAGQ,IAAI,KAAK;YACtD;YACA,IAAIA,IAAI,CAACC,MAAM,EAAE;cACb;cACA;cACAR,IAAI,CAAC,GAAGO,IAAI,CAAC;cACbF,MAAM,CAAC,IAAII,KAAK,CAAC,YAAY,CAAC,CAAC;YACnC,CAAC,MAAM;cACHL,OAAO,CAAC,CAAC;YACb;UACJ,CAAC,CAAC;QACN,CAAC,MAAM;UACH;UACAA,OAAO,CAAC,CAAC;QACb;MACJ,CAAC,CAAC;IACN;IACA;EACJ,CAAC,CAAC,OAAOM,KAAK,EAAE;IACZ;EACJ;EACAC,QAAQ,CAACC,KAAK,GAAGd,OAAO,CAACQ,IAAI,CAACM,KAAK,GAAG,KAAK,GAAGlB,SAAS,CAACkB,KAAK;EAC7D;EACAZ,IAAI,CAAC,CAAC;AACV,CAAC,CAAC;AAEFL,MAAM,CAACkB,UAAU,CAAC,MAAOC,EAAE,IAAK;EAC5B;EACA;EACA;;EAEA;EACA,MAAMC,WAAW,GAAG,CAAC,gBAAgB,EAAE,mBAAmB,CAAC;EAC3D,MAAMC,YAAY,GAAG,CAACD,WAAW,CAACE,QAAQ,CAACH,EAAE,CAACI,IAAI,CAAC;EACnD,MAAMC,SAAS,GAAGC,YAAY,CAAC,CAAC;EAEhC,IAAIJ,YAAY,IAAI,CAACG,SAAS,CAACE,IAAI,EAAE;IACjCF,SAAS,CAACG,SAAS,GAAGR,EAAE,CAACS,QAAQ;IACjC,OAAO,gBAAgB;EAC3B;AACJ,CAAC,CAAC;AAEF,eAAe5B,MAAM","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}