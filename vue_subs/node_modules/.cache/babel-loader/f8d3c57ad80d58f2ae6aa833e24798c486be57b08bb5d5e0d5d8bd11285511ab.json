{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/esnext.iterator.constructor.js\";\nimport \"core-js/modules/esnext.iterator.filter.js\";\nimport \"core-js/modules/esnext.iterator.map.js\";\nvar epsilon = 1e-4,\n  epsilonInverse = 1e4,\n  x0 = -180,\n  x0e = x0 + epsilon,\n  x1 = 180,\n  x1e = x1 - epsilon,\n  y0 = -90,\n  y0e = y0 + epsilon,\n  y1 = 90,\n  y1e = y1 - epsilon;\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\nfunction clampPoint(p) {\n  var x = p[0],\n    y = p[1],\n    clamped = false;\n  if (x <= x0e) x = x0, clamped = true;else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice();\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push({\n      index: -1,\n      polygon: polygon,\n      ring: ring\n    });\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n        x = point[0],\n        y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n            xk = pointk[0],\n            yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = {\n            index: -1,\n            polygon: polygon,\n            ring: ring.slice(0, i + 1)\n          };\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push({\n          index: -1,\n          polygon: polygon,\n          ring: ring = ring.slice(k - 1)\n        });\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n}\n\n// Now stitch the fragments back together into rings.\nfunction stitchFragments(fragments) {\n  var i,\n    n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n    fragmentByEnd = {},\n    fragment,\n    start,\n    startFragment,\n    end,\n    endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = {\n          index: -1,\n          polygon: startFragment.polygon,\n          ring: startFragment.ring.concat(fragment.ring)\n        };\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n        fragment = {\n          index: n++,\n          polygon: endFragment.polygon,\n          ring: fragment.ring.concat(endFragment.ring)\n        };\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\nfunction stitchFeature(input) {\n  var output = {\n    type: \"Feature\",\n    geometry: stitchGeometry(input.geometry)\n  };\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n  switch (input.type) {\n    case \"GeometryCollection\":\n      output = {\n        type: \"GeometryCollection\",\n        geometries: input.geometries.map(stitchGeometry)\n      };\n      break;\n    case \"Point\":\n      output = {\n        type: \"Point\",\n        coordinates: clampPoint(input.coordinates)\n      };\n      break;\n    case \"MultiPoint\":\n    case \"LineString\":\n      output = {\n        type: input.type,\n        coordinates: clampPoints(input.coordinates)\n      };\n      break;\n    case \"MultiLineString\":\n      output = {\n        type: \"MultiLineString\",\n        coordinates: input.coordinates.map(clampPoints)\n      };\n      break;\n    case \"Polygon\":\n      {\n        var polygon = [];\n        extractFragments(input.coordinates, polygon, fragments = []);\n        stitchFragments(fragments);\n        output = {\n          type: \"Polygon\",\n          coordinates: polygon\n        };\n        break;\n      }\n    case \"MultiPolygon\":\n      {\n        fragments = [], i = -1, n = input.coordinates.length;\n        var polygons = new Array(n);\n        while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n        stitchFragments(fragments);\n        output = {\n          type: \"MultiPolygon\",\n          coordinates: polygons.filter(nonempty)\n        };\n        break;\n      }\n    default:\n      return input;\n  }\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\nexport default function (input) {\n  if (input == null) return input;\n  switch (input.type) {\n    case \"Feature\":\n      return stitchFeature(input);\n    case \"FeatureCollection\":\n      {\n        var output = {\n          type: \"FeatureCollection\",\n          features: input.features.map(stitchFeature)\n        };\n        if (input.bbox != null) output.bbox = input.bbox;\n        return output;\n      }\n    default:\n      return stitchGeometry(input);\n  }\n}","map":{"version":3,"names":["epsilon","epsilonInverse","x0","x0e","x1","x1e","y0","y0e","y1","y1e","nonempty","coordinates","length","quantize","x","Math","floor","normalizePoint","y","clampPoint","p","clamped","clampPoints","points","map","extractFragments","rings","polygon","fragments","j","m","ring","slice","push","index","i","n","point","k","pointk","xk","yk","fragmentBefore","pop","stitchFragments","fragmentByStart","fragmentByEnd","fragment","start","startFragment","end","endFragment","concat","stitchFeature","input","output","type","geometry","stitchGeometry","id","bbox","properties","geometries","polygons","Array","filter","features"],"sources":["/home/josh/Documents/projects/subs/vue_subs/node_modules/d3-geo-projection/src/stitch.js"],"sourcesContent":["var epsilon = 1e-4,\n    epsilonInverse = 1e4,\n    x0 = -180, x0e = x0 + epsilon,\n    x1 = 180, x1e = x1 - epsilon,\n    y0 = -90, y0e = y0 + epsilon,\n    y1 = 90, y1e = y1 - epsilon;\n\nfunction nonempty(coordinates) {\n  return coordinates.length > 0;\n}\n\nfunction quantize(x) {\n  return Math.floor(x * epsilonInverse) / epsilonInverse;\n}\n\nfunction normalizePoint(y) {\n  return y === y0 || y === y1 ? [0, y] : [x0, quantize(y)]; // pole or antimeridian?\n}\n\nfunction clampPoint(p) {\n  var x = p[0], y = p[1], clamped = false;\n  if (x <= x0e) x = x0, clamped = true;\n  else if (x >= x1e) x = x1, clamped = true;\n  if (y <= y0e) y = y0, clamped = true;\n  else if (y >= y1e) y = y1, clamped = true;\n  return clamped ? [x, y] : p;\n}\n\nfunction clampPoints(points) {\n  return points.map(clampPoint);\n}\n\n// For each ring, detect where it crosses the antimeridian or pole.\nfunction extractFragments(rings, polygon, fragments) {\n  for (var j = 0, m = rings.length; j < m; ++j) {\n    var ring = rings[j].slice();\n\n    // By default, assume that this ring doesn’t need any stitching.\n    fragments.push({index: -1, polygon: polygon, ring: ring});\n\n    for (var i = 0, n = ring.length; i < n; ++i) {\n      var point = ring[i],\n          x = point[0],\n          y = point[1];\n\n      // If this is an antimeridian or polar point…\n      if (x <= x0e || x >= x1e || y <= y0e || y >= y1e) {\n        ring[i] = clampPoint(point);\n\n        // Advance through any antimeridian or polar points…\n        for (var k = i + 1; k < n; ++k) {\n          var pointk = ring[k],\n              xk = pointk[0],\n              yk = pointk[1];\n          if (xk > x0e && xk < x1e && yk > y0e && yk < y1e) break;\n        }\n\n        // If this was just a single antimeridian or polar point,\n        // we don’t need to cut this ring into a fragment;\n        // we can just leave it as-is.\n        if (k === i + 1) continue;\n\n        // Otherwise, if this is not the first point in the ring,\n        // cut the current fragment so that it ends at the current point.\n        // The current point is also normalized for later joining.\n        if (i) {\n          var fragmentBefore = {index: -1, polygon: polygon, ring: ring.slice(0, i + 1)};\n          fragmentBefore.ring[fragmentBefore.ring.length - 1] = normalizePoint(y);\n          fragments[fragments.length - 1] = fragmentBefore;\n        }\n\n        // If the ring started with an antimeridian fragment,\n        // we can ignore that fragment entirely.\n        else fragments.pop();\n\n        // If the remainder of the ring is an antimeridian fragment,\n        // move on to the next ring.\n        if (k >= n) break;\n\n        // Otherwise, add the remaining ring fragment and continue.\n        fragments.push({index: -1, polygon: polygon, ring: ring = ring.slice(k - 1)});\n        ring[0] = normalizePoint(ring[0][1]);\n        i = -1;\n        n = ring.length;\n      }\n    }\n  }\n}\n\n// Now stitch the fragments back together into rings.\nfunction stitchFragments(fragments) {\n  var i, n = fragments.length;\n\n  // To connect the fragments start-to-end, create a simple index by end.\n  var fragmentByStart = {},\n      fragmentByEnd = {},\n      fragment,\n      start,\n      startFragment,\n      end,\n      endFragment;\n\n  // For each fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    start = fragment.ring[0];\n    end = fragment.ring[fragment.ring.length - 1];\n\n    // If this fragment is closed, add it as a standalone ring.\n    if (start[0] === end[0] && start[1] === end[1]) {\n      fragment.polygon.push(fragment.ring);\n      fragments[i] = null;\n      continue;\n    }\n\n    fragment.index = i;\n    fragmentByStart[start] = fragmentByEnd[end] = fragment;\n  }\n\n  // For each open fragment…\n  for (i = 0; i < n; ++i) {\n    fragment = fragments[i];\n    if (fragment) {\n      start = fragment.ring[0];\n      end = fragment.ring[fragment.ring.length - 1];\n      startFragment = fragmentByEnd[start];\n      endFragment = fragmentByStart[end];\n\n      delete fragmentByStart[start];\n      delete fragmentByEnd[end];\n\n      // If this fragment is closed, add it as a standalone ring.\n      if (start[0] === end[0] && start[1] === end[1]) {\n        fragment.polygon.push(fragment.ring);\n        continue;\n      }\n\n      if (startFragment) {\n        delete fragmentByEnd[start];\n        delete fragmentByStart[startFragment.ring[0]];\n        startFragment.ring.pop(); // drop the shared coordinate\n        fragments[startFragment.index] = null;\n        fragment = {index: -1, polygon: startFragment.polygon, ring: startFragment.ring.concat(fragment.ring)};\n\n        if (startFragment === endFragment) {\n          // Connect both ends to this single fragment to create a ring.\n          fragment.polygon.push(fragment.ring);\n        } else {\n          fragment.index = n++;\n          fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n        }\n      } else if (endFragment) {\n        delete fragmentByStart[end];\n        delete fragmentByEnd[endFragment.ring[endFragment.ring.length - 1]];\n        fragment.ring.pop(); // drop the shared coordinate\n        fragment = {index: n++, polygon: endFragment.polygon, ring: fragment.ring.concat(endFragment.ring)};\n        fragments[endFragment.index] = null;\n        fragments.push(fragmentByStart[fragment.ring[0]] = fragmentByEnd[fragment.ring[fragment.ring.length - 1]] = fragment);\n      } else {\n        fragment.ring.push(fragment.ring[0]); // close ring\n        fragment.polygon.push(fragment.ring);\n      }\n    }\n  }\n}\n\nfunction stitchFeature(input) {\n  var output = {type: \"Feature\", geometry: stitchGeometry(input.geometry)};\n  if (input.id != null) output.id = input.id;\n  if (input.bbox != null) output.bbox = input.bbox;\n  if (input.properties != null) output.properties = input.properties;\n  return output;\n}\n\nfunction stitchGeometry(input) {\n  if (input == null) return input;\n  var output, fragments, i, n;\n  switch (input.type) {\n    case \"GeometryCollection\": output = {type: \"GeometryCollection\", geometries: input.geometries.map(stitchGeometry)}; break;\n    case \"Point\": output = {type: \"Point\", coordinates: clampPoint(input.coordinates)}; break;\n    case \"MultiPoint\": case \"LineString\": output = {type: input.type, coordinates: clampPoints(input.coordinates)}; break;\n    case \"MultiLineString\": output = {type: \"MultiLineString\", coordinates: input.coordinates.map(clampPoints)}; break;\n    case \"Polygon\": {\n      var polygon = [];\n      extractFragments(input.coordinates, polygon, fragments = []);\n      stitchFragments(fragments);\n      output = {type: \"Polygon\", coordinates: polygon};\n      break;\n    }\n    case \"MultiPolygon\": {\n      fragments = [], i = -1, n = input.coordinates.length;\n      var polygons = new Array(n);\n      while (++i < n) extractFragments(input.coordinates[i], polygons[i] = [], fragments);\n      stitchFragments(fragments);\n      output = {type: \"MultiPolygon\", coordinates: polygons.filter(nonempty)};\n      break;\n    }\n    default: return input;\n  }\n  if (input.bbox != null) output.bbox = input.bbox;\n  return output;\n}\n\nexport default function(input) {\n  if (input == null) return input;\n  switch (input.type) {\n    case \"Feature\": return stitchFeature(input);\n    case \"FeatureCollection\": {\n      var output = {type: \"FeatureCollection\", features: input.features.map(stitchFeature)};\n      if (input.bbox != null) output.bbox = input.bbox;\n      return output;\n    }\n    default: return stitchGeometry(input);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}