{"ast":null,"code":"/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { Dictionary } from \"./Dictionary\";\nimport * as $type from \"./Type\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\nvar Cache = /** @class */function () {\n  function Cache() {\n    /**\r\n     * Storage for cache items.\r\n     */\n    this._storage = new Dictionary();\n    /**\r\n     * Default TTL in milliseconds.\r\n     */\n    this.ttl = 1000;\n  }\n  /**\r\n   * Caches or updates cached value, resets TTL.\r\n   *\r\n   * If `ttl` is set to zero, item will never expire.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value\r\n   * @param ttl    TTL of the cache to live in milliseconds\r\n   */\n  Cache.prototype.set = function (owner, key, value, ttl) {\n    // Create if storage does not exist for this owner\n    var ownerStorage = this._storage.insertKeyIfEmpty(owner, function () {\n      return new Dictionary();\n    });\n    // Create cache item\n    var item = {\n      \"touched\": new Date().getTime(),\n      \"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\n      \"value\": value\n    };\n    // Set\n    ownerStorage.setKey(key, item);\n  };\n  /**\r\n   * Rerturns cached item, respecting TTL.\r\n   *\r\n   * @param owner  An id of the object that owns this cache\r\n   * @param key    Index key\r\n   * @param value  Value to return if cache not available\r\n   * @return Value, or `undefined` if not set\r\n   */\n  Cache.prototype.get = function (owner, key, value) {\n    if (value === void 0) {\n      value = undefined;\n    }\n    // \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\n    if (this._storage.hasKey(owner)) {\n      var ownerStorage = this._storage.getKey(owner);\n      if (ownerStorage.hasKey(key)) {\n        var cacheItem = ownerStorage.getKey(key);\n        if (cacheItem.ttl && cacheItem.touched + cacheItem.ttl < new Date().getTime()) {\n          cacheItem.expired = true;\n        }\n        if (cacheItem.expired) {\n          ownerStorage.removeKey(key);\n          return value;\n        }\n        return cacheItem.value;\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n  /**\r\n   * Clears cache for specific owner or everything.\r\n   *\r\n   * @param owner Owner to clear cache for\r\n   */\n  Cache.prototype.clear = function (owner) {\n    if (owner) {\n      this._storage.removeKey(owner);\n    } else {\n      this._storage.clear();\n    }\n  };\n  return Cache;\n}();\nexport { Cache };\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\nexport var cache = new Cache();","map":{"version":3,"names":["Dictionary","$type","Cache","_storage","ttl","prototype","set","owner","key","value","ownerStorage","insertKeyIfEmpty","item","Date","getTime","isNumber","setKey","get","undefined","hasKey","getKey","cacheItem","touched","expired","removeKey","clear","cache"],"sources":["../../../../../src/.internal/core/utils/Cache.ts"],"sourcesContent":["/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Dictionary } from \"./Dictionary\";\r\nimport * as $type from \"./Type\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Defines an interface for cache items.\r\n */\r\ninterface CacheItem<A> {\r\n\r\n\t/**\r\n\t * A timestamp of when the item was created/updated.\r\n\t */\r\n\t\"touched\": number,\r\n\r\n\t/**\r\n\t * TTL (time to live) in milliseconds.\r\n\t */\r\n\t\"ttl\"?: number,\r\n\r\n\t/**\r\n\t * Cached value.\r\n\t */\r\n\t\"value\": A,\r\n\r\n\t/**\r\n\t * Is this item expired?\r\n\t *\r\n\t * @todo a system process that would check chace element TTLs and expire them\r\n\t */\r\n\t\"expired\"?: boolean\r\n\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents object cache.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better storage\r\n * @todo TTL logging\r\n * @todo Garbage collector\r\n */\r\nexport class Cache<A> {\r\n\r\n\t/**\r\n\t * Storage for cache items.\r\n\t */\r\n\tprivate _storage = new Dictionary<string, Dictionary<string, CacheItem<A>>>();\r\n\r\n\t/**\r\n\t * Default TTL in milliseconds.\r\n\t */\r\n\tpublic ttl: number = 1000;\r\n\r\n\t/**\r\n\t * Caches or updates cached value, resets TTL.\r\n\t *\r\n\t * If `ttl` is set to zero, item will never expire.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value\r\n\t * @param ttl    TTL of the cache to live in milliseconds\r\n\t */\r\n\tpublic set(owner: string, key: string, value: A, ttl?: number): void {\r\n\r\n\t\t// Create if storage does not exist for this owner\r\n\t\tlet ownerStorage = this._storage.insertKeyIfEmpty(owner, () => new Dictionary<string, CacheItem<A>>());\r\n\r\n\t\t// Create cache item\r\n\t\tlet item: CacheItem<A> = {\r\n\t\t\t\"touched\": new Date().getTime(),\r\n\t\t\t\"ttl\": $type.isNumber(ttl) ? ttl : this.ttl,\r\n\t\t\t\"value\": value\r\n\t\t};\r\n\r\n\t\t// Set\r\n\t\townerStorage.setKey(key, item);\r\n\t}\r\n\r\n\t/**\r\n\t * Rerturns cached item, respecting TTL.\r\n\t *\r\n\t * @param owner  An id of the object that owns this cache\r\n\t * @param key    Index key\r\n\t * @param value  Value to return if cache not available\r\n\t * @return Value, or `undefined` if not set\r\n\t */\r\n\tpublic get(owner: string, key: string, value: any = undefined): $type.Optional<A> {\r\n\t\t// \t\t || ypeof this._storage[owner][key] === \"undefined\" || this._storage[owner][key].expired === true) {\r\n\t\tif (this._storage.hasKey(owner)) {\r\n\t\t\tlet ownerStorage = <Dictionary<string, CacheItem<A>>>this._storage.getKey(owner);\r\n\r\n\t\t\tif (ownerStorage.hasKey(key)) {\r\n\t\t\t\tlet cacheItem: CacheItem<A> = <CacheItem<A>>ownerStorage.getKey(key);\r\n\t\t\t\tif (cacheItem.ttl && ((cacheItem.touched + cacheItem.ttl) < new Date().getTime())) {\r\n\t\t\t\t\tcacheItem.expired = true;\r\n\t\t\t\t}\r\n\t\t\t\tif (cacheItem.expired) {\r\n\t\t\t\t\townerStorage.removeKey(key);\r\n\t\t\t\t\treturn value;\r\n\t\t\t\t}\r\n\t\t\t\treturn cacheItem.value;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn value;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Clears cache for specific owner or everything.\r\n\t *\r\n\t * @param owner Owner to clear cache for\r\n\t */\r\n\tpublic clear(owner?: string): void {\r\n\t\tif (owner) {\r\n\t\t\tthis._storage.removeKey(owner);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis._storage.clear();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * ============================================================================\r\n * GLOBAL INSTANCE\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * A global instance of cache. Use this instance to cache any values.\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport let cache: Cache<any> = new Cache();\r\n"],"mappings":"AAAA;;;;;;AAMA,SAASA,UAAU,QAAQ,cAAc;AACzC,OAAO,KAAKC,KAAK,MAAM,QAAQ;AAwC/B;;;;;;AAOA;;;;;;;;AAQA,IAAAC,KAAA;EAAA,SAAAA,MAAA;IAEC;;;IAGQ,KAAAC,QAAQ,GAAG,IAAIH,UAAU,EAA4C;IAE7E;;;IAGO,KAAAI,GAAG,GAAW,IAAI;EA2E1B;EAzEC;;;;;;;;;;EAUOF,KAAA,CAAAG,SAAA,CAAAC,GAAG,GAAV,UAAWC,KAAa,EAAEC,GAAW,EAAEC,KAAQ,EAAEL,GAAY;IAE5D;IACA,IAAIM,YAAY,GAAG,IAAI,CAACP,QAAQ,CAACQ,gBAAgB,CAACJ,KAAK,EAAE;MAAM,WAAIP,UAAU,EAAwB;IAAtC,CAAsC,CAAC;IAEtG;IACA,IAAIY,IAAI,GAAiB;MACxB,SAAS,EAAE,IAAIC,IAAI,EAAE,CAACC,OAAO,EAAE;MAC/B,KAAK,EAAEb,KAAK,CAACc,QAAQ,CAACX,GAAG,CAAC,GAAGA,GAAG,GAAG,IAAI,CAACA,GAAG;MAC3C,OAAO,EAAEK;KACT;IAED;IACAC,YAAY,CAACM,MAAM,CAACR,GAAG,EAAEI,IAAI,CAAC;EAC/B,CAAC;EAED;;;;;;;;EAQOV,KAAA,CAAAG,SAAA,CAAAY,GAAG,GAAV,UAAWV,KAAa,EAAEC,GAAW,EAAEC,KAAsB;IAAtB,IAAAA,KAAA;MAAAA,KAAA,GAAAS,SAAsB;IAAA;IAC5D;IACA,IAAI,IAAI,CAACf,QAAQ,CAACgB,MAAM,CAACZ,KAAK,CAAC,EAAE;MAChC,IAAIG,YAAY,GAAqC,IAAI,CAACP,QAAQ,CAACiB,MAAM,CAACb,KAAK,CAAC;MAEhF,IAAIG,YAAY,CAACS,MAAM,CAACX,GAAG,CAAC,EAAE;QAC7B,IAAIa,SAAS,GAA+BX,YAAY,CAACU,MAAM,CAACZ,GAAG,CAAC;QACpE,IAAIa,SAAS,CAACjB,GAAG,IAAMiB,SAAS,CAACC,OAAO,GAAGD,SAAS,CAACjB,GAAG,GAAI,IAAIS,IAAI,EAAE,CAACC,OAAO,EAAG,EAAE;UAClFO,SAAS,CAACE,OAAO,GAAG,IAAI;;QAEzB,IAAIF,SAAS,CAACE,OAAO,EAAE;UACtBb,YAAY,CAACc,SAAS,CAAChB,GAAG,CAAC;UAC3B,OAAOC,KAAK;;QAEb,OAAOY,SAAS,CAACZ,KAAK;OACtB,MACI;QACJ,OAAOA,KAAK;;KAEb,MACI;MACJ,OAAOA,KAAK;;EAEd,CAAC;EAED;;;;;EAKOP,KAAA,CAAAG,SAAA,CAAAoB,KAAK,GAAZ,UAAalB,KAAc;IAC1B,IAAIA,KAAK,EAAE;MACV,IAAI,CAACJ,QAAQ,CAACqB,SAAS,CAACjB,KAAK,CAAC;KAC9B,MACI;MACJ,IAAI,CAACJ,QAAQ,CAACsB,KAAK,EAAE;;EAEvB,CAAC;EAEF,OAAAvB,KAAC;AAAD,CAAC,CArFD;;AAuFA;;;;;;AAOA;;;;;AAKA,OAAO,IAAIwB,KAAK,GAAe,IAAIxB,KAAK,EAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}