{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * Number formatting-related functionality.\r\n */\nimport { __extends } from \"tslib\";\nimport { Language } from \"../utils/Language\";\nimport { BaseObject } from \"../Base\";\nimport { getTextFormatter } from \"../formatters/TextFormatter\";\nimport { registry } from \"../Registry\";\nimport * as $strings from \"../utils/Strings\";\nimport * as $object from \"../utils/Object\";\nimport * as $utils from \"../utils/Utils\";\nimport * as $type from \"../utils/Type\";\nimport * as $math from \"../utils/Math\";\n/**\r\n * NumberFormatter class. Formats numbers according to specified formats.\r\n *\r\n * @todo Apply translations to suffixes/prefixes\r\n */\nvar NumberFormatter = /** @class */function (_super) {\n  __extends(NumberFormatter, _super);\n  /**\r\n   * Constructor\r\n   */\n  function NumberFormatter() {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A base value for negative numbers. Will treat all numbers below this value\r\n     * as negative numbers.\r\n     */\n    _this._negativeBase = 0;\n    /**\r\n     * Holds number format.\r\n     *\r\n     * @default #,###.#####\r\n     */\n    _this._numberFormat = \"#,###.#####\";\n    /**\r\n     * Output format to produce. If the format calls for applying color to the\r\n     * formatted value, this setting will determine what markup to use: SVG or\r\n     * HTML.\r\n     *\r\n     * Available options: svg, html.\r\n     *\r\n     * @default \"svg\"\r\n     */\n    _this._outputFormat = \"svg\";\n    /**\r\n     * Any number smaller than this will be considered \"small\" number, which will\r\n     * trigger special formatting if \"a\" format modifier is used.\r\n     */\n    _this._smallNumberThreshold = 1.00;\n    _this._forceLTR = false;\n    _this.className = \"NumberFormatter\";\n    _this.applyTheme();\n    return _this;\n  }\n  NumberFormatter.prototype.dispose = function () {\n    _super.prototype.dispose.call(this);\n    if (this.language) {\n      this.language.dispose();\n    }\n  };\n  Object.defineProperty(NumberFormatter.prototype, \"language\", {\n    /**\r\n     * @return Language\r\n     */\n    get: function () {\n      if (!this._language) {\n        if (this.sprite) {\n          this._language = this.sprite.language;\n        } else {\n          this._language = new Language();\n        }\n      }\n      return this._language;\n    },\n    /**\r\n     * A reference to [[Language]] instance.\r\n     *\r\n     * Formatter will use language to translate various items, like number\r\n     * suffixes, etc.\r\n     *\r\n     * @param value  Language\r\n     */\n    set: function (value) {\n      this._language = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n  NumberFormatter.prototype.format = function (value, format, precision) {\n    // no format passed in or \"Number\"\n    if (typeof format === \"undefined\" || $type.isString(format) && format.toLowerCase() === \"number\") {\n      format = this._numberFormat;\n    }\n    // Init return value\n    var formatted;\n    // Cast to number just in case\n    // TODO: maybe use better casting\n    var source = Number(value);\n    // Is it a built-in format or Intl.NumberFormatOptions\n    if ($type.isObject(format)) {\n      try {\n        if (this.intlLocales) {\n          return new Intl.NumberFormat(this.intlLocales, format).format(source);\n        } else {\n          return new Intl.NumberFormat(undefined, format).format(source);\n        }\n      } catch (e) {\n        return \"Invalid\";\n      }\n    } else {\n      // Clean format\n      format = $utils.cleanFormat(format);\n      // Get format info (it will also deal with parser caching)\n      var info = this.parseFormat(format, this.language);\n      // format and replace the number\n      var details = void 0;\n      if (source > this._negativeBase) {\n        details = info.positive;\n      } else if (source < this._negativeBase) {\n        details = info.negative;\n      } else {\n        details = info.zero;\n      }\n      // Adjust precision\n      if ($type.hasValue(precision) && !details.mod) {\n        details = $object.clone(details);\n        details.decimals.active = source == 0 ? 0 : precision;\n      }\n      // Format\n      formatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\n    }\n    if (this.forceLTR) {\n      formatted = \"‎\" + formatted;\n    }\n    return formatted;\n  };\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. \"#,###.00\"\r\n   * @param language Language\r\n   */\n  NumberFormatter.prototype.parseFormat = function (format, language) {\n    var _this = this;\n    // Check cache\n    var cached = this.getCache(format);\n    if ($type.hasValue(cached)) {\n      return cached;\n    }\n    // init format parse info holder\n    var info = {\n      \"positive\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"negative\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      },\n      \"zero\": {\n        \"thousands\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"interval\": -1,\n          \"separator\": language.translateEmpty(\"_thousandSeparator\")\n        },\n        \"decimals\": {\n          \"active\": -1,\n          \"passive\": -1,\n          \"separator\": language.translateEmpty(\"_decimalSeparator\")\n        },\n        \"template\": \"\",\n        \"source\": \"\",\n        \"parsed\": false\n      }\n    };\n    // Escape double vertical bars (that mean display one vertical bar)\n    format = format.replace(\"||\", $strings.PLACEHOLDER2);\n    // Split it up and deal with different formats\n    var parts = format.split(\"|\");\n    info.positive.source = parts[0];\n    if (typeof parts[2] === \"undefined\") {\n      info.zero = info.positive;\n    } else {\n      info.zero.source = parts[2];\n    }\n    if (typeof parts[1] === \"undefined\") {\n      info.negative = info.positive;\n    } else {\n      info.negative.source = parts[1];\n    }\n    // Parse each\n    $object.each(info, function (part, item) {\n      // Already parsed\n      if (item.parsed) {\n        return;\n      }\n      // Check cached\n      if (typeof _this.getCache(item.source) !== \"undefined\") {\n        info[part] = _this.getCache(item.source);\n        return;\n      }\n      // Begin parsing\n      var partFormat = item.source;\n      // Just \"Number\"?\n      if (partFormat.toLowerCase() === \"number\") {\n        partFormat = $type.isString(_this._numberFormat) ? _this._numberFormat : \"#,###.#####\";\n      }\n      // Let TextFormatter split into chunks\n      var chunks = getTextFormatter().chunk(partFormat, true);\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i];\n        // replace back double vertical bar\n        chunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\n        if (chunk.type === \"value\") {\n          // Parse format\n          // Look for codes\n          var matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\n          if (matches) {\n            if (matches === null || matches[0] === \"\") {\n              // no codes here - assume string\n              // nothing to do here\n              item.template += chunk.text;\n            } else {\n              // look for the format modifiers at the end\n              var mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\n              if (mods) {\n                item.mod = mods[0].toLowerCase();\n                item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\n              }\n              // break the format up\n              var a = matches[0].split(\".\");\n              // Deal with thousands\n              if (a[0] === \"\") {\n                // No directives for thousands\n                // Leave default settings (no formatting)\n              } else {\n                // Counts\n                item.thousands.active = (a[0].match(/0/g) || []).length;\n                item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\n                // Separator interval\n                var b = a[0].split(\",\");\n                if (b.length === 1) {\n                  // No thousands separators\n                  // Do nothing\n                } else {\n                  // Use length fo the last chunk as thousands length\n                  item.thousands.interval = $type.getValue(b.pop()).length;\n                  if (item.thousands.interval === 0) {\n                    item.thousands.interval = -1;\n                  }\n                }\n              }\n              // Deal with decimals\n              if (typeof a[1] === \"undefined\") {\n                // No directives for decimals\n                // Leave at defaults (no formatting)\n              } else {\n                // Counts\n                item.decimals.active = (a[1].match(/0/g) || []).length;\n                item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n              }\n              // Add special code to template\n              item.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\n            }\n          }\n        } else {\n          // Quoted string - take it as it is\n          item.template += chunk.text;\n        }\n      }\n      // Apply style formatting\n      //item.template = getTextFormatter().format(item.template, this.outputFormat);\n      // Save cache\n      _this.setCache(item.source, item);\n      // Mark this as parsed\n      item.parsed = true;\n    });\n    // Save cache (the whole thing)\n    this.setCache(format, info);\n    return info;\n  };\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   */\n  NumberFormatter.prototype.applyFormat = function (value, details) {\n    // Use absolute values\n    var negative = value < 0;\n    value = Math.abs(value);\n    // Recalculate according to modifier\n    var prefix = \"\",\n      suffix = \"\";\n    var mods = details.mod ? details.mod.split(\"\") : [];\n    if (mods.indexOf(\"b\") !== -1) {\n      var a_1 = this.applyPrefix(value, this.bytePrefixes, mods.indexOf(\"!\") !== -1);\n      value = a_1[0];\n      prefix = a_1[1];\n      suffix = a_1[2];\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"a\") !== -1) {\n      var a_2 = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf(\"!\") !== -1);\n      value = a_2[0];\n      prefix = a_2[1];\n      suffix = a_2[2];\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (mods.indexOf(\"p\") !== -1) {\n      var ol = Math.min(value.toString().length + 2, 21);\n      //value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      prefix = this.language.translate(\"_percentPrefix\") || \"\";\n      suffix = this.language.translate(\"_percentSuffix\") || \"\";\n      if (prefix == \"\" && suffix == \"\") {\n        suffix = \"%\";\n      }\n    } else if (mods.indexOf(\"%\") !== -1) {\n      var ol = $math.min(value.toString().length + 2, 21);\n      value *= 100;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = \"%\";\n    } else if (mods.indexOf(\"‰\") !== -1) {\n      var ol = $math.min(value.toString().length + 3, 21);\n      value *= 1000;\n      value = parseFloat(value.toPrecision(ol));\n      suffix = \"‰\";\n    }\n    // Round to passive\n    if (mods.indexOf(\"e\") !== -1) {\n      // convert the value to exponential\n      var exp = void 0;\n      if (details.decimals.passive >= 0) {\n        exp = value.toExponential(details.decimals.passive).split(\"e\");\n      } else {\n        exp = value.toExponential().split(\"e\");\n      }\n      value = Number(exp[0]);\n      suffix = \"e\" + exp[1];\n      if (details.modSpacing) {\n        suffix = \" \" + suffix;\n      }\n    } else if (details.decimals.passive === 0) {\n      value = Math.round(value);\n    } else if (details.decimals.passive > 0) {\n      var d = Math.pow(10, details.decimals.passive);\n      value = Math.round(value * d) / d;\n    }\n    // Init return value\n    var res = \"\";\n    // Calc integer and decimal parts\n    var a = $utils.numberToString(value).split(\".\");\n    // Format integers\n    var ints = a[0];\n    // Pad integers to active length\n    if (ints.length < details.thousands.active) {\n      ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n    }\n    // Insert thousands separators\n    if (details.thousands.interval > 0) {\n      var ip = [];\n      var intsr = ints.split(\"\").reverse().join(\"\");\n      for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n        var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n        if (c !== \"\") {\n          ip.unshift(c);\n        }\n      }\n      ints = ip.join(details.thousands.separator);\n    }\n    // Add integers\n    res += ints;\n    // Add decimals\n    if (a.length === 1) {\n      a.push(\"\");\n    }\n    var decs = a[1];\n    // Fill zeros?\n    if (decs.length < details.decimals.active) {\n      decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n    }\n    if (decs !== \"\") {\n      res += details.decimals.separator + decs;\n    }\n    // Can't have empty return value\n    if (res === \"\") {\n      res = \"0\";\n    }\n    // Add minus sign back\n    if (value !== 0 && negative && mods.indexOf(\"s\") === -1) {\n      res = \"-\" + res;\n    }\n    // Add suffixes/prefixes\n    if (prefix) {\n      res = prefix + res;\n    }\n    if (suffix) {\n      res += suffix;\n    }\n    return res;\n  };\n  /**\r\n   * Chooses appropriate prefix and suffix based on the passed in rules.\r\n   *\r\n   * @param  value     Value\r\n   * @param  prefixes  Prefix array\r\n   * @param  force     Force application of a first prefix (@sice 4.5.4)\r\n   * @return Result\r\n   */\n  NumberFormatter.prototype.applyPrefix = function (value, prefixes, force) {\n    if (force === void 0) {\n      force = false;\n    }\n    var newvalue = value;\n    var prefix = \"\";\n    var suffix = \"\";\n    var applied = false;\n    var k = 1;\n    for (var i = 0, len = prefixes.length; i < len; i++) {\n      if (prefixes[i].number <= value) {\n        if (prefixes[i].number === 0) {\n          newvalue = 0;\n        } else {\n          newvalue = value / prefixes[i].number;\n          k = prefixes[i].number;\n        }\n        prefix = prefixes[i].prefix;\n        suffix = prefixes[i].suffix;\n        applied = true;\n      }\n    }\n    if (!applied && force && prefixes.length && value != 0) {\n      // Prefix was not applied. Use the first prefix.\n      newvalue = value / prefixes[0].number;\n      prefix = prefixes[0].prefix;\n      suffix = prefixes[0].suffix;\n      applied = true;\n    }\n    if (applied) {\n      newvalue = parseFloat(newvalue.toPrecision($math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)));\n    }\n    return [newvalue, prefix, suffix];\n  };\n  /**\r\n   * Invalidates the parent [[Sprite]] object.\r\n   */\n  NumberFormatter.prototype.invalidateSprite = function () {\n    if (this.sprite) {\n      this.sprite.invalidate();\n    }\n  };\n  Object.defineProperty(NumberFormatter.prototype, \"numberFormat\", {\n    /**\r\n     * @return A format to use for number formatting\r\n     */\n    get: function () {\n      return this._numberFormat;\n    },\n    /**\r\n     * Number format.\r\n     *\r\n     * @default \"#,###.#####\"\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param format  A format to use for number formatting\r\n     */\n    set: function (format) {\n      this._numberFormat = format;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"intlLocales\", {\n    /**\r\n     * @return Date format\r\n     */\n    get: function () {\n      return this._intlLocales;\n    },\n    /**\r\n     * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\r\n     *\r\n     * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\r\n     * @param value Locales\r\n     */\n    set: function (value) {\n      this._intlLocales = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"negativeBase\", {\n    /**\r\n     * @return A format to use for number formatting\r\n     */\n    get: function () {\n      return this._negativeBase;\n    },\n    /**\r\n     * Negative base for negative numbers.\r\n     *\r\n     * @default 0\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param format  A format to use for number formatting\r\n     */\n    set: function (value) {\n      this._negativeBase = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bigNumberPrefixes\", {\n    /**\r\n     * @return Prefixes for big numbers\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._bigNumberPrefixes)) {\n        this._bigNumberPrefixes = [{\n          \"number\": 1e+3,\n          \"suffix\": this.language.translate(\"_big_number_suffix_3\")\n        }, {\n          \"number\": 1e+6,\n          \"suffix\": this.language.translate(\"_big_number_suffix_6\")\n        }, {\n          \"number\": 1e+9,\n          \"suffix\": this.language.translate(\"_big_number_suffix_9\")\n        }, {\n          \"number\": 1e+12,\n          \"suffix\": this.language.translate(\"_big_number_suffix_12\")\n        }, {\n          \"number\": 1e+15,\n          \"suffix\": this.language.translate(\"_big_number_suffix_15\")\n        }, {\n          \"number\": 1e+18,\n          \"suffix\": this.language.translate(\"_big_number_suffix_18\")\n        }, {\n          \"number\": 1e+21,\n          \"suffix\": this.language.translate(\"_big_number_suffix_21\")\n        }, {\n          \"number\": 1e+24,\n          \"suffix\": this.language.translate(\"_big_number_suffix_24\")\n        }];\n      }\n      return this._bigNumberPrefixes;\n    },\n    /**\r\n     * Prefixes for big numbers.\r\n     *\r\n     * It's an array of objects of number/prefix pairs.\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { \"number\": 1e+3, \"suffix\": \"K\" },\r\n     *   { \"number\": 1e+6, \"suffix\": \"M\" },\r\n     *   { \"number\": 1e+9, \"suffix\": \"G\" },\r\n     *   { \"number\": 1e+12, \"suffix\": \"T\" },\r\n     *   { \"number\": 1e+15, \"suffix\": \"P\" },\r\n     *   { \"number\": 1e+18, \"suffix\": \"E\" },\r\n     *   { \"number\": 1e+21, \"suffix\": \"Z\" },\r\n     *   { \"number\": 1e+24, \"suffix\": \"Y\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * If the number is bigger than the `number` ir will be converted to the\r\n     * appropriate bigger number with prefix.\r\n     *\r\n     * E.g. as per above `1500` will be converted to `1.5K`.\r\n     *\r\n     * Please note that for this transformation to be enabled, you need to\r\n     * enable it specific modifier in your format setting.\r\n     *\r\n     * The modifier for big/small number modification is \"a\":\r\n     *\r\n     * ```Text\r\n     * {myfield.formatNumber(\"#,###.00a\")}\r\n     * ```\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for big numbers\r\n     */\n    set: function (prefixes) {\n      this._bigNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberPrefixes\", {\n    /**\r\n     * @return Prefixes for small numbers\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._smallNumberPrefixes)) {\n        this._smallNumberPrefixes = [{\n          \"number\": 1e-24,\n          \"suffix\": this.language.translate(\"_small_number_suffix_24\")\n        }, {\n          \"number\": 1e-21,\n          \"suffix\": this.language.translate(\"_small_number_suffix_21\")\n        }, {\n          \"number\": 1e-18,\n          \"suffix\": this.language.translate(\"_small_number_suffix_18\")\n        }, {\n          \"number\": 1e-15,\n          \"suffix\": this.language.translate(\"_small_number_suffix_15\")\n        }, {\n          \"number\": 1e-12,\n          \"suffix\": this.language.translate(\"_small_number_suffix_12\")\n        }, {\n          \"number\": 1e-9,\n          \"suffix\": this.language.translate(\"_small_number_suffix_9\")\n        }, {\n          \"number\": 1e-6,\n          \"suffix\": this.language.translate(\"_small_number_suffix_6\")\n        }, {\n          \"number\": 1e-3,\n          \"suffix\": this.language.translate(\"_small_number_suffix_3\")\n        }];\n      }\n      return this._smallNumberPrefixes;\n    },\n    /**\r\n     * Prefixes for big numbers.\r\n     *\r\n     * It's an array of objects of number/prefix pairs.\r\n     *\r\n     * ```JSON\r\n     * [\r\n     *   { \"number\": 1e-24, \"suffix\": \"y\" },\r\n     *   { \"number\": 1e-21, \"suffix\": \"z\" },\r\n     *   { \"number\": 1e-18, \"suffix\": \"a\" },\r\n     *   { \"number\": 1e-15, \"suffix\": \"f\" },\r\n     *   { \"number\": 1e-12, \"suffix\": \"p\" },\r\n     *   { \"number\": 1e-9, \"suffix\": \"n\" },\r\n     *   { \"number\": 1e-6, \"suffix\": \"μ\" },\r\n     *   { \"number\": 1e-3, \"suffix\": \"m\" }\r\n     * ]\r\n     * ```\r\n     *\r\n     * If the number is smaller than the `number` ir will be converted to the\r\n     * appropriate smaller number with prefix.\r\n     *\r\n     * E.g. as per above `0.0015` will be converted to `1.5m`.\r\n     *\r\n     * Please note that for this transformation to be enabled, you need to\r\n     * enable it specific modifier in your format setting.\r\n     *\r\n     * The modifier for big/small number modification is \"a\":\r\n     *\r\n     * ```Text\r\n     * {myfield.formatNumber(\"#,###.00a\")}\r\n     * ```\r\n     *\r\n     * IMPORTANT: The order of the suffixes is important. The list must start\r\n     * from the smallest number and work towards bigger ones.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for small numbers\r\n     */\n    set: function (prefixes) {\n      this._smallNumberPrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"smallNumberThreshold\", {\n    /**\r\n     * @return Small number threshold\r\n     */\n    get: function () {\n      return this._smallNumberThreshold;\n    },\n    /**\r\n     * Any number smaller than this will be considered \"small\" number, which will\r\n     * trigger special formatting if \"a\" format modifier is used.\r\n     *\r\n     * @since 4.6.8\r\n     * @param  value  Small number threshold\r\n     */\n    set: function (value) {\n      this._smallNumberThreshold = value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"bytePrefixes\", {\n    /**\r\n     * @return Prefixes for byte-size formatting\r\n     */\n    get: function () {\n      if (!$type.hasValue(this._bytePrefixes)) {\n        this._bytePrefixes = [{\n          \"number\": 1,\n          suffix: this.language.translate(\"_byte_suffix_B\")\n        }, {\n          \"number\": 1024,\n          suffix: this.language.translate(\"_byte_suffix_KB\")\n        }, {\n          \"number\": 1048576,\n          suffix: this.language.translate(\"_byte_suffix_MB\")\n        }, {\n          \"number\": 1073741824,\n          suffix: this.language.translate(\"_byte_suffix_GB\")\n        }, {\n          \"number\": 1099511627776,\n          suffix: this.language.translate(\"_byte_suffix_TB\")\n        }, {\n          \"number\": 1125899906842624,\n          suffix: this.language.translate(\"_byte_suffix_PB\")\n        }];\n      }\n      return this._bytePrefixes;\n    },\n    /**\r\n     * Basically the same as `bigNumberPrefixes`, except base for calculation\r\n     * is not thousand but byte (1024).\r\n     *\r\n     * The modifier is \"b\".\r\n     *\r\n     *  ```Text\r\n     * {myfield.formatNumber(\"#,###.00b\")}\r\n     * ```\r\n     *\r\n     * The above `2048` will change to `2K`.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n     * @param prefixes  Prefixes for byte-size formatting\r\n     */\n    set: function (prefixes) {\n      this._bytePrefixes = prefixes;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"outputFormat\", {\n    /**\r\n     * @ignore Exclude from docs\r\n     * @return Output format\r\n     */\n    get: function () {\n      return this._outputFormat;\n    },\n    /**\r\n     * Ooutput format: \"svg\" or \"html\".\r\n     *\r\n     * @ignore Exclude from docs\r\n     * @param value  Output format\r\n     */\n    set: function (outputFormat) {\n      this._outputFormat = outputFormat.toLowerCase();\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"forceLTR\", {\n    get: function () {\n      return this._forceLTR;\n    },\n    set: function (value) {\n      this._forceLTR = value;\n      this.invalidateSprite();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n  NumberFormatter.prototype.escape = function (text) {\n    return text.replace(\"||\", $strings.PLACEHOLDER2);\n  };\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n  NumberFormatter.prototype.unescape = function (text) {\n    return text.replace($strings.PLACEHOLDER2, \"|\");\n  };\n  return NumberFormatter;\n}(BaseObject);\nexport { NumberFormatter };\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;","map":{"version":3,"names":["Language","BaseObject","getTextFormatter","registry","$strings","$object","$utils","$type","$math","NumberFormatter","_super","__extends","_this","call","_negativeBase","_numberFormat","_outputFormat","_smallNumberThreshold","_forceLTR","className","applyTheme","prototype","dispose","language","Object","defineProperty","get","_language","sprite","set","value","format","precision","isString","toLowerCase","formatted","source","Number","isObject","intlLocales","Intl","NumberFormat","undefined","e","cleanFormat","info","parseFormat","details","positive","negative","zero","hasValue","mod","clone","decimals","active","template","split","PLACEHOLDER","join","applyFormat","forceLTR","cached","getCache","translateEmpty","replace","PLACEHOLDER2","parts","each","part","item","parsed","partFormat","chunks","chunk","i","length","text","type","matches","match","mods","modSpacing","a","thousands","passive","b","interval","getValue","pop","setCache","Math","abs","prefix","suffix","indexOf","a_1","applyPrefix","bytePrefixes","a_2","smallNumberThreshold","smallNumberPrefixes","bigNumberPrefixes","ol","min","toString","parseFloat","toPrecision","translate","exp","toExponential","round","d","pow","res","numberToString","ints","Array","ip","intsr","reverse","len","c","substr","unshift","separator","push","decs","prefixes","force","newvalue","applied","k","number","floor","invalidateSprite","invalidate","_intlLocales","_bigNumberPrefixes","_smallNumberPrefixes","_bytePrefixes","outputFormat","escape","unescape","registeredClasses"],"sources":["../../../../../src/.internal/core/formatters/NumberFormatter.ts"],"sourcesContent":["/**\r\n * Number formatting-related functionality.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Sprite } from \"../Sprite\";\r\nimport { Language } from \"../utils/Language\";\r\nimport { BaseObject } from \"../Base\";\r\nimport { ITextChunk, getTextFormatter } from \"../formatters/TextFormatter\";\r\nimport { registry } from \"../Registry\";\r\nimport * as $strings from \"../utils/Strings\";\r\nimport * as $object from \"../utils/Object\";\r\nimport * as $utils from \"../utils/Utils\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $math from \"../utils/Math\";\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport interface INumberSuffix {\r\n\tnumber: number;\r\n\tsuffix: string;\r\n}\r\n\r\n/**\r\n * NumberFormatter class. Formats numbers according to specified formats.\r\n *\r\n * @todo Apply translations to suffixes/prefixes\r\n */\r\nexport class NumberFormatter extends BaseObject {\r\n\r\n\t/**\r\n\t * A base value for negative numbers. Will treat all numbers below this value\r\n\t * as negative numbers.\r\n\t */\r\n\tprotected _negativeBase: number = 0;\r\n\r\n\t/**\r\n\t * Holds number format.\r\n\t *\r\n\t * @default #,###.#####\r\n\t */\r\n\tprotected _numberFormat: string | Intl.NumberFormatOptions = \"#,###.#####\";\r\n\r\n\t/**\r\n\t * Locales to use when formatting using Intl.NumberFormatter\r\n\t */\r\n\tprotected _intlLocales: string;\r\n\r\n\t/**\r\n\t * Output format to produce. If the format calls for applying color to the\r\n\t * formatted value, this setting will determine what markup to use: SVG or\r\n\t * HTML.\r\n\t *\r\n\t * Available options: svg, html.\r\n\t *\r\n\t * @default \"svg\"\r\n\t */\r\n\tprotected _outputFormat: string = \"svg\";\r\n\r\n\t/**\r\n\t * Holds big number prefixes to apply to numbers if `a` modifier is used in\r\n\t * format.\r\n\t */\r\n\tprotected _bigNumberPrefixes: INumberSuffix[];\r\n\r\n\t/**\r\n\t * Holds small number prefixes to apply to numbers if `a` modifier is used in\r\n\t * format.\r\n\t */\r\n\tprotected _smallNumberPrefixes: INumberSuffix[];\r\n\r\n\t/**\r\n\t * Any number smaller than this will be considered \"small\" number, which will\r\n\t * trigger special formatting if \"a\" format modifier is used.\r\n\t */\r\n\tprotected _smallNumberThreshold: number = 1.00;\r\n\r\n\t/**\r\n\t * Holds prefixes to apply to data size numbers if `b` modifier is used in\r\n\t * format.\r\n\t */\r\n\tprotected _bytePrefixes: INumberSuffix[];\r\n\r\n\tprotected _forceLTR: boolean = false;\r\n\r\n\t/**\r\n\t * Holds reference to parent [[Sprite]] object.\r\n\t */\r\n\tpublic sprite: $type.Optional<Sprite>;\r\n\r\n\t/**\r\n\t * Holds reference to [[Language]] object.\r\n\t */\r\n\tprivate _language: $type.Optional<Language>;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis.className = \"NumberFormatter\";\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\tpublic dispose(): void {\r\n\t\tsuper.dispose();\r\n\r\n\t\tif (this.language) {\r\n\t\t\tthis.language.dispose();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * A reference to [[Language]] instance.\r\n\t *\r\n\t * Formatter will use language to translate various items, like number\r\n\t * suffixes, etc.\r\n\t *\r\n\t * @param value  Language\r\n\t */\r\n\tpublic set language(value: Language) {\r\n\t\tthis._language = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Language\r\n\t */\r\n\tpublic get language(): Language {\r\n\t\tif (!this._language) {\r\n\t\t\tif (this.sprite) {\r\n\t\t\t\tthis._language = this.sprite.language;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis._language = new Language;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this._language;\r\n\t}\r\n\r\n\t/**\r\n\t * Formats the number according to specific format.\r\n\t *\r\n\t * @param value   Value to format\r\n\t * @param format  Format to apply\r\n\t * @return Formatted number\r\n\t */\r\n\tpublic format(value: number | string, format?: string | Intl.NumberFormatOptions, precision?: number): string {\r\n\r\n\t\t// no format passed in or \"Number\"\r\n\t\tif (typeof format === \"undefined\" || ($type.isString(format) && format.toLowerCase() === \"number\")) {\r\n\t\t\tformat = this._numberFormat;\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet formatted;\r\n\r\n\t\t// Cast to number just in case\r\n\t\t// TODO: maybe use better casting\r\n\t\tlet source: number = Number(value);\r\n\r\n\t\t// Is it a built-in format or Intl.NumberFormatOptions\r\n\t\tif ($type.isObject(format)) {\r\n\t\t\ttry {\r\n\t\t\t\tif (this.intlLocales) {\r\n\t\t\t\t\treturn new Intl.NumberFormat(this.intlLocales, <Intl.NumberFormatOptions>format).format(source);\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn new Intl.NumberFormat(undefined, <Intl.NumberFormatOptions>format).format(source);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch (e) {\r\n\t\t\t\treturn \"Invalid\";\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t// Clean format\r\n\t\t\tformat = $utils.cleanFormat(format);\r\n\r\n\t\t\t// Get format info (it will also deal with parser caching)\r\n\t\t\tlet info = this.parseFormat(format, this.language);\r\n\r\n\r\n\t\t\t// format and replace the number\r\n\t\t\tlet details;\r\n\t\t\tif (source > this._negativeBase) {\r\n\t\t\t\tdetails = info.positive;\r\n\t\t\t}\r\n\t\t\telse if (source < this._negativeBase) {\r\n\t\t\t\tdetails = info.negative;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdetails = info.zero;\r\n\t\t\t}\r\n\r\n\t\t\t// Adjust precision\r\n\t\t\tif ($type.hasValue(precision) && !details.mod) {\r\n\t\t\t\tdetails = $object.clone(details);\r\n\t\t\t\tdetails.decimals.active = source == 0 ? 0: precision;\r\n\t\t\t}\r\n\r\n\t\t\t// Format\r\n\t\t\tformatted = details.template.split($strings.PLACEHOLDER).join(this.applyFormat(source, details));\r\n\r\n\t\t}\r\n\r\n\t\tif (this.forceLTR) {\r\n\t\t\tformatted = \"‎\" + formatted;\r\n\t\t}\r\n\r\n\t\treturn formatted;\r\n\t}\r\n\r\n\t/**\r\n\t * Parses supplied format into structured object which can be used to format\r\n\t * the number.\r\n\t *\r\n\t * @param format Format string, i.e. \"#,###.00\"\r\n\t * @param language Language\r\n\t */\r\n\tprotected parseFormat(format: string, language: Language): any {\r\n\r\n\t\t// Check cache\r\n\t\tlet cached = this.getCache(format);\r\n\t\tif ($type.hasValue(cached)) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\r\n\t\t// init format parse info holder\r\n\t\tlet info: any = {\r\n\t\t\t\"positive\": {\r\n\t\t\t\t\"thousands\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"interval\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"decimals\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"template\": \"\",\r\n\t\t\t\t\"source\": \"\",\r\n\t\t\t\t\"parsed\": false\r\n\t\t\t},\r\n\t\t\t\"negative\": {\r\n\t\t\t\t\"thousands\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"interval\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"decimals\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"template\": \"\",\r\n\t\t\t\t\"source\": \"\",\r\n\t\t\t\t\"parsed\": false\r\n\t\t\t},\r\n\t\t\t\"zero\": {\r\n\t\t\t\t\"thousands\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"interval\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_thousandSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"decimals\": {\r\n\t\t\t\t\t\"active\": -1,\r\n\t\t\t\t\t\"passive\": -1,\r\n\t\t\t\t\t\"separator\": language.translateEmpty(\"_decimalSeparator\")\r\n\t\t\t\t},\r\n\t\t\t\t\"template\": \"\",\r\n\t\t\t\t\"source\": \"\",\r\n\t\t\t\t\"parsed\": false\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Escape double vertical bars (that mean display one vertical bar)\r\n\t\tformat = format.replace(\"||\", $strings.PLACEHOLDER2);\r\n\r\n\t\t// Split it up and deal with different formats\r\n\t\tlet parts = format.split(\"|\");\r\n\t\tinfo.positive.source = parts[0];\r\n\r\n\t\tif (typeof parts[2] === \"undefined\") {\r\n\t\t\tinfo.zero = info.positive;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinfo.zero.source = parts[2];\r\n\t\t}\r\n\r\n\t\tif (typeof parts[1] === \"undefined\") {\r\n\t\t\tinfo.negative = info.positive;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tinfo.negative.source = parts[1];\r\n\t\t}\r\n\r\n\t\t// Parse each\r\n\t\t$object.each(info, (part, item) => {\r\n\t\t\t// Already parsed\r\n\t\t\tif (item.parsed) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Check cached\r\n\t\t\tif (typeof this.getCache(item.source) !== \"undefined\") {\r\n\t\t\t\tinfo[part] = this.getCache(item.source);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Begin parsing\r\n\t\t\tlet partFormat: string = item.source;\r\n\r\n\t\t\t// Just \"Number\"?\r\n\t\t\tif (partFormat.toLowerCase() === \"number\") {\r\n\t\t\t\tpartFormat = $type.isString(this._numberFormat) ? this._numberFormat : \"#,###.#####\";\r\n\t\t\t}\r\n\r\n\t\t\t// Let TextFormatter split into chunks\r\n\t\t\tlet chunks: ITextChunk[] = getTextFormatter().chunk(partFormat, true);\r\n\t\t\tfor (let i: number = 0; i < chunks.length; i++) {\r\n\t\t\t\tlet chunk: ITextChunk = chunks[i];\r\n\r\n\t\t\t\t// replace back double vertical bar\r\n\t\t\t\tchunk.text = chunk.text.replace($strings.PLACEHOLDER2, \"|\");\r\n\r\n\t\t\t\tif (chunk.type === \"value\") {\r\n\t\t\t\t\t// Parse format\r\n\r\n\t\t\t\t\t// Look for codes\r\n\t\t\t\t\tlet matches: string[] | null = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\r\n\r\n\t\t\t\t\tif (matches) {\r\n\t\t\t\t\t\tif (matches === null || matches[0] === \"\") {\r\n\t\t\t\t\t\t\t// no codes here - assume string\r\n\t\t\t\t\t\t\t// nothing to do here\r\n\t\t\t\t\t\t\titem.template += chunk.text;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\t// look for the format modifiers at the end\r\n\t\t\t\t\t\t\tlet mods: string[] | null = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\r\n\r\n\t\t\t\t\t\t\tif (mods) {\r\n\t\t\t\t\t\t\t\titem.mod = mods[0].toLowerCase();\r\n\t\t\t\t\t\t\t\titem.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// break the format up\r\n\t\t\t\t\t\t\tlet a = matches[0].split(\".\");\r\n\r\n\t\t\t\t\t\t\t// Deal with thousands\r\n\t\t\t\t\t\t\tif (a[0] === \"\") {\r\n\t\t\t\t\t\t\t\t// No directives for thousands\r\n\t\t\t\t\t\t\t\t// Leave default settings (no formatting)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// Counts\r\n\t\t\t\t\t\t\t\titem.thousands.active = (a[0].match(/0/g) || []).length;\r\n\t\t\t\t\t\t\t\titem.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active;\r\n\r\n\t\t\t\t\t\t\t\t// Separator interval\r\n\t\t\t\t\t\t\t\tlet b = a[0].split(\",\");\r\n\t\t\t\t\t\t\t\tif (b.length === 1) {\r\n\t\t\t\t\t\t\t\t\t// No thousands separators\r\n\t\t\t\t\t\t\t\t\t// Do nothing\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t// Use length fo the last chunk as thousands length\r\n\t\t\t\t\t\t\t\t\titem.thousands.interval = $type.getValue(b.pop()).length;\r\n\r\n\t\t\t\t\t\t\t\t\tif (item.thousands.interval === 0) {\r\n\t\t\t\t\t\t\t\t\t\titem.thousands.interval = -1;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Deal with decimals\r\n\t\t\t\t\t\t\tif (typeof (a[1]) === \"undefined\") {\r\n\t\t\t\t\t\t\t\t// No directives for decimals\r\n\t\t\t\t\t\t\t\t// Leave at defaults (no formatting)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t// Counts\r\n\t\t\t\t\t\t\t\titem.decimals.active = (a[1].match(/0/g) || []).length;\r\n\t\t\t\t\t\t\t\titem.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t// Add special code to template\r\n\t\t\t\t\t\t\titem.template += chunk.text.split(matches[0]).join($strings.PLACEHOLDER);\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Quoted string - take it as it is\r\n\t\t\t\t\titem.template += chunk.text;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Apply style formatting\r\n\t\t\t//item.template = getTextFormatter().format(item.template, this.outputFormat);\r\n\r\n\t\t\t// Save cache\r\n\t\t\tthis.setCache(item.source, item);\r\n\r\n\t\t\t// Mark this as parsed\r\n\t\t\titem.parsed = true;\r\n\r\n\t\t});\r\n\r\n\t\t// Save cache (the whole thing)\r\n\t\tthis.setCache(format, info);\r\n\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies parsed format to a numeric value.\r\n\t *\r\n\t * @param value    Value\r\n\t * @param details  Parsed format as returned by parseFormat()\r\n\t * @return Formatted number\r\n\t */\r\n\tprotected applyFormat(value: number, details: any): string {\r\n\r\n\t\t// Use absolute values\r\n\t\tlet negative: boolean = value < 0;\r\n\t\tvalue = Math.abs(value);\r\n\r\n\t\t// Recalculate according to modifier\r\n\t\tlet prefix: string = \"\", suffix: string = \"\";\r\n\t\tlet mods: string[] = details.mod ? details.mod.split(\"\") : [];\r\n\t\tif (mods.indexOf(\"b\") !== -1) {\r\n\t\t\tlet a = this.applyPrefix(value, this.bytePrefixes, mods.indexOf(\"!\") !== -1);\r\n\t\t\tvalue = a[0];\r\n\t\t\tprefix = a[1];\r\n\t\t\tsuffix = a[2];\r\n\t\t\tif (details.modSpacing) {\r\n\t\t\t\tsuffix = \" \" + suffix;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"a\") !== -1) {\r\n\t\t\tlet a = this.applyPrefix(value, value < this.smallNumberThreshold ? this.smallNumberPrefixes : this.bigNumberPrefixes, mods.indexOf(\"!\") !== -1);\r\n\t\t\tvalue = a[0];\r\n\t\t\tprefix = a[1];\r\n\t\t\tsuffix = a[2];\r\n\t\t\tif (details.modSpacing) {\r\n\t\t\t\tsuffix = \" \" + suffix;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"p\") !== -1) {\r\n\t\t\tlet ol = Math.min(value.toString().length + 2, 21);\r\n\t\t\t//value *= 100;\r\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\r\n\t\t\tprefix = this.language.translate(\"_percentPrefix\") || \"\";\r\n\t\t\tsuffix = this.language.translate(\"_percentSuffix\") || \"\";\r\n\t\t\tif (prefix == \"\" && suffix == \"\") {\r\n\t\t\t\tsuffix = \"%\";\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"%\") !== -1) {\r\n\t\t\tlet ol = $math.min(value.toString().length + 2, 21);\r\n\t\t\tvalue *= 100;\r\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\r\n\t\t\tsuffix = \"%\";\r\n\t\t}\r\n\t\telse if (mods.indexOf(\"‰\") !== -1) {\r\n\t\t\tlet ol = $math.min(value.toString().length + 3, 21);\r\n\t\t\tvalue *= 1000;\r\n\t\t\tvalue = parseFloat(value.toPrecision(ol));\r\n\t\t\tsuffix = \"‰\";\r\n\t\t}\r\n\r\n\t\t// Round to passive\r\n\t\tif (mods.indexOf(\"e\") !== -1) {\r\n\t\t\t// convert the value to exponential\r\n\t\t\tlet exp: string[];\r\n\t\t\tif (details.decimals.passive >= 0) {\r\n\t\t\t\texp = value.toExponential(details.decimals.passive).split(\"e\");\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\texp = value.toExponential().split(\"e\");\r\n\t\t\t}\r\n\t\t\tvalue = Number(exp[0]);\r\n\t\t\tsuffix = \"e\" + exp[1];\r\n\t\t\tif (details.modSpacing) {\r\n\t\t\t\tsuffix = \" \" + suffix;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (details.decimals.passive === 0) {\r\n\t\t\tvalue = Math.round(value);\r\n\t\t}\r\n\t\telse if (details.decimals.passive > 0) {\r\n\t\t\tlet d: number = Math.pow(10, details.decimals.passive);\r\n\t\t\tvalue = Math.round(value * d) / d;\r\n\t\t}\r\n\r\n\t\t// Init return value\r\n\t\tlet res: string = \"\";\r\n\r\n\t\t// Calc integer and decimal parts\r\n\t\tlet a = $utils.numberToString(value).split(\".\");\r\n\r\n\t\t// Format integers\r\n\t\tlet ints = a[0];\r\n\r\n\t\t// Pad integers to active length\r\n\t\tif (ints.length < details.thousands.active) {\r\n\t\t\tints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\r\n\t\t}\r\n\r\n\t\t// Insert thousands separators\r\n\t\tif (details.thousands.interval > 0) {\r\n\t\t\tlet ip: string[] = [];\r\n\t\t\tlet intsr: string = ints.split(\"\").reverse().join(\"\");\r\n\t\t\tfor (let i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\r\n\t\t\t\tlet c: string = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\r\n\t\t\t\tif (c !== \"\") {\r\n\t\t\t\t\tip.unshift(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tints = ip.join(details.thousands.separator);\r\n\t\t}\r\n\r\n\t\t// Add integers\r\n\t\tres += ints;\r\n\r\n\t\t// Add decimals\r\n\t\tif (a.length === 1) {\r\n\t\t\ta.push(\"\");\r\n\t\t}\r\n\t\tlet decs: string = a[1];\r\n\r\n\t\t// Fill zeros?\r\n\t\tif (decs.length < details.decimals.active) {\r\n\t\t\tdecs += Array(details.decimals.active - decs.length + 1).join(\"0\");\r\n\t\t}\r\n\r\n\t\tif (decs !== \"\") {\r\n\t\t\tres += details.decimals.separator + decs;\r\n\t\t}\r\n\r\n\t\t// Can't have empty return value\r\n\t\tif (res === \"\") {\r\n\t\t\tres = \"0\";\r\n\t\t}\r\n\r\n\t\t// Add minus sign back\r\n\t\tif (value !== 0 && negative && (mods.indexOf(\"s\") === -1)) {\r\n\t\t\tres = \"-\" + res;\r\n\t\t}\r\n\r\n\t\t// Add suffixes/prefixes\r\n\t\tif (prefix) {\r\n\t\t\tres = prefix + res;\r\n\t\t}\r\n\t\tif (suffix) {\r\n\t\t\tres += suffix;\r\n\t\t}\r\n\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Chooses appropriate prefix and suffix based on the passed in rules.\r\n\t *\r\n\t * @param  value     Value\r\n\t * @param  prefixes  Prefix array\r\n\t * @param  force     Force application of a first prefix (@sice 4.5.4)\r\n\t * @return Result\r\n\t */\r\n\tprotected applyPrefix(value: number, prefixes: any[], force: boolean = false): any[] {\r\n\t\tlet newvalue = value;\r\n\t\tlet prefix = \"\";\r\n\t\tlet suffix = \"\";\r\n\t\tlet applied = false;\r\n\t\tlet k = 1;\r\n\r\n\t\tfor (let i = 0, len = prefixes.length; i < len; i++) {\r\n\t\t\tif (prefixes[i].number <= value) {\r\n\t\t\t\tif (prefixes[i].number === 0) {\r\n\t\t\t\t\tnewvalue = 0;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tnewvalue = value / prefixes[i].number;\r\n\t\t\t\t\tk = prefixes[i].number;\r\n\t\t\t\t}\r\n\t\t\t\tprefix = prefixes[i].prefix;\r\n\t\t\t\tsuffix = prefixes[i].suffix;\r\n\t\t\t\tapplied = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t\tif (!applied && force && prefixes.length && value != 0) {\r\n\t\t\t// Prefix was not applied. Use the first prefix.\r\n\t\t\tnewvalue = value / prefixes[0].number;\r\n\t\t\tprefix = prefixes[0].prefix;\r\n\t\t\tsuffix = prefixes[0].suffix;\r\n\t\t\tapplied = true;\r\n\t\t}\r\n\r\n\t\tif (applied) {\r\n\t\t\tnewvalue = parseFloat(\r\n\t\t\t\tnewvalue.toPrecision(\r\n\t\t\t\t\t$math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn [newvalue, prefix, suffix];\r\n\t}\r\n\r\n\t/**\r\n\t * Invalidates the parent [[Sprite]] object.\r\n\t */\r\n\tprotected invalidateSprite(): void {\r\n\t\tif (this.sprite) {\r\n\t\t\tthis.sprite.invalidate();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Number format.\r\n\t *\r\n\t * @default \"#,###.#####\"\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param format  A format to use for number formatting\r\n\t */\r\n\tpublic set numberFormat(format: string | Intl.NumberFormatOptions) {\r\n\t\tthis._numberFormat = format;\r\n\t}\r\n\r\n\t/**\r\n\t * @return A format to use for number formatting\r\n\t */\r\n\tpublic get numberFormat(): string | Intl.NumberFormatOptions {\r\n\t\treturn this._numberFormat;\r\n\t}\r\n\r\n\t/**\r\n\t * Locales if you are using date formats in `Intl.NumberFormatOptions` syntax.\r\n\t * \r\n\t * @see (@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat) about using Intl for number formatting\r\n\t * @param value Locales\r\n\t */\r\n\tpublic set intlLocales(value: string) {\r\n\t\tthis._intlLocales = value;\r\n\t\tthis.invalidateSprite();\r\n\t}\r\n\r\n\t/**\r\n\t * @return Date format\r\n\t */\r\n\tpublic get intlLocales(): string {\r\n\t\treturn this._intlLocales;\r\n\t}\r\n\r\n\t/**\r\n\t * Negative base for negative numbers.\r\n\t *\r\n\t * @default 0\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param format  A format to use for number formatting\r\n\t */\r\n\tpublic set negativeBase(value: number) {\r\n\t\tthis._negativeBase = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return A format to use for number formatting\r\n\t */\r\n\tpublic get negativeBase(): number {\r\n\t\treturn this._negativeBase;\r\n\t}\r\n\r\n\t/**\r\n\t * Prefixes for big numbers.\r\n\t *\r\n\t * It's an array of objects of number/prefix pairs.\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { \"number\": 1e+3, \"suffix\": \"K\" },\r\n\t *   { \"number\": 1e+6, \"suffix\": \"M\" },\r\n\t *   { \"number\": 1e+9, \"suffix\": \"G\" },\r\n\t *   { \"number\": 1e+12, \"suffix\": \"T\" },\r\n\t *   { \"number\": 1e+15, \"suffix\": \"P\" },\r\n\t *   { \"number\": 1e+18, \"suffix\": \"E\" },\r\n\t *   { \"number\": 1e+21, \"suffix\": \"Z\" },\r\n\t *   { \"number\": 1e+24, \"suffix\": \"Y\" }\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * If the number is bigger than the `number` ir will be converted to the\r\n\t * appropriate bigger number with prefix.\r\n\t *\r\n\t * E.g. as per above `1500` will be converted to `1.5K`.\r\n\t *\r\n\t * Please note that for this transformation to be enabled, you need to\r\n\t * enable it specific modifier in your format setting.\r\n\t *\r\n\t * The modifier for big/small number modification is \"a\":\r\n\t *\r\n\t * ```Text\r\n\t * {myfield.formatNumber(\"#,###.00a\")}\r\n\t * ```\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param prefixes  Prefixes for big numbers\r\n\t */\r\n\tpublic set bigNumberPrefixes(prefixes: INumberSuffix[]) {\r\n\t\tthis._bigNumberPrefixes = prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Prefixes for big numbers\r\n\t */\r\n\tpublic get bigNumberPrefixes(): INumberSuffix[] {\r\n\t\tif (!$type.hasValue(this._bigNumberPrefixes)) {\r\n\t\t\tthis._bigNumberPrefixes = [\r\n\t\t\t\t{ \"number\": 1e+3, \"suffix\": this.language.translate(\"_big_number_suffix_3\") },\r\n\t\t\t\t{ \"number\": 1e+6, \"suffix\": this.language.translate(\"_big_number_suffix_6\") },\r\n\t\t\t\t{ \"number\": 1e+9, \"suffix\": this.language.translate(\"_big_number_suffix_9\") },\r\n\t\t\t\t{ \"number\": 1e+12, \"suffix\": this.language.translate(\"_big_number_suffix_12\") },\r\n\t\t\t\t{ \"number\": 1e+15, \"suffix\": this.language.translate(\"_big_number_suffix_15\") },\r\n\t\t\t\t{ \"number\": 1e+18, \"suffix\": this.language.translate(\"_big_number_suffix_18\") },\r\n\t\t\t\t{ \"number\": 1e+21, \"suffix\": this.language.translate(\"_big_number_suffix_21\") },\r\n\t\t\t\t{ \"number\": 1e+24, \"suffix\": this.language.translate(\"_big_number_suffix_24\") }\r\n\t\t\t]\r\n\t\t}\r\n\t\treturn this._bigNumberPrefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Prefixes for big numbers.\r\n\t *\r\n\t * It's an array of objects of number/prefix pairs.\r\n\t *\r\n\t * ```JSON\r\n\t * [\r\n\t *   { \"number\": 1e-24, \"suffix\": \"y\" },\r\n\t *   { \"number\": 1e-21, \"suffix\": \"z\" },\r\n\t *   { \"number\": 1e-18, \"suffix\": \"a\" },\r\n\t *   { \"number\": 1e-15, \"suffix\": \"f\" },\r\n\t *   { \"number\": 1e-12, \"suffix\": \"p\" },\r\n\t *   { \"number\": 1e-9, \"suffix\": \"n\" },\r\n\t *   { \"number\": 1e-6, \"suffix\": \"μ\" },\r\n\t *   { \"number\": 1e-3, \"suffix\": \"m\" }\r\n\t * ]\r\n\t * ```\r\n\t *\r\n\t * If the number is smaller than the `number` ir will be converted to the\r\n\t * appropriate smaller number with prefix.\r\n\t *\r\n\t * E.g. as per above `0.0015` will be converted to `1.5m`.\r\n\t *\r\n\t * Please note that for this transformation to be enabled, you need to\r\n\t * enable it specific modifier in your format setting.\r\n\t *\r\n\t * The modifier for big/small number modification is \"a\":\r\n\t *\r\n\t * ```Text\r\n\t * {myfield.formatNumber(\"#,###.00a\")}\r\n\t * ```\r\n\t *\r\n\t * IMPORTANT: The order of the suffixes is important. The list must start\r\n\t * from the smallest number and work towards bigger ones.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param prefixes  Prefixes for small numbers\r\n\t */\r\n\tpublic set smallNumberPrefixes(prefixes: INumberSuffix[]) {\r\n\t\tthis._smallNumberPrefixes = prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Prefixes for small numbers\r\n\t */\r\n\tpublic get smallNumberPrefixes(): INumberSuffix[] {\r\n\t\tif (!$type.hasValue(this._smallNumberPrefixes)) {\r\n\t\t\tthis._smallNumberPrefixes = [\r\n\t\t\t\t{ \"number\": 1e-24, \"suffix\": this.language.translate(\"_small_number_suffix_24\") },\r\n\t\t\t\t{ \"number\": 1e-21, \"suffix\": this.language.translate(\"_small_number_suffix_21\") },\r\n\t\t\t\t{ \"number\": 1e-18, \"suffix\": this.language.translate(\"_small_number_suffix_18\") },\r\n\t\t\t\t{ \"number\": 1e-15, \"suffix\": this.language.translate(\"_small_number_suffix_15\") },\r\n\t\t\t\t{ \"number\": 1e-12, \"suffix\": this.language.translate(\"_small_number_suffix_12\") },\r\n\t\t\t\t{ \"number\": 1e-9, \"suffix\": this.language.translate(\"_small_number_suffix_9\") },\r\n\t\t\t\t{ \"number\": 1e-6, \"suffix\": this.language.translate(\"_small_number_suffix_6\") },\r\n\t\t\t\t{ \"number\": 1e-3, \"suffix\": this.language.translate(\"_small_number_suffix_3\") }\r\n\t\t\t]\r\n\t\t}\r\n\t\treturn this._smallNumberPrefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Any number smaller than this will be considered \"small\" number, which will\r\n\t * trigger special formatting if \"a\" format modifier is used.\r\n\t *\r\n\t * @since 4.6.8\r\n\t * @param  value  Small number threshold\r\n\t */\r\n\tpublic set smallNumberThreshold(value: number) {\r\n\t\tthis._smallNumberThreshold = value;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Small number threshold\r\n\t */\r\n\tpublic get smallNumberThreshold(): number {\r\n\t\treturn this._smallNumberThreshold;\r\n\t}\r\n\r\n\t/**\r\n\t * Basically the same as `bigNumberPrefixes`, except base for calculation\r\n\t * is not thousand but byte (1024).\r\n\t *\r\n\t * The modifier is \"b\".\r\n\t *\r\n\t *  ```Text\r\n\t * {myfield.formatNumber(\"#,###.00b\")}\r\n\t * ```\r\n\t *\r\n\t * The above `2048` will change to `2K`.\r\n\t *\r\n\t * @see {@link https://www.amcharts.com/docs/v4/concepts/formatters/formatting-numbers/} Tutorial on number formatting\r\n\t * @param prefixes  Prefixes for byte-size formatting\r\n\t */\r\n\tpublic set bytePrefixes(prefixes: INumberSuffix[]) {\r\n\t\tthis._bytePrefixes = prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * @return Prefixes for byte-size formatting\r\n\t */\r\n\tpublic get bytePrefixes(): INumberSuffix[] {\r\n\t\tif (!$type.hasValue(this._bytePrefixes)) {\r\n\t\t\tthis._bytePrefixes = [\r\n\t\t\t\t{ \"number\": 1, suffix: this.language.translate(\"_byte_suffix_B\") },\r\n\t\t\t\t{ \"number\": 1024, suffix: this.language.translate(\"_byte_suffix_KB\") },\r\n\t\t\t\t{ \"number\": 1048576, suffix: this.language.translate(\"_byte_suffix_MB\") },\r\n\t\t\t\t{ \"number\": 1073741824, suffix: this.language.translate(\"_byte_suffix_GB\") },\r\n\t\t\t\t{ \"number\": 1099511627776, suffix: this.language.translate(\"_byte_suffix_TB\") },\r\n\t\t\t\t{ \"number\": 1125899906842624, suffix: this.language.translate(\"_byte_suffix_PB\") }\r\n\t\t\t]\r\n\t\t}\r\n\t\treturn this._bytePrefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Ooutput format: \"svg\" or \"html\".\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param value  Output format\r\n\t */\r\n\tpublic set outputFormat(outputFormat: string) {\r\n\t\tthis._outputFormat = outputFormat.toLowerCase();\r\n\t\tthis.invalidateSprite();\r\n\t}\r\n\r\n\t/**\r\n\t * @ignore Exclude from docs\r\n\t * @return Output format\r\n\t */\r\n\tpublic get outputFormat(): string {\r\n\t\treturn this._outputFormat;\r\n\t}\r\n\r\n\tpublic set forceLTR(value: boolean) {\r\n\t\tthis._forceLTR = value;\r\n\t\tthis.invalidateSprite();\r\n\t}\r\n\r\n\tpublic get forceLTR(): boolean {\r\n\t\treturn this._forceLTR;\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces brackets with temporary placeholders.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Input text\r\n\t * @return Escaped text\r\n\t */\r\n\tpublic escape(text: string): string {\r\n\t\treturn text.replace(\"||\", $strings.PLACEHOLDER2);\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces placeholders back to brackets.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param text  Escaped text\r\n\t * @return Unescaped text\r\n\t */\r\n\tpublic unescape(text: string): string {\r\n\t\treturn text.replace($strings.PLACEHOLDER2, \"|\");\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * Register class in system, so that it can be instantiated using its name from\r\n * anywhere.\r\n *\r\n * @ignore\r\n */\r\nregistry.registeredClasses[\"NumberFormatter\"] = NumberFormatter;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}