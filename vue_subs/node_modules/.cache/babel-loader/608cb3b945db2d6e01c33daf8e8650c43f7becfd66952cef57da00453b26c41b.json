{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * Interaction manages all aspects of user interaction - mouse move,\r\n * click, hover, drag events, touch gestures.\r\n *\r\n * [[InteractionObject]] elements that want to use certain events, must attach event\r\n * listeners to Interaction instance.\r\n *\r\n * Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n * those elements to handle interaction information received via event triggers.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\nimport { BaseObjectEvents } from \"../Base\";\nimport { List } from \"../utils/List\";\nimport { Animation } from \"../utils/Animation\";\nimport { MultiDisposer } from \"../utils/Disposer\";\nimport { InteractionObject } from \"./InteractionObject\";\nimport { InteractionKeyboardObject } from \"./InteractionKeyboardObject\";\nimport { Dictionary } from \"../utils/Dictionary\";\nimport { Inertia } from \"./Inertia\";\nimport { addEventListener } from \"../utils/DOM\";\nimport { keyboard } from \"../utils/Keyboard\";\nimport { system } from \"./../System\";\nimport { options } from \"./../Options\";\nimport * as $ease from \"../utils/Ease\";\nimport * as $math from \"../utils/Math\";\nimport * as $array from \"../utils/Array\";\nimport * as $dom from \"../utils/DOM\";\nimport * as $iter from \"../utils/Iterator\";\nimport * as $type from \"../utils/Type\";\nimport * as $time from \"../utils/Time\";\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n* Interaction manages all aspects of user interaction - mouse move,\r\n* click, hover, drag events, touch gestures.\r\n*\r\n* [[InteractionObject]] elements that want to use certain events, must attach event\r\n* listeners to Interaction instance.\r\n*\r\n* Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n* those elements to handle interaction information received via event triggers.\r\n*\r\n* @see {@link IInteractionEvents} for a list of available events\r\n*/\nvar Interaction = /** @class */function (_super) {\n  __extends(Interaction, _super);\n  /**\r\n   * Constructor. Sets up universal document-wide move events to handle stuff\r\n   * outside particular chart container.\r\n   */\n  function Interaction() {\n    var _this =\n    // Call super\n    _super.call(this) || this;\n    /**\r\n     * An indicator of global events were already initialized.\r\n     */\n    _this._globalEventsAdded = false;\n    /**\r\n     * Holds which mouse event listeners to use.\r\n     */\n    _this._pointerEvents = {\n      \"pointerdown\": \"mousedown\",\n      \"pointerup\": \"mouseup\",\n      \"pointermove\": \"mousemove\",\n      \"pointercancel\": \"mouseup\",\n      \"pointerover\": \"mouseover\",\n      \"pointerout\": \"mouseout\",\n      \"wheel\": \"wheel\"\n    };\n    /**\r\n     * Indicates if Interaction should use only \"pointer\" type events, like\r\n     * \"pointermove\", available in all modern browsers, ignoring \"legacy\"\r\n     * events, like \"touchmove\".\r\n     */\n    _this._usePointerEventsOnly = false;\n    /**\r\n     * Use only touch events (for touch only devices such as tablets and phones)\r\n     */\n    _this._useTouchEventsOnly = false;\n    /**\r\n     * Add special hover events. Normally, touch device tap will also simulate\r\n     * hover event. On some devices (ahem iOS) we want to prevent that so that\r\n     * over/out events are not duplicated.\r\n     */\n    _this._addHoverEvents = true;\n    /**\r\n     * Indicates if passive mode options is supported by this browser.\r\n     */\n    _this._passiveSupported = false;\n    /**\r\n     * Holds list of delayed events\r\n     */\n    _this._delayedEvents = {\n      out: []\n    };\n    /**\r\n     * List of objects that current have a pointer hovered over them.\r\n     */\n    _this.overObjects = new List();\n    /**\r\n     * List of objects that currently has a pressed pointer.\r\n     */\n    _this.downObjects = new List();\n    /**\r\n     * List of objects that need mouse position to be reported to them.\r\n     */\n    _this.trackedObjects = new List();\n    /**\r\n     * List of objects that are currently being dragged.\r\n     */\n    _this.transformedObjects = new List();\n    /**\r\n     * Holds all known pointers.\r\n     */\n    _this.pointers = new Dictionary();\n    /**\r\n     * Inertia options that need to be applied to after element drag, if it's\r\n     * `inert = true`.\r\n     *\r\n     * This is just a default, which can and probably will be overridden by\r\n     * actual elements.\r\n     */\n    _this.inertiaOptions = new Dictionary();\n    /**\r\n     * Default options for click events. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n    _this.hitOptions = {\n      \"doubleHitTime\": 300,\n      //\"delayFirstHit\": false,\n      \"hitTolerance\": 10,\n      \"noFocus\": true\n    };\n    /**\r\n     * Default options for hover events. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n    _this.hoverOptions = {\n      \"touchOutBehavior\": \"leave\",\n      \"touchOutDelay\": 1000\n    };\n    /**\r\n     * Default options for detecting a swipe gesture. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n    _this.swipeOptions = {\n      \"time\": 500,\n      \"verticalThreshold\": 75,\n      \"horizontalThreshold\": 30\n    };\n    /**\r\n     * Default options for keyboard operations. These can be overridden in\r\n     * [[InteractionObject]].\r\n     */\n    _this.keyboardOptions = {\n      \"speed\": 0.1,\n      \"accelleration\": 1.2,\n      \"accellerationDelay\": 2000\n    };\n    /**\r\n     * Default options for keyboard operations. These can be overridden in\r\n     * [[InteractionObject]].\r\n     *\r\n     * @since 4.5.14\r\n     */\n    _this.mouseOptions = {\n      \"sensitivity\": 1\n    };\n    // Set class name\n    _this.className = \"Interaction\";\n    // Create InteractionObject for <body>\n    _this.body = _this.getInteraction(document.body);\n    _this._disposers.push(_this.body);\n    // Detect browser capabilities and determine what event listeners to use\n    if (window.hasOwnProperty(\"PointerEvent\")) {\n      // IE10+/Edge without touch controls enabled\n      _this._pointerEvents.pointerdown = \"pointerdown\";\n      _this._pointerEvents.pointerup = \"pointerup\";\n      _this._pointerEvents.pointermove = \"pointermove\";\n      _this._pointerEvents.pointercancel = \"pointercancel\";\n      _this._pointerEvents.pointerover = \"pointerover\";\n      _this._pointerEvents.pointerout = \"pointerout\";\n      //this._usePointerEventsOnly = true;\n    } else if (window.hasOwnProperty(\"MSPointerEvent\")) {\n      // IE9\n      _this._pointerEvents.pointerdown = \"MSPointerDown\";\n      _this._pointerEvents.pointerup = \"MSPointerUp\";\n      _this._pointerEvents.pointermove = \"MSPointerMove\";\n      _this._pointerEvents.pointercancel = \"MSPointerUp\";\n      _this._pointerEvents.pointerover = \"MSPointerOver\";\n      _this._pointerEvents.pointerout = \"MSPointerOut\";\n      //this._usePointerEventsOnly = true;\n    } else if (typeof matchMedia !== \"undefined\" && matchMedia('(pointer:fine)').matches) {\n      // This is only for Safari as it does not support PointerEvent\n      // Do nothing and let it use regular `mouse*` events\n      // Hi Apple ;)\n      // Additionally disable hover events for iOS devices\n      if ('ontouchstart' in window) {\n        _this._addHoverEvents = false;\n        _this._useTouchEventsOnly = true;\n      }\n    } else if (window.navigator.userAgent.match(/MSIE /)) {\n      // Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!\n      _this._usePointerEventsOnly = true;\n    } else if (_this.fullFF()) {\n      // Old FF, let's use regular events.\n      // (Newer FFs would be detected by the PointerEvent availability check)\n      _this._usePointerEventsOnly = true;\n    } else {\n      // Uses defaults for normal browsers\n      // We also assume that this must be a touch device that does not have\n      // any pointer events\n      _this._useTouchEventsOnly = true;\n    }\n    // Detect if device has a mouse\n    // This is turning out to be not reliable\n    // @todo remove\n    /*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== \"undefined\") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {\r\n        this._useTouchEventsOnly = true;\r\n    }*/\n    // Detect proper mouse wheel events\n    if (\"onwheel\" in document.createElement(\"div\")) {\n      // Modern browsers\n      _this._pointerEvents.wheel = \"wheel\";\n    } else if ($type.hasValue(document.onmousewheel)) {\n      // Webkit and IE support at least \"mousewheel\"\n      _this._pointerEvents.wheel = \"mousewheel\";\n    }\n    // Set up default inertia options\n    _this.inertiaOptions.setKey(\"move\", {\n      \"time\": 100,\n      \"duration\": 500,\n      \"factor\": 1,\n      \"easing\": $ease.polyOut3\n    });\n    _this.inertiaOptions.setKey(\"resize\", {\n      \"time\": 100,\n      \"duration\": 500,\n      \"factor\": 1,\n      \"easing\": $ease.polyOut3\n    });\n    // Set the passive mode support\n    _this._passiveSupported = Interaction.passiveSupported;\n    // Apply theme\n    _this.applyTheme();\n    return _this;\n  }\n  /**\r\n   * This is a nasty detection for Firefox. The reason why we have is that\r\n   * Firefox ESR version does not support matchMedia correctly.\r\n   *\r\n   * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.\r\n   *\r\n   * @return Full Firefox?\r\n   */\n  Interaction.prototype.fullFF = function () {\n    return window.navigator.userAgent.match(/Firefox/) && !window.navigator.userAgent.match(/Android/);\n  };\n  Interaction.prototype.debug = function () {};\n  /**\r\n   * ==========================================================================\r\n   * Processing\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Sets up global events.\r\n   *\r\n   * We need this so that we can track drag movement beyond chart's container.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.addGlobalEvents = function () {\n    var _this = this;\n    if (!this._globalEventsAdded) {\n      if (!this._useTouchEventsOnly) {\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointerdown, function (ev) {\n          _this.handleGlobalPointerDown(ev);\n        }));\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointermove, function (ev) {\n          _this.handleGlobalPointerMove(ev);\n        }));\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointerup, function (ev) {\n          _this.handleGlobalPointerUp(ev);\n        }));\n        this._disposers.push(addEventListener(document, this._pointerEvents.pointercancel, function (ev) {\n          _this.handleGlobalPointerUp(ev, true);\n        }));\n        this._disposers.push(addEventListener(document, \"mouseenter\", function (ev) {\n          if (!$type.hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {\n            _this.handleDocumentLeave(ev);\n          }\n        }));\n      }\n      // No need to duplicate events for hubrid systems that support both\n      // pointer events and touch events. Touch events are need only for\n      // some touch-only systems, like Mobile Safari.\n      if (!this._usePointerEventsOnly) {\n        this._disposers.push(addEventListener(document, \"touchstart\", function (ev) {\n          _this.handleGlobalTouchStart(ev);\n        }));\n        this._disposers.push(addEventListener(document, \"touchmove\", function (ev) {\n          _this.handleGlobalTouchMove(ev);\n        }));\n        this._disposers.push(addEventListener(document, \"touchend\", function (ev) {\n          _this.handleGlobalTouchEnd(ev);\n        }));\n      }\n      this._disposers.push(addEventListener(document, \"keydown\", function (ev) {\n        _this.handleGlobalKeyDown(ev);\n      }));\n      this._disposers.push(addEventListener(document, \"keyup\", function (ev) {\n        _this.handleGlobalKeyUp(ev);\n      }));\n      this._globalEventsAdded = true;\n    }\n  };\n  /**\r\n   * Sets if [[InteractionObject]] is clickable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n  Interaction.prototype.processClickable = function (io) {\n    // Add or remove touch events\n    this.processTouchable(io);\n  };\n  /**\r\n   * Sets if [[InteractionObject]] will display context menu when right-clicked.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n  Interaction.prototype.processContextMenu = function (io) {\n    if (io.contextMenuDisabled) {\n      if (!io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\n        io.eventDisposers.setKey(\"contextMenuDisabled\", addEventListener(io.element, \"contextmenu\", function (e) {\n          e.preventDefault();\n        }));\n      }\n    } else {\n      if (io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\n        io.eventDisposers.getKey(\"contextMenuDisabled\").dispose();\n      }\n    }\n  };\n  /**\r\n   * Sets if [[InteractionObject]] is hoverable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io [[InteractionObject]] instance\r\n   */\n  Interaction.prototype.processHoverable = function (io) {\n    var _this = this;\n    if (io.hoverable || io.trackable) {\n      // Add global events\n      this.addGlobalEvents();\n      // Add hover styles\n      this.applyCursorOverStyle(io);\n      // Add local events\n      if (!io.eventDisposers.hasKey(\"hoverable\") && this._addHoverEvents) {\n        io.eventDisposers.setKey(\"hoverable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.pointerout, function (e) {\n          return _this.handlePointerOut(io, e);\n        }), addEventListener(io.element, this._pointerEvents.pointerover, function (e) {\n          return _this.handlePointerOver(io, e);\n        })]));\n      }\n      if (io.trackable) {\n        //sprite.addEventListener(\"touchmove\", this.handleTouchMove, false, this);\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"hoverable\");\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"hoverable\");\n      }\n    }\n    // Add or remove touch events\n    this.processTouchable(io);\n  };\n  /**\r\n   * Sets up [[InteractionObject]] as movable. Movable can be any\r\n   * transformation, e.g. drag, swipe, resize, track.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processMovable = function (io) {\n    // Add unified events\n    if (io.draggable || io.swipeable || io.trackable || io.resizable) {\n      // Prep the element\n      if (!this.isGlobalElement(io) && !io.isTouchProtected) {\n        this.prepElement(io);\n      }\n      // Add hover styles\n      this.applyCursorOverStyle(io);\n    }\n    // Add or remove touch events\n    this.processTouchable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is trackable and sets relative events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processTrackable = function (io) {\n    this.processHoverable(io);\n    this.processMovable(io);\n    if (io.trackable) {\n      this.trackedObjects.moveValue(io);\n    } else {\n      this.trackedObjects.removeValue(io);\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is draggable.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processDraggable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is swipeable and sets relative events.\r\n   *\r\n   * A swipe event is triggered when a horizontal drag of 75px or more (and\r\n   * less than 30px vertically) occurs within 700 milliseconds. This can be\r\n   * overridden in sprites [[swipeOptions]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processSwipeable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is resizable and attaches required events\r\n   * to it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processResizable = function (io) {\n    this.processMovable(io);\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is supposed to capture mouse wheel events\r\n   * and prepares it to catch those events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processWheelable = function (io) {\n    var _this = this;\n    if (io.wheelable) {\n      //io.hoverable = true;\n      if (!io.eventDisposers.hasKey(\"wheelable\")) {\n        io.eventDisposers.setKey(\"wheelable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.wheel, function (e) {\n          return _this.handleMouseWheel(io, e);\n        }, this._passiveSupported ? {\n          passive: false\n        } : false), io.events.on(\"out\", function (e) {\n          if (io.wheelable) {\n            _this.unlockWheel();\n          }\n        }), io.events.on(\"over\", function (e) {\n          //console.log(\"whelab over\")\n          if (io.wheelable) {\n            _this.lockWheel();\n          }\n        })]));\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"wheelable\");\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"wheelable\");\n      }\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is focusable. A focusable element is an\r\n   * element that will be highlighted when users presses TAB key. If the\r\n   * element is focusable, this function will attach relative focus/blur\r\n   * events to it.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processFocusable = function (io) {\n    var _this = this;\n    if (io.focusable === true && io.tabindex > -1 && !this._useTouchEventsOnly) {\n      if (!io.eventDisposers.hasKey(\"focusable\")) {\n        io.eventDisposers.setKey(\"focusable\", new MultiDisposer([addEventListener(io.element, \"focus\", function (e) {\n          return _this.handleFocus(io, e);\n        }), addEventListener(io.element, \"blur\", function (e) {\n          return _this.handleBlur(io, e);\n        }), addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n          return _this.handleFocusBlur(io, e);\n        }), addEventListener(io.element, \"touchstart\", function (e) {\n          return _this.handleFocusBlur(io, e);\n        }, this._passiveSupported ? {\n          passive: false\n        } : false)]));\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"focusable\");\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"focusable\");\n      }\n    }\n  };\n  /**\r\n   * Checks if [[InteractionObject]] is \"touchable\". It means any interaction\r\n   * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   */\n  Interaction.prototype.processTouchable = function (io) {\n    var _this = this;\n    // Add unified events\n    if (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {\n      // Add global events\n      this.addGlobalEvents();\n      // Add local events\n      if (!io.eventDisposers.hasKey(\"touchable\")) {\n        if (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", new MultiDisposer([addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n            return _this.handlePointerDown(io, e);\n          }), addEventListener(io.element, \"touchstart\", function (e) {\n            return _this.handleTouchDown(io, e);\n          }, this._passiveSupported ? {\n            passive: false\n          } : false)]));\n        } else if (!this._useTouchEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, this._pointerEvents.pointerdown, function (e) {\n            return _this.handlePointerDown(io, e);\n          }));\n        } else if (!this._usePointerEventsOnly) {\n          io.eventDisposers.setKey(\"touchable\", addEventListener(io.element, \"touchstart\", function (e) {\n            return _this.handleTouchDown(io, e);\n          }, this._passiveSupported ? {\n            passive: false\n          } : false));\n        }\n      }\n    } else {\n      var disposer = io.eventDisposers.getKey(\"touchable\");\n      if (disposer != null) {\n        disposer.dispose();\n        io.eventDisposers.removeKey(\"touchable\");\n      }\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Non-pointer events\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Dispatches \"focus\" event when element gains focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handleFocus = function (io, ev) {\n    if (!io.focusable) {\n      ev.preventDefault();\n      return;\n    }\n    io.isFocused = true;\n    if (io.events.isEnabled(\"focus\") && !system.isPaused) {\n      var imev = {\n        type: \"focus\",\n        target: io,\n        event: ev\n      };\n      io.events.dispatchImmediately(\"focus\", imev);\n    }\n  };\n  /**\r\n   * Used by regular click events to prevent focus if \"noFocus\" is set.\r\n   *\r\n   * This should not be called by \"focus\" handlers.\r\n   *\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handleFocusBlur = function (io, ev) {\n    if (io.focusable !== false && this.getHitOption(io, \"noFocus\")) {\n      io.events.once(\"focus\", function () {\n        io.events.disableType(\"blur\");\n        $dom.blur();\n        if (io.sprite) {\n          io.sprite.handleBlur();\n        }\n        io.events.enableType(\"blur\");\n      });\n    }\n  };\n  /**\r\n   * Dispatches \"blur\" event when element loses focus.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handleBlur = function (io, ev) {\n    if (!io.focusable) {\n      ev.preventDefault();\n      return;\n    }\n    io.isFocused = false;\n    if (io.events.isEnabled(\"blur\") && !system.isPaused) {\n      var imev = {\n        type: \"blur\",\n        target: io,\n        event: ev\n      };\n      io.events.dispatchImmediately(\"blur\", imev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Global keyboard-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Checks if there is an item that has currently focus and that they key is\r\n   * one of the directional keys. If both of the conditions are true, it\r\n   * creates an object to simulate movement of dragable element with keyboard.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev An original keyboard event\r\n   */\n  Interaction.prototype.handleGlobalKeyDown = function (ev) {\n    if (this.focusedObject) {\n      if (keyboard.isKey(ev, \"esc\")) {\n        // ESC removes focus\n        $dom.blur();\n      } else if (this.focusedObject.draggable && keyboard.isKey(ev, [\"up\", \"down\", \"left\", \"right\"])) {\n        // Prevent scrolling of the document\n        ev.preventDefault();\n        // Get focused object\n        var io = this.focusedObject;\n        // Get particular key\n        var disposerKey = \"interactionKeyboardObject\";\n        // If such disposer already exists we know the event is going on so we\n        // just move on\n        if (io.eventDisposers.hasKey(disposerKey)) {\n          return;\n        }\n        // Create a keyboard mover\n        var ko = new InteractionKeyboardObject(io, ev);\n        io.eventDisposers.setKey(disposerKey, ko);\n        switch (keyboard.getEventKey(ev)) {\n          case \"up\":\n            ko.directionY = -1;\n            break;\n          case \"down\":\n            ko.directionY = 1;\n            break;\n          case \"left\":\n            ko.directionX = -1;\n            break;\n          case \"right\":\n            ko.directionX = 1;\n            break;\n        }\n      }\n    }\n  };\n  /**\r\n   * Dispatches related events when the keyboard key is realeasd.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev An original keyboard event\r\n   */\n  Interaction.prototype.handleGlobalKeyUp = function (ev) {\n    var disposerKey = \"interactionKeyboardObject\";\n    if (this.focusedObject) {\n      var disposer = this.focusedObject.eventDisposers.getKey(disposerKey);\n      if (disposer != null) {\n        // Prevent scrolling of the document\n        ev.preventDefault();\n        // Dispose stuff\n        disposer.dispose();\n        this.focusedObject.eventDisposers.removeKey(disposerKey);\n      }\n      // Does focused object have \"hit\" event?\n      var sprite = this.focusedObject.sprite;\n      if (keyboard.isKey(ev, \"enter\") && sprite) {\n        if (sprite.events.isEnabled(\"hit\") || sprite.events.isEnabled(\"toggled\")) {\n          this.focusedObject.dispatchImmediately(\"hit\");\n        } else if (sprite.showTooltipOn == \"hit\") {\n          this.focusedObject.dispatchImmediately(\"up\");\n        }\n      }\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Global pointer-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Handler for a global \"pointermove\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n  Interaction.prototype.handleGlobalPointerMove = function (ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Update current point position\n    pointer.point = this.getPointerPoint(ev);\n    // Prepare and fire global event\n    if (this.events.isEnabled(\"track\") && !system.isPaused) {\n      var imev = {\n        type: \"track\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"track\", imev);\n    }\n    // Track\n    this.addBreadCrumb(pointer, pointer.point);\n    // Process further\n    this.handleGlobalMove(pointer, ev);\n  };\n  /**\r\n   * Handler for a global \"pointerdown\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n  Interaction.prototype.handleGlobalPointerDown = function (ev) {\n    // Remove delayed hovers\n    this.processDelayed();\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Prepare and fire global event\n    if (this.events.isEnabled(\"down\") && !system.isPaused) {\n      var imev = {\n        type: \"down\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"down\", imev);\n    }\n  };\n  /**\r\n   * Prevents touch action from firing.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event\r\n   */\n  Interaction.prototype.preventTouchAction = function (ev) {\n    if (!ev.defaultPrevented) {\n      ev.preventDefault();\n    }\n  };\n  /**\r\n   * Handler for a global \"pointerup\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n  Interaction.prototype.handleGlobalPointerUp = function (ev, cancelled) {\n    if (cancelled === void 0) {\n      cancelled = false;\n    }\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Prepare and fire global event\n    if (this.events.isEnabled(\"up\") && !system.isPaused) {\n      var imev = {\n        type: \"up\",\n        target: this,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      this.events.dispatchImmediately(\"up\", imev);\n    }\n    // Process further\n    this.handleGlobalUp(pointer, ev, cancelled);\n  };\n  /**\r\n  * ==========================================================================\r\n  * Global touch-related even handlers\r\n  * ==========================================================================\r\n  */\n  /**\r\n   * Handler for a global \"touchmove\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n  Interaction.prototype.handleGlobalTouchMove = function (ev) {\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]);\n      // Update current point position\n      pointer.point = this.getPointerPoint(ev.changedTouches[i]);\n      // Prepare and fire global event\n      if (this.events.isEnabled(\"track\") && !system.isPaused) {\n        var imev = {\n          type: \"track\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"track\", imev);\n      }\n      // Track\n      this.addBreadCrumb(pointer, pointer.point);\n      // Process further\n      this.handleGlobalMove(pointer, ev);\n    }\n  };\n  /**\r\n   * Handler for a global \"touchstart\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n  Interaction.prototype.handleGlobalTouchStart = function (ev) {\n    // Remove delayed hovers\n    this.processDelayed();\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]);\n      // Prepare and fire global event\n      if (!this._usePointerEventsOnly && this.events.isEnabled(\"down\") && !system.isPaused) {\n        var imev = {\n          type: \"down\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"down\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handler for a global \"touchend\" event.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev Event object\r\n   */\n  Interaction.prototype.handleGlobalTouchEnd = function (ev) {\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]);\n      // Prepare and fire global event\n      if (this.events.isEnabled(\"up\") && !system.isPaused) {\n        var imev = {\n          type: \"up\",\n          target: this,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        this.events.dispatchImmediately(\"up\", imev);\n      }\n      // Handle element-related events\n      this.handleGlobalUp(pointer, ev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Element-specific pointer-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Handles event when pointer is over [[InteractionObject]] and button is\r\n   * pressed.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handlePointerDown = function (io, ev) {\n    // Stop further propagation so we don't get multiple triggers on hybrid\n    // devices (both mouse and touch capabilities)\n    //ev.preventDefault();\n    //ev.stopPropagation();\n    //if (ev.defaultPrevented) {\n    //}\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Ignore if it's anything but mouse's primary button\n    if (!pointer.touch && ev.which != 1 && ev.which != 3) {\n      return;\n    }\n    // Set mouse button\n    pointer.button = ev.which;\n    // Reset pointer\n    this.resetPointer(pointer, ev);\n    // Process down\n    this.handleDown(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when [[InteractionObject]] is hovered by a mouse pointer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handlePointerOver = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Process down\n    this.handleOver(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when [[InteractionObject]] loses hover from a mouse pointer.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handlePointerOut = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Process down\n    this.handleOut(io, pointer, ev);\n  };\n  /**\r\n   * Handles event when mouse wheel is crolled over the [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n   */\n  Interaction.prototype.handleMouseWheel = function (io, ev) {\n    // Get pointer\n    var pointer = this.getPointer(ev);\n    // Update current point position\n    pointer.point = this.getPointerPoint(ev);\n    // Init delta values\n    var deltaX = 0,\n      deltaY = 0;\n    // Set up modifier\n    // This is needed because FireFox reports wheel deltas in \"lines\" instead\n    // of pixels so we have to approximate pixel value\n    var mod = 1;\n    if (ev.deltaMode == 1) {\n      mod = 50;\n    }\n    // Adjust configurable sensitivity\n    mod *= this.getMouseOption(io, \"sensitivity\");\n    // Calculate deltas\n    if (ev instanceof WheelEvent) {\n      deltaX = Math.round(-1 * ev.wheelDeltaX || ev.deltaX * mod);\n      deltaY = Math.round(-1 * ev.wheelDeltaY || ev.deltaY * mod);\n    } else {\n      throw new Error(\"Invalid event type\");\n    }\n    // Handle the event\n    this.handleWheel(io, pointer, deltaX, deltaY, ev);\n  };\n  /**\r\n   * ==========================================================================\r\n   * Element-specific touch-related even handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n    * Handles an event when an [[InteractionObject]] is touched on a touch\r\n    * device.\r\n    *\r\n    * @ignore Exclude from docs\r\n    * @param io  Element\r\n    * @param ev  Original event\r\n    */\n  Interaction.prototype.handleTouchDown = function (io, ev) {\n    // Stop further propagation so we don't get multiple triggers on hybrid\n    // devices (both mouse and touch capabilities)\n    //this.maybePreventDefault(io, ev);\n    //return;\n    // Process each changed touch point\n    for (var i = 0; i < ev.changedTouches.length; i++) {\n      // Get pointer\n      var pointer = this.getPointer(ev.changedTouches[i]);\n      this.maybePreventDefault(io, ev, pointer);\n      // Reset pointer\n      this.resetPointer(pointer, ev.changedTouches[i]);\n      // Process down\n      this.handleDown(io, pointer, ev);\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Universal handlers\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Handles click/tap. Checks for doublehit.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleHit = function (io, pointer, ev) {\n    // Check if this is a double-hit\n    var now = $time.getTime();\n    if (io.lastHit && io.lastHit >= now - this.getHitOption(io, \"doubleHitTime\")) {\n      // Yup - it's a double-hit\n      // Cancel the hit\n      //clearTimeout(io.lastHitPointer.hitTimeout);\n      // If it happened too fast it probably means that hybrid device just\n      // generated two events for the same tap\n      if (now - io.lastHit < 100) {\n        // Ignore\n        return;\n      }\n      // Clear last hit\n      io.lastHit = undefined;\n      io.lastHitPointer = undefined;\n      // Dispatch event\n      if (io.events.isEnabled(\"doublehit\") && !system.isPaused) {\n        var imev = {\n          type: \"doublehit\",\n          target: io,\n          point: pointer.point,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"doublehit\", imev);\n      }\n    } else {\n      // Log last hit\n      io.lastHit = now;\n      io.lastHitPointer = pointer;\n      if (pointer.button === 3) {\n        // Execute HIT now\n        if (io.events.isEnabled(\"rightclick\") && !system.isPaused) {\n          var imev = {\n            type: \"rightclick\",\n            target: io,\n            event: ev\n          };\n          io.events.dispatchImmediately(\"rightclick\", imev);\n        }\n      } else {\n        if (io.events.isEnabled(\"hit\") && !system.isPaused) {\n          var imev = {\n            type: \"hit\",\n            target: io,\n            event: ev,\n            point: pointer.point,\n            touch: pointer.touch\n          };\n          io.events.dispatchImmediately(\"hit\", imev);\n        }\n      }\n    }\n  };\n  /**\r\n   * Handles pointer hovering over [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   * @param soft     Invoked by helper function\r\n   */\n  Interaction.prototype.handleOver = function (io, pointer, ev, soft) {\n    if (soft === void 0) {\n      soft = false;\n    }\n    if (!io.hoverable) {\n      return;\n    }\n    var hoversPaused = false;\n    if (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n      hoversPaused = true;\n      this.cancelAllHovers(ev);\n    }\n    // Remove any delayed outs\n    this.processDelayed();\n    // Add pointer\n    io.overPointers.moveValue(pointer);\n    // Check if object is not yet hovered\n    if (!io.isRealHover) {\n      // Set element as hovered\n      if (!hoversPaused) {\n        io.isHover = true;\n        io.isRealHover = true;\n        this.overObjects.moveValue(io);\n      }\n      // Generate body track event. This is needed so that if element loads\n      // under unmoved mouse cursor, we still need all the actions that are\n      // required to happen to kick in.\n      this.handleTrack(this.body, pointer, ev, true);\n      // Event\n      if (io.events.isEnabled(\"over\") && !system.isPaused && !hoversPaused) {\n        var imev = {\n          type: \"over\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"over\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles when [[InteractionObject]] is no longer hovered.\r\n   *\r\n   * If `soft = true`, this means that method is being invoked by some other\r\n   * code, not hard \"out\" function, like `handleUp` which implies we need to\r\n   * run additional checks before unhovering the object.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   * @param soft     Invoked by helper function\r\n   * @param force    Force imediate out\r\n   */\n  Interaction.prototype.handleOut = function (io, pointer, ev, soft, force) {\n    var _this = this;\n    if (soft === void 0) {\n      soft = false;\n    }\n    if (force === void 0) {\n      force = false;\n    }\n    if (!io.hoverable) {\n      return;\n    }\n    // Remove pointer\n    io.overPointers.removeValue(pointer);\n    // Check if element is still hovered\n    if (io.isHover && (!io.hasDelayedOut || force)) {\n      // Should we run additional checks?\n      if (soft && io.overPointers.length) {\n        // There are still pointers hovering - don't do anything else and\n        // wait until either no over pointers are there or we get a hard out\n        // event.\n        return;\n      }\n      // Should we delay \"out\" if this is happening on a touch device?\n      if (pointer && pointer.touch && !force && !this.old(pointer)) {\n        // This is a touch pointer, and it hasn't moved, let's pretend\n        // the object is still hovered, and act as per \"behavior\" setting\n        var behavior = this.getHoverOption(io, \"touchOutBehavior\");\n        if (behavior == \"leave\") {\n          // Set to \"leave\", so we do not execute any \"out\" event.\n          // It will be handled by any other interaction that happens\n          // afterwards.\n          this._delayedEvents.out.push({\n            type: \"out\",\n            io: io,\n            pointer: pointer,\n            event: ev,\n            keepUntil: $time.getTime() + 500\n          });\n          io.hasDelayedOut = true;\n          return;\n        } else if (behavior == \"delay\" && this.getHoverOption(io, \"touchOutDelay\")) {\n          this._delayedEvents.out.push({\n            type: \"out\",\n            io: io,\n            pointer: pointer,\n            event: ev,\n            keepUntil: $time.getTime() + 500,\n            timeout: this.setTimeout(function () {\n              _this.handleOut(io, pointer, ev, true);\n            }, this.getHoverOption(io, \"touchOutDelay\"))\n          });\n          return;\n        } else {\n          // Nothing for \"remove\" - that's how it works \"out-of-the-box\"\n        }\n      }\n      // Set element as not hovered\n      io.isHover = false;\n      this.overObjects.removeValue(io);\n      // Invoke event\n      if (!io.isDisposed() && io.events.isEnabled(\"out\") && !system.isPaused) {\n        var imev = {\n          type: \"out\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"out\", imev);\n      }\n      // Reset object from lefover delayed outs, pointers\n      io.overPointers.clear();\n      io.hasDelayedOut = false;\n      // @todo (clean delayed)\n    }\n  };\n  /**\r\n   * Processes dalyed events, such as \"out\" event that was initiated for\r\n   * elements by touch.\r\n   */\n  Interaction.prototype.processDelayed = function () {\n    var delayedEvent;\n    while (true) {\n      delayedEvent = this._delayedEvents.out.pop();\n      if (!delayedEvent) {\n        break;\n      }\n      if (delayedEvent.timeout) {\n        delayedEvent.timeout.dispose();\n      }\n      this.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);\n    }\n  };\n  /**\r\n   * Performs tasks on pointer down.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleDown = function (io, pointer, ev) {\n    // Need to prevent default event from happening on transformable objects\n    this.maybePreventDefault(io, ev, pointer);\n    // Stop inertia animations if they're currently being played out\n    if (io.inert) {\n      this.stopInertia(io);\n    }\n    // Trigger hover because some touch devices won't trigger over events\n    // on their own\n    this.handleOver(io, pointer, ev, true);\n    // Add pointer to list\n    io.downPointers.moveValue(pointer);\n    // Apply styles if necessary\n    this.applyCursorDownStyle(io, pointer);\n    // Check if object is already down\n    if (!io.isDown) {\n      // Lose focus if needed\n      if (io.focusable !== false && this.getHitOption(io, \"noFocus\") && this.focusedObject) {\n        $dom.blur();\n      }\n      // Set object as hovered\n      io.isDown = true;\n      this.downObjects.moveValue(io);\n      // Prep object for dragging and/or resizing\n      if (io.draggable) {\n        this.processDragStart(io, pointer, ev);\n      }\n      if (io.resizable) {\n        this.processResizeStart(io, pointer, ev);\n      }\n    }\n    // Dispatch \"down\" event\n    if (io.events.isEnabled(\"down\") && !system.isPaused) {\n      var imev = {\n        type: \"down\",\n        target: io,\n        event: ev,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"down\", imev);\n    }\n  };\n  /**\r\n   * Performs tasks on pointer up.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleGlobalUp = function (pointer, ev, cancelled) {\n    var _this = this;\n    if (cancelled === void 0) {\n      cancelled = false;\n    }\n    var sorted = this.downObjects.values.slice();\n    sorted.sort(function (x, y) {\n      if (x && y) {\n        var pos = x.element.compareDocumentPosition(y.element);\n        if (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n          return 1;\n        } else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {\n          return -1;\n        } else {\n          return 0;\n        }\n      } else {\n        return 0;\n      }\n    });\n    // Process all down objects\n    $array.each(sorted, function (io) {\n      // Check if this particular pointer is pressing down\n      // on object\n      if (io && io.downPointers.contains(pointer)) {\n        _this.handleUp(io, pointer, ev, cancelled);\n      }\n    });\n  };\n  /**\r\n   * Simulates all pointers being up once mouse leaves document area.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleDocumentLeave = function (ev) {\n    var _this = this;\n    // Process all down objects\n    $iter.each(this.downObjects.backwards().iterator(), function (io) {\n      io.downPointers.each(function (pointer) {\n        _this.handleUp(io, pointer, ev);\n      });\n    });\n  };\n  /**\r\n   * Handles when [[InteractionObject]] is no longer hovered.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Interaction object\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleUp = function (io, pointer, ev, cancelled) {\n    if (cancelled === void 0) {\n      cancelled = false;\n    }\n    // Restore cursor style\n    this.restoreCursorDownStyle(io, pointer);\n    // Remove pointer from the list\n    io.downPointers.removeValue(pointer);\n    // Trigger out because some touch devices won't trigger out events\n    // on their own\n    if (pointer && pointer.touch || this._useTouchEventsOnly) {\n      this.handleOut(io, pointer, ev, true);\n    }\n    // Check if object still down\n    if (io.isDown) {\n      // Check if there are no other pointers hovering this element\n      if (io.downPointers.length == 0) {\n        // Set element as no longer down\n        io.isDown = false;\n        this.downObjects.removeValue(io);\n      }\n      // Dispatch \"up\" event\n      if (io.events.isEnabled(\"up\") && !system.isPaused && pointer) {\n        var imev = {\n          type: \"up\",\n          target: io,\n          event: ev,\n          pointer: pointer,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"up\", imev);\n      }\n      // Check if this was not a cancelled event.\n      // If event was canelled (which might happen if gesture resulted in\n      // navigation or page scroll) there's no point in triggering hit and\n      // other actions.\n      if (!cancelled) {\n        // Handle swiping-related stuff\n        if (io.swipeable && this.swiped(io, pointer)) {\n          // Swiped - nothing else should happen\n          this.handleSwipe(io, pointer, ev);\n        } else {\n          // Check if it maybe a click\n          if (io.clickable && !this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n            this.handleHit(io, pointer, ev);\n          }\n          // Handle inertia\n          if (io.inert && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\n            this.handleInertia(io, pointer);\n          } else if (io.draggable) {\n            this.processDragStop(io, pointer, ev);\n          }\n          if (io.resizable) {\n            this.processResizeStop(io, pointer, ev);\n          }\n        }\n      }\n    }\n  };\n  /**\r\n   * Checks if event needs to be prevented on draggable and such items, so that\r\n   * touch gestures like navigation and scroll do not kick in.\r\n   *\r\n   * @param io  Object\r\n   * @param ev  Event\r\n   */\n  Interaction.prototype.maybePreventDefault = function (io, ev, pointer) {\n    if ($type.hasValue(ev) && (io.draggable || io.swipeable || io.trackable || io.resizable) && !this.isGlobalElement(io) && ev.cancelable !== false && (!io.isTouchProtected || !pointer || !pointer.touch)) {\n      ev.preventDefault();\n    }\n  };\n  /**\r\n   * Cancels all hovers on all currently hovered objects.\r\n   *\r\n   * @param  pointer  Pointer\r\n   * @param  ev       Event\r\n   */\n  Interaction.prototype.cancelAllHovers = function (ev) {\n    var _this = this;\n    //this.overObjects.each((io) => {\n    $iter.each(this.overObjects.backwards().iterator(), function (io) {\n      if (io) {\n        var pointer = io.overPointers.getIndex(0);\n        _this.handleOut(io, pointer, ev, true, true);\n      }\n    });\n  };\n  /**\r\n   * Checks if hovers should be cancelled on transform as per global options.\r\n   * @param   pointer  Pointer\r\n   * @return           Cancel?\r\n   */\n  Interaction.prototype.shouldCancelHovers = function (pointer) {\n    return options.disableHoverOnTransform == \"always\" || options.disableHoverOnTransform == \"touch\" && pointer.touch;\n  };\n  /**\r\n   * Handles pointer move.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleGlobalMove = function (pointer, ev) {\n    var _this = this;\n    // Process hovered elements\n    // We check if the element became unhovered without reporting the mouseout\n    // event. (it happens in some cases)\n    if (!pointer.touch) {\n      var target_1 = $dom.eventTarget(pointer.lastEvent);\n      $iter.each(this.overObjects.backwards().iterator(), function (io) {\n        // Is this pointer relevant to element?\n        if (io && io.overPointers.contains(pointer) && io.hoverable) {\n          // Check if the element is still hovered\n          var reset = false;\n          if (io.element && pointer.lastEvent) {\n            if (!$dom.contains(io.element, target_1)) {\n              reset = true;\n            }\n          } else {\n            reset = true;\n          }\n          if (reset) {\n            _this.handleOut(io, pointer, ev, true);\n          }\n        }\n      });\n    }\n    // Process down elements\n    $iter.each(this.transformedObjects.backwards().iterator(), function (io) {\n      // Is this pointer relevant to element?\n      if (io.downPointers.contains(pointer) &&\n      // Swipe still happening?\n      !(io.swipeable && _this.swiping(io, pointer)) && (io.draggable || io.resizable)) {\n        _this.handleTransform(io, ev);\n      }\n    });\n    // Process tracked elements\n    $iter.each(this.trackedObjects.backwards().iterator(), function (io) {\n      // Is this pointer relevant to element?\n      if (!io.overPointers.contains(pointer)) {\n        _this.handleTrack(io, pointer, ev);\n      }\n    });\n  };\n  /**\r\n   * Handles reporting of pointer movement.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io        Element\r\n   * @param pointer    Pointer\r\n   * @param ev         Original event\r\n   * @param skipCheck  Sould we skip check if cursor actually moved\r\n   */\n  Interaction.prototype.handleTrack = function (io, pointer, ev, skipCheck) {\n    if (skipCheck === void 0) {\n      skipCheck = false;\n    }\n    // Do nothing if the cursor did not actually move\n    if (!skipCheck && !this.moved(pointer, 0)) {\n      return;\n    }\n    // Initiate TRACK event\n    if (io.events.isEnabled(\"track\") && !system.isPaused) {\n      var imev = {\n        type: \"track\",\n        target: io,\n        event: ev,\n        point: pointer.point,\n        pointer: pointer,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"track\", imev);\n    }\n  };\n  /**\r\n   * Handles swipe action.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleSwipe = function (io, pointer, ev) {\n    // We pass in InteractionEvent with shift in mouse coordinates\n    // between when the drag started and ended\n    if (io.events.isEnabled(\"swipe\") && !system.isPaused) {\n      var imev = {\n        type: \"swipe\",\n        target: io,\n        event: ev,\n        touch: pointer.touch\n      };\n      io.events.dispatchImmediately(\"swipe\", imev);\n    }\n    if (pointer.startPoint.x < pointer.point.x) {\n      if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\n        var imev = {\n          type: \"swiperight\",\n          target: io,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"swiperight\", imev);\n      }\n    } else {\n      if (io.events.isEnabled(\"swipeleft\") && !system.isPaused) {\n        var imev = {\n          type: \"swipeleft\",\n          target: io,\n          event: ev,\n          touch: pointer.touch\n        };\n        io.events.dispatchImmediately(\"swipeleft\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles event triggering for wheel rotation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param deltaX   Horizontal shift\r\n   * @param deltaY   Vertical shift\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.handleWheel = function (io, pointer, deltaX, deltaY, ev) {\n    var shift = {\n      x: deltaX,\n      y: deltaY\n    };\n    // Trigger generic WHEEL event\n    if (io.events.isEnabled(\"wheel\") && !system.isPaused) {\n      io.events.dispatchImmediately(\"wheel\", {\n        type: \"wheel\",\n        target: io,\n        event: ev,\n        point: pointer.point,\n        shift: shift\n      });\n    }\n    // Trigger direction-specific events\n    // Horizontal\n    if (deltaX < 0) {\n      if (io.events.isEnabled(\"wheelleft\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelleft\", {\n          type: \"wheelleft\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    } else if (deltaX > 0) {\n      if (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelright\", {\n          type: \"wheelright\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n      // Vertical\n    } else if (deltaY < 0) {\n      if (io.events.isEnabled(\"wheelup\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheelup\", {\n          type: \"wheelup\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    } else if (deltaY > 0) {\n      if (io.events.isEnabled(\"wheeldown\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"wheeldown\", {\n          type: \"wheeldown\",\n          target: io,\n          event: ev,\n          point: pointer.point,\n          shift: shift\n        });\n      }\n    }\n  };\n  /**\r\n   * Initiates inertia checking sub-routines for different movement types:\r\n   * drag, resize.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param sprite\r\n   * @param pointer\r\n   */\n  Interaction.prototype.handleInertia = function (io, pointer) {\n    if (io.draggable && io.downPointers.length === 0) {\n      this.handleMoveInertia(io, pointer);\n    }\n    if (io.resizable && io.downPointers.length > 1) {\n      this.handleResizeInertia(io, pointer);\n    }\n  };\n  /**\r\n   * Continues moving the element to simulate the effect of inertia. Happens\r\n   * when `inert` and `draggable` object is dragged and then released.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n  Interaction.prototype.handleMoveInertia = function (io, pointer) {\n    var interaction = io;\n    var type = \"move\";\n    var point = {\n      \"x\": pointer.point.x,\n      \"y\": pointer.point.y\n    };\n    var startPoint = {\n      \"x\": pointer.startPoint.x,\n      \"y\": pointer.startPoint.y\n    };\n    // Init inertia object\n    var inertia = new Inertia(interaction, type, point, startPoint);\n    // Get inertia data\n    var ref = this.getTrailPoint(pointer, $time.getTime() - this.getInertiaOption(io, \"move\", \"time\"));\n    if (typeof ref === \"undefined\") {\n      this.processDragStop(io, pointer, pointer.lastUpEvent);\n      return;\n    }\n    // Init animation options\n    var factor = this.getInertiaOption(io, \"move\", \"factor\");\n    var animationOptions = [{\n      \"to\": pointer.point.x + (pointer.point.x - ref.point.x) * factor,\n      \"property\": \"x\"\n    }, {\n      \"to\": pointer.point.y + (pointer.point.y - ref.point.y) * factor,\n      \"property\": \"y\"\n    }];\n    // Start animation\n    var animation = new Animation(inertia, animationOptions, this.getInertiaOption(io, \"move\", \"duration\"), this.getInertiaOption(io, \"move\", \"easing\")).start();\n    this._disposers.push(animation.events.on(\"animationended\", function (ev) {\n      inertia.done();\n    }));\n    // Add inertia object\n    io.inertias.setKey(\"move\", inertia);\n  };\n  /**\r\n   * Continues resizing of a `resizable` element after it is resized and\r\n   * released.\r\n   *\r\n   * **NOTE:** this is is just a placeholder function. No actual fucntionality\r\n   * is implemented, yet.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n  Interaction.prototype.handleResizeInertia = function (io, pointer) {\n    // Some day, folks. Some day...\n  };\n  /**\r\n   * Recalculates element's position and size based on position of\r\n   * all its related pointers.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io  Element\r\n   * @param ev  Original event\r\n   */\n  Interaction.prototype.handleTransform = function (io, ev) {\n    // Get primary pointer and its respective points\n    var pointer1 = io.downPointers.getIndex(0);\n    var point1 = null;\n    var startPoint1 = null;\n    if (pointer1) {\n      point1 = pointer1.point;\n      startPoint1 = pointer1.startPoint;\n    }\n    // Init secondary pointer\n    var pointer2;\n    var point2;\n    var startPoint2;\n    // Use center of the sprite to simulate \"second\" point of touch\n    point2 = {\n      \"x\": io.originalPosition.x,\n      \"y\": io.originalPosition.y\n    };\n    startPoint2 = point2;\n    // Determine if it's a sinngle pointer or multi\n    var singlePoint = true;\n    for (var i = 1; i < io.downPointers.length; i++) {\n      // Get pointer\n      var nextPointer = io.downPointers.getIndex(i);\n      // Doublecheck if it's not the same pointer by comparing original position\n      if (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {\n        // Several pointers down\n        singlePoint = false;\n        // Get second pointer\n        pointer2 = nextPointer;\n        point2 = pointer2.point;\n        startPoint2 = pointer2.startPoint;\n        // Stop looking\n        break;\n      }\n    }\n    // Primary touch point moved?\n    var pointer1Moved = pointer1 && this.moved(pointer1, 0);\n    // Report DRAG_START if necessary\n    if (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {\n      if (io.events.isEnabled(\"dragstart\") && !system.isPaused) {\n        io.events.dispatchImmediately(\"dragstart\", pointer1.dragStartEvents.shift());\n      }\n      //delete pointer1.dragStartEvents;\n    }\n    // Determine what we do in order of superiority\n    if (singlePoint && io.draggable) {\n      // We have only one pointer and the Sprite is draggable\n      // There's nothing else to be done - just move it\n      this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\n      if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\"))) {\n        this.cancelAllHovers(ev);\n      }\n    } else {\n      // Check if second touch point moved\n      var pointer2Moved = pointer2 && this.moved(pointer2, 0);\n      if (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\")) || this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, \"hitTolerance\"))) {\n        this.cancelAllHovers(ev);\n      }\n      if (io.draggable && io.resizable) {\n        //this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);\n        this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n        this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n      } else {\n        if (io.draggable) {\n          this.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\n        }\n        if (io.resizable && (!singlePoint || ev.ctrlKey)) {\n          this.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\n        }\n      }\n    }\n  };\n  /**\r\n   * Handles movement of the dragged element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io            Element\r\n   * @param point         Current point of the pointer\r\n   * @param startPoint    Starting point of the pointer\r\n   * @param ev            Original event\r\n   * @param pointerMoved  Did pointer move?\r\n   */\n  Interaction.prototype.handleTransformMove = function (io, point, startPoint, ev, pointerMoved, touch) {\n    if (pointerMoved) {\n      if (io.events.isEnabled(\"drag\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\n        var imev = {\n          type: \"drag\",\n          target: io,\n          event: ev,\n          shift: {\n            \"x\": point.x - startPoint.x,\n            \"y\": point.y - startPoint.y\n          },\n          startPoint: startPoint,\n          point: point,\n          touch: touch\n        };\n        io.events.dispatchImmediately(\"drag\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles resizing of the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io            Element\r\n   * @param point1        Current position of reference point #1\r\n   * @param startPoint1   Original position of reference point #1\r\n   * @param point2        Current position of reference point #2\r\n   * @param startPoint2   Original position of reference point #2\r\n   * @param ev            Original event\r\n   * @param pointerMoved  Did pointer move?\r\n   */\n  Interaction.prototype.handleTransformResize = function (io, point1, startPoint1, point2, startPoint2, ev, pointerMoved, touch) {\n    if (io.events.isEnabled(\"resize\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\n      var imev = {\n        type: \"resize\",\n        target: io,\n        event: ev,\n        scale: $math.getScale(point1, startPoint1, point2, startPoint2),\n        startPoint1: startPoint1,\n        point1: point1,\n        startPoint2: startPoint2,\n        point2: point2,\n        touch: touch\n      };\n      io.events.dispatchImmediately(\"resize\", imev);\n    }\n  };\n  /**\r\n   * Handles all the preparations of the element when it starts to be dragged.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.processDragStart = function (io, pointer, ev) {\n    // Add to draggedObjects\n    this.transformedObjects.moveValue(io);\n    if (this.shouldCancelHovers(pointer)) {\n      this.cancelAllHovers(ev);\n    }\n    // Report \"dragstart\"\n    var imev = {\n      type: \"dragstart\",\n      target: io,\n      event: ev,\n      touch: pointer ? pointer.touch : false\n    };\n    // Log object that we are starting to drag, so we can check against and\n    // avoid hovers on other objects that might be in the path of movement.\n    if (pointer) {\n      pointer.dragTarget = io;\n      //pointer.startPoint = pointer.point;\n    }\n    /**\r\n     * If pointer is set we will not fire the event until the pointer has\r\n     * actually moved. If it's not set we don't have to wait for anything, so we\r\n     * just fire off the event right away.\r\n     */\n    if (pointer && pointer.dragStartEvents) {\n      pointer.dragStartEvents.push(imev);\n    } else {\n      if (!system.isPaused) {\n        io.dispatchImmediately(\"dragstart\", imev);\n      }\n    }\n  };\n  /**\r\n   * Finishes up element drag operation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.processDragStop = function (io, pointer, ev) {\n    // Pointer set?\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n    // Unset drag object\n    if (pointer) {\n      pointer.dragTarget = undefined;\n    }\n    // Removed from transformedObjects\n    this.transformedObjects.removeValue(io);\n    // Unlock document\n    //this.unlockDocument();\n    // Report dragstop\n    if (!pointer || this.moved(pointer, 0)) {\n      if (io.events.isEnabled(\"dragstop\") && !system.isPaused) {\n        var imev = {\n          type: \"dragstop\",\n          target: io,\n          touch: pointer ? pointer.touch : false\n        };\n        io.events.dispatchImmediately(\"dragstop\", imev);\n      }\n    }\n  };\n  /**\r\n   * Handles all the preparations of the element when it starts to be resized.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.processResizeStart = function (io, pointer, ev) {\n    // Add to draggedObjects\n    this.transformedObjects.moveValue(io);\n  };\n  /**\r\n   * Finishes up element drag operation.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @param ev       Original event\r\n   */\n  Interaction.prototype.processResizeStop = function (io, pointer, ev) {\n    // Removed from transformedObjects\n    this.transformedObjects.removeValue(io);\n  };\n  /**\r\n   * ==========================================================================\r\n   * Controls for InteractionObjects initiating directly\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Manually triggers drag start on the element. Could be useful in cases\r\n   * where tracking or dragging one element can also influence dragging another\r\n   * element.\r\n   *\r\n   * Passing in `pointer` reference is advisable. If not passed in it will try\r\n   * to determine which pointer to attach to. However, it's better to specify\r\n   * it explicitly.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n  Interaction.prototype.dragStart = function (io, pointer) {\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n    if (pointer) {\n      this.handleDown(io, pointer, pointer.lastDownEvent);\n    }\n  };\n  /**\r\n   * Manually ends drag on the element.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n  Interaction.prototype.dragStop = function (io, pointer, cancelled) {\n    if (!pointer) {\n      pointer = this.getDragPointer(io);\n    }\n    if (pointer && !cancelled) {\n      this.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);\n    }\n  };\n  /**\r\n   * This method uses a fuzzy logic to find the pointer to be used for dragging.\r\n   * Beware that this is not a rock-solid solution. If there are a few objects\r\n   * being dragged at the same time, you may get unexepected results.\r\n   *\r\n   * @param io  InteractionObject to get pointers from\r\n   * @return Pointer currently being used for dragging\r\n   */\n  Interaction.prototype.getDragPointer = function (io) {\n    if (io) {\n      // InteractionObject is supplied\n      // Use it's first down pointer\n      return io.downPointers.getIndex(0);\n    } else if (this.transformedObjects.length) {\n      // Use first dragged object\n      return this.getDragPointer(this.transformedObjects.getIndex(0));\n    } else {\n      return undefined;\n    }\n  };\n  /**\r\n   * ==========================================================================\r\n   * Utils\r\n   * ==========================================================================\r\n   * @hidden\r\n   */\n  /**\r\n   * Returns pointer id for the given event object.\r\n   *\r\n   * @param ev  Event\r\n   * @return Pointer ID\r\n   */\n  Interaction.prototype.getPointerId = function (ev) {\n    var id = \"\";\n    if ($type.hasValue(ev.identifier)) {\n      id = \"\" + ev.identifier;\n    } else if ($type.hasValue(ev.pointerId)) {\n      id = \"\" + ev.pointerId;\n    } else {\n      id = \"m\";\n    }\n    return id.replace(\"-\", \"\");\n  };\n  /**\r\n   * Returns a cursor position of the event.\r\n   *\r\n   * @param ev  Original event\r\n   * @return Event point\r\n   */\n  Interaction.prototype.getPointerPoint = function (ev) {\n    return {\n      \"x\": ev.clientX,\n      \"y\": ev.clientY\n    };\n  };\n  /**\r\n   * Returns [[Pointer]] object that is associated with the Event.\r\n   *\r\n   * If no such [[Pointer]] object exists, it is created.\r\n   *\r\n   * @param ev  Event\r\n   * @return Pointer\r\n   */\n  Interaction.prototype.getPointer = function (ev) {\n    // Get pointer id\n    var id = this.getPointerId(ev);\n    // Get current coordinates\n    var point = this.getPointerPoint(ev);\n    // Look for the pointer in the Dictionary if it maybe already exists\n    var pointer;\n    if (this.pointers.hasKey(id)) {\n      // We already have such pointer\n      pointer = this.pointers.getKey(id);\n      // We need this, because Edge reuses pointer ids across touch and mouse\n      pointer.touch = this.isPointerTouch(ev);\n      // Reset pointer\n      //pointer.point = point;\n    } else {\n      // Init pointer\n      pointer = {\n        \"id\": id,\n        //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"pointer\"),\n        //\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"mouse\"),\n        \"touch\": this.isPointerTouch(ev),\n        \"startPoint\": point,\n        \"startTime\": $time.getTime(),\n        \"point\": point,\n        \"track\": [],\n        \"swipeCanceled\": false,\n        \"dragStartEvents\": []\n      };\n      // Add first breadcrumb\n      this.addBreadCrumb(pointer, point);\n      // Add for re-use later\n      this.pointers.setKey(id, pointer);\n    }\n    // Log last event\n    pointer.lastEvent = ev;\n    this.lastPointer = pointer;\n    return pointer;\n  };\n  /**\r\n   * Determines if pointer event originated from a touch pointer or mouse.\r\n   *\r\n   * @param ev  Original event\r\n   * @return Touch pointer?\r\n   */\n  Interaction.prototype.isPointerTouch = function (ev) {\n    if (typeof Touch !== \"undefined\" && ev instanceof Touch) {\n      return true;\n    } else if (typeof PointerEvent !== \"undefined\" && ev instanceof PointerEvent && $type.hasValue(ev.pointerType)) {\n      switch (ev.pointerType) {\n        case \"touch\":\n        case \"pen\":\n        case 2:\n          return true;\n        case \"mouse\":\n        case 4:\n          return false;\n        default:\n          return !(ev instanceof MouseEvent);\n      }\n    } else if ($type.hasValue(ev.type)) {\n      if (ev.type.match(/^mouse/)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\r\n   * Resets the poiner to original state, i.e. cleans movement information,\r\n   * starting point, etc.\r\n   *\r\n   * @param pointer Pointer\r\n   */\n  Interaction.prototype.resetPointer = function (pointer, ev) {\n    // Get current coordinates\n    var point = this.getPointerPoint(ev);\n    ;\n    pointer.startTime = $time.getTime();\n    pointer.startPoint = {\n      x: point.x,\n      y: point.y\n    };\n    pointer.point = {\n      x: point.x,\n      y: point.y\n    };\n    pointer.track = [];\n    pointer.swipeCanceled = false;\n    //clearTimeout(pointer.swipeTimeout);\n    //clearTimeout(pointer.holdTimeout);\n  };\n  /**\r\n   * Adds a \"breadcrumb\" point to the [[Pointer]] to log its movement path.\r\n   *\r\n   * @param pointer  Pointer\r\n   * @param point    Point coordinates\r\n   */\n  Interaction.prototype.addBreadCrumb = function (pointer, point) {\n    pointer.track.push({\n      \"timestamp\": $time.getTime(),\n      \"point\": point\n    });\n  };\n  /**\r\n   * Prepares the document for various touch-related operations.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.lockDocument = function () {\n    this.prepElement(this.body);\n  };\n  /**\r\n   * Restores document functionality.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.unlockDocument = function () {\n    if (this.transformedObjects.length == 0) {\n      this.restoreAllStyles(this.body);\n    }\n  };\n  /**\r\n   * Lock element (disable all touch)\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.lockElement = function (io) {\n    this.prepElement(io);\n  };\n  /**\r\n   * Restores element's functionality.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.unlockElement = function (io) {\n    this.restoreAllStyles(io);\n  };\n  /**\r\n   * Locks document's wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.lockWheel = function () {\n    window.addEventListener(this._pointerEvents.wheel, this.wheelLockEvent, this._passiveSupported ? {\n      passive: false\n    } : false);\n  };\n  /**\r\n   * Unlocks document's wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   */\n  Interaction.prototype.unlockWheel = function () {\n    window.removeEventListener(this._pointerEvents.wheel, this.wheelLockEvent);\n  };\n  /**\r\n   * Checks if top element at pointer's position belongs to the SVG.\r\n   *\r\n   * @ignore Exlude from docs\r\n   * @param pointer  Pointer\r\n   * @param svg      The <svg> element\r\n   * @param id       A unique identifier of the object that is checking for locality\r\n   * @return Belongs to SVG\r\n   */\n  Interaction.prototype.isLocalElement = function (pointer, svg, id) {\n    var cached = this.getCache(\"local_pointer_\" + pointer.id);\n    if ($type.hasValue(cached)) {\n      return cached;\n    }\n    var doc = $dom.getRoot(svg) || document;\n    if (doc.elementFromPoint) {\n      var target = doc.elementFromPoint(pointer.point.x, pointer.point.y);\n      var local = target && $dom.contains(svg, target);\n      this.setCache(\"local_pointer_\" + pointer.id + \"_\" + id, local, 100);\n      return local;\n    }\n    return false;\n  };\n  /**\r\n   * A function that cancels mouse wheel scroll.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param ev  Event object\r\n   * @return Returns `false` to cancel\r\n   */\n  Interaction.prototype.wheelLockEvent = function (ev) {\n    ev.preventDefault();\n    return false;\n  };\n  /**\r\n   * Applies a set of styles to an element. Stores the original styles so they\r\n   * can be restored later.\r\n   *\r\n   * @ignore\r\n   * @param io      Element\r\n   */\n  Interaction.prototype.prepElement = function (io) {\n    var el = io.element;\n    if (el) {\n      // Define possible props\n      var props = [\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\", \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\", \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\", \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\", \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\", \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"];\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in el.style) {\n          this.setTemporaryStyle(io, props[i], \"none\");\n        }\n      }\n      // Remove iOS-specific selection;\n      this.setTemporaryStyle(io, \"tapHighlightColor\", \"rgba(0, 0, 0, 0)\");\n      //this.setTemporaryStyle(io, \"webkitOverflowScrolling\", \"none\");\n    }\n  };\n  /**\r\n   * Restores replaced styles\r\n   *\r\n   * @ignore\r\n   * @param  io  Element\r\n   */\n  Interaction.prototype.unprepElement = function (io) {\n    var el = io.element;\n    if (el) {\n      // Define possible props\n      var props = [\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\", \"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\", \"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\", \"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\", \"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\", \"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"];\n      for (var i = 0; i < props.length; i++) {\n        if (props[i] in el.style) {\n          this.restoreStyle(io, props[i]);\n        }\n      }\n      // Remove iOS-specific selection;\n      this.restoreStyle(io, \"tapHighlightColor\");\n      //this.restoreStyle(io, \"webkitOverflowScrolling\");\n    }\n  };\n  /**\r\n   * Returns an option associated with hit events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n  Interaction.prototype.getHitOption = function (io, option) {\n    var res = io.hitOptions[option];\n    if (typeof res === \"undefined\") {\n      res = this.hitOptions[option];\n    }\n    return res;\n  };\n  /**\r\n   * Returns an option associated with hover events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n  Interaction.prototype.getHoverOption = function (io, option) {\n    var res = io.hoverOptions[option];\n    if (typeof res === \"undefined\") {\n      res = this.hoverOptions[option];\n    }\n    return res;\n  };\n  /**\r\n   * Returns an option associated with swipe events.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n  Interaction.prototype.getSwipeOption = function (io, option) {\n    var res = io.swipeOptions[option];\n    if (typeof res === \"undefined\") {\n      res = this.swipeOptions[option];\n    }\n    return res;\n  };\n  /**\r\n   * Returns an option for keyboard.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n  Interaction.prototype.getKeyboardOption = function (io, option) {\n    var res = io.keyboardOptions[option];\n    if (typeof res === \"undefined\") {\n      res = this.keyboardOptions[option];\n    }\n    return res;\n  };\n  /**\r\n   * Returns an option for mouse.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n  Interaction.prototype.getMouseOption = function (io, option) {\n    var res = io.mouseOptions[option];\n    if (typeof res === \"undefined\") {\n      res = this.mouseOptions[option];\n    }\n    return res;\n  };\n  /**\r\n   * Returns an option associated with inertia.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io      Element\r\n   * @param type    Inertia type\r\n   * @param option  Option key\r\n   * @return Option value\r\n   */\n  Interaction.prototype.getInertiaOption = function (io, type, option) {\n    var options = io.inertiaOptions.getKey(type);\n    var res;\n    if (options && $type.hasValue(options[option])) {\n      res = options[option];\n    } else {\n      res = this.inertiaOptions.getKey(type)[option];\n    }\n    return res;\n  };\n  /**\r\n   * Stops currently going on inertia. Useful if inertia is currently being\r\n   * animated and the object is being interacted with.\r\n   *\r\n   * @param io Element\r\n   */\n  Interaction.prototype.stopInertia = function (io) {\n    var x;\n    var inertias = [\"move\", \"resize\"];\n    for (var i = 0; i < inertias.length; i++) {\n      x = inertias[i];\n      if (io.inertias.hasKey(x)) {\n        var inertia = io.inertias.getKey(x);\n        if (inertia) {\n          inertia.dispose();\n          //io.inertiaAnimations.removeKey(x);\n          //this.processDragStop(io);\n          continue;\n        }\n      }\n    }\n  };\n  /**\r\n   * Check if swiping is currently being performed on an object.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer to check\r\n   * @return `true` if swiping\r\n   */\n  Interaction.prototype.swiping = function (io, pointer) {\n    var now = $time.getTime();\n    if (pointer.swipeCanceled || !io.swipeable) {\n      return false;\n    } else if (Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\") && pointer.startTime > now - this.getSwipeOption(io, \"time\")) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Returns `true` if a successfull swipe action was performed on an element.\r\n   *\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   * @return Swiped?\r\n   */\n  Interaction.prototype.swiped = function (io, pointer) {\n    var now = $time.getTime();\n    if (pointer.swipeCanceled) {\n      return false;\n    } else if (Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, \"horizontalThreshold\") && Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\") && pointer.startTime > now - this.getSwipeOption(io, \"time\")) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\r\n   * Applies style to mouse cursor based on its stage in relation to\r\n   * [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param Element\r\n   */\n  Interaction.prototype.applyCursorOverStyle = function (io) {\n    // Get sprite's cursor ooptions\n    var options = io.cursorOptions;\n    if (!$type.hasValue(options.overStyle)) {\n      return;\n    }\n    // Apply cursor down styles\n    for (var i = 0; i < options.overStyle.length; i++) {\n      $dom.setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);\n    }\n  };\n  /**\r\n   * Applies style to mouse cursor based on its stage in relation to\r\n   * [[InteractionObject]].\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n  Interaction.prototype.applyCursorDownStyle = function (io, pointer) {\n    // Not applicable for touch pointers since they don't display a cursor\n    if (pointer && pointer.touch) {\n      return;\n    }\n    var downStyle = io.cursorOptions.downStyle;\n    // Is down?\n    if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\n      // Apply cursor down styles\n      for (var i = 0; i < downStyle.length; i++) {\n        this.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);\n        this.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);\n      }\n    }\n  };\n  /**\r\n   * Restores original cursor style for the element.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param io       Element\r\n   * @param pointer  Pointer\r\n   */\n  Interaction.prototype.restoreCursorDownStyle = function (io, pointer) {\n    // Not applicable for touch pointers since they don't display a cursor\n    if (pointer && pointer.touch) {\n      return;\n    }\n    var downStyle = io.cursorOptions.downStyle;\n    // Is down?\n    if (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\n      // Apply cursor down styles\n      for (var i = 0; i < downStyle.length; i++) {\n        this.restoreStyle(this.body, downStyle[i].property);\n        this.restoreStyle(io, downStyle[i].property);\n      }\n    }\n  };\n  /**\r\n   * Sets style on the body of the document.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Style definitions\r\n   */\n  Interaction.prototype.setGlobalStyle = function (style) {\n    var body = getInteraction().body;\n    var styles = $type.isArray(style) ? style : [style];\n    for (var i = 0; i < styles.length; i++) {\n      this.setTemporaryStyle(body, styles[i].property, styles[i].value);\n    }\n  };\n  /**\r\n   * Restores style on the body of the document.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param style  Style definitions\r\n   */\n  Interaction.prototype.restoreGlobalStyle = function (style) {\n    var body = getInteraction().body;\n    var styles = $type.isArray(style) ? style : [style];\n    for (var i = 0; i < styles.length; i++) {\n      this.restoreStyle(body, styles[i].property);\n    }\n  };\n  /**\r\n   * Checks if element is a non-cahrt element.\r\n   *\r\n   * @param io  InteractionObject\r\n   * @return Global element?\r\n   */\n  Interaction.prototype.isGlobalElement = function (io) {\n    return document.body === io.element;\n  };\n  /**\r\n   * Checks if pointer has moved since it was created.\r\n   *\r\n   * @param pointer    Pointer\r\n   * @param tolerance  Tolerance in pixels\r\n   * @param minTime    Minimum time required for the pointer to be down to be considered moved\r\n   * @return `true` if the pointer has moved\r\n   */\n  Interaction.prototype.moved = function (pointer, tolerance, minTime) {\n    /*// If there was more time, we don't care if cursor actually moved\r\n    let duration = $time.getTime() - pointer.startTime;\r\n    if ($type.hasValue(minTime) && (minTime > duration)) {\r\n        return false;\r\n    }*/\n    if (minTime === void 0) {\n      minTime = 300;\n    }\n    // That was quick measure shift\n    var shift = this.getShift(pointer);\n    return Math.abs(shift.x) > tolerance || Math.abs(shift.y) > tolerance;\n  };\n  /**\r\n   * Returns if pointer is \"old\", meaning it has been pressing for more than\r\n   * X milliseconds.\r\n   *\r\n   * @ignore\r\n   * @param pointer  Pointer\r\n   * @param minTime  Minimum time to consider pointer old\r\n   * @return {boolean}\r\n   */\n  Interaction.prototype.old = function (pointer, minTime) {\n    if (minTime === void 0) {\n      minTime = 300;\n    }\n    return $time.getTime() - pointer.startTime > minTime;\n  };\n  /**\r\n   * Returns total a shift in pointers coordinates between its original\r\n   * position and now.\r\n   *\r\n   * @param pointer  Pointer\r\n   * @return Shift in coordinates (x/y)\r\n   */\n  Interaction.prototype.getShift = function (pointer) {\n    return {\n      \"x\": pointer.startPoint.x - pointer.point.x,\n      \"y\": pointer.startPoint.y - pointer.point.y\n    };\n  };\n  /**\r\n   * Returns a point from [[Pointer]]'s move history at a certain timetamp.\r\n   *\r\n   * @param pointer    Pointer\r\n   * @param timestamp  Timestamp\r\n   * @return Point\r\n   */\n  Interaction.prototype.getTrailPoint = function (pointer, timestamp) {\n    var res;\n    for (var i = 0; i < pointer.track.length; i++) {\n      if (pointer.track[i].timestamp >= timestamp) {\n        res = pointer.track[i];\n        break;\n      }\n    }\n    return res;\n  };\n  /**\r\n   * Checks if same pointer already exists in the list.\r\n   *\r\n   * @param list     List to check agains\r\n   * @param pointer  Pointer\r\n   * @return Exists?\r\n   */\n  Interaction.prototype.pointerExists = function (list, pointer) {\n    var exists = false;\n    list.each(function (item) {\n      if (item == pointer) {\n        return;\n      }\n      exists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;\n    });\n    return exists;\n  };\n  /**\r\n   * Returns an [[InteractionObject]] representation of a DOM element.\r\n   *\r\n   * You can use this on any HTML or SVG element, to add interactive features\r\n   * to it.\r\n   *\r\n   * @param element  Element\r\n   * @return InteractionObject\r\n   */\n  Interaction.prototype.getInteraction = function (element) {\n    return new InteractionObject(element);\n  };\n  /**\r\n   * Sets a style property on an element. Stores original value to be restored\r\n   * later with [[restoreStyle]].\r\n   *\r\n   * @see {@link restoreStyle}\r\n   * @param io        Element\r\n   * @param property  Property\r\n   * @param value     Value\r\n   */\n  Interaction.prototype.setTemporaryStyle = function (io, property, value) {\n    // Get element\n    //let el = io.element.tagName == \"g\" ? <SVGSVGElement>io.element.parentNode : io.element;\n    var el = io.element;\n    // Save original property if it is set and hasn't been saved before already\n    if ($type.hasValue(el.style[property]) && !io.replacedStyles.hasKey(property)) {\n      io.replacedStyles.setKey(property, el.style[property]);\n    }\n    // Replace with the new one\n    $dom.setStyle(el, property, value);\n  };\n  /**\r\n   * Restores specific style on an element.\r\n   *\r\n   * @param io        Element\r\n   * @param property  Style property\r\n   */\n  Interaction.prototype.restoreStyle = function (io, property) {\n    // Reset style\n    if (io.replacedStyles.hasKey(property)) {\n      io.element.style[property] = io.replacedStyles.getKey(property);\n      io.replacedStyles.removeKey(property);\n    } else {\n      delete io.element.style[property];\n    }\n  };\n  /**\r\n   * Restore temporarily reset styles on an element.\r\n   *\r\n   * @param io Element\r\n   */\n  Interaction.prototype.restoreAllStyles = function (io) {\n    $iter.each(io.replacedStyles.iterator(), function (a) {\n      var key = a[0];\n      var value = a[1];\n      io.element.style[key] = value;\n      io.replacedStyles.removeKey(key);\n    });\n  };\n  /**\r\n   * Disposes this object and cleans up after itself.\r\n   */\n  Interaction.prototype.dispose = function () {\n    if (!this.isDisposed()) {\n      _super.prototype.dispose.call(this);\n      this.restoreAllStyles(this.body);\n      this.unlockWheel();\n    }\n  };\n  // @ts-ignore Used for debugging\n  Interaction.prototype.log = function (text, ev, io) {\n    var show = true;\n    if (show) {\n      // Touchlist?\n      if (ev.changedTouches) {\n        for (var i = 0; i < ev.changedTouches.length; i++) {\n          this.logTouch(text, ev.type, ev.changedTouches[i]);\n        }\n        return;\n      }\n      // Get type\n      var type = \"\";\n      if (ev.pointerType) {\n        switch (ev.pointerType) {\n          case 2:\n            type = \"touch\";\n            break;\n          case 4:\n            type = \"mouse\";\n            break;\n          default:\n            type = ev.pointerType;\n            break;\n        }\n      } else if (typeof TouchEvent != \"undefined\" && ev instanceof TouchEvent) {\n        type = \"touch\";\n      } else if (ev.type.match(/^mouse/)) {\n        type = \"mouse\";\n      } else {\n        type = \"???\";\n      }\n      // Get ID\n      var id = \"\";\n      if ($type.hasValue(ev.identifier)) {\n        id = ev.identifier;\n      } else if ($type.hasValue(ev.pointerId)) {\n        id = ev.pointerId;\n      } else {\n        id = \"???\";\n      }\n      if (io) {\n        console.log(text + \" (\" + io.uid + \")  \" + ev.type + \"  \" + type + \"  \" + id);\n      } else {\n        console.log(text + \"  \" + ev.type + \"  \" + type + \"  \" + id);\n      }\n    }\n  };\n  /**\r\n   * Checks whether there are currently any objects being transformed (dragged\r\n   * or resized).\r\n   *\r\n   * If `except` is set, that object will be ignored.\r\n   *\r\n   * @since 4.9.3\r\n   * @param   except  Ignore this object(s)\r\n   * @return          Objects are being transformed\r\n   */\n  Interaction.prototype.areTransformed = function (except) {\n    var count = this.transformedObjects.length;\n    if (except) {\n      var ex = $type.isArray(except) ? except : [except];\n      for (var i = 0; i < ex.length; i++) {\n        if (this.transformedObjects.contains(ex[i])) {\n          count--;\n        }\n      }\n    }\n    return count > 0;\n  };\n  /**\r\n   * Log.\r\n   */\n  Interaction.prototype.logTouch = function (text, type, ev) {\n    console.log(text + \"  \" + type + \"  \" + \"touch\" + \"  \" + ev.identifier);\n  };\n  Object.defineProperty(Interaction, \"passiveSupported\", {\n    /**\r\n     * Indicates if passive mode options is supported by this browser.\r\n     */\n    get: function () {\n      var _this = this;\n      if (this._passiveSupported == null) {\n        // Check for passive mode support\n        try {\n          var options_1 = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              _this._passiveSupported = true;\n            }\n          });\n          window.addEventListener(\"test\", options_1, options_1);\n          window.removeEventListener(\"test\", options_1, options_1);\n        } catch (err) {\n          this._passiveSupported = false;\n        }\n      }\n      return this._passiveSupported;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Interaction;\n}(BaseObjectEvents);\nexport { Interaction };\nvar interaction = null;\n/**\r\n * Returns a single unified global instance of [[Interaction]].\r\n *\r\n * All code should use this function, rather than create their own instances\r\n * of [[Interaction]].\r\n */\nexport function getInteraction() {\n  if (interaction == null) {\n    interaction = new Interaction();\n  }\n  return interaction;\n}","map":{"version":3,"names":["BaseObjectEvents","List","Animation","MultiDisposer","InteractionObject","InteractionKeyboardObject","Dictionary","Inertia","addEventListener","keyboard","system","options","$ease","$math","$array","$dom","$iter","$type","$time","Interaction","_super","__extends","_this","call","_globalEventsAdded","_pointerEvents","_usePointerEventsOnly","_useTouchEventsOnly","_addHoverEvents","_passiveSupported","_delayedEvents","out","overObjects","downObjects","trackedObjects","transformedObjects","pointers","inertiaOptions","hitOptions","hoverOptions","swipeOptions","keyboardOptions","mouseOptions","className","body","getInteraction","document","_disposers","push","window","hasOwnProperty","pointerdown","pointerup","pointermove","pointercancel","pointerover","pointerout","matchMedia","matches","navigator","userAgent","match","fullFF","createElement","wheel","hasValue","onmousewheel","setKey","polyOut3","passiveSupported","applyTheme","prototype","debug","addGlobalEvents","ev","handleGlobalPointerDown","handleGlobalPointerMove","handleGlobalPointerUp","relatedTarget","buttons","which","handleDocumentLeave","handleGlobalTouchStart","handleGlobalTouchMove","handleGlobalTouchEnd","handleGlobalKeyDown","handleGlobalKeyUp","processClickable","io","processTouchable","processContextMenu","contextMenuDisabled","eventDisposers","hasKey","element","e","preventDefault","getKey","dispose","processHoverable","hoverable","trackable","applyCursorOverStyle","handlePointerOut","handlePointerOver","disposer","removeKey","processMovable","draggable","swipeable","resizable","isGlobalElement","isTouchProtected","prepElement","processTrackable","moveValue","removeValue","processDraggable","processSwipeable","processResizable","processWheelable","wheelable","handleMouseWheel","passive","events","on","unlockWheel","lockWheel","processFocusable","focusable","tabindex","handleFocus","handleBlur","handleFocusBlur","clickable","handlePointerDown","handleTouchDown","isFocused","isEnabled","isPaused","imev","type","target","event","dispatchImmediately","getHitOption","once","disableType","blur","sprite","enableType","focusedObject","isKey","disposerKey","ko","getEventKey","directionY","directionX","showTooltipOn","pointer","getPointer","point","getPointerPoint","touch","addBreadCrumb","handleGlobalMove","processDelayed","preventTouchAction","defaultPrevented","cancelled","handleGlobalUp","i","changedTouches","length","button","resetPointer","handleDown","handleOver","handleOut","deltaX","deltaY","mod","deltaMode","getMouseOption","WheelEvent","Math","round","wheelDeltaX","wheelDeltaY","Error","handleWheel","maybePreventDefault","handleHit","now","getTime","lastHit","undefined","lastHitPointer","soft","hoversPaused","shouldCancelHovers","areTransformed","moved","cancelAllHovers","overPointers","isRealHover","isHover","handleTrack","force","hasDelayedOut","old","behavior","getHoverOption","keepUntil","timeout","setTimeout","isDisposed","clear","delayedEvent","pop","inert","stopInertia","downPointers","applyCursorDownStyle","isDown","processDragStart","processResizeStart","sorted","values","slice","sort","x","y","pos","compareDocumentPosition","Node","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_CONTAINS","each","contains","handleUp","backwards","iterator","restoreCursorDownStyle","swiped","handleSwipe","handleInertia","processDragStop","processResizeStop","cancelable","getIndex","disableHoverOnTransform","target_1","eventTarget","lastEvent","reset","swiping","handleTransform","skipCheck","startPoint","shift","handleMoveInertia","handleResizeInertia","interaction","inertia","ref","getTrailPoint","getInertiaOption","lastUpEvent","factor","animationOptions","animation","start","done","inertias","pointer1","point1","startPoint1","pointer2","point2","startPoint2","originalPosition","singlePoint","nextPointer","pointer1Moved","dragStartEvents","handleTransformMove","pointer2Moved","handleTransformResize","ctrlKey","pointerMoved","scale","getScale","dragTarget","getDragPointer","dragStart","lastDownEvent","dragStop","getPointerId","id","identifier","pointerId","replace","clientX","clientY","isPointerTouch","lastPointer","Touch","PointerEvent","pointerType","MouseEvent","startTime","track","swipeCanceled","lockDocument","unlockDocument","restoreAllStyles","lockElement","unlockElement","wheelLockEvent","removeEventListener","isLocalElement","svg","cached","getCache","doc","getRoot","elementFromPoint","local","setCache","el","props","style","setTemporaryStyle","unprepElement","restoreStyle","option","res","getSwipeOption","getKeyboardOption","abs","cursorOptions","overStyle","setStyle","property","value","downStyle","setGlobalStyle","styles","isArray","restoreGlobalStyle","tolerance","minTime","getShift","timestamp","pointerExists","list","exists","item","replacedStyles","a","key","log","text","show","logTouch","TouchEvent","console","uid","except","count","ex","Object","defineProperty","get","options_1","err"],"sources":["../../../../../src/.internal/core/interaction/Interaction.ts"],"sourcesContent":["/**\r\n * Interaction manages all aspects of user interaction - mouse move,\r\n * click, hover, drag events, touch gestures.\r\n *\r\n * [[InteractionObject]] elements that want to use certain events, must attach event\r\n * listeners to Interaction instance.\r\n *\r\n * Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n * those elements to handle interaction information received via event triggers.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { BaseObjectEvents, IBaseObjectEvents } from \"../Base\";\r\nimport { List } from \"../utils/List\";\r\nimport { AMEvent } from \"../utils/EventDispatcher\";\r\nimport { Animation } from \"../utils/Animation\";\r\nimport { IInertiaOptions, ISwipeOptions, IHitOptions, IHoverOptions, IKeyboardOptions, IMouseOptions } from \"./InteractionOptions\";\r\nimport { MultiDisposer, IDisposer } from \"../utils/Disposer\";\r\nimport { InteractionObject, IInteractionObjectEvents } from \"./InteractionObject\";\r\nimport { InteractionKeyboardObject } from \"./InteractionKeyboardObject\";\r\nimport { Dictionary } from \"../utils/Dictionary\";\r\nimport { Inertia, InertiaTypes } from \"./Inertia\";\r\nimport { IPointer, IBreadcrumb } from \"./Pointer\";\r\nimport { addEventListener } from \"../utils/DOM\";\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IStyleProperty } from \"../defs/IStyleProperty\";\r\nimport { keyboard } from \"../utils/Keyboard\";\r\nimport { system } from \"./../System\";\r\nimport { options } from \"./../Options\";\r\nimport * as $ease from \"../utils/Ease\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $array from \"../utils/Array\";\r\nimport * as $dom from \"../utils/DOM\";\r\nimport * as $iter from \"../utils/Iterator\";\r\nimport * as $type from \"../utils/Type\";\r\nimport * as $time from \"../utils/Time\";\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * REQUISITES\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Represents an Event object that comes from [[Interaction]]\r\n */\r\nexport interface IInteractionEvents extends IBaseObjectEvents {\r\n\r\n\ttrack: {\r\n\t\tpointer: IPointer;\r\n\t\ttouch: boolean;\r\n\t\tevent: MouseEvent | TouchEvent;\r\n\t};\r\n\r\n\tdown: {\r\n\t\tpointer: IPointer;\r\n\t\ttouch: boolean;\r\n\t\tevent: MouseEvent | TouchEvent;\r\n\t};\r\n\r\n\tup: {\r\n\t\tpointer: IPointer;\r\n\t\ttouch: boolean;\r\n\t\tevent: MouseEvent | TouchEvent;\r\n\t};\r\n\r\n\tfocus: {\r\n\t\tevent: FocusEvent;\r\n\t}\r\n}\r\n\r\n/**\r\n * Interface representing a delayed event\r\n *\r\n * @ignore Exclude from docs\r\n */\r\nexport interface IDelayedEvent {\r\n\ttype: keyof IInteractionObjectEvents;\r\n\tio: InteractionObject;\r\n\tpointer: IPointer;\r\n\tevent: MouseEvent | TouchEvent;\r\n\tkeepUntil?: number;\r\n\ttimeout?: IDisposer;\r\n}\r\n\r\n\r\n/**\r\n * ============================================================================\r\n * MAIN CLASS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n\r\n/**\r\n* Interaction manages all aspects of user interaction - mouse move,\r\n* click, hover, drag events, touch gestures.\r\n*\r\n* [[InteractionObject]] elements that want to use certain events, must attach event\r\n* listeners to Interaction instance.\r\n*\r\n* Interaction itself will not modify [[InteractionObject]] elements, it will be up to\r\n* those elements to handle interaction information received via event triggers.\r\n*\r\n* @see {@link IInteractionEvents} for a list of available events\r\n*/\r\nexport class Interaction extends BaseObjectEvents {\r\n\r\n\t/**\r\n\t * Defines available events.\r\n\t *\r\n\t * @deprecated Use inetraction.body.events instead\r\n\t */\r\n\tpublic _events!: IInteractionEvents;\r\n\r\n\t/**\r\n\t * A reference to an [[Interaction]] object for document's body.\r\n\t *\r\n\t * Users can use it to add global, non-chart related events, that will be\r\n\t * applicable to the whole document.\r\n\t */\r\n\tpublic body: InteractionObject;\r\n\r\n\t/**\r\n\t * An indicator of global events were already initialized.\r\n\t */\r\n\tprotected _globalEventsAdded: boolean = false;\r\n\r\n\t/**\r\n\t * Holds which mouse event listeners to use.\r\n\t */\r\n\tprotected _pointerEvents = {\r\n\t\t\"pointerdown\": \"mousedown\",\r\n\t\t\"pointerup\": \"mouseup\",\r\n\t\t\"pointermove\": \"mousemove\",\r\n\t\t\"pointercancel\": \"mouseup\",\r\n\t\t\"pointerover\": \"mouseover\",\r\n\t\t\"pointerout\": \"mouseout\",\r\n\t\t\"wheel\": \"wheel\"\r\n\t};\r\n\r\n\t/**\r\n\t * Indicates if Interaction should use only \"pointer\" type events, like\r\n\t * \"pointermove\", available in all modern browsers, ignoring \"legacy\"\r\n\t * events, like \"touchmove\".\r\n\t */\r\n\tprotected _usePointerEventsOnly: boolean = false;\r\n\r\n\t/**\r\n\t * Use only touch events (for touch only devices such as tablets and phones)\r\n\t */\r\n\tprotected _useTouchEventsOnly: boolean = false;\r\n\r\n\t/**\r\n\t * Add special hover events. Normally, touch device tap will also simulate\r\n\t * hover event. On some devices (ahem iOS) we want to prevent that so that\r\n\t * over/out events are not duplicated.\r\n\t */\r\n\tprotected _addHoverEvents: boolean = true;\r\n\r\n\t/**\r\n\t * Indicates if passive mode options is supported by this browser.\r\n\t */\r\n\tprotected _passiveSupported: boolean = false;\r\n\r\n\t/**\r\n\t * Holds list of delayed events\r\n\t */\r\n\tprotected _delayedEvents: { out: IDelayedEvent[] } = { out: [] };\r\n\r\n\t/**\r\n\t * List of objects that current have a pointer hovered over them.\r\n\t */\r\n\tpublic overObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * List of objects that currently has a pressed pointer.\r\n\t */\r\n\tpublic downObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * List of objects that need mouse position to be reported to them.\r\n\t */\r\n\tpublic trackedObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * List of objects that are currently being dragged.\r\n\t */\r\n\tpublic transformedObjects: List<InteractionObject> = new List<InteractionObject>();\r\n\r\n\t/**\r\n\t * An object that currently has focus. Usually set automatically via\r\n\t * [[InteractionObject]] `isFocus` method.\r\n\t */\r\n\tpublic focusedObject: $type.Optional<InteractionObject>;\r\n\r\n\t/**\r\n\t * Holds all known pointers.\r\n\t */\r\n\tpublic pointers = new Dictionary<string, IPointer>();\r\n\r\n\t/**\r\n\t * Last pointer that generate some kind of action.\r\n\t *\r\n\t * @since 4.9.5\r\n\t * @ignore\r\n\t */\r\n\tpublic lastPointer: $type.Optional<IPointer>;\r\n\r\n\t/**\r\n\t * Inertia options that need to be applied to after element drag, if it's\r\n\t * `inert = true`.\r\n\t *\r\n\t * This is just a default, which can and probably will be overridden by\r\n\t * actual elements.\r\n\t */\r\n\tpublic inertiaOptions = new Dictionary<InertiaTypes, IInertiaOptions>();\r\n\r\n\t/**\r\n\t * Default options for click events. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic hitOptions: IHitOptions = {\r\n\t\t\"doubleHitTime\": 300,\r\n\t\t//\"delayFirstHit\": false,\r\n\t\t\"hitTolerance\": 10,\r\n\t\t\"noFocus\": true\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for hover events. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic hoverOptions: IHoverOptions = {\r\n\t\t\"touchOutBehavior\": \"leave\",\r\n\t\t\"touchOutDelay\": 1000\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for detecting a swipe gesture. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic swipeOptions: ISwipeOptions = {\r\n\t\t\"time\": 500,\r\n\t\t\"verticalThreshold\": 75,\r\n\t\t\"horizontalThreshold\": 30\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for keyboard operations. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t */\r\n\tpublic keyboardOptions: IKeyboardOptions = {\r\n\t\t\"speed\": 0.1,\r\n\t\t\"accelleration\": 1.2,\r\n\t\t\"accellerationDelay\": 2000\r\n\t};\r\n\r\n\t/**\r\n\t * Default options for keyboard operations. These can be overridden in\r\n\t * [[InteractionObject]].\r\n\t *\r\n\t * @since 4.5.14\r\n\t */\r\n\tpublic mouseOptions: IMouseOptions = {\r\n\t\t\"sensitivity\": 1\r\n\t};\r\n\r\n\r\n\t/**\r\n\t * Constructor. Sets up universal document-wide move events to handle stuff\r\n\t * outside particular chart container.\r\n\t */\r\n\tconstructor() {\r\n\r\n\t\t// Call super\r\n\t\tsuper();\r\n\r\n\t\t// Set class name\r\n\t\tthis.className = \"Interaction\";\r\n\r\n\t\t// Create InteractionObject for <body>\r\n\t\tthis.body = this.getInteraction(document.body);\r\n\r\n\t\tthis._disposers.push(this.body);\r\n\r\n\t\t// Detect browser capabilities and determine what event listeners to use\r\n\t\tif (window.hasOwnProperty(\"PointerEvent\")) {\r\n\t\t\t// IE10+/Edge without touch controls enabled\r\n\t\t\tthis._pointerEvents.pointerdown = \"pointerdown\";\r\n\t\t\tthis._pointerEvents.pointerup = \"pointerup\";\r\n\t\t\tthis._pointerEvents.pointermove = \"pointermove\";\r\n\t\t\tthis._pointerEvents.pointercancel = \"pointercancel\";\r\n\t\t\tthis._pointerEvents.pointerover = \"pointerover\";\r\n\t\t\tthis._pointerEvents.pointerout = \"pointerout\";\r\n\t\t\t//this._usePointerEventsOnly = true;\r\n\t\t} else if (window.hasOwnProperty(\"MSPointerEvent\")) {\r\n\t\t\t// IE9\r\n\t\t\tthis._pointerEvents.pointerdown = \"MSPointerDown\";\r\n\t\t\tthis._pointerEvents.pointerup = \"MSPointerUp\";\r\n\t\t\tthis._pointerEvents.pointermove = \"MSPointerMove\";\r\n\t\t\tthis._pointerEvents.pointercancel = \"MSPointerUp\";\r\n\t\t\tthis._pointerEvents.pointerover = \"MSPointerOver\";\r\n\t\t\tthis._pointerEvents.pointerout = \"MSPointerOut\";\r\n\t\t\t//this._usePointerEventsOnly = true;\r\n\t\t}\r\n\t\telse if ((typeof matchMedia !== \"undefined\") && matchMedia('(pointer:fine)').matches) {\r\n\t\t\t// This is only for Safari as it does not support PointerEvent\r\n\t\t\t// Do nothing and let it use regular `mouse*` events\r\n\t\t\t// Hi Apple ;)\r\n\r\n\t\t\t// Additionally disable hover events for iOS devices\r\n\t\t\tif ('ontouchstart' in window) {\r\n\t\t\t\tthis._addHoverEvents = false;\r\n\t\t\t\tthis._useTouchEventsOnly = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (window.navigator.userAgent.match(/MSIE /)) {\r\n\t\t\t// Oh looky, an MSIE that does not support PointerEvent. Hi granpa IE9!\r\n\t\t\tthis._usePointerEventsOnly = true;\r\n\t\t}\r\n\t\telse if (this.fullFF()) {\r\n\t\t\t// Old FF, let's use regular events.\r\n\t\t\t// (Newer FFs would be detected by the PointerEvent availability check)\r\n\t\t\tthis._usePointerEventsOnly = true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Uses defaults for normal browsers\r\n\t\t\t// We also assume that this must be a touch device that does not have\r\n\t\t\t// any pointer events\r\n\t\t\tthis._useTouchEventsOnly = true;\r\n\t\t}\r\n\r\n\t\t// Detect if device has a mouse\r\n\t\t// This is turning out to be not reliable\r\n\t\t// @todo remove\r\n\t\t/*if (!window.navigator.msPointerEnabled && (typeof matchMedia !== \"undefined\") && !matchMedia('(pointer:fine)').matches && !this.fullFF()) {\r\n\t\t\tthis._useTouchEventsOnly = true;\r\n\t\t}*/\r\n\r\n\t\t// Detect proper mouse wheel events\r\n\t\tif (\"onwheel\" in document.createElement(\"div\")) {\r\n\t\t\t// Modern browsers\r\n\t\t\tthis._pointerEvents.wheel = \"wheel\";\r\n\t\t}\r\n\t\telse if ($type.hasValue((<any>document).onmousewheel)) {\r\n\t\t\t// Webkit and IE support at least \"mousewheel\"\r\n\t\t\tthis._pointerEvents.wheel = \"mousewheel\";\r\n\t\t}\r\n\r\n\t\t// Set up default inertia options\r\n\t\tthis.inertiaOptions.setKey(\"move\", {\r\n\t\t\t\"time\": 100,\r\n\t\t\t\"duration\": 500,\r\n\t\t\t\"factor\": 1,\r\n\t\t\t\"easing\": $ease.polyOut3\r\n\t\t});\r\n\t\tthis.inertiaOptions.setKey(\"resize\", {\r\n\t\t\t\"time\": 100,\r\n\t\t\t\"duration\": 500,\r\n\t\t\t\"factor\": 1,\r\n\t\t\t\"easing\": $ease.polyOut3\r\n\t\t});\r\n\r\n\t\t// Set the passive mode support\r\n\t\tthis._passiveSupported = Interaction.passiveSupported;\r\n\r\n\t\t// Apply theme\r\n\t\tthis.applyTheme();\r\n\t}\r\n\r\n\t/**\r\n\t * This is a nasty detection for Firefox. The reason why we have is that\r\n\t * Firefox ESR version does not support matchMedia correctly.\r\n\t *\r\n\t * On iOS, Firefox uses different userAgent, so we don't have to detect iOS.\r\n\t *\r\n\t * @return Full Firefox?\r\n\t */\r\n\tprotected fullFF(): boolean {\r\n\t\treturn (window.navigator.userAgent.match(/Firefox/)) && !(window.navigator.userAgent.match(/Android/));\r\n\t}\r\n\r\n\tprotected debug(): void { }\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Processing\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Sets up global events.\r\n\t *\r\n\t * We need this so that we can track drag movement beyond chart's container.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic addGlobalEvents(): void {\r\n\t\tif (!this._globalEventsAdded) {\r\n\r\n\t\t\tif (!this._useTouchEventsOnly) {\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerDown(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointermove,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerMove(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointerup,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerUp(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\tthis._pointerEvents.pointercancel,\r\n\t\t\t\t\t(ev: MouseEvent) => { this.handleGlobalPointerUp(ev, true) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener<MouseEvent | PointerEvent>(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"mouseenter\",\r\n\t\t\t\t\t(ev: MouseEvent) => {\r\n\t\t\t\t\t\tif (!$type.hasValue(ev.relatedTarget) && (ev.buttons == 0 || ev.which == 0)) {\r\n\t\t\t\t\t\t\tthis.handleDocumentLeave(ev);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t));\r\n\t\t\t}\r\n\r\n\t\t\t// No need to duplicate events for hubrid systems that support both\r\n\t\t\t// pointer events and touch events. Touch events are need only for\r\n\t\t\t// some touch-only systems, like Mobile Safari.\r\n\t\t\tif (!this._usePointerEventsOnly) {\r\n\t\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t(ev: TouchEvent) => { this.handleGlobalTouchStart(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"touchmove\",\r\n\t\t\t\t\t(ev: TouchEvent) => { this.handleGlobalTouchMove(ev) }\r\n\t\t\t\t));\r\n\r\n\t\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\t\tdocument,\r\n\t\t\t\t\t\"touchend\",\r\n\t\t\t\t\t(ev: TouchEvent) => { this.handleGlobalTouchEnd(ev) }\r\n\t\t\t\t));\r\n\t\t\t}\r\n\r\n\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\tdocument,\r\n\t\t\t\t\"keydown\",\r\n\t\t\t\t(ev: KeyboardEvent) => { this.handleGlobalKeyDown(ev) }\r\n\t\t\t));\r\n\r\n\t\t\tthis._disposers.push(addEventListener(\r\n\t\t\t\tdocument,\r\n\t\t\t\t\"keyup\",\r\n\t\t\t\t(ev: KeyboardEvent) => { this.handleGlobalKeyUp(ev) }\r\n\t\t\t));\r\n\r\n\t\t\tthis._globalEventsAdded = true;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets if [[InteractionObject]] is clickable.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io [[InteractionObject]] instance\r\n\t */\r\n\tpublic processClickable(io: InteractionObject): void {\r\n\t\t// Add or remove touch events\r\n\t\tthis.processTouchable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets if [[InteractionObject]] will display context menu when right-clicked.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io [[InteractionObject]] instance\r\n\t */\r\n\tpublic processContextMenu(io: InteractionObject): void {\r\n\t\tif (io.contextMenuDisabled) {\r\n\t\t\tif (!io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\r\n\t\t\t\tio.eventDisposers.setKey(\"contextMenuDisabled\",\r\n\t\t\t\t\taddEventListener<MouseEvent | PointerEvent>(io.element, \"contextmenu\", (e) => {\r\n\t\t\t\t\t\te.preventDefault();\r\n\t\t\t\t\t})\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (io.eventDisposers.hasKey(\"contextMenuDisabled\")) {\r\n\t\t\t\tio.eventDisposers.getKey(\"contextMenuDisabled\").dispose();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets if [[InteractionObject]] is hoverable.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io [[InteractionObject]] instance\r\n\t */\r\n\tpublic processHoverable(io: InteractionObject): void {\r\n\t\tif (io.hoverable || io.trackable) {\r\n\r\n\t\t\t// Add global events\r\n\t\t\tthis.addGlobalEvents();\r\n\r\n\t\t\t// Add hover styles\r\n\t\t\tthis.applyCursorOverStyle(io);\r\n\r\n\t\t\t// Add local events\r\n\t\t\tif (!io.eventDisposers.hasKey(\"hoverable\") && this._addHoverEvents) {\r\n\t\t\t\tio.eventDisposers.setKey(\"hoverable\", new MultiDisposer([\r\n\t\t\t\t\taddEventListener<MouseEvent | PointerEvent>(io.element, this._pointerEvents.pointerout, (e) => this.handlePointerOut(io, e)),\r\n\t\t\t\t\taddEventListener<MouseEvent | PointerEvent>(io.element, this._pointerEvents.pointerover, (e) => this.handlePointerOver(io, e))\r\n\t\t\t\t]));\r\n\t\t\t}\r\n\r\n\t\t\tif (io.trackable) {\r\n\t\t\t\t//sprite.addEventListener(\"touchmove\", this.handleTouchMove, false, this);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"hoverable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"hoverable\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add or remove touch events\r\n\t\tthis.processTouchable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets up [[InteractionObject]] as movable. Movable can be any\r\n\t * transformation, e.g. drag, swipe, resize, track.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processMovable(io: InteractionObject) {\r\n\r\n\t\t// Add unified events\r\n\t\tif (io.draggable || io.swipeable || io.trackable || io.resizable) {\r\n\r\n\t\t\t// Prep the element\r\n\t\t\tif (!this.isGlobalElement(io) && !io.isTouchProtected) {\r\n\t\t\t\tthis.prepElement(io);\r\n\t\t\t}\r\n\r\n\t\t\t// Add hover styles\r\n\t\t\tthis.applyCursorOverStyle(io);\r\n\r\n\t\t}\r\n\r\n\t\t// Add or remove touch events\r\n\t\tthis.processTouchable(io);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is trackable and sets relative events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processTrackable(io: InteractionObject): void {\r\n\t\tthis.processHoverable(io);\r\n\t\tthis.processMovable(io);\r\n\t\tif (io.trackable) {\r\n\t\t\tthis.trackedObjects.moveValue(io);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.trackedObjects.removeValue(io);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is draggable.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processDraggable(io: InteractionObject): void {\r\n\t\tthis.processMovable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is swipeable and sets relative events.\r\n\t *\r\n\t * A swipe event is triggered when a horizontal drag of 75px or more (and\r\n\t * less than 30px vertically) occurs within 700 milliseconds. This can be\r\n\t * overridden in sprites [[swipeOptions]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processSwipeable(io: InteractionObject): void {\r\n\t\tthis.processMovable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is resizable and attaches required events\r\n\t * to it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processResizable(io: InteractionObject): void {\r\n\t\tthis.processMovable(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is supposed to capture mouse wheel events\r\n\t * and prepares it to catch those events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processWheelable(io: InteractionObject): void {\r\n\t\tif (io.wheelable) {\r\n\t\t\t//io.hoverable = true;\r\n\t\t\tif (!io.eventDisposers.hasKey(\"wheelable\")) {\r\n\t\t\t\tio.eventDisposers.setKey(\"wheelable\", new MultiDisposer([\r\n\t\t\t\t\taddEventListener<WheelEvent>(\r\n\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\tthis._pointerEvents.wheel,\r\n\t\t\t\t\t\t(e) => this.handleMouseWheel(io, e),\r\n\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t),\r\n\t\t\t\t\tio.events.on(\"out\", (e) => {\r\n\t\t\t\t\t\tif (io.wheelable) {\r\n\t\t\t\t\t\t\tthis.unlockWheel();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}),\r\n\t\t\t\t\tio.events.on(\"over\", (e) => {\r\n\t\t\t\t//console.log(\"whelab over\")\r\n\t\t\t\t\t\tif (io.wheelable) {\r\n\t\t\t\t\t\t\tthis.lockWheel();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t]));\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"wheelable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"wheelable\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is focusable. A focusable element is an\r\n\t * element that will be highlighted when users presses TAB key. If the\r\n\t * element is focusable, this function will attach relative focus/blur\r\n\t * events to it.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processFocusable(io: InteractionObject): void {\r\n\t\tif (io.focusable === true && (io.tabindex > -1) && !this._useTouchEventsOnly) {\r\n\t\t\tif (!io.eventDisposers.hasKey(\"focusable\")) {\r\n\t\t\t\tio.eventDisposers.setKey(\"focusable\", new MultiDisposer([\r\n\t\t\t\t\taddEventListener<FocusEvent>(io.element, \"focus\", (e) => this.handleFocus(io, e)),\r\n\t\t\t\t\taddEventListener<FocusEvent>(io.element, \"blur\", (e) => this.handleBlur(io, e)),\r\n\t\t\t\t\taddEventListener<MouseEvent>(\r\n\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t\t(e) => this.handleFocusBlur(io, e)\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\taddEventListener<TouchEvent>(\r\n\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t\t(e) => this.handleFocusBlur(io, e),\r\n\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t)\r\n\t\t\t\t]));\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"focusable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"focusable\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if [[InteractionObject]] is \"touchable\". It means any interaction\r\n\t * whatsoever: mouse click, touch screen tap, swipe, drag, resize, etc.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t */\r\n\tpublic processTouchable(io: InteractionObject): void {\r\n\r\n\t\t// Add unified events\r\n\t\tif (io.clickable || io.hoverable || io.trackable || io.draggable || io.swipeable || io.resizable) {\r\n\r\n\t\t\t// Add global events\r\n\t\t\tthis.addGlobalEvents();\r\n\r\n\t\t\t// Add local events\r\n\t\t\tif (!io.eventDisposers.hasKey(\"touchable\")) {\r\n\t\t\t\tif (!this._useTouchEventsOnly && !this._usePointerEventsOnly) {\r\n\t\t\t\t\tio.eventDisposers.setKey(\"touchable\", new MultiDisposer([\r\n\r\n\t\t\t\t\t\taddEventListener<MouseEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t\t\t(e) => this.handlePointerDown(io, e)\r\n\t\t\t\t\t\t),\r\n\r\n\t\t\t\t\t\taddEventListener<TouchEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t\t\t(e) => this.handleTouchDown(io, e),\r\n\t\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t\t)\r\n\r\n\t\t\t\t\t]));\r\n\t\t\t\t}\r\n\t\t\t\telse if (!this._useTouchEventsOnly) {\r\n\t\t\t\t\tio.eventDisposers.setKey(\"touchable\",\r\n\t\t\t\t\t\taddEventListener<MouseEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\tthis._pointerEvents.pointerdown,\r\n\t\t\t\t\t\t\t(e) => this.handlePointerDown(io, e)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!this._usePointerEventsOnly) {\r\n\t\t\t\t\tio.eventDisposers.setKey(\"touchable\",\r\n\t\t\t\t\t\taddEventListener<TouchEvent>(\r\n\t\t\t\t\t\t\tio.element,\r\n\t\t\t\t\t\t\t\"touchstart\",\r\n\t\t\t\t\t\t\t(e) => this.handleTouchDown(io, e),\r\n\t\t\t\t\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\t\t\tconst disposer = io.eventDisposers.getKey(\"touchable\");\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tio.eventDisposers.removeKey(\"touchable\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Non-pointer events\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Dispatches \"focus\" event when element gains focus.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handleFocus(io: InteractionObject, ev: FocusEvent): void {\r\n\t\tif (!io.focusable) {\r\n\t\t\tev.preventDefault();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tio.isFocused = true;\r\n\t\tif (io.events.isEnabled(\"focus\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"focus\"] = {\r\n\t\t\t\ttype: \"focus\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"focus\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Used by regular click events to prevent focus if \"noFocus\" is set.\r\n\t *\r\n\t * This should not be called by \"focus\" handlers.\r\n\t *\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tprivate handleFocusBlur(io: InteractionObject, ev: MouseEvent | TouchEvent): void {\r\n\t\tif (io.focusable !== false && this.getHitOption(io, \"noFocus\")) {\r\n\t\t\tio.events.once(\"focus\", () => {\r\n\t\t\t\tio.events.disableType(\"blur\");\r\n\t\t\t\t$dom.blur();\r\n\t\t\t\tif (io.sprite) {\r\n\t\t\t\t\tio.sprite.handleBlur();\r\n\t\t\t\t}\r\n\t\t\t\tio.events.enableType(\"blur\");\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches \"blur\" event when element loses focus.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handleBlur(io: InteractionObject, ev: FocusEvent): void {\r\n\t\tif (!io.focusable) {\r\n\t\t\tev.preventDefault();\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tio.isFocused = false;\r\n\t\tif (io.events.isEnabled(\"blur\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"blur\"] = {\r\n\t\t\t\ttype: \"blur\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"blur\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Global keyboard-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Checks if there is an item that has currently focus and that they key is\r\n\t * one of the directional keys. If both of the conditions are true, it\r\n\t * creates an object to simulate movement of dragable element with keyboard.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev An original keyboard event\r\n\t */\r\n\tpublic handleGlobalKeyDown(ev: KeyboardEvent): void {\r\n\r\n\t\tif (this.focusedObject) {\r\n\t\t\tif (keyboard.isKey(ev, \"esc\")) {\r\n\t\t\t\t// ESC removes focus\r\n\t\t\t\t$dom.blur();\r\n\t\t\t}\r\n\t\t\telse if (this.focusedObject.draggable && keyboard.isKey(ev, [\"up\", \"down\", \"left\", \"right\"])) {\r\n\r\n\t\t\t\t// Prevent scrolling of the document\r\n\t\t\t\tev.preventDefault();\r\n\r\n\t\t\t\t// Get focused object\r\n\t\t\t\tlet io = this.focusedObject;\r\n\r\n\t\t\t\t// Get particular key\r\n\t\t\t\tlet disposerKey = \"interactionKeyboardObject\";\r\n\r\n\t\t\t\t// If such disposer already exists we know the event is going on so we\r\n\t\t\t\t// just move on\r\n\t\t\t\tif (io.eventDisposers.hasKey(disposerKey)) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Create a keyboard mover\r\n\t\t\t\tlet ko = new InteractionKeyboardObject(io, ev);\r\n\t\t\t\tio.eventDisposers.setKey(disposerKey, ko);\r\n\t\t\t\tswitch (keyboard.getEventKey(ev)) {\r\n\t\t\t\t\tcase \"up\":\r\n\t\t\t\t\t\tko.directionY = -1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"down\":\r\n\t\t\t\t\t\tko.directionY = 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"left\":\r\n\t\t\t\t\t\tko.directionX = -1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase \"right\":\r\n\t\t\t\t\t\tko.directionX = 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Dispatches related events when the keyboard key is realeasd.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev An original keyboard event\r\n\t */\r\n\tpublic handleGlobalKeyUp(ev: KeyboardEvent): void {\r\n\t\tlet disposerKey = \"interactionKeyboardObject\";\r\n\t\tif (this.focusedObject) {\r\n\t\t\tconst disposer = this.focusedObject.eventDisposers.getKey(disposerKey);\r\n\r\n\t\t\tif (disposer != null) {\r\n\t\t\t\t// Prevent scrolling of the document\r\n\t\t\t\tev.preventDefault();\r\n\r\n\t\t\t\t// Dispose stuff\r\n\t\t\t\tdisposer.dispose();\r\n\t\t\t\tthis.focusedObject.eventDisposers.removeKey(disposerKey);\r\n\t\t\t}\r\n\r\n\t\t\t// Does focused object have \"hit\" event?\r\n\t\t\tconst sprite = this.focusedObject.sprite;\r\n\t\t\tif (keyboard.isKey(ev, \"enter\") && sprite) {\r\n\t\t\t\tif (sprite.events.isEnabled(\"hit\") || sprite.events.isEnabled(\"toggled\")) {\r\n\t\t\t\t\tthis.focusedObject.dispatchImmediately(\"hit\");\r\n\t\t\t\t}\r\n\t\t\t\telse if (sprite.showTooltipOn == \"hit\") {\r\n\t\t\t\t\tthis.focusedObject.dispatchImmediately(\"up\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Global pointer-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Handler for a global \"pointermove\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalPointerMove(ev: MouseEvent): void {\r\n\t\t// Get pointer\r\n\t\tlet pointer: IPointer = this.getPointer(ev);\r\n\r\n\t\t// Update current point position\r\n\t\tpointer.point = this.getPointerPoint(ev);\r\n\r\n\t\t// Prepare and fire global event\r\n\t\tif (this.events.isEnabled(\"track\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"track\"] = {\r\n\t\t\t\ttype: \"track\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"track\", imev);\r\n\t\t}\r\n\r\n\t\t// Track\r\n\t\tthis.addBreadCrumb(pointer, pointer.point);\r\n\r\n\t\t// Process further\r\n\t\tthis.handleGlobalMove(pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"pointerdown\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalPointerDown(ev: MouseEvent): void {\r\n\r\n\t\t// Remove delayed hovers\r\n\t\tthis.processDelayed();\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer: IPointer = this.getPointer(ev);\r\n\r\n\t\t// Prepare and fire global event\r\n\t\tif (this.events.isEnabled(\"down\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"down\"] = {\r\n\t\t\t\ttype: \"down\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"down\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Prevents touch action from firing.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event\r\n\t */\r\n\tpublic preventTouchAction(ev: TouchEvent): void {\r\n\t\tif (!ev.defaultPrevented) {\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"pointerup\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalPointerUp(ev: MouseEvent, cancelled: boolean = false): void {\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer: IPointer = this.getPointer(ev);\r\n\r\n\t\t// Prepare and fire global event\r\n\t\tif (this.events.isEnabled(\"up\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"up\"] = {\r\n\t\t\t\ttype: \"up\",\r\n\t\t\t\ttarget: this,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tthis.events.dispatchImmediately(\"up\", imev);\r\n\t\t}\r\n\r\n\t\t// Process further\r\n\t\tthis.handleGlobalUp(pointer, ev, cancelled);\r\n\r\n\t}\r\n\r\n\t/**\r\n * ==========================================================================\r\n * Global touch-related even handlers\r\n * ==========================================================================\r\n */\r\n\r\n\t/**\r\n\t * Handler for a global \"touchmove\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalTouchMove(ev: TouchEvent): void {\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer: IPointer = this.getPointer(ev.changedTouches[i]);\r\n\r\n\t\t\t// Update current point position\r\n\t\t\tpointer.point = this.getPointerPoint(ev.changedTouches[i]);\r\n\r\n\t\t\t// Prepare and fire global event\r\n\t\t\tif (this.events.isEnabled(\"track\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"track\"] = {\r\n\t\t\t\t\ttype: \"track\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"track\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Track\r\n\t\t\tthis.addBreadCrumb(pointer, pointer.point);\r\n\r\n\t\t\t// Process further\r\n\t\t\tthis.handleGlobalMove(pointer, ev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"touchstart\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalTouchStart(ev: TouchEvent): void {\r\n\r\n\t\t// Remove delayed hovers\r\n\t\tthis.processDelayed();\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer: IPointer = this.getPointer(ev.changedTouches[i]);\r\n\r\n\t\t\t// Prepare and fire global event\r\n\t\t\tif (!this._usePointerEventsOnly && this.events.isEnabled(\"down\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"down\"] = {\r\n\t\t\t\t\ttype: \"down\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"down\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handler for a global \"touchend\" event.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev Event object\r\n\t */\r\n\tpublic handleGlobalTouchEnd(ev: TouchEvent): void {\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer: IPointer = this.getPointer(ev.changedTouches[i]);\r\n\r\n\t\t\t// Prepare and fire global event\r\n\t\t\tif (this.events.isEnabled(\"up\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<this, IInteractionEvents>[\"up\"] = {\r\n\t\t\t\t\ttype: \"up\",\r\n\t\t\t\t\ttarget: this,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tthis.events.dispatchImmediately(\"up\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Handle element-related events\r\n\t\t\tthis.handleGlobalUp(pointer, ev);\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Element-specific pointer-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Handles event when pointer is over [[InteractionObject]] and button is\r\n\t * pressed.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handlePointerDown(io: InteractionObject, ev: MouseEvent | PointerEvent): void {\r\n\r\n\t\t// Stop further propagation so we don't get multiple triggers on hybrid\r\n\t\t// devices (both mouse and touch capabilities)\r\n\t\t//ev.preventDefault();\r\n\t\t//ev.stopPropagation();\r\n\t\t//if (ev.defaultPrevented) {\r\n\t\t//}\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Ignore if it's anything but mouse's primary button\r\n\t\tif (!pointer.touch && ev.which != 1 && ev.which != 3) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Set mouse button\r\n\t\tpointer.button = ev.which;\r\n\r\n\t\t// Reset pointer\r\n\t\tthis.resetPointer(pointer, ev);\r\n\r\n\t\t// Process down\r\n\t\tthis.handleDown(io, pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when [[InteractionObject]] is hovered by a mouse pointer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handlePointerOver(io: InteractionObject, ev: MouseEvent | PointerEvent): void {\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Process down\r\n\t\tthis.handleOver(io, pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when [[InteractionObject]] loses hover from a mouse pointer.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handlePointerOut(io: InteractionObject, ev: MouseEvent | PointerEvent): void {\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Process down\r\n\t\tthis.handleOut(io, pointer, ev);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event when mouse wheel is crolled over the [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t * @todo Investigate more-cross browser stuff https://developer.mozilla.org/en-US/docs/Web/Events/wheel\r\n\t */\r\n\tpublic handleMouseWheel(io: InteractionObject, ev: WheelEvent): void {\r\n\r\n\t\t// Get pointer\r\n\t\tlet pointer = this.getPointer(ev);\r\n\r\n\t\t// Update current point position\r\n\t\tpointer.point = this.getPointerPoint(ev);\r\n\r\n\t\t// Init delta values\r\n\t\tlet deltaX: number = 0, deltaY: number = 0;\r\n\r\n\t\t// Set up modifier\r\n\t\t// This is needed because FireFox reports wheel deltas in \"lines\" instead\r\n\t\t// of pixels so we have to approximate pixel value\r\n\t\tlet mod = 1;\r\n\t\tif (ev.deltaMode == 1) {\r\n\t\t\tmod = 50;\r\n\t\t}\r\n\r\n\t\t// Adjust configurable sensitivity\r\n\t\tmod *= this.getMouseOption(io, \"sensitivity\");\r\n\r\n\t\t// Calculate deltas\r\n\t\tif (ev instanceof WheelEvent) {\r\n\t\t\tdeltaX = Math.round((-1 * (<any>ev).wheelDeltaX) || (ev.deltaX * mod));\r\n\t\t\tdeltaY = Math.round((-1 * (<any>ev).wheelDeltaY) || (ev.deltaY * mod));\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid event type\");\r\n\t\t}\r\n\r\n\t\t// Handle the event\r\n\t\tthis.handleWheel(io, pointer, deltaX, deltaY, ev);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Element-specific touch-related even handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t  * Handles an event when an [[InteractionObject]] is touched on a touch\r\n\t  * device.\r\n\t  *\r\n\t  * @ignore Exclude from docs\r\n\t  * @param io  Element\r\n\t  * @param ev  Original event\r\n\t  */\r\n\tpublic handleTouchDown(io: InteractionObject, ev: TouchEvent): void {\r\n\r\n\t\t// Stop further propagation so we don't get multiple triggers on hybrid\r\n\t\t// devices (both mouse and touch capabilities)\r\n\t\t//this.maybePreventDefault(io, ev);\r\n\t\t//return;\r\n\r\n\t\t// Process each changed touch point\r\n\t\tfor (let i = 0; i < ev.changedTouches.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet pointer = this.getPointer(ev.changedTouches[i]);\r\n\t\t\tthis.maybePreventDefault(io, ev, pointer);\r\n\r\n\t\t\t// Reset pointer\r\n\t\t\tthis.resetPointer(pointer, ev.changedTouches[i]);\r\n\r\n\t\t\t// Process down\r\n\t\t\tthis.handleDown(io, pointer, ev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Universal handlers\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Handles click/tap. Checks for doublehit.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleHit(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Check if this is a double-hit\r\n\t\tlet now = $time.getTime();\r\n\t\tif (io.lastHit && (io.lastHit >= (now - this.getHitOption(io, \"doubleHitTime\")))) {\r\n\r\n\t\t\t// Yup - it's a double-hit\r\n\r\n\t\t\t// Cancel the hit\r\n\t\t\t//clearTimeout(io.lastHitPointer.hitTimeout);\r\n\r\n\t\t\t// If it happened too fast it probably means that hybrid device just\r\n\t\t\t// generated two events for the same tap\r\n\t\t\tif ((now - io.lastHit) < 100) {\r\n\t\t\t\t// Ignore\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Clear last hit\r\n\t\t\tio.lastHit = undefined;\r\n\t\t\tio.lastHitPointer = undefined;\r\n\r\n\t\t\t// Dispatch event\r\n\t\t\tif (io.events.isEnabled(\"doublehit\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"doublehit\"] = {\r\n\t\t\t\t\ttype: \"doublehit\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"doublehit\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t// Log last hit\r\n\t\t\tio.lastHit = now;\r\n\t\t\tio.lastHitPointer = pointer;\r\n\r\n\t\t\tif (pointer.button === 3) {\r\n\t\t\t\t// Execute HIT now\r\n\t\t\t\tif (io.events.isEnabled(\"rightclick\") && !system.isPaused) {\r\n\t\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"rightclick\"] = {\r\n\t\t\t\t\t\ttype: \"rightclick\",\r\n\t\t\t\t\t\ttarget: io,\r\n\t\t\t\t\t\tevent: ev\r\n\t\t\t\t\t}\r\n\t\t\t\t\tio.events.dispatchImmediately(\"rightclick\", imev);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (io.events.isEnabled(\"hit\") && !system.isPaused) {\r\n\t\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"hit\"] = {\r\n\t\t\t\t\t\ttype: \"hit\",\r\n\t\t\t\t\t\ttarget: io,\r\n\t\t\t\t\t\tevent: ev,\r\n\t\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t\t};\r\n\t\t\t\t\tio.events.dispatchImmediately(\"hit\", imev);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles pointer hovering over [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t * @param soft     Invoked by helper function\r\n\t */\r\n\tpublic handleOver(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, soft: boolean = false): void {\r\n\r\n\t\tif (!io.hoverable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tlet hoversPaused = false;\r\n\t\tif (this.shouldCancelHovers(pointer) && this.areTransformed() && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\thoversPaused = true;\r\n\t\t\tthis.cancelAllHovers(ev);\r\n\t\t}\r\n\r\n\t\t// Remove any delayed outs\r\n\t\tthis.processDelayed();\r\n\r\n\t\t// Add pointer\r\n\t\tio.overPointers.moveValue(pointer);\r\n\r\n\t\t// Check if object is not yet hovered\r\n\t\tif (!io.isRealHover) {\r\n\r\n\t\t\t// Set element as hovered\r\n\t\t\tif (!hoversPaused) {\r\n\t\t\t\tio.isHover = true;\r\n\t\t\t\tio.isRealHover = true;\r\n\t\t\t\tthis.overObjects.moveValue(io);\r\n\t\t\t}\r\n\r\n\t\t\t// Generate body track event. This is needed so that if element loads\r\n\t\t\t// under unmoved mouse cursor, we still need all the actions that are\r\n\t\t\t// required to happen to kick in.\r\n\t\t\tthis.handleTrack(this.body, pointer, ev, true);\r\n\r\n\t\t\t// Event\r\n\t\t\tif (io.events.isEnabled(\"over\") && !system.isPaused && !hoversPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"over\"] = {\r\n\t\t\t\t\ttype: \"over\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"over\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles when [[InteractionObject]] is no longer hovered.\r\n\t *\r\n\t * If `soft = true`, this means that method is being invoked by some other\r\n\t * code, not hard \"out\" function, like `handleUp` which implies we need to\r\n\t * run additional checks before unhovering the object.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t * @param soft     Invoked by helper function\r\n\t * @param force    Force imediate out\r\n\t */\r\n\tpublic handleOut(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, soft: boolean = false, force: boolean = false): void {\r\n\r\n\t\tif (!io.hoverable) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Remove pointer\r\n\t\tio.overPointers.removeValue(pointer);\r\n\r\n\t\t// Check if element is still hovered\r\n\t\tif (io.isHover && (!io.hasDelayedOut || force)) {\r\n\r\n\r\n\t\t\t// Should we run additional checks?\r\n\t\t\tif (soft && io.overPointers.length) {\r\n\t\t\t\t// There are still pointers hovering - don't do anything else and\r\n\t\t\t\t// wait until either no over pointers are there or we get a hard out\r\n\t\t\t\t// event.\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Should we delay \"out\" if this is happening on a touch device?\r\n\t\t\tif (pointer && pointer.touch && !force && !this.old(pointer)) {\r\n\r\n\t\t\t\t// This is a touch pointer, and it hasn't moved, let's pretend\r\n\t\t\t\t// the object is still hovered, and act as per \"behavior\" setting\r\n\t\t\t\tlet behavior = this.getHoverOption(io, \"touchOutBehavior\");\r\n\t\t\t\tif (behavior == \"leave\") {\r\n\t\t\t\t\t// Set to \"leave\", so we do not execute any \"out\" event.\r\n\t\t\t\t\t// It will be handled by any other interaction that happens\r\n\t\t\t\t\t// afterwards.\r\n\t\t\t\t\tthis._delayedEvents.out.push({\r\n\t\t\t\t\t\ttype: \"out\",\r\n\t\t\t\t\t\tio: io,\r\n\t\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\t\tevent: ev,\r\n\t\t\t\t\t\tkeepUntil: $time.getTime() + 500\r\n\t\t\t\t\t});\r\n\t\t\t\t\tio.hasDelayedOut = true;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse if (behavior == \"delay\" && this.getHoverOption(io, \"touchOutDelay\")) {\r\n\t\t\t\t\tthis._delayedEvents.out.push({\r\n\t\t\t\t\t\ttype: \"out\",\r\n\t\t\t\t\t\tio: io,\r\n\t\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\t\tevent: ev,\r\n\t\t\t\t\t\tkeepUntil: $time.getTime() + 500,\r\n\t\t\t\t\t\ttimeout: this.setTimeout(() => {\r\n\t\t\t\t\t\t\tthis.handleOut(io, pointer, ev, true);\r\n\t\t\t\t\t\t}, this.getHoverOption(io, \"touchOutDelay\"))\r\n\t\t\t\t\t});\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// Nothing for \"remove\" - that's how it works \"out-of-the-box\"\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Set element as not hovered\r\n\t\t\tio.isHover = false;\r\n\t\t\tthis.overObjects.removeValue(io);\r\n\r\n\t\t\t// Invoke event\r\n\t\t\tif (!io.isDisposed() && io.events.isEnabled(\"out\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"out\"] = {\r\n\t\t\t\t\ttype: \"out\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"out\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Reset object from lefover delayed outs, pointers\r\n\t\t\tio.overPointers.clear();\r\n\t\t\tio.hasDelayedOut = false;\r\n\t\t\t// @todo (clean delayed)\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Processes dalyed events, such as \"out\" event that was initiated for\r\n\t * elements by touch.\r\n\t */\r\n\tprivate processDelayed(): void {\r\n\t\tlet delayedEvent;\r\n\r\n\t\twhile (true) {\r\n\t\t\tdelayedEvent = this._delayedEvents.out.pop();\r\n\r\n\t\t\tif (!delayedEvent) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tif (delayedEvent.timeout) {\r\n\t\t\t\tdelayedEvent.timeout.dispose();\r\n\t\t\t}\r\n\r\n\t\t\tthis.handleOut(delayedEvent.io, delayedEvent.pointer, delayedEvent.event, false, true);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs tasks on pointer down.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleDown(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent | undefined): void {\r\n\r\n\t\t// Need to prevent default event from happening on transformable objects\r\n\t\tthis.maybePreventDefault(io, ev, pointer);\r\n\r\n\t\t// Stop inertia animations if they're currently being played out\r\n\t\tif (io.inert) {\r\n\t\t\tthis.stopInertia(io);\r\n\t\t}\r\n\r\n\t\t// Trigger hover because some touch devices won't trigger over events\r\n\t\t// on their own\r\n\t\tthis.handleOver(io, pointer, ev, true);\r\n\r\n\t\t// Add pointer to list\r\n\t\tio.downPointers.moveValue(pointer);\r\n\r\n\t\t// Apply styles if necessary\r\n\t\tthis.applyCursorDownStyle(io, pointer);\r\n\r\n\t\t// Check if object is already down\r\n\t\tif (!io.isDown) {\r\n\r\n\t\t\t// Lose focus if needed\r\n\t\t\tif (io.focusable !== false && this.getHitOption(io, \"noFocus\") && this.focusedObject) {\r\n\t\t\t\t$dom.blur();\r\n\t\t\t}\r\n\r\n\t\t\t// Set object as hovered\r\n\t\t\tio.isDown = true;\r\n\t\t\tthis.downObjects.moveValue(io);\r\n\r\n\t\t\t// Prep object for dragging and/or resizing\r\n\t\t\tif (io.draggable) {\r\n\t\t\t\tthis.processDragStart(io, pointer, ev);\r\n\t\t\t}\r\n\t\t\tif (io.resizable) {\r\n\t\t\t\tthis.processResizeStart(io, pointer, ev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Dispatch \"down\" event\r\n\t\tif (io.events.isEnabled(\"down\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"down\"] = {\r\n\t\t\t\ttype: \"down\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"down\", imev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Performs tasks on pointer up.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleGlobalUp(pointer: IPointer, ev: MouseEvent | TouchEvent | undefined, cancelled: boolean = false): void {\r\n\t\tconst sorted = this.downObjects.values.slice();\r\n\r\n\t\tsorted.sort((x, y) => {\r\n\t\t\tif (x && y) {\r\n\t\t\t\tconst pos = x.element.compareDocumentPosition(y.element);\r\n\r\n\t\t\t\tif (pos & Node.DOCUMENT_POSITION_CONTAINED_BY) {\r\n\t\t\t\t\treturn 1;\r\n\r\n\t\t\t\t} else if (pos & Node.DOCUMENT_POSITION_CONTAINS) {\r\n\t\t\t\t\treturn -1;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Process all down objects\r\n\t\t$array.each(sorted, (io) => {\r\n\t\t\t// Check if this particular pointer is pressing down\r\n\t\t\t// on object\r\n\t\t\tif (io && io.downPointers.contains(pointer)) {\r\n\t\t\t\tthis.handleUp(io, pointer, ev, cancelled);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Simulates all pointers being up once mouse leaves document area.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleDocumentLeave(ev: MouseEvent): void {\r\n\r\n\t\t// Process all down objects\r\n\t\t$iter.each(this.downObjects.backwards().iterator(), (io) => {\r\n\t\t\tio.downPointers.each((pointer) => {\r\n\t\t\t\tthis.handleUp(io, pointer, ev);\r\n\t\t\t})\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles when [[InteractionObject]] is no longer hovered.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Interaction object\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleUp(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, cancelled: boolean = false): void {\r\n\r\n\t\t// Restore cursor style\r\n\t\tthis.restoreCursorDownStyle(io, pointer);\r\n\r\n\t\t// Remove pointer from the list\r\n\t\tio.downPointers.removeValue(pointer);\r\n\r\n\t\t// Trigger out because some touch devices won't trigger out events\r\n\t\t// on their own\r\n\t\tif ((pointer && pointer.touch) || this._useTouchEventsOnly) {\r\n\t\t\tthis.handleOut(io, pointer, ev, true);\r\n\t\t}\r\n\r\n\t\t// Check if object still down\r\n\t\tif (io.isDown) {\r\n\r\n\t\t\t// Check if there are no other pointers hovering this element\r\n\t\t\tif (io.downPointers.length == 0) {\r\n\t\t\t\t// Set element as no longer down\r\n\t\t\t\tio.isDown = false;\r\n\t\t\t\tthis.downObjects.removeValue(io);\r\n\t\t\t}\r\n\r\n\t\t\t// Dispatch \"up\" event\r\n\t\t\tif (io.events.isEnabled(\"up\") && !system.isPaused && pointer) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"up\"] = {\r\n\t\t\t\t\ttype: \"up\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpointer: pointer,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"up\", imev);\r\n\t\t\t}\r\n\r\n\t\t\t// Check if this was not a cancelled event.\r\n\t\t\t// If event was canelled (which might happen if gesture resulted in\r\n\t\t\t// navigation or page scroll) there's no point in triggering hit and\r\n\t\t\t// other actions.\r\n\t\t\tif (!cancelled) {\r\n\r\n\t\t\t\t// Handle swiping-related stuff\r\n\t\t\t\tif (io.swipeable && this.swiped(io, pointer)) {\r\n\t\t\t\t\t// Swiped - nothing else should happen\r\n\t\t\t\t\tthis.handleSwipe(io, pointer, ev);\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// Check if it maybe a click\r\n\t\t\t\t\tif (io.clickable && !this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\t\t\t\tthis.handleHit(io, pointer, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Handle inertia\r\n\t\t\t\t\tif (io.inert && this.moved(pointer, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\t\t\t\tthis.handleInertia(io, pointer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (io.draggable) {\r\n\t\t\t\t\t\tthis.processDragStop(io, pointer, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (io.resizable) {\r\n\t\t\t\t\t\tthis.processResizeStop(io, pointer, ev);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if event needs to be prevented on draggable and such items, so that\r\n\t * touch gestures like navigation and scroll do not kick in.\r\n\t *\r\n\t * @param io  Object\r\n\t * @param ev  Event\r\n\t */\r\n\tprivate maybePreventDefault(io: InteractionObject, ev: MouseEvent | TouchEvent | undefined, pointer?: IPointer): void {\r\n\t\tif (\r\n\t\t\t$type.hasValue(ev)\r\n\t\t\t&& (io.draggable || io.swipeable || io.trackable || io.resizable)\r\n\t\t\t&& !this.isGlobalElement(io)\r\n\t\t\t&& ev.cancelable !== false\r\n\t\t\t&& (!io.isTouchProtected || !pointer || !pointer.touch)\r\n\t\t) {\r\n\t\t\tev.preventDefault();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Cancels all hovers on all currently hovered objects.\r\n\t *\r\n\t * @param  pointer  Pointer\r\n\t * @param  ev       Event\r\n\t */\r\n\tprivate cancelAllHovers(ev?: MouseEvent | TouchEvent): void {\r\n\t\t//this.overObjects.each((io) => {\r\n\t\t$iter.each(this.overObjects.backwards().iterator(), (io) => {\r\n\t\t\tif (io) {\r\n\t\t\t\tconst pointer = io.overPointers.getIndex(0);\r\n\t\t\t\tthis.handleOut(io, pointer, ev, true, true);\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if hovers should be cancelled on transform as per global options.\r\n\t * @param   pointer  Pointer\r\n\t * @return           Cancel?\r\n\t */\r\n\tprivate shouldCancelHovers(pointer: IPointer): boolean {\r\n\t\treturn options.disableHoverOnTransform == \"always\" || (options.disableHoverOnTransform == \"touch\" && pointer.touch);\r\n\t}\r\n\r\n\t/**\r\n\t * Handles pointer move.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleGlobalMove(pointer: IPointer, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Process hovered elements\r\n\t\t// We check if the element became unhovered without reporting the mouseout\r\n\t\t// event. (it happens in some cases)\r\n\t\tif (!pointer.touch) {\r\n\t\t\tconst target = <HTMLElement>$dom.eventTarget(<Event>pointer.lastEvent);\r\n\r\n\t\t\t$iter.each(this.overObjects.backwards().iterator(), (io) => {\r\n\t\t\t\t// Is this pointer relevant to element?\r\n\t\t\t\tif (io && io.overPointers.contains(pointer) && io.hoverable) {\r\n\t\t\t\t\t// Check if the element is still hovered\r\n\t\t\t\t\tlet reset = false;\r\n\t\t\t\t\tif (io.element && pointer.lastEvent) {\r\n\t\t\t\t\t\tif (!$dom.contains(io.element, target)) {\r\n\t\t\t\t\t\t\treset = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\treset = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (reset) {\r\n\t\t\t\t\t\tthis.handleOut(io, pointer, ev, true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\r\n\t\t// Process down elements\r\n\t\t$iter.each(this.transformedObjects.backwards().iterator(), (io) => {\r\n\t\t\t// Is this pointer relevant to element?\r\n\t\t\tif (io.downPointers.contains(pointer) &&\r\n\t\t\t\t// Swipe still happening?\r\n\t\t\t\t!(io.swipeable && this.swiping(io, pointer)) &&\r\n\t\t\t\t(io.draggable || io.resizable)) {\r\n\t\t\t\tthis.handleTransform(io, ev);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Process tracked elements\r\n\t\t$iter.each(this.trackedObjects.backwards().iterator(), (io) => {\r\n\t\t\t// Is this pointer relevant to element?\r\n\t\t\tif (!io.overPointers.contains(pointer)) {\r\n\t\t\t\tthis.handleTrack(io, pointer, ev);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Handles reporting of pointer movement.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io        Element\r\n\t * @param pointer    Pointer\r\n\t * @param ev         Original event\r\n\t * @param skipCheck  Sould we skip check if cursor actually moved\r\n\t */\r\n\tpublic handleTrack(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent, skipCheck = false): void {\r\n\r\n\t\t// Do nothing if the cursor did not actually move\r\n\t\tif (!skipCheck && !this.moved(pointer, 0)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Initiate TRACK event\r\n\t\tif (io.events.isEnabled(\"track\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"track\"] = {\r\n\t\t\t\ttype: \"track\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpoint: pointer.point,\r\n\t\t\t\tpointer: pointer,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"track\", imev);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles swipe action.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleSwipe(io: InteractionObject, pointer: IPointer, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// We pass in InteractionEvent with shift in mouse coordinates\r\n\t\t// between when the drag started and ended\r\n\t\tif (io.events.isEnabled(\"swipe\") && !system.isPaused) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"swipe\"] = {\r\n\t\t\t\ttype: \"swipe\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\ttouch: pointer.touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"swipe\", imev);\r\n\t\t}\r\n\r\n\t\tif (pointer.startPoint.x < pointer.point.x) {\r\n\t\t\tif (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"swiperight\"] = {\r\n\t\t\t\t\ttype: \"swiperight\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"swiperight\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (io.events.isEnabled(\"swipeleft\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"swipeleft\"] = {\r\n\t\t\t\t\ttype: \"swipeleft\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\ttouch: pointer.touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"swipeleft\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles event triggering for wheel rotation.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param deltaX   Horizontal shift\r\n\t * @param deltaY   Vertical shift\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic handleWheel(io: InteractionObject, pointer: IPointer, deltaX: number, deltaY: number, ev: WheelEvent): void {\r\n\t\tconst shift: IPoint = {\r\n\t\t\tx: deltaX,\r\n\t\t\ty: deltaY\r\n\t\t};\r\n\r\n\t\t// Trigger generic WHEEL event\r\n\t\tif (io.events.isEnabled(\"wheel\") && !system.isPaused) {\r\n\t\t\tio.events.dispatchImmediately(\"wheel\", {\r\n\t\t\t\ttype: \"wheel\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tpoint: pointer.point,\r\n\t\t\t\tshift: shift\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Trigger direction-specific events\r\n\r\n\t\t// Horizontal\r\n\t\tif (deltaX < 0) {\r\n\t\t\tif (io.events.isEnabled(\"wheelleft\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheelleft\", {\r\n\t\t\t\t\ttype: \"wheelleft\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t} else if (deltaX > 0) {\r\n\t\t\tif (io.events.isEnabled(\"swiperight\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheelright\", {\r\n\t\t\t\t\ttype: \"wheelright\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\t// Vertical\r\n\t\t} else if (deltaY < 0) {\r\n\t\t\tif (io.events.isEnabled(\"wheelup\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheelup\", {\r\n\t\t\t\t\ttype: \"wheelup\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t} else if (deltaY > 0) {\r\n\t\t\tif (io.events.isEnabled(\"wheeldown\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"wheeldown\", {\r\n\t\t\t\t\ttype: \"wheeldown\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tpoint: pointer.point,\r\n\t\t\t\t\tshift: shift\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Initiates inertia checking sub-routines for different movement types:\r\n\t * drag, resize.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param sprite\r\n\t * @param pointer\r\n\t */\r\n\tpublic handleInertia(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\tif (io.draggable && io.downPointers.length === 0) {\r\n\t\t\tthis.handleMoveInertia(io, pointer);\r\n\t\t}\r\n\r\n\t\tif (io.resizable && io.downPointers.length > 1) {\r\n\t\t\tthis.handleResizeInertia(io, pointer);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Continues moving the element to simulate the effect of inertia. Happens\r\n\t * when `inert` and `draggable` object is dragged and then released.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic handleMoveInertia(io: InteractionObject, pointer: IPointer): void {\r\n\t\tlet interaction = io;\r\n\t\tlet type: \"move\" = \"move\";\r\n\t\tlet point = {\r\n\t\t\t\"x\": pointer.point.x,\r\n\t\t\t\"y\": pointer.point.y\r\n\t\t};\r\n\t\tlet startPoint = {\r\n\t\t\t\"x\": pointer.startPoint.x,\r\n\t\t\t\"y\": pointer.startPoint.y\r\n\t\t};\r\n\r\n\t\t// Init inertia object\r\n\t\tlet inertia = new Inertia(interaction, type, point, startPoint);\r\n\r\n\t\t// Get inertia data\r\n\t\tlet ref = this.getTrailPoint(pointer, $time.getTime() - this.getInertiaOption(io, \"move\", \"time\"));\r\n\t\tif (typeof ref === \"undefined\") {\r\n\t\t\tthis.processDragStop(io, pointer, pointer.lastUpEvent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Init animation options\r\n\t\tlet factor = this.getInertiaOption(io, \"move\", \"factor\");\r\n\t\tlet animationOptions = [{\r\n\t\t\t\"to\": pointer.point.x + (pointer.point.x - ref.point.x) * factor,\r\n\t\t\t\"property\": \"x\"\r\n\t\t}, {\r\n\t\t\t\"to\": pointer.point.y + (pointer.point.y - ref.point.y) * factor,\r\n\t\t\t\"property\": \"y\"\r\n\t\t}];\r\n\r\n\t\t// Start animation\r\n\t\tlet animation: Animation = new Animation(\r\n\t\t\tinertia,\r\n\t\t\tanimationOptions,\r\n\t\t\tthis.getInertiaOption(io, \"move\", \"duration\"),\r\n\t\t\tthis.getInertiaOption(io, \"move\", \"easing\")\r\n\t\t).start();\r\n\t\tthis._disposers.push(animation.events.on(\"animationended\", (ev) => {\r\n\t\t\tinertia.done();\r\n\t\t}));\r\n\r\n\t\t// Add inertia object\r\n\t\tio.inertias.setKey(\"move\", inertia);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Continues resizing of a `resizable` element after it is resized and\r\n\t * released.\r\n\t *\r\n\t * **NOTE:** this is is just a placeholder function. No actual fucntionality\r\n\t * is implemented, yet.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic handleResizeInertia(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\t// Some day, folks. Some day...\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Recalculates element's position and size based on position of\r\n\t * all its related pointers.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io  Element\r\n\t * @param ev  Original event\r\n\t */\r\n\tpublic handleTransform(io: InteractionObject, ev: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Get primary pointer and its respective points\r\n\t\tlet pointer1: $type.Optional<IPointer> = io.downPointers.getIndex(0);\r\n\t\tlet point1: IPoint = null;\r\n\t\tlet startPoint1: IPoint = null;\r\n\r\n\t\tif (pointer1) {\r\n\t\t\tpoint1 = pointer1.point;\r\n\t\t\tstartPoint1 = pointer1.startPoint;\r\n\t\t}\r\n\r\n\t\t// Init secondary pointer\r\n\t\tlet pointer2: $type.Optional<IPointer>;\r\n\t\tlet point2: IPoint;\r\n\t\tlet startPoint2: IPoint;\r\n\r\n\t\t// Use center of the sprite to simulate \"second\" point of touch\r\n\t\tpoint2 = {\r\n\t\t\t\"x\": io.originalPosition.x,\r\n\t\t\t\"y\": io.originalPosition.y\r\n\t\t};\r\n\t\tstartPoint2 = point2;\r\n\r\n\t\t// Determine if it's a sinngle pointer or multi\r\n\t\tlet singlePoint: boolean = true;\r\n\t\tfor (let i = 1; i < io.downPointers.length; i++) {\r\n\r\n\t\t\t// Get pointer\r\n\t\t\tlet nextPointer = io.downPointers.getIndex(i);\r\n\r\n\t\t\t// Doublecheck if it's not the same pointer by comparing original position\r\n\t\t\tif (startPoint1.x != nextPointer.startPoint.x && startPoint1.y != nextPointer.startPoint.y) {\r\n\r\n\t\t\t\t// Several pointers down\r\n\t\t\t\tsinglePoint = false;\r\n\r\n\t\t\t\t// Get second pointer\r\n\t\t\t\tpointer2 = nextPointer;\r\n\t\t\t\tpoint2 = pointer2.point;\r\n\t\t\t\tstartPoint2 = pointer2.startPoint;\r\n\r\n\t\t\t\t// Stop looking\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Primary touch point moved?\r\n\t\tlet pointer1Moved = pointer1 && this.moved(pointer1, 0);\r\n\r\n\t\t// Report DRAG_START if necessary\r\n\t\tif (io.draggable && pointer1 && pointer1.dragStartEvents && pointer1.dragStartEvents.length && pointer1Moved) {\r\n\t\t\tif (io.events.isEnabled(\"dragstart\") && !system.isPaused) {\r\n\t\t\t\tio.events.dispatchImmediately(\"dragstart\", pointer1.dragStartEvents.shift());\r\n\t\t\t}\r\n\t\t\t//delete pointer1.dragStartEvents;\r\n\t\t}\r\n\r\n\t\t// Determine what we do in order of superiority\r\n\t\tif (singlePoint && io.draggable) {\r\n\r\n\t\t\t// We have only one pointer and the Sprite is draggable\r\n\t\t\t// There's nothing else to be done - just move it\r\n\t\t\tthis.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\r\n\r\n\t\t\tif (this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\"))) {\r\n\t\t\t\tthis.cancelAllHovers(ev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\t// Check if second touch point moved\r\n\t\t\tlet pointer2Moved = pointer2 && this.moved(pointer2, 0);\r\n\r\n\t\t\tif (\r\n\t\t\t\t(this.shouldCancelHovers(pointer1) && this.moved(pointer1, this.getHitOption(io, \"hitTolerance\")))\r\n\t\t\t\t||\r\n\t\t\t\t(this.shouldCancelHovers(pointer2) && this.moved(pointer2, this.getHitOption(io, \"hitTolerance\")))\r\n\t\t\t) {\r\n\t\t\t\tthis.cancelAllHovers(ev);\r\n\t\t\t}\r\n\r\n\t\t\tif (io.draggable && io.resizable) {\r\n\t\t\t\t//this.handleTransformAll(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved);\r\n\t\t\t\tthis.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n\t\t\t\tthis.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n\t\t\t}\r\n\t\t\telse {\r\n\r\n\t\t\t\tif (io.draggable) {\r\n\t\t\t\t\tthis.handleTransformMove(io, point1, startPoint1, ev, pointer1Moved, pointer1.touch);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (io.resizable && (!singlePoint || ev.ctrlKey)) {\r\n\t\t\t\t\tthis.handleTransformResize(io, point1, startPoint1, point2, startPoint2, ev, pointer1Moved && pointer2Moved, pointer1.touch);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles movement of the dragged element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io            Element\r\n\t * @param point         Current point of the pointer\r\n\t * @param startPoint    Starting point of the pointer\r\n\t * @param ev            Original event\r\n\t * @param pointerMoved  Did pointer move?\r\n\t */\r\n\tpublic handleTransformMove(io: InteractionObject, point: IPoint, startPoint: IPoint, ev: MouseEvent | TouchEvent | KeyboardEvent, pointerMoved: boolean, touch: boolean): void {\r\n\r\n\t\tif (pointerMoved) {\r\n\t\t\tif (io.events.isEnabled(\"drag\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"drag\"] = {\r\n\t\t\t\t\ttype: \"drag\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\tevent: ev,\r\n\t\t\t\t\tshift: {\r\n\t\t\t\t\t\t\"x\": point.x - startPoint.x,\r\n\t\t\t\t\t\t\"y\": point.y - startPoint.y\r\n\t\t\t\t\t},\r\n\t\t\t\t\tstartPoint: startPoint,\r\n\t\t\t\t\tpoint: point,\r\n\t\t\t\t\ttouch: touch\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"drag\", imev);\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles resizing of the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io            Element\r\n\t * @param point1        Current position of reference point #1\r\n\t * @param startPoint1   Original position of reference point #1\r\n\t * @param point2        Current position of reference point #2\r\n\t * @param startPoint2   Original position of reference point #2\r\n\t * @param ev            Original event\r\n\t * @param pointerMoved  Did pointer move?\r\n\t */\r\n\tpublic handleTransformResize(io: InteractionObject, point1: IPoint, startPoint1: IPoint, point2: IPoint, startPoint2: IPoint, ev: MouseEvent | TouchEvent, pointerMoved: boolean, touch: boolean): void {\r\n\t\tif (io.events.isEnabled(\"resize\") && !system.isPaused && (!io.isTouchProtected || !touch)) {\r\n\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"resize\"] = {\r\n\t\t\t\ttype: \"resize\",\r\n\t\t\t\ttarget: io,\r\n\t\t\t\tevent: ev,\r\n\t\t\t\tscale: $math.getScale(point1, startPoint1, point2, startPoint2),\r\n\t\t\t\tstartPoint1: startPoint1,\r\n\t\t\t\tpoint1: point1,\r\n\t\t\t\tstartPoint2: startPoint2,\r\n\t\t\t\tpoint2: point2,\r\n\t\t\t\ttouch: touch\r\n\t\t\t};\r\n\t\t\tio.events.dispatchImmediately(\"resize\", imev);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Handles all the preparations of the element when it starts to be dragged.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processDragStart(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Add to draggedObjects\r\n\t\tthis.transformedObjects.moveValue(io);\r\n\r\n\t\tif (this.shouldCancelHovers(pointer)) {\r\n\t\t\tthis.cancelAllHovers(ev);\r\n\t\t}\r\n\r\n\t\t// Report \"dragstart\"\r\n\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"dragstart\"] = {\r\n\t\t\ttype: \"dragstart\",\r\n\t\t\ttarget: io,\r\n\t\t\tevent: ev,\r\n\t\t\ttouch: pointer ? pointer.touch : false\r\n\t\t};\r\n\r\n\t\t// Log object that we are starting to drag, so we can check against and\r\n\t\t// avoid hovers on other objects that might be in the path of movement.\r\n\t\tif (pointer) {\r\n\t\t\tpointer.dragTarget = io;\r\n\t\t\t//pointer.startPoint = pointer.point;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * If pointer is set we will not fire the event until the pointer has\r\n\t\t * actually moved. If it's not set we don't have to wait for anything, so we\r\n\t\t * just fire off the event right away.\r\n\t\t */\r\n\t\tif (pointer && pointer.dragStartEvents) {\r\n\t\t\tpointer.dragStartEvents.push(imev);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (!system.isPaused) {\r\n\t\t\t\tio.dispatchImmediately(\"dragstart\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Finishes up element drag operation.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processDragStop(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Pointer set?\r\n\t\tif (!pointer) {\r\n\t\t\tpointer = this.getDragPointer(io);\r\n\t\t}\r\n\r\n\t\t// Unset drag object\r\n\t\tif (pointer) {\r\n\t\t\tpointer.dragTarget = undefined;\r\n\t\t}\r\n\r\n\t\t// Removed from transformedObjects\r\n\t\tthis.transformedObjects.removeValue(io);\r\n\r\n\t\t// Unlock document\r\n\t\t//this.unlockDocument();\r\n\r\n\t\t// Report dragstop\r\n\t\tif (!pointer || this.moved(pointer, 0)) {\r\n\t\t\tif (io.events.isEnabled(\"dragstop\") && !system.isPaused) {\r\n\t\t\t\tlet imev: AMEvent<InteractionObject, IInteractionObjectEvents>[\"dragstop\"] = {\r\n\t\t\t\t\ttype: \"dragstop\",\r\n\t\t\t\t\ttarget: io,\r\n\t\t\t\t\ttouch: pointer ? pointer.touch : false\r\n\t\t\t\t};\r\n\t\t\t\tio.events.dispatchImmediately(\"dragstop\", imev);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Handles all the preparations of the element when it starts to be resized.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processResizeStart(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Add to draggedObjects\r\n\t\tthis.transformedObjects.moveValue(io);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Finishes up element drag operation.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @param ev       Original event\r\n\t */\r\n\tpublic processResizeStop(io: InteractionObject, pointer?: IPointer, ev?: MouseEvent | TouchEvent): void {\r\n\r\n\t\t// Removed from transformedObjects\r\n\t\tthis.transformedObjects.removeValue(io);\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Controls for InteractionObjects initiating directly\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Manually triggers drag start on the element. Could be useful in cases\r\n\t * where tracking or dragging one element can also influence dragging another\r\n\t * element.\r\n\t *\r\n\t * Passing in `pointer` reference is advisable. If not passed in it will try\r\n\t * to determine which pointer to attach to. However, it's better to specify\r\n\t * it explicitly.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic dragStart(io: InteractionObject, pointer?: IPointer): void {\r\n\t\tif (!pointer) {\r\n\t\t\tpointer = this.getDragPointer(io);\r\n\t\t}\r\n\r\n\t\tif (pointer) {\r\n\t\t\tthis.handleDown(io, pointer, pointer.lastDownEvent);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Manually ends drag on the element.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic dragStop(io: InteractionObject, pointer?: IPointer, cancelled?: boolean): void {\r\n\t\tif (!pointer) {\r\n\t\t\tpointer = this.getDragPointer(io);\r\n\t\t}\r\n\r\n\t\tif (pointer && !cancelled) {\r\n\t\t\tthis.handleGlobalUp(pointer, pointer.lastUpEvent, cancelled);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * This method uses a fuzzy logic to find the pointer to be used for dragging.\r\n\t * Beware that this is not a rock-solid solution. If there are a few objects\r\n\t * being dragged at the same time, you may get unexepected results.\r\n\t *\r\n\t * @param io  InteractionObject to get pointers from\r\n\t * @return Pointer currently being used for dragging\r\n\t */\r\n\tpublic getDragPointer(io?: InteractionObject): $type.Optional<IPointer> {\r\n\t\tif (io) {\r\n\t\t\t// InteractionObject is supplied\r\n\t\t\t// Use it's first down pointer\r\n\t\t\treturn io.downPointers.getIndex(0);\r\n\t\t}\r\n\t\telse if (this.transformedObjects.length) {\r\n\t\t\t// Use first dragged object\r\n\t\t\treturn this.getDragPointer(this.transformedObjects.getIndex(0));\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * ==========================================================================\r\n\t * Utils\r\n\t * ==========================================================================\r\n\t * @hidden\r\n\t */\r\n\r\n\t/**\r\n\t * Returns pointer id for the given event object.\r\n\t *\r\n\t * @param ev  Event\r\n\t * @return Pointer ID\r\n\t */\r\n\tprotected getPointerId(ev: any): string {\r\n\t\tlet id = \"\";\r\n\t\tif ($type.hasValue(ev.identifier)) {\r\n\t\t\tid = \"\" + <string>ev.identifier;\r\n\t\t} else if ($type.hasValue(ev.pointerId)) {\r\n\t\t\tid = \"\" + <string>ev.pointerId;\r\n\t\t} else {\r\n\t\t\tid = \"m\";\r\n\t\t}\r\n\t\treturn id.replace(\"-\", \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a cursor position of the event.\r\n\t *\r\n\t * @param ev  Original event\r\n\t * @return Event point\r\n\t */\r\n\tprotected getPointerPoint(ev: MouseEvent | Touch): IPoint {\r\n\t\treturn {\r\n\t\t\t\"x\": ev.clientX,\r\n\t\t\t\"y\": ev.clientY\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Returns [[Pointer]] object that is associated with the Event.\r\n\t *\r\n\t * If no such [[Pointer]] object exists, it is created.\r\n\t *\r\n\t * @param ev  Event\r\n\t * @return Pointer\r\n\t */\r\n\tprotected getPointer(ev: MouseEvent | Touch): IPointer {\r\n\r\n\t\t// Get pointer id\r\n\t\tlet id = this.getPointerId(ev);\r\n\r\n\t\t// Get current coordinates\r\n\t\tlet point = this.getPointerPoint(ev);\r\n\r\n\t\t// Look for the pointer in the Dictionary if it maybe already exists\r\n\t\tlet pointer: IPointer;\r\n\t\tif (this.pointers.hasKey(id)) {\r\n\r\n\t\t\t// We already have such pointer\r\n\t\t\tpointer = this.pointers.getKey(id)!;\r\n\r\n\t\t\t// We need this, because Edge reuses pointer ids across touch and mouse\r\n\t\t\tpointer.touch = this.isPointerTouch(ev);\r\n\r\n\t\t\t// Reset pointer\r\n\t\t\t//pointer.point = point;\r\n\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Init pointer\r\n\t\t\tpointer = {\r\n\t\t\t\t\"id\": id,\r\n\t\t\t\t//\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"pointer\"),\r\n\t\t\t\t//\"touch\": !(ev instanceof MouseEvent) || ((<any>ev).pointerType && (<any>ev).pointerType != \"mouse\"),\r\n\t\t\t\t\"touch\": this.isPointerTouch(ev),\r\n\t\t\t\t\"startPoint\": point,\r\n\t\t\t\t\"startTime\": $time.getTime(),\r\n\t\t\t\t\"point\": point,\r\n\t\t\t\t\"track\": [],\r\n\t\t\t\t\"swipeCanceled\": false,\r\n\t\t\t\t\"dragStartEvents\": []\r\n\t\t\t};\r\n\r\n\t\t\t// Add first breadcrumb\r\n\t\t\tthis.addBreadCrumb(pointer, point);\r\n\r\n\t\t\t// Add for re-use later\r\n\t\t\tthis.pointers.setKey(id, pointer);\r\n\t\t}\r\n\r\n\t\t// Log last event\r\n\t\tpointer.lastEvent = ev;\r\n\r\n\t\tthis.lastPointer = pointer;\r\n\r\n\t\treturn pointer;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines if pointer event originated from a touch pointer or mouse.\r\n\t *\r\n\t * @param ev  Original event\r\n\t * @return Touch pointer?\r\n\t */\r\n\tprotected isPointerTouch(ev: MouseEvent | Touch): boolean {\r\n\t\tif (typeof Touch !== \"undefined\" && ev instanceof Touch) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse if (typeof PointerEvent !== \"undefined\" && ev instanceof PointerEvent && $type.hasValue((<any>ev).pointerType)) {\r\n\t\t\tswitch ((<any>ev).pointerType) {\r\n\t\t\t\tcase \"touch\":\r\n\t\t\t\tcase \"pen\":\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\treturn true;\r\n\t\t\t\tcase \"mouse\":\r\n\t\t\t\tcase 4:\r\n\t\t\t\t\treturn false;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\treturn !(ev instanceof MouseEvent);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ($type.hasValue((<any>ev).type)) {\r\n\t\t\tif ((<any>ev).type.match(/^mouse/)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Resets the poiner to original state, i.e. cleans movement information,\r\n\t * starting point, etc.\r\n\t *\r\n\t * @param pointer Pointer\r\n\t */\r\n\tprotected resetPointer(pointer: IPointer, ev: MouseEvent | PointerEvent | Touch): void {\r\n\t\t// Get current coordinates\r\n\t\tlet point = this.getPointerPoint(ev);;\r\n\t\tpointer.startTime = $time.getTime();\r\n\t\tpointer.startPoint = { x: point.x, y: point.y };\r\n\t\tpointer.point = { x: point.x, y: point.y };\r\n\t\tpointer.track = [];\r\n\t\tpointer.swipeCanceled = false;\r\n\t\t//clearTimeout(pointer.swipeTimeout);\r\n\t\t//clearTimeout(pointer.holdTimeout);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a \"breadcrumb\" point to the [[Pointer]] to log its movement path.\r\n\t *\r\n\t * @param pointer  Pointer\r\n\t * @param point    Point coordinates\r\n\t */\r\n\tprotected addBreadCrumb(pointer: IPointer, point: IPoint): void {\r\n\t\tpointer.track.push({\r\n\t\t\t\"timestamp\": $time.getTime(),\r\n\t\t\t\"point\": point\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Prepares the document for various touch-related operations.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic lockDocument(): void {\r\n\t\tthis.prepElement(this.body);\r\n\t}\r\n\r\n\t/**\r\n\t * Restores document functionality.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic unlockDocument(): void {\r\n\t\tif (this.transformedObjects.length == 0) {\r\n\t\t\tthis.restoreAllStyles(this.body);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Lock element (disable all touch)\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic lockElement(io: InteractionObject): void {\r\n\t\tthis.prepElement(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Restores element's functionality.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic unlockElement(io: InteractionObject): void {\r\n\t\tthis.restoreAllStyles(io);\r\n\t}\r\n\r\n\t/**\r\n\t * Locks document's wheel scroll.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic lockWheel(): void {\r\n\t\twindow.addEventListener(\r\n\t\t\tthis._pointerEvents.wheel,\r\n\t\t\tthis.wheelLockEvent,\r\n\t\t\tthis._passiveSupported ? { passive: false } : false\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Unlocks document's wheel scroll.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t */\r\n\tpublic unlockWheel(): void {\r\n\t\twindow.removeEventListener(\r\n\t\t\tthis._pointerEvents.wheel,\r\n\t\t\tthis.wheelLockEvent\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if top element at pointer's position belongs to the SVG.\r\n\t *\r\n\t * @ignore Exlude from docs\r\n\t * @param pointer  Pointer\r\n\t * @param svg      The <svg> element\r\n\t * @param id       A unique identifier of the object that is checking for locality\r\n\t * @return Belongs to SVG\r\n\t */\r\n\tpublic isLocalElement(pointer: IPointer, svg: SVGSVGElement, id: string): boolean {\r\n\t\tconst cached = this.getCache(\"local_pointer_\" + pointer.id);\r\n\t\tif ($type.hasValue(cached)) {\r\n\t\t\treturn cached;\r\n\t\t}\r\n\t\tconst doc = ($dom.getRoot(svg) || document);\r\n\t\tif (doc.elementFromPoint) {\r\n\t\t\tconst target = doc.elementFromPoint(pointer.point.x, pointer.point.y);\r\n\t\t\tconst local = target && $dom.contains(svg, <HTMLElement>target);\r\n\t\t\tthis.setCache(\"local_pointer_\" + pointer.id + \"_\" + id, local, 100);\r\n\t\t\treturn local;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * A function that cancels mouse wheel scroll.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param ev  Event object\r\n\t * @return Returns `false` to cancel\r\n\t */\r\n\tprotected wheelLockEvent(ev: Event): boolean {\r\n\t\tev.preventDefault();\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a set of styles to an element. Stores the original styles so they\r\n\t * can be restored later.\r\n\t *\r\n\t * @ignore\r\n\t * @param io      Element\r\n\t */\r\n\tpublic prepElement(io: InteractionObject): void {\r\n\r\n\t\tlet el = io.element;\r\n\r\n\t\tif (el) {\r\n\r\n\t\t\t// Define possible props\r\n\t\t\tlet props = [\r\n\t\t\t\t\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\",\r\n\t\t\t\t\"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\",\r\n\t\t\t\t\"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\",\r\n\t\t\t\t\"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\",\r\n\t\t\t\t\"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\",\r\n\t\t\t\t\"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"\r\n\t\t\t];\r\n\t\t\tfor (let i = 0; i < props.length; i++) {\r\n\t\t\t\tif (props[i] in el.style) {\r\n\t\t\t\t\tthis.setTemporaryStyle(io, props[i], \"none\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove iOS-specific selection;\r\n\t\t\tthis.setTemporaryStyle(io, \"tapHighlightColor\", \"rgba(0, 0, 0, 0)\");\r\n\t\t\t//this.setTemporaryStyle(io, \"webkitOverflowScrolling\", \"none\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Restores replaced styles\r\n\t *\r\n\t * @ignore\r\n\t * @param  io  Element\r\n\t */\r\n\tpublic unprepElement(io: InteractionObject): void {\r\n\r\n\t\tlet el = io.element;\r\n\r\n\t\tif (el) {\r\n\r\n\t\t\t// Define possible props\r\n\t\t\tlet props = [\r\n\t\t\t\t\"touchAction\", \"webkitTouchAction\", \"MozTouchAction\", \"MSTouchAction\", \"msTouchAction\", \"oTouchAction\",\r\n\t\t\t\t\"userSelect\", \"webkitUserSelect\", \"MozUserSelect\", \"MSUserSelect\", \"msUserSelect\", \"oUserSelect\",\r\n\t\t\t\t\"touchSelect\", \"webkitTouchSelect\", \"MozTouchSelect\", \"MSTouchSelect\", \"msTouchSelect\", \"oTouchSelect\",\r\n\t\t\t\t\"touchCallout\", \"webkitTouchCallout\", \"MozTouchCallout\", \"MSTouchCallout\", \"msTouchCallout\", \"oTouchCallout\",\r\n\t\t\t\t\"contentZooming\", \"webkitContentZooming\", \"MozContentZooming\", \"MSContentZooming\", \"msContentZooming\", \"oContentZooming\",\r\n\t\t\t\t\"userDrag\", \"webkitUserDrag\", \"MozUserDrag\", \"MSUserDrag\", \"msUserDrag\", \"oUserDrag\"\r\n\t\t\t];\r\n\t\t\tfor (let i = 0; i < props.length; i++) {\r\n\t\t\t\tif (props[i] in el.style) {\r\n\t\t\t\t\tthis.restoreStyle(io, props[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Remove iOS-specific selection;\r\n\t\t\tthis.restoreStyle(io, \"tapHighlightColor\");\r\n\t\t\t//this.restoreStyle(io, \"webkitOverflowScrolling\");\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with hit events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getHitOption(io: InteractionObject, option: keyof IHitOptions): any {\r\n\t\tlet res = io.hitOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.hitOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with hover events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getHoverOption(io: InteractionObject, option: keyof IHoverOptions): any {\r\n\t\tlet res = io.hoverOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.hoverOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with swipe events.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getSwipeOption(io: InteractionObject, option: keyof ISwipeOptions): any {\r\n\t\tlet res = io.swipeOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.swipeOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option for keyboard.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getKeyboardOption(io: InteractionObject, option: keyof IKeyboardOptions): any {\r\n\t\tlet res = io.keyboardOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.keyboardOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option for mouse.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getMouseOption(io: InteractionObject, option: keyof IMouseOptions): any {\r\n\t\tlet res = io.mouseOptions[option];\r\n\t\tif (typeof res === \"undefined\") {\r\n\t\t\tres = this.mouseOptions[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an option associated with inertia.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io      Element\r\n\t * @param type    Inertia type\r\n\t * @param option  Option key\r\n\t * @return Option value\r\n\t */\r\n\tpublic getInertiaOption(io: InteractionObject, type: InertiaTypes, option: keyof IInertiaOptions): any {\r\n\t\tlet options: any = io.inertiaOptions.getKey(type);\r\n\t\tlet res: IInertiaOptions;\r\n\t\tif (options && $type.hasValue(options[option])) {\r\n\t\t\tres = options[option];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tres = (<any>this.inertiaOptions.getKey(type))[option];\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops currently going on inertia. Useful if inertia is currently being\r\n\t * animated and the object is being interacted with.\r\n\t *\r\n\t * @param io Element\r\n\t */\r\n\tprotected stopInertia(io: InteractionObject): void {\r\n\t\tlet x: InertiaTypes;\r\n\t\tlet inertias: Array<InertiaTypes> = [\"move\", \"resize\"];\r\n\t\tfor (let i = 0; i < inertias.length; i++) {\r\n\t\t\tx = inertias[i];\r\n\t\t\tif (io.inertias.hasKey(x)) {\r\n\t\t\t\tlet inertia: $type.Optional<Inertia> = io.inertias.getKey(x);\r\n\t\t\t\tif (inertia) {\r\n\t\t\t\t\tinertia.dispose();\r\n\t\t\t\t\t//io.inertiaAnimations.removeKey(x);\r\n\t\t\t\t\t//this.processDragStop(io);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Check if swiping is currently being performed on an object.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer to check\r\n\t * @return `true` if swiping\r\n\t */\r\n\tpublic swiping(io: InteractionObject, pointer: IPointer): boolean {\r\n\t\tlet now = $time.getTime();\r\n\r\n\t\tif (pointer.swipeCanceled || !io.swipeable) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (\r\n\t\t\t(Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\")) &&\r\n\t\t\t(pointer.startTime > (now - this.getSwipeOption(io, \"time\")))\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns `true` if a successfull swipe action was performed on an element.\r\n\t *\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t * @return Swiped?\r\n\t */\r\n\tpublic swiped(io: InteractionObject, pointer: IPointer): boolean {\r\n\t\tlet now = $time.getTime();\r\n\t\tif (pointer.swipeCanceled) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse if (\r\n\t\t\t(Math.abs(pointer.startPoint.x - pointer.point.x) > this.getSwipeOption(io, \"horizontalThreshold\")) &&\r\n\t\t\t(Math.abs(pointer.startPoint.y - pointer.point.y) < this.getSwipeOption(io, \"verticalThreshold\")) &&\r\n\t\t\t(pointer.startTime > (now - this.getSwipeOption(io, \"time\")))\r\n\t\t) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Applies style to mouse cursor based on its stage in relation to\r\n\t * [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param Element\r\n\t */\r\n\tpublic applyCursorOverStyle(io: InteractionObject): void {\r\n\r\n\t\t// Get sprite's cursor ooptions\r\n\t\tlet options = io.cursorOptions;\r\n\r\n\t\tif (!$type.hasValue(options.overStyle)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Apply cursor down styles\r\n\t\tfor (let i = 0; i < options.overStyle.length; i++) {\r\n\t\t\t$dom.setStyle(io.element, options.overStyle[i].property, options.overStyle[i].value);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Applies style to mouse cursor based on its stage in relation to\r\n\t * [[InteractionObject]].\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic applyCursorDownStyle(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\t// Not applicable for touch pointers since they don't display a cursor\r\n\t\tif (pointer && pointer.touch) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst downStyle = io.cursorOptions.downStyle;\r\n\t\t// Is down?\r\n\t\tif (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\r\n\t\t\t// Apply cursor down styles\r\n\t\t\tfor (let i = 0; i < downStyle.length; i++) {\r\n\t\t\t\tthis.setTemporaryStyle(this.body, downStyle[i].property, downStyle[i].value);\r\n\t\t\t\tthis.setTemporaryStyle(io, downStyle[i].property, downStyle[i].value);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restores original cursor style for the element.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param io       Element\r\n\t * @param pointer  Pointer\r\n\t */\r\n\tpublic restoreCursorDownStyle(io: InteractionObject, pointer: IPointer): void {\r\n\r\n\t\t// Not applicable for touch pointers since they don't display a cursor\r\n\t\tif (pointer && pointer.touch) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tconst downStyle = io.cursorOptions.downStyle;\r\n\r\n\t\t// Is down?\r\n\t\tif (io.downPointers.contains(pointer) && $type.hasValue(downStyle)) {\r\n\t\t\t// Apply cursor down styles\r\n\t\t\tfor (let i = 0; i < downStyle.length; i++) {\r\n\t\t\t\tthis.restoreStyle(this.body, downStyle[i].property);\r\n\t\t\t\tthis.restoreStyle(io, downStyle[i].property);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets style on the body of the document.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Style definitions\r\n\t */\r\n\tpublic setGlobalStyle(style: Array<IStyleProperty> | IStyleProperty): void {\r\n\t\tlet body = getInteraction().body;\r\n\t\tlet styles = <Array<IStyleProperty>>($type.isArray(style) ? style : [style]);\r\n\t\tfor (let i = 0; i < styles.length; i++) {\r\n\t\t\tthis.setTemporaryStyle(body, styles[i].property, styles[i].value);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restores style on the body of the document.\r\n\t *\r\n\t * @ignore Exclude from docs\r\n\t * @param style  Style definitions\r\n\t */\r\n\tpublic restoreGlobalStyle(style: Array<IStyleProperty> | IStyleProperty): void {\r\n\t\tlet body = getInteraction().body;\r\n\t\tlet styles = <Array<IStyleProperty>>($type.isArray(style) ? style : [style]);\r\n\t\tfor (let i = 0; i < styles.length; i++) {\r\n\t\t\tthis.restoreStyle(body, styles[i].property);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if element is a non-cahrt element.\r\n\t *\r\n\t * @param io  InteractionObject\r\n\t * @return Global element?\r\n\t */\r\n\tprotected isGlobalElement(io: InteractionObject): boolean {\r\n\t\treturn document.body === io.element;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if pointer has moved since it was created.\r\n\t *\r\n\t * @param pointer    Pointer\r\n\t * @param tolerance  Tolerance in pixels\r\n\t * @param minTime    Minimum time required for the pointer to be down to be considered moved\r\n\t * @return `true` if the pointer has moved\r\n\t */\r\n\tpublic moved(pointer: IPointer, tolerance: number, minTime: number = 300): boolean {\r\n\r\n\t\t/*// If there was more time, we don't care if cursor actually moved\r\n\t\tlet duration = $time.getTime() - pointer.startTime;\r\n\t\tif ($type.hasValue(minTime) && (minTime > duration)) {\r\n\t\t\treturn false;\r\n\t\t}*/\r\n\r\n\t\t// That was quick measure shift\r\n\t\tlet shift = this.getShift(pointer);\r\n\r\n\t\treturn (Math.abs(shift.x) > tolerance) || (Math.abs(shift.y) > tolerance);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns if pointer is \"old\", meaning it has been pressing for more than\r\n\t * X milliseconds.\r\n\t *\r\n\t * @ignore\r\n\t * @param pointer  Pointer\r\n\t * @param minTime  Minimum time to consider pointer old\r\n\t * @return {boolean}\r\n\t */\r\n\tpublic old(pointer: IPointer, minTime: number = 300): boolean {\r\n\t\treturn $time.getTime() - pointer.startTime > minTime;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns total a shift in pointers coordinates between its original\r\n\t * position and now.\r\n\t *\r\n\t * @param pointer  Pointer\r\n\t * @return Shift in coordinates (x/y)\r\n\t */\r\n\tpublic getShift(pointer: IPointer): IPoint {\r\n\t\treturn {\r\n\t\t\t\"x\": pointer.startPoint.x - pointer.point.x,\r\n\t\t\t\"y\": pointer.startPoint.y - pointer.point.y\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a point from [[Pointer]]'s move history at a certain timetamp.\r\n\t *\r\n\t * @param pointer    Pointer\r\n\t * @param timestamp  Timestamp\r\n\t * @return Point\r\n\t */\r\n\tpublic getTrailPoint(pointer: IPointer, timestamp: number): $type.Optional<IBreadcrumb> {\r\n\t\tlet res: $type.Optional<IBreadcrumb>;\r\n\t\tfor (let i = 0; i < pointer.track.length; i++) {\r\n\t\t\tif (pointer.track[i].timestamp >= timestamp) {\r\n\t\t\t\tres = pointer.track[i];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if same pointer already exists in the list.\r\n\t *\r\n\t * @param list     List to check agains\r\n\t * @param pointer  Pointer\r\n\t * @return Exists?\r\n\t */\r\n\tprotected pointerExists(list: List<IPointer>, pointer: IPointer): boolean {\r\n\t\tlet exists = false;\r\n\t\tlist.each((item) => {\r\n\t\t\tif (item == pointer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\texists = item.point.x == pointer.point.x && item.point.y == pointer.point.y;\r\n\t\t});\r\n\t\treturn exists;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an [[InteractionObject]] representation of a DOM element.\r\n\t *\r\n\t * You can use this on any HTML or SVG element, to add interactive features\r\n\t * to it.\r\n\t *\r\n\t * @param element  Element\r\n\t * @return InteractionObject\r\n\t */\r\n\tpublic getInteraction(element: HTMLElement | SVGSVGElement): InteractionObject {\r\n\t\treturn new InteractionObject(element);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets a style property on an element. Stores original value to be restored\r\n\t * later with [[restoreStyle]].\r\n\t *\r\n\t * @see {@link restoreStyle}\r\n\t * @param io        Element\r\n\t * @param property  Property\r\n\t * @param value     Value\r\n\t */\r\n\tpublic setTemporaryStyle(io: InteractionObject, property: string, value: string): void {\r\n\r\n\t\t// Get element\r\n\t\t//let el = io.element.tagName == \"g\" ? <SVGSVGElement>io.element.parentNode : io.element;\r\n\t\tlet el = io.element;\r\n\r\n\t\t// Save original property if it is set and hasn't been saved before already\r\n\t\tif ($type.hasValue((<any>el.style)[property]) && !io.replacedStyles.hasKey(property)) {\r\n\t\t\tio.replacedStyles.setKey(property, (<any>el.style)[property]);\r\n\t\t}\r\n\r\n\t\t// Replace with the new one\r\n\t\t$dom.setStyle(el, property, value);\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Restores specific style on an element.\r\n\t *\r\n\t * @param io        Element\r\n\t * @param property  Style property\r\n\t */\r\n\tpublic restoreStyle(io: InteractionObject, property: string): void {\r\n\r\n\t\t// Reset style\r\n\t\tif (io.replacedStyles.hasKey(property)) {\r\n\t\t\t(<any>io.element.style)[property] = io.replacedStyles.getKey(property);\r\n\t\t\tio.replacedStyles.removeKey(property);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdelete (<any>io.element.style)[property];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Restore temporarily reset styles on an element.\r\n\t *\r\n\t * @param io Element\r\n\t */\r\n\tpublic restoreAllStyles(io: InteractionObject): void {\r\n\t\t$iter.each(io.replacedStyles.iterator(), (a) => {\r\n\t\t\tconst key = a[0];\r\n\t\t\tconst value = a[1];\r\n\t\t\t(<any>io.element.style)[key] = value;\r\n\t\t\tio.replacedStyles.removeKey(key);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Disposes this object and cleans up after itself.\r\n\t */\r\n\tpublic dispose(): void {\r\n\t\tif (!this.isDisposed()) {\r\n\t\t\tsuper.dispose();\r\n\t\t\tthis.restoreAllStyles(this.body);\r\n\t\t\tthis.unlockWheel();\r\n\t\t}\r\n\t}\r\n\r\n\t// @ts-ignore Used for debugging\r\n\tprivate log(text: string, ev: MouseEvent | TouchEvent | PointerEvent, io?: InteractionObject): void {\r\n\t\tlet show = true;\r\n\t\tif (show) {\r\n\t\t\t// Touchlist?\r\n\t\t\tif ((<any>ev).changedTouches) {\r\n\t\t\t\tfor (let i = 0; i < (<any>ev).changedTouches.length; i++) {\r\n\t\t\t\t\tthis.logTouch(text, ev.type, (<any>ev).changedTouches[i])\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Get type\r\n\t\t\tlet type = \"\";\r\n\t\t\tif ((<any>ev).pointerType) {\r\n\t\t\t\tswitch ((<any>ev).pointerType) {\r\n\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\ttype = \"touch\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\ttype = \"mouse\";\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\ttype = (<any>ev).pointerType;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if (typeof TouchEvent != \"undefined\" && ev instanceof TouchEvent) {\r\n\t\t\t\ttype = \"touch\";\r\n\t\t\t}\r\n\t\t\telse if (ev.type.match(/^mouse/)) {\r\n\t\t\t\ttype = \"mouse\";\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ttype = \"???\";\r\n\t\t\t}\r\n\r\n\t\t\t// Get ID\r\n\t\t\tlet id = \"\";\r\n\t\t\tif ($type.hasValue((<any>ev).identifier)) {\r\n\t\t\t\tid = <string>(<any>ev).identifier;\r\n\t\t\t} else if ($type.hasValue((<any>ev).pointerId)) {\r\n\t\t\t\tid = <string>(<any>ev).pointerId;\r\n\t\t\t} else {\r\n\t\t\t\tid = \"???\";\r\n\t\t\t}\r\n\r\n\t\t\tif (io) {\r\n\t\t\t\tconsole.log(text + \" (\" + io.uid + \")  \" + ev.type + \"  \" + type + \"  \" + id);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconsole.log(text + \"  \" + ev.type + \"  \" + type + \"  \" + id);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Checks whether there are currently any objects being transformed (dragged\r\n\t * or resized).\r\n\t *\r\n\t * If `except` is set, that object will be ignored.\r\n\t *\r\n\t * @since 4.9.3\r\n\t * @param   except  Ignore this object(s)\r\n\t * @return          Objects are being transformed\r\n\t */\r\n\tpublic areTransformed(except?: InteractionObject | InteractionObject[]): boolean {\r\n\t\tlet count = this.transformedObjects.length;\r\n\t\tif (except) {\r\n\t\t\tconst ex = $type.isArray(except) ? except : [except];\r\n\t\t\tfor (let i = 0; i < ex.length; i++) {\r\n\t\t\t\tif (this.transformedObjects.contains(ex[i])) {\r\n\t\t\t\t\tcount--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Log.\r\n\t */\r\n\tprivate logTouch(text: string, type: string, ev: Touch): void {\r\n\t\tconsole.log(text + \"  \" + type + \"  \" + \"touch\" + \"  \" + ev.identifier);\r\n\t}\r\n\r\n\t/**\r\n\t * Indicates if passive mode options is supported by this browser.\r\n\t */\r\n\tprivate static _passiveSupported: boolean;\r\n\r\n\t/**\r\n\t * Indicates if passive mode options is supported by this browser.\r\n\t */\r\n\tstatic get passiveSupported() {\r\n\r\n\t\tif (this._passiveSupported == null) {\r\n\r\n\t\t\t// Check for passive mode support\r\n\t\t\ttry {\r\n\t\t\t\tlet options = Object.defineProperty({}, \"passive\", {\r\n\t\t\t\t\tget: () => {\r\n\t\t\t\t\t\tthis._passiveSupported = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\twindow.addEventListener(\"test\", options, options);\r\n\t\t\t\twindow.removeEventListener(\"test\", options, options);\r\n\t\t\t} catch (err) {\r\n\t\t\t\tthis._passiveSupported = false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this._passiveSupported;\r\n\t}\r\n\r\n}\r\n\r\n\r\nlet interaction: Interaction | null = null;\r\n\r\n/**\r\n * Returns a single unified global instance of [[Interaction]].\r\n *\r\n * All code should use this function, rather than create their own instances\r\n * of [[Interaction]].\r\n */\r\nexport function getInteraction(): Interaction {\r\n\tif (interaction == null) {\r\n\t\tinteraction = new Interaction();\r\n\t}\r\n\r\n\treturn interaction;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}