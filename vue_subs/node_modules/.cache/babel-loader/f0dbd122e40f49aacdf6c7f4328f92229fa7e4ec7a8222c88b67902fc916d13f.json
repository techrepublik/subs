{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.array.push.js\");\nvar Queue = require('tinyqueue');\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\nfunction polylabel(polygon, precision, debug) {\n  precision = precision || 1.0;\n\n  // find the bounding box of the outer ring\n  var minX, minY, maxX, maxY;\n  for (var i = 0; i < polygon[0].length; i++) {\n    var p = polygon[0][i];\n    if (!i || p[0] < minX) minX = p[0];\n    if (!i || p[1] < minY) minY = p[1];\n    if (!i || p[0] > maxX) maxX = p[0];\n    if (!i || p[1] > maxY) maxY = p[1];\n  }\n  var width = maxX - minX;\n  var height = maxY - minY;\n  var cellSize = Math.min(width, height);\n  var h = cellSize / 2;\n  if (cellSize === 0) {\n    var degeneratePoleOfInaccessibility = [minX, minY];\n    degeneratePoleOfInaccessibility.distance = 0;\n    return degeneratePoleOfInaccessibility;\n  }\n\n  // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n  var cellQueue = new Queue(undefined, compareMax);\n\n  // cover polygon with initial cells\n  for (var x = minX; x < maxX; x += cellSize) {\n    for (var y = minY; y < maxY; y += cellSize) {\n      cellQueue.push(new Cell(x + h, y + h, h, polygon));\n    }\n  }\n\n  // take centroid as the first best guess\n  var bestCell = getCentroidCell(polygon);\n\n  // special case for rectangular polygons\n  var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n  if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n  var numProbes = cellQueue.length;\n  while (cellQueue.length) {\n    // pick the most promising cell from the queue\n    var cell = cellQueue.pop();\n\n    // update the best cell if we found a better one\n    if (cell.d > bestCell.d) {\n      bestCell = cell;\n      if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n    }\n\n    // do not drill down further if there's no chance of a better solution\n    if (cell.max - bestCell.d <= precision) continue;\n\n    // split the cell into four cells\n    h = cell.h / 2;\n    cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n    cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n    cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n    numProbes += 4;\n  }\n  if (debug) {\n    console.log('num probes: ' + numProbes);\n    console.log('best distance: ' + bestCell.d);\n  }\n  var poleOfInaccessibility = [bestCell.x, bestCell.y];\n  poleOfInaccessibility.distance = bestCell.d;\n  return poleOfInaccessibility;\n}\nfunction compareMax(a, b) {\n  return b.max - a.max;\n}\nfunction Cell(x, y, h, polygon) {\n  this.x = x; // cell center x\n  this.y = y; // cell center y\n  this.h = h; // half the cell size\n  this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n  this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n  var inside = false;\n  var minDistSq = Infinity;\n  for (var k = 0; k < polygon.length; k++) {\n    var ring = polygon[k];\n    for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n      var a = ring[i];\n      var b = ring[j];\n      if (a[1] > y !== b[1] > y && x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;\n      minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n    }\n  }\n  return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n  var area = 0;\n  var x = 0;\n  var y = 0;\n  var points = polygon[0];\n  for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n    var a = points[i];\n    var b = points[j];\n    var f = a[0] * b[1] - b[0] * a[1];\n    x += (a[0] + b[0]) * f;\n    y += (a[1] + b[1]) * f;\n    area += f * 3;\n  }\n  if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n  return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n  var x = a[0];\n  var y = a[1];\n  var dx = b[0] - x;\n  var dy = b[1] - y;\n  if (dx !== 0 || dy !== 0) {\n    var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      x = b[0];\n      y = b[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n  dx = px - x;\n  dy = py - y;\n  return dx * dx + dy * dy;\n}","map":{"version":3,"names":["require","Queue","default","module","exports","polylabel","polygon","precision","debug","minX","minY","maxX","maxY","i","length","p","width","height","cellSize","Math","min","h","degeneratePoleOfInaccessibility","distance","cellQueue","undefined","compareMax","x","y","push","Cell","bestCell","getCentroidCell","bboxCell","d","numProbes","cell","pop","console","log","round","max","poleOfInaccessibility","a","b","pointToPolygonDist","SQRT2","inside","minDistSq","Infinity","k","ring","len","j","getSegDistSq","sqrt","area","points","f","px","py","dx","dy","t"],"sources":["/home/josh/Documents/projects/subs/vue_subs/node_modules/polylabel/polylabel.js"],"sourcesContent":["'use strict';\n\nvar Queue = require('tinyqueue');\n\nif (Queue.default) Queue = Queue.default; // temporary webpack fix\n\nmodule.exports = polylabel;\nmodule.exports.default = polylabel;\n\nfunction polylabel(polygon, precision, debug) {\n    precision = precision || 1.0;\n\n    // find the bounding box of the outer ring\n    var minX, minY, maxX, maxY;\n    for (var i = 0; i < polygon[0].length; i++) {\n        var p = polygon[0][i];\n        if (!i || p[0] < minX) minX = p[0];\n        if (!i || p[1] < minY) minY = p[1];\n        if (!i || p[0] > maxX) maxX = p[0];\n        if (!i || p[1] > maxY) maxY = p[1];\n    }\n\n    var width = maxX - minX;\n    var height = maxY - minY;\n    var cellSize = Math.min(width, height);\n    var h = cellSize / 2;\n\n    if (cellSize === 0) {\n        var degeneratePoleOfInaccessibility = [minX, minY];\n        degeneratePoleOfInaccessibility.distance = 0;\n        return degeneratePoleOfInaccessibility;\n    }\n\n    // a priority queue of cells in order of their \"potential\" (max distance to polygon)\n    var cellQueue = new Queue(undefined, compareMax);\n\n    // cover polygon with initial cells\n    for (var x = minX; x < maxX; x += cellSize) {\n        for (var y = minY; y < maxY; y += cellSize) {\n            cellQueue.push(new Cell(x + h, y + h, h, polygon));\n        }\n    }\n\n    // take centroid as the first best guess\n    var bestCell = getCentroidCell(polygon);\n\n    // special case for rectangular polygons\n    var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);\n    if (bboxCell.d > bestCell.d) bestCell = bboxCell;\n\n    var numProbes = cellQueue.length;\n\n    while (cellQueue.length) {\n        // pick the most promising cell from the queue\n        var cell = cellQueue.pop();\n\n        // update the best cell if we found a better one\n        if (cell.d > bestCell.d) {\n            bestCell = cell;\n            if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);\n        }\n\n        // do not drill down further if there's no chance of a better solution\n        if (cell.max - bestCell.d <= precision) continue;\n\n        // split the cell into four cells\n        h = cell.h / 2;\n        cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));\n        cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));\n        cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));\n        numProbes += 4;\n    }\n\n    if (debug) {\n        console.log('num probes: ' + numProbes);\n        console.log('best distance: ' + bestCell.d);\n    }\n\n    var poleOfInaccessibility = [bestCell.x, bestCell.y];\n    poleOfInaccessibility.distance = bestCell.d;\n    return poleOfInaccessibility;\n}\n\nfunction compareMax(a, b) {\n    return b.max - a.max;\n}\n\nfunction Cell(x, y, h, polygon) {\n    this.x = x; // cell center x\n    this.y = y; // cell center y\n    this.h = h; // half the cell size\n    this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon\n    this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell\n}\n\n// signed distance from point to polygon outline (negative if point is outside)\nfunction pointToPolygonDist(x, y, polygon) {\n    var inside = false;\n    var minDistSq = Infinity;\n\n    for (var k = 0; k < polygon.length; k++) {\n        var ring = polygon[k];\n\n        for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {\n            var a = ring[i];\n            var b = ring[j];\n\n            if ((a[1] > y !== b[1] > y) &&\n                (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;\n\n            minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));\n        }\n    }\n\n    return minDistSq === 0 ? 0 : (inside ? 1 : -1) * Math.sqrt(minDistSq);\n}\n\n// get polygon centroid\nfunction getCentroidCell(polygon) {\n    var area = 0;\n    var x = 0;\n    var y = 0;\n    var points = polygon[0];\n\n    for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {\n        var a = points[i];\n        var b = points[j];\n        var f = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * f;\n        y += (a[1] + b[1]) * f;\n        area += f * 3;\n    }\n    if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);\n    return new Cell(x / area, y / area, 0, polygon);\n}\n\n// get squared distance from a point to a segment\nfunction getSegDistSq(px, py, a, b) {\n\n    var x = a[0];\n    var y = a[1];\n    var dx = b[0] - x;\n    var dy = b[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = b[0];\n            y = b[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = px - x;\n    dy = py - y;\n\n    return dx * dx + dy * dy;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}