{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\r\n * A collection of functions that deals with path calculations.\r\n */\nimport * as $math from \"../utils/Math\";\nimport * as $type from \"../utils/Type\";\nimport { getGhostPaper } from \"../rendering/Paper\";\nimport { options } from \"../Options\";\n/**\r\n * ============================================================================\r\n * PATH FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\n/**\r\n * Returns an SVG path from a number of points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param points  An array of line elbow points\r\n * @return SVG path\r\n */\nexport function polyline(points) {\n  var path = lineTo(points[0]);\n  var prevPoint = {\n    x: 0,\n    y: 0\n  };\n  var minStep = options.minPolylineStep;\n  if (!$type.isNumber(minStep)) {\n    minStep = 0.5;\n  }\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    if ($math.getDistance(point, prevPoint) > minStep) {\n      path += lineTo(point);\n      prevPoint = point;\n    }\n  }\n  return path;\n}\n/**\r\n * Returns a starting point of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  Starting point\r\n * @return SVG path\r\n */\nexport function moveTo(point) {\n  return \" M\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\n}\n/**\r\n * Returns a line part of SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  SVG path\r\n * @return SVG path\r\n */\nexport function lineTo(point) {\n  return \" L\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\n}\n/**\r\n * Returns a quadratic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point         End point of the curve\r\n * @param controlPoint  Control point\r\n * @return SVG path\r\n */\nexport function quadraticCurveTo(point, controlPoint) {\n  return \" Q\" + $math.round(controlPoint.x, 4) + \",\" + $math.round(controlPoint.y, 4) + \" \" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4);\n}\n/**\r\n * Returns a cubic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point          End point of the curve\r\n * @param controlPointA  Control point A\r\n * @param controlPointB  Control point B\r\n * @return SVG path\r\n */\nexport function cubicCurveTo(point, controlPointA, controlPointB) {\n  return \" C\" + $math.round(controlPointA.x, 4) + \",\" + $math.round(controlPointA.y, 4) + \" \" + $math.round(controlPointB.x, 4) + \",\" + $math.round(controlPointB.y, 4) + \" \" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4);\n}\n/**\r\n * Returns a terminator for an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @return SVG path\r\n */\nexport function closePath() {\n  return \" Z\";\n}\n/**\r\n * Returns an arc part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better parameter descriptions\r\n * @param startAngle  Starting angle\r\n * @param arc         Arc\r\n * @param radius      Radius\r\n * @param radiusY     Vertical radius\r\n * @return SVG path\r\n */\nexport function arcTo(startAngle, arc, radius, radiusY) {\n  if (arc == 0) {\n    return \"\";\n  }\n  if (!$type.isNumber(radiusY)) {\n    radiusY = radius;\n  }\n  var path = \"\";\n  var c = \",\";\n  var segments = Math.ceil(Math.abs(arc) / 180);\n  var l = 1;\n  if (arc < 0) {\n    l = 0;\n  }\n  // previous, as we use a not A\n  var pax = 0;\n  var pay = 0;\n  // center\n  var cx = -$math.cos(startAngle) * radius;\n  var cy = -$math.sin(startAngle) * radiusY;\n  // foir very short angles and big radius, solves artefacts\n  if (arc < 0.5 && radius > 3000) {\n    var endAngle = startAngle + arc;\n    var ax = $math.round($math.cos(endAngle) * radius, 4);\n    var ay = $math.round($math.sin(endAngle) * radiusY, 4);\n    return lineTo({\n      x: ax,\n      y: ay\n    });\n  }\n  for (var i = 0; i < segments; i++) {\n    var endAngle = startAngle + arc / segments * (i + 1);\n    var ax = $math.round($math.cos(endAngle) * radius + cx - pax, 4);\n    var ay = $math.round($math.sin(endAngle) * radiusY + cy - pay, 4);\n    path += \" a\" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;\n    pax = ax;\n    pay = ay;\n  }\n  return path;\n}\n/**\r\n * Creates an arc path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param startAngle         [description]\r\n * @param arc                [description]\r\n * @param radius             [description]\r\n * @param innerRadius        [description]\r\n * @param radiusY            [description]\r\n * @param cornerRadius       [description]\r\n * @param innerCornerRadius  [description]\r\n * @return SVG path\r\n */\nexport function arc(startAngle, arc, radius, innerRadius, radiusY, cornerRadius, innerCornerRadius) {\n  if (arc == 0) {\n    return \"\";\n  }\n  if (!$type.isNumber(innerRadius)) {\n    innerRadius = 0;\n  }\n  if (radius == 0 && innerRadius <= 0) {\n    return \"\";\n  }\n  if (radius < innerRadius) {\n    var temp = radius;\n    radius = innerRadius;\n    innerRadius = temp;\n    if ($type.isNumber(radiusY)) {\n      radiusY = radiusY / innerRadius * radius;\n    }\n  }\n  arc = $math.min(arc, 360);\n  if (arc == 360) {\n    cornerRadius = 0;\n    innerCornerRadius = 0;\n  }\n  var endAngle = startAngle + arc;\n  var crSin = $math.sin($math.min(arc, 45) / 2);\n  radiusY = $type.isNumber(radiusY) ? radiusY : radius;\n  cornerRadius = cornerRadius || 0;\n  innerCornerRadius = $type.isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;\n  var innerRadiusY = radiusY / radius * innerRadius;\n  var cornerRadiusY = radiusY / radius * cornerRadius;\n  var innerCornerRadiusY = radiusY / radius * innerCornerRadius;\n  cornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\n  cornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n  innerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\n  innerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\n  cornerRadius = $math.round($math.fitToRange(cornerRadius, 0, radius * crSin), 4);\n  cornerRadiusY = $math.round($math.fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);\n  innerCornerRadius = $math.round($math.fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);\n  innerCornerRadiusY = $math.round($math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);\n  var crAngle = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\n  var crAngleY = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\n  if (innerRadius < innerCornerRadius) {\n    innerRadius = innerCornerRadius;\n  }\n  if (innerRadiusY < innerCornerRadiusY) {\n    innerRadiusY = innerCornerRadiusY;\n  }\n  var crInnerAngle = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\n  var crInnerAngleY = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\n  if (!$type.isNumber(crInnerAngle)) {\n    crInnerAngle = 0;\n  }\n  if (!$type.isNumber(crInnerAngleY)) {\n    crInnerAngleY = 0;\n  }\n  var middleAngle = startAngle + arc / 2;\n  var mPoint = {\n    x: $math.round($math.cos(middleAngle) * innerRadius, 4),\n    y: $math.sin(middleAngle) * innerRadiusY\n  };\n  var a0 = {\n    x: $math.cos(startAngle) * (innerRadius + innerCornerRadius),\n    y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY)\n  };\n  var b0 = {\n    x: $math.cos(startAngle) * (radius - cornerRadius),\n    y: $math.sin(startAngle) * (radiusY - cornerRadiusY)\n  };\n  var c0 = {\n    x: $math.cos(endAngle) * (radius - cornerRadius),\n    y: $math.sin(endAngle) * (radiusY - cornerRadiusY)\n  };\n  var d0 = {\n    x: $math.cos(endAngle) * (innerRadius + innerCornerRadius),\n    y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY)\n  };\n  var b1 = {\n    x: $math.cos(startAngle + crAngle) * radius,\n    y: $math.sin(startAngle + crAngleY) * radiusY\n  };\n  var d1 = {\n    x: $math.cos(endAngle - crInnerAngle) * innerRadius,\n    y: $math.sin(endAngle - crInnerAngleY) * innerRadiusY\n  };\n  // some magic math\n  innerCornerRadius += innerCornerRadius * $math.sin(crInnerAngle / 2);\n  innerCornerRadiusY += innerCornerRadiusY * $math.sin(crInnerAngleY / 2);\n  if (crInnerAngle > (endAngle - startAngle) / 2) {\n    d1 = mPoint;\n  }\n  var path = \"\";\n  // start from b if this is full circle\n  if (arc == 360) {\n    path = moveTo(b0);\n  }\n  // otherwise start from a\n  else {\n    path = moveTo(a0);\n    path += lineTo(b0);\n    path += arcToPoint(b1, cornerRadius, cornerRadiusY, true);\n  }\n  // draw arc\n  path += arcTo(startAngle + crAngle, arc - 2 * crAngle, radius, radiusY);\n  // draw inner arc\n  if ($type.isNumber(innerRadius) && innerRadius != 0) {\n    // move to B if this is full circle\n    if (arc == 360 && cornerRadius == 0) {\n      path += moveTo(d0);\n    }\n    // draw line otherwise\n    else {\n      path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\n      path += lineTo(d0);\n      path += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);\n    }\n    path += arcTo(endAngle - crInnerAngle, -(arc - 2 * crInnerAngle), innerRadius, innerRadiusY);\n    if (arc < 360 || cornerRadius > 0) {\n      path += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);\n    }\n    path += lineTo(a0);\n  } else {\n    path += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\n    if (arc < 360) {\n      path += lineTo(a0);\n    }\n  }\n  return path;\n}\n/**\r\n * Creates a path for an arc to specific coordinate.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param point         Reference point\r\n * @param radius        Radius\r\n * @param radiusY       Vertical radius (for skewed arcs)\r\n * @param sweepFlag     [description]\r\n * @param largeArcFlag  [description]\r\n * @param xAxisRotation [description]\r\n * @return Arc path\r\n */\nexport function arcToPoint(point, radius, radiusY, sweepFlag, largeArcFlag, xAxisRotation) {\n  if (radius == 0) {\n    return \"\";\n  }\n  xAxisRotation = xAxisRotation || 0;\n  largeArcFlag = Boolean(largeArcFlag);\n  sweepFlag = Boolean(sweepFlag);\n  var c = \",\";\n  var sweepFlagValue = +sweepFlag; // converts to 1 or 0\n  var largeArcFlagValue = +largeArcFlag; // converts to 1 or 0\n  return \" A\" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + $math.round(point.x, 4) + c + $math.round(point.y, 4);\n}\n/**\r\n * Creates a new rectangle.\r\n *\r\n * @ignore Exclude from docs\r\n * @param width   Width (px)\r\n * @param height  Height (px)\r\n * @param x       X position\r\n * @param y       Y position\r\n * @return Rectangle\r\n */\nexport function rectangle(width, height, x, y) {\n  if (!$type.isNumber(x)) {\n    x = 0;\n  }\n  if (!$type.isNumber(y)) {\n    y = 0;\n  }\n  return moveTo({\n    x: x,\n    y: y\n  }) + lineTo({\n    x: x + width,\n    y: y\n  }) + lineTo({\n    x: x + width,\n    y: y + height\n  }) + lineTo({\n    x: x,\n    y: y + height\n  }) + closePath();\n}\n/**\r\n * Converts a rectangle to an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param rect  Rectangle\r\n * @param ccw   Counter-clockwise?\r\n * @return SVG path\r\n */\nexport function rectToPath(rect, ccw) {\n  var c = \",\";\n  var L = \" L\";\n  if (ccw) {\n    return \"M\" + rect.x + c + rect.y + L + rect.x + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + (rect.x + rect.width) + c + rect.y + L + rect.x + c + rect.y;\n  } else {\n    return \"M\" + rect.x + c + rect.y + L + (rect.x + rect.width) + c + rect.y + L + (rect.x + rect.width) + c + (rect.y + rect.height) + L + rect.x + c + (rect.y + rect.height) + L + rect.x + c + rect.y;\n  }\n}\n/**\r\n * Converts SVG path to array of points.\r\n *\r\n * Note, this is experimental feature based on method which is deprecated\r\n * on some browsers and some browsers do not support it at all.\r\n *\r\n * You can save the output of this function, but not rely on it completely.\r\n */\nexport function pathToPoints(path, pointCount) {\n  var paper = getGhostPaper();\n  var svgPath = paper.add(\"path\").node;\n  svgPath.setAttribute(\"d\", path);\n  if (svgPath.getPointAtLength && svgPath.getTotalLength) {\n    var length_1 = svgPath.getTotalLength();\n    var toPoints = [];\n    for (var i = 0; i < pointCount; i++) {\n      var point = svgPath.getPointAtLength(i / pointCount * length_1);\n      toPoints.push({\n        x: point.x,\n        y: point.y\n      });\n    }\n    return toPoints;\n  }\n  svgPath.remove();\n}\nexport function spiralPoints(cx, cy, radius, radiusY, innerRadius, step, radiusStep, startAngle, endAngle) {\n  if (!$type.isNumber(startAngle)) {\n    startAngle = 0;\n  }\n  if (!$type.isNumber(startAngle)) {\n    endAngle = startAngle;\n  }\n  var r = innerRadius + 0.01;\n  var angle = startAngle * $math.RADIANS;\n  var points = [];\n  while (r < radius + radiusStep) {\n    var stepSize = step;\n    if (stepSize / 2 > r) {\n      stepSize = 2 * r;\n    }\n    angle += 2 * Math.asin(stepSize / 2 / r);\n    if (angle * $math.DEGREES > endAngle + (radius - innerRadius) / radiusStep * 360) {\n      break;\n    }\n    var degrees = angle * $math.DEGREES;\n    var point = {\n      x: cx + r * Math.cos(angle),\n      y: cy + r * radiusY / radius * Math.sin(angle)\n    };\n    points.push(point);\n    r = innerRadius + degrees / 360 * radiusStep;\n  }\n  points.shift();\n  return points;\n}\nexport function pointsToPath(points) {\n  if (!points || points.length == 0) {\n    return \"\";\n  }\n  var path = moveTo(points[0]);\n  if (points && points.length > 0) {\n    for (var i = 1; i < points.length; i++) {\n      path += lineTo(points[i]);\n    }\n  }\n  return path;\n}","map":{"version":3,"names":["$math","$type","getGhostPaper","options","polyline","points","path","lineTo","prevPoint","x","y","minStep","minPolylineStep","isNumber","i","len","length","point","getDistance","moveTo","round","quadraticCurveTo","controlPoint","cubicCurveTo","controlPointA","controlPointB","closePath","arcTo","startAngle","arc","radius","radiusY","c","segments","Math","ceil","abs","l","pax","pay","cx","cos","cy","sin","endAngle","ax","ay","innerRadius","cornerRadius","innerCornerRadius","temp","min","crSin","innerRadiusY","cornerRadiusY","innerCornerRadiusY","fitToRange","crAngle","asin","DEGREES","crAngleY","crInnerAngle","crInnerAngleY","middleAngle","mPoint","a0","b0","c0","d0","b1","d1","arcToPoint","sweepFlag","largeArcFlag","xAxisRotation","Boolean","sweepFlagValue","largeArcFlagValue","rectangle","width","height","rectToPath","rect","ccw","L","pathToPoints","pointCount","paper","svgPath","add","node","setAttribute","getPointAtLength","getTotalLength","length_1","toPoints","push","remove","spiralPoints","step","radiusStep","r","angle","RADIANS","stepSize","degrees","shift","pointsToPath"],"sources":["../../../../../src/.internal/core/rendering/Path.ts"],"sourcesContent":["/**\r\n * A collection of functions that deals with path calculations.\r\n */\r\n\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { IPoint } from \"../defs/IPoint\";\r\nimport { IRectangle } from \"../defs/IRectangle\";\r\nimport * as $math from \"../utils/Math\";\r\nimport * as $type from \"../utils/Type\";\r\nimport { getGhostPaper } from \"../rendering/Paper\";\r\nimport { options } from \"../Options\";\r\n\r\n/**\r\n * ============================================================================\r\n * PATH FUNCTIONS\r\n * ============================================================================\r\n * @hidden\r\n */\r\n\r\n/**\r\n * Returns an SVG path from a number of points.\r\n *\r\n * @ignore Exclude from docs\r\n * @param points  An array of line elbow points\r\n * @return SVG path\r\n */\r\nexport function polyline(points: IPoint[]): string {\r\n\tlet path = lineTo(points[0]);\r\n\tlet prevPoint = { x: 0, y: 0 };\r\n\r\n\tlet minStep = options.minPolylineStep;\r\n\tif (!$type.isNumber(minStep)) {\r\n\t\tminStep = 0.5;\r\n\t}\r\n\r\n\tfor (let i = 0, len = points.length; i < len; i++) {\r\n\t\tlet point = points[i];\r\n\t\tif ($math.getDistance(point, prevPoint) > minStep) {\r\n\t\t\tpath += lineTo(point);\r\n\t\t\tprevPoint = point;\r\n\t\t}\r\n\t}\r\n\treturn path;\r\n}\r\n\r\n\r\n/**\r\n * Returns a starting point of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  Starting point\r\n * @return SVG path\r\n */\r\nexport function moveTo(point: IPoint): string {\r\n\treturn \" M\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\r\n}\r\n\r\n/**\r\n * Returns a line part of SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point  SVG path\r\n * @return SVG path\r\n */\r\nexport function lineTo(point: IPoint): string {\r\n\treturn \" L\" + $math.round(point.x, 4) + \",\" + $math.round(point.y, 4) + \" \";\r\n}\r\n\r\n/**\r\n * Returns a quadratic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point         End point of the curve\r\n * @param controlPoint  Control point\r\n * @return SVG path\r\n */\r\nexport function quadraticCurveTo(point: IPoint, controlPoint: IPoint): string {\r\n\treturn \" Q\" + $math.round(controlPoint.x, 4)\r\n\t\t+ \",\" + $math.round(controlPoint.y, 4) + \" \" + $math.round(point.x, 4)\r\n\t\t+ \",\" + $math.round(point.y, 4);\r\n}\r\n\r\n/**\r\n * Returns a cubic curve part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param point          End point of the curve\r\n * @param controlPointA  Control point A\r\n * @param controlPointB  Control point B\r\n * @return SVG path\r\n */\r\nexport function cubicCurveTo(point: IPoint, controlPointA: IPoint, controlPointB: IPoint): string {\r\n\treturn \" C\" + $math.round(controlPointA.x, 4)\r\n\t\t+ \",\" + $math.round(controlPointA.y, 4) + \" \" + $math.round(controlPointB.x, 4)\r\n\t\t+ \",\" + $math.round(controlPointB.y, 4) + \" \" + $math.round(point.x, 4)\r\n\t\t+ \",\" + $math.round(point.y, 4);\r\n}\r\n\r\n/**\r\n * Returns a terminator for an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @return SVG path\r\n */\r\nexport function closePath(): string {\r\n\treturn \" Z\";\r\n}\r\n\r\n/**\r\n * Returns an arc part of an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Better parameter descriptions\r\n * @param startAngle  Starting angle\r\n * @param arc         Arc\r\n * @param radius      Radius\r\n * @param radiusY     Vertical radius\r\n * @return SVG path\r\n */\r\nexport function arcTo(startAngle: number, arc: number, radius: number, radiusY?: number): string {\r\n\r\n\tif (arc == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif (!$type.isNumber(radiusY)) {\r\n\t\tradiusY = radius;\r\n\t}\r\n\r\n\tlet path = \"\";\r\n\tlet c = \",\";\r\n\tlet segments = Math.ceil(Math.abs(arc) / 180);\r\n\tlet l = 1;\r\n\r\n\tif (arc < 0) {\r\n\t\tl = 0;\r\n\t}\r\n\r\n\t// previous, as we use a not A\r\n\tlet pax: number = 0;\r\n\tlet pay: number = 0;\r\n\r\n\t// center\r\n\tlet cx: number = -$math.cos(startAngle) * radius;\r\n\tlet cy: number = -$math.sin(startAngle) * radiusY;\r\n\r\n\t// foir very short angles and big radius, solves artefacts\r\n\tif (arc < 0.5 && radius > 3000) {\r\n\t\tlet endAngle = startAngle + arc\r\n\t\tlet ax = $math.round($math.cos(endAngle) * radius, 4);\r\n\t\tlet ay = $math.round($math.sin(endAngle) * radiusY, 4);\r\n\t\treturn lineTo({ x: ax, y: ay })\r\n\t}\r\n\r\n\tfor (let i = 0; i < segments; i++) {\r\n\t\tlet endAngle = startAngle + arc / segments * (i + 1);\r\n\r\n\t\tlet ax = $math.round($math.cos(endAngle) * radius + cx - pax, 4);\r\n\t\tlet ay = $math.round($math.sin(endAngle) * radiusY + cy - pay, 4);\r\n\r\n\t\tpath += \" a\" + radius + c + radiusY + c + 0 + c + 0 + c + l + c + ax + c + ay;\r\n\r\n\t\tpax = ax;\r\n\t\tpay = ay;\r\n\t}\r\n\treturn path;\r\n}\r\n\r\n/**\r\n * Creates an arc path.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param startAngle         [description]\r\n * @param arc                [description]\r\n * @param radius             [description]\r\n * @param innerRadius        [description]\r\n * @param radiusY            [description]\r\n * @param cornerRadius       [description]\r\n * @param innerCornerRadius  [description]\r\n * @return SVG path\r\n */\r\nexport function arc(startAngle: number, arc: number, radius: number, innerRadius?: number, radiusY?: number, cornerRadius?: number, innerCornerRadius?: number): string {\r\n\tif (arc == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif (!$type.isNumber(innerRadius)) {\r\n\t\tinnerRadius = 0;\r\n\t}\r\n\r\n\tif (radius == 0 && innerRadius <= 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\tif (radius < innerRadius) {\r\n\t\tlet temp = radius;\r\n\t\tradius = innerRadius;\r\n\t\tinnerRadius = temp;\r\n\r\n\t\tif ($type.isNumber(radiusY)) {\r\n\t\t\tradiusY = radiusY / innerRadius * radius;\r\n\t\t}\r\n\t}\r\n\r\n\tarc = $math.min(arc, 360);\r\n\r\n\tif (arc == 360) {\r\n\t\tcornerRadius = 0;\r\n\t\tinnerCornerRadius = 0;\r\n\t}\r\n\r\n\tlet endAngle = startAngle + arc;\r\n\tlet crSin = $math.sin($math.min(arc, 45) / 2);\r\n\r\n\tradiusY = $type.isNumber(radiusY) ? radiusY : radius;\r\n\tcornerRadius = cornerRadius || 0;\r\n\tinnerCornerRadius = $type.isNumber(innerCornerRadius) ? innerCornerRadius : cornerRadius;\r\n\r\n\tlet innerRadiusY = (radiusY / radius) * innerRadius;\r\n\r\n\tlet cornerRadiusY = (radiusY / radius) * cornerRadius;\r\n\tlet innerCornerRadiusY = (radiusY / radius) * innerCornerRadius;\r\n\r\n\tcornerRadius = $math.fitToRange(cornerRadius, 0, (radius - innerRadius) / 2);\r\n\tcornerRadiusY = $math.fitToRange(cornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n\r\n\tinnerCornerRadius = $math.fitToRange(innerCornerRadius, 0, (radius - innerRadius) / 2);\r\n\tinnerCornerRadiusY = $math.fitToRange(innerCornerRadiusY, 0, (radiusY - innerRadiusY) / 2);\r\n\r\n\tcornerRadius = $math.round($math.fitToRange(cornerRadius, 0, radius * crSin), 4);\r\n\tcornerRadiusY = $math.round($math.fitToRange(cornerRadiusY, 0, radiusY * crSin), 4);\r\n\r\n\tinnerCornerRadius = $math.round($math.fitToRange(innerCornerRadius, 0, innerRadius * crSin), 4);\r\n\tinnerCornerRadiusY = $math.round($math.fitToRange(innerCornerRadiusY, 0, innerRadiusY * crSin), 4);\r\n\r\n\tlet crAngle: number = Math.asin(cornerRadius / radius / 2) * $math.DEGREES * 2;\r\n\tlet crAngleY: number = Math.asin(cornerRadiusY / radiusY / 2) * $math.DEGREES * 2;\r\n\r\n\tif (innerRadius < innerCornerRadius) {\r\n\t\tinnerRadius = innerCornerRadius;\r\n\t}\r\n\r\n\tif (innerRadiusY < innerCornerRadiusY) {\r\n\t\tinnerRadiusY = innerCornerRadiusY;\r\n\t}\r\n\r\n\tlet crInnerAngle: number = Math.asin(innerCornerRadius / innerRadius / 2) * $math.DEGREES * 2;\r\n\tlet crInnerAngleY: number = Math.asin(innerCornerRadiusY / innerRadiusY / 2) * $math.DEGREES * 2;\r\n\r\n\tif (!$type.isNumber(crInnerAngle)) {\r\n\t\tcrInnerAngle = 0;\r\n\t}\r\n\tif (!$type.isNumber(crInnerAngleY)) {\r\n\t\tcrInnerAngleY = 0;\r\n\t}\r\n\r\n\tlet middleAngle = startAngle + arc / 2;\r\n\tlet mPoint = { x: $math.round($math.cos(middleAngle) * innerRadius, 4), y: $math.sin(middleAngle) * innerRadiusY };\r\n\r\n\tlet a0 = { x: $math.cos(startAngle) * (innerRadius + innerCornerRadius), y: $math.sin(startAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n\tlet b0 = { x: $math.cos(startAngle) * (radius - cornerRadius), y: $math.sin(startAngle) * (radiusY - cornerRadiusY) };\r\n\tlet c0 = { x: $math.cos(endAngle) * (radius - cornerRadius), y: $math.sin(endAngle) * (radiusY - cornerRadiusY) };\r\n\tlet d0 = { x: $math.cos(endAngle) * (innerRadius + innerCornerRadius), y: $math.sin(endAngle) * (innerRadiusY + innerCornerRadiusY) };\r\n\r\n\tlet b1 = { x: $math.cos(startAngle + crAngle) * radius, y: $math.sin(startAngle + crAngleY) * radiusY };\r\n\tlet d1 = { x: $math.cos(endAngle - crInnerAngle) * innerRadius, y: $math.sin(endAngle - crInnerAngleY) * innerRadiusY };\r\n\r\n\t// some magic math\r\n\tinnerCornerRadius += innerCornerRadius * $math.sin(crInnerAngle / 2);\r\n\tinnerCornerRadiusY += innerCornerRadiusY * $math.sin(crInnerAngleY / 2);\r\n\r\n\tif (crInnerAngle > (endAngle - startAngle) / 2) {\r\n\t\td1 = mPoint;\r\n\t}\r\n\r\n\tlet path: string = \"\";\r\n\t// start from b if this is full circle\r\n\tif (arc == 360) {\r\n\t\tpath = moveTo(b0);\r\n\t}\r\n\t// otherwise start from a\r\n\telse {\r\n\t\tpath = moveTo(a0);\r\n\t\tpath += lineTo(b0);\r\n\t\tpath += arcToPoint(b1, cornerRadius, cornerRadiusY, true);\r\n\t}\r\n\r\n\t// draw arc\r\n\tpath += arcTo(startAngle + crAngle, arc - 2 * crAngle, radius, radiusY);\r\n\r\n\t// draw inner arc\r\n\tif ($type.isNumber(innerRadius) && innerRadius != 0) {\r\n\r\n\t\t// move to B if this is full circle\r\n\t\tif (arc == 360 && cornerRadius == 0) {\r\n\t\t\tpath += moveTo(d0);\r\n\t\t}\r\n\t\t// draw line otherwise\r\n\t\telse {\r\n\t\t\tpath += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\r\n\t\t\tpath += lineTo(d0);\r\n\t\t\tpath += arcToPoint(d1, innerCornerRadius, innerCornerRadiusY, true);\r\n\t\t}\r\n\r\n\t\tpath += arcTo(endAngle - crInnerAngle, -(arc - 2 * crInnerAngle), innerRadius, innerRadiusY);\r\n\t\tif (arc < 360 || cornerRadius > 0) {\r\n\t\t\tpath += arcToPoint(a0, innerCornerRadius, innerCornerRadiusY, true);\r\n\t\t}\r\n\t\tpath += lineTo(a0);\r\n\t}\r\n\telse {\r\n\t\tpath += arcToPoint(c0, cornerRadius, cornerRadiusY, true);\r\n\t\tif (arc < 360) {\r\n\t\t\tpath += lineTo(a0);\r\n\t\t}\r\n\t}\r\n\r\n\treturn path;\r\n}\r\n\r\n/**\r\n * Creates a path for an arc to specific coordinate.\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param point         Reference point\r\n * @param radius        Radius\r\n * @param radiusY       Vertical radius (for skewed arcs)\r\n * @param sweepFlag     [description]\r\n * @param largeArcFlag  [description]\r\n * @param xAxisRotation [description]\r\n * @return Arc path\r\n */\r\nexport function arcToPoint(point: IPoint, radius: number, radiusY?: number, sweepFlag?: boolean, largeArcFlag?: boolean, xAxisRotation?: number): string {\r\n\tif (radius == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\txAxisRotation = xAxisRotation || 0;\r\n\tlargeArcFlag = Boolean(largeArcFlag);\r\n\tsweepFlag = Boolean(sweepFlag);\r\n\r\n\tlet c = \",\";\r\n\tlet sweepFlagValue: number = +sweepFlag; // converts to 1 or 0\r\n\tlet largeArcFlagValue: number = +largeArcFlag;  // converts to 1 or 0\r\n\r\n\treturn \" A\" + radius + c + radiusY + c + xAxisRotation + c + largeArcFlagValue + c + sweepFlagValue + c + $math.round(point.x, 4) + c + $math.round(point.y, 4);\r\n}\r\n\r\n/**\r\n * Creates a new rectangle.\r\n *\r\n * @ignore Exclude from docs\r\n * @param width   Width (px)\r\n * @param height  Height (px)\r\n * @param x       X position\r\n * @param y       Y position\r\n * @return Rectangle\r\n */\r\nexport function rectangle(width: number, height: number, x?: number, y?: number): string {\r\n\tif (!$type.isNumber(x)) {\r\n\t\tx = 0;\r\n\t}\r\n\tif (!$type.isNumber(y)) {\r\n\t\ty = 0;\r\n\t}\r\n\treturn moveTo({ x: x, y: y }) + lineTo({ x: x + width, y: y }) + lineTo({ x: x + width, y: y + height }) + lineTo({ x: x, y: y + height }) + closePath();\r\n}\r\n\r\n/**\r\n * Converts a rectangle to an SVG path.\r\n *\r\n * @ignore Exclude from docs\r\n * @param rect  Rectangle\r\n * @param ccw   Counter-clockwise?\r\n * @return SVG path\r\n */\r\nexport function rectToPath(rect: IRectangle, ccw?: boolean): string {\r\n\tlet c = \",\";\r\n\tlet L = \" L\";\r\n\tif (ccw) {\r\n\t\treturn \"M\" + rect.x\r\n\t\t\t+ c + rect.y + L + rect.x\r\n\t\t\t+ c + (rect.y + rect.height) + L + (rect.x + rect.width)\r\n\t\t\t+ c + (rect.y + rect.height) + L + (rect.x + rect.width)\r\n\t\t\t+ c + rect.y + L + rect.x\r\n\t\t\t+ c + rect.y;\r\n\t}\r\n\telse {\r\n\t\treturn \"M\" + rect.x\r\n\t\t\t+ c + rect.y + L + (rect.x + rect.width)\r\n\t\t\t+ c + rect.y + L + (rect.x + rect.width)\r\n\t\t\t+ c + (rect.y + rect.height) + L + rect.x\r\n\t\t\t+ c + (rect.y + rect.height) + L + rect.x\r\n\t\t\t+ c + rect.y;\r\n\t}\r\n}\r\n\r\n/**\r\n * Converts SVG path to array of points.\r\n *\r\n * Note, this is experimental feature based on method which is deprecated\r\n * on some browsers and some browsers do not support it at all.\r\n *\r\n * You can save the output of this function, but not rely on it completely.\r\n */\r\nexport function pathToPoints(path: string, pointCount: number): IPoint[] {\r\n\r\n\tlet paper = getGhostPaper();\r\n\tlet svgPath: SVGPathElement = <any>paper.add(\"path\").node;\r\n\tsvgPath.setAttribute(\"d\", path);\r\n\r\n\tif (svgPath.getPointAtLength && svgPath.getTotalLength) {\r\n\t\tlet length = svgPath.getTotalLength();\r\n\r\n\t\tlet toPoints = []\r\n\t\tfor (let i = 0; i < pointCount; i++) {\r\n\t\t\tlet point = svgPath.getPointAtLength(i / pointCount * length);\r\n\t\t\ttoPoints.push({ x: point.x, y: point.y });\r\n\t\t}\r\n\r\n\t\treturn toPoints;\r\n\t}\r\n\r\n\tsvgPath.remove();\r\n}\r\n\r\n\r\nexport function spiralPoints(cx: number, cy: number, radius: number, radiusY: number, innerRadius: number, step: number, radiusStep: number, startAngle?: number, endAngle?: number): IPoint[] {\r\n\r\n\tif (!$type.isNumber(startAngle)) {\r\n\t\tstartAngle = 0;\r\n\t}\r\n\r\n\tif (!$type.isNumber(startAngle)) {\r\n\t\tendAngle = startAngle;\r\n\t}\r\n\r\n\tlet r = innerRadius + 0.01;\r\n\tlet angle = startAngle * $math.RADIANS;\r\n\tlet points = [];\r\n\r\n\twhile (r < radius + radiusStep) {\r\n\r\n\t\tlet stepSize = step;\r\n\t\tif (stepSize / 2 > r) {\r\n\t\t\tstepSize = 2 * r;\r\n\t\t}\r\n\r\n\t\tangle += 2 * Math.asin(stepSize / 2 / r);\t\t\r\n\r\n\t\tif (angle * $math.DEGREES > endAngle + ((radius - innerRadius) / radiusStep) * 360) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tlet degrees = angle * $math.DEGREES;\r\n\r\n\t\tlet point = { x: cx + r * Math.cos(angle), y: cy + r * radiusY / radius * Math.sin(angle) };\r\n\t\tpoints.push(point);\r\n\r\n\t\tr = innerRadius + degrees / 360 * radiusStep;\r\n\r\n\t}\r\n\r\n\tpoints.shift();\r\n\r\n\treturn points;\r\n}\r\n\r\nexport function pointsToPath(points: IPoint[]) {\r\n\tif (!points || points.length == 0) {\r\n\t\treturn \"\";\r\n\t}\r\n\tlet path = moveTo(points[0]);\r\n\tif (points && points.length > 0) {\r\n\t\tfor (let i = 1; i < points.length; i++) {\r\n\t\t\tpath += lineTo(points[i]);\r\n\t\t}\r\n\t}\r\n\treturn path;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}